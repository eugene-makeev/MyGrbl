
MyGRBL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000002  00800100  000065c6  0000665a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000065c6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000662  00800102  00800102  0000665c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000665c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  0000668c  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005b8  00000000  00000000  000066cc  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   00008261  00000000  00000000  00006c84  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000021e2  00000000  00000000  0000eee5  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   00005158  00000000  00000000  000110c7  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001228  00000000  00000000  00016220  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001c27  00000000  00000000  00017448  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005eb2  00000000  00000000  0001906f  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000005a8  00000000  00000000  0001ef21  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 35 01 	jmp	0x26a	; 0x26a <__ctors_end>
       4:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
       8:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
       c:	0c 94 2f 2c 	jmp	0x585e	; 0x585e <__vector_3>
      10:	0c 94 1a 2d 	jmp	0x5a34	; 0x5a34 <__vector_4>
      14:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      18:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      1c:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      20:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      24:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      28:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      2c:	0c 94 b6 16 	jmp	0x2d6c	; 0x2d6c <__vector_11>
      30:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      34:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      38:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      3c:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      40:	0c 94 ae 18 	jmp	0x315c	; 0x315c <__vector_16>
      44:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      48:	0c 94 11 12 	jmp	0x2422	; 0x2422 <__vector_18>
      4c:	0c 94 e7 11 	jmp	0x23ce	; 0x23ce <__vector_19>
      50:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      54:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      58:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      5c:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      60:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      64:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      68:	5a 06       	cpc	r5, r26
      6a:	5a 06       	cpc	r5, r26
      6c:	5a 06       	cpc	r5, r26
      6e:	5a 06       	cpc	r5, r26
      70:	3d 06       	cpc	r3, r29
      72:	c6 0f       	add	r28, r22
      74:	c6 0f       	add	r28, r22
      76:	c6 0f       	add	r28, r22
      78:	c6 0f       	add	r28, r22
      7a:	c6 0f       	add	r28, r22
      7c:	32 06       	cpc	r3, r18
      7e:	c6 0f       	add	r28, r22
      80:	c6 0f       	add	r28, r22
      82:	c6 0f       	add	r28, r22
      84:	c6 0f       	add	r28, r22
      86:	c6 0f       	add	r28, r22
      88:	c6 0f       	add	r28, r22
      8a:	83 06       	cpc	r8, r19
      8c:	83 06       	cpc	r8, r19
      8e:	83 06       	cpc	r8, r19
      90:	a2 06       	cpc	r10, r18
      92:	a2 06       	cpc	r10, r18
      94:	c6 0f       	add	r28, r22
      96:	c6 0f       	add	r28, r22
      98:	c6 0f       	add	r28, r22
      9a:	c6 0f       	add	r28, r22
      9c:	c6 0f       	add	r28, r22
      9e:	c6 0f       	add	r28, r22
      a0:	32 06       	cpc	r3, r18
      a2:	c6 0f       	add	r28, r22
      a4:	32 06       	cpc	r3, r18
      a6:	c6 0f       	add	r28, r22
      a8:	c6 0f       	add	r28, r22
      aa:	c6 0f       	add	r28, r22
      ac:	c6 0f       	add	r28, r22
      ae:	c6 0f       	add	r28, r22
      b0:	c6 0f       	add	r28, r22
      b2:	c6 0f       	add	r28, r22
      b4:	5a 06       	cpc	r5, r26
      b6:	c6 0f       	add	r28, r22
      b8:	cc 06       	cpc	r12, r28
      ba:	c6 0f       	add	r28, r22
      bc:	c6 0f       	add	r28, r22
      be:	a8 06       	cpc	r10, r24
      c0:	c6 0f       	add	r28, r22
      c2:	c6 0f       	add	r28, r22
      c4:	c6 0f       	add	r28, r22
      c6:	c6 0f       	add	r28, r22
      c8:	c6 0f       	add	r28, r22
      ca:	a8 06       	cpc	r10, r24
      cc:	c6 0f       	add	r28, r22
      ce:	c6 0f       	add	r28, r22
      d0:	c6 0f       	add	r28, r22
      d2:	3d 06       	cpc	r3, r29
      d4:	c0 06       	cpc	r12, r16
      d6:	c0 06       	cpc	r12, r16
      d8:	c0 06       	cpc	r12, r16
      da:	c0 06       	cpc	r12, r16
      dc:	c0 06       	cpc	r12, r16
      de:	c0 06       	cpc	r12, r16
      e0:	c6 0f       	add	r28, r22
      e2:	c6 06       	cpc	r12, r22
      e4:	c6 0f       	add	r28, r22
      e6:	c6 0f       	add	r28, r22
      e8:	c6 0f       	add	r28, r22
      ea:	c6 0f       	add	r28, r22
      ec:	c6 0f       	add	r28, r22
      ee:	c6 0f       	add	r28, r22
      f0:	c6 0f       	add	r28, r22
      f2:	c6 0f       	add	r28, r22
      f4:	c6 0f       	add	r28, r22
      f6:	c6 0f       	add	r28, r22
      f8:	c6 0f       	add	r28, r22
      fa:	c6 0f       	add	r28, r22
      fc:	c6 0f       	add	r28, r22
      fe:	c6 0f       	add	r28, r22
     100:	c6 0f       	add	r28, r22
     102:	c6 0f       	add	r28, r22
     104:	c6 0f       	add	r28, r22
     106:	c6 0f       	add	r28, r22
     108:	60 06       	cpc	r6, r16
     10a:	c6 0f       	add	r28, r22
     10c:	c6 0f       	add	r28, r22
     10e:	c6 0f       	add	r28, r22
     110:	c6 0f       	add	r28, r22
     112:	c6 0f       	add	r28, r22
     114:	c6 0f       	add	r28, r22
     116:	c6 0f       	add	r28, r22
     118:	c6 0f       	add	r28, r22
     11a:	c6 0f       	add	r28, r22
     11c:	89 06       	cpc	r8, r25
     11e:	89 06       	cpc	r8, r25
     120:	32 06       	cpc	r3, r18
     122:	9c 06       	cpc	r9, r28
     124:	9c 06       	cpc	r9, r28
     126:	f5 06       	cpc	r15, r21
     128:	f5 06       	cpc	r15, r21
     12a:	f5 06       	cpc	r15, r21
     12c:	04 07       	cpc	r16, r20
     12e:	04 07       	cpc	r16, r20
     130:	04 07       	cpc	r16, r20
     132:	e0 0f       	add	r30, r16
     134:	e0 0f       	add	r30, r16
     136:	1b 07       	cpc	r17, r27
     138:	1b 07       	cpc	r17, r27
     13a:	e0 0f       	add	r30, r16
     13c:	e0 0f       	add	r30, r16
     13e:	e0 0f       	add	r30, r16
     140:	e0 0f       	add	r30, r16
     142:	e0 0f       	add	r30, r16
     144:	e0 0f       	add	r30, r16
     146:	e0 0f       	add	r30, r16
     148:	e0 0f       	add	r30, r16
     14a:	e0 0f       	add	r30, r16
     14c:	e0 0f       	add	r30, r16
     14e:	e0 0f       	add	r30, r16
     150:	e0 0f       	add	r30, r16
     152:	e0 0f       	add	r30, r16
     154:	e0 0f       	add	r30, r16
     156:	e0 0f       	add	r30, r16
     158:	e0 0f       	add	r30, r16
     15a:	e0 0f       	add	r30, r16
     15c:	e0 0f       	add	r30, r16
     15e:	e0 0f       	add	r30, r16
     160:	e0 0f       	add	r30, r16
     162:	f5 06       	cpc	r15, r21
     164:	50 07       	cpc	r21, r16
     166:	e4 0f       	add	r30, r20
     168:	e4 0f       	add	r30, r20
     16a:	5a 07       	cpc	r21, r26
     16c:	67 07       	cpc	r22, r23
     16e:	74 07       	cpc	r23, r20
     170:	81 07       	cpc	r24, r17
     172:	e4 0f       	add	r30, r20
     174:	85 07       	cpc	r24, r21
     176:	e4 0f       	add	r30, r20
     178:	93 07       	cpc	r25, r19
     17a:	e4 0f       	add	r30, r20
     17c:	9d 07       	cpc	r25, r29
     17e:	a7 07       	cpc	r26, r23
     180:	b1 07       	cpc	r27, r17
     182:	e4 0f       	add	r30, r20
     184:	e4 0f       	add	r30, r20
     186:	e4 0f       	add	r30, r20
     188:	c1 07       	cpc	r28, r17
     18a:	ce 07       	cpc	r28, r30
     18c:	db 07       	cpc	r29, r27
     18e:	4e 12       	cpse	r4, r30
     190:	52 12       	cpse	r5, r18
     192:	5a 12       	cpse	r5, r26
     194:	b0 12       	cpse	r11, r16
     196:	b0 12       	cpse	r11, r16
     198:	b0 12       	cpse	r11, r16
     19a:	b0 12       	cpse	r11, r16
     19c:	b0 12       	cpse	r11, r16
     19e:	b0 12       	cpse	r11, r16
     1a0:	b0 12       	cpse	r11, r16
     1a2:	b0 12       	cpse	r11, r16
     1a4:	b0 12       	cpse	r11, r16
     1a6:	63 12       	cpse	r6, r19
     1a8:	67 12       	cpse	r6, r23
     1aa:	6b 12       	cpse	r6, r27
     1ac:	6f 12       	cpse	r6, r31
     1ae:	73 12       	cpse	r7, r19
     1b0:	77 12       	cpse	r7, r23
     1b2:	7b 12       	cpse	r7, r27
     1b4:	7f 12       	cpse	r7, r31
     1b6:	b0 12       	cpse	r11, r16
     1b8:	83 12       	cpse	r8, r19
     1ba:	87 12       	cpse	r8, r23
     1bc:	8b 12       	cpse	r8, r27
     1be:	8f 12       	cpse	r8, r31
     1c0:	93 12       	cpse	r9, r19
     1c2:	97 12       	cpse	r9, r23
     1c4:	b0 12       	cpse	r11, r16
     1c6:	9b 12       	cpse	r9, r27
     1c8:	08 4a       	sbci	r16, 0xA8	; 168
     1ca:	d7 3b       	cpi	r29, 0xB7	; 183
     1cc:	3b ce       	rjmp	.-906    	; 0xfffffe44 <__eeprom_end+0xff7efe44>
     1ce:	01 6e       	ori	r16, 0xE1	; 225
     1d0:	84 bc       	out	0x24, r8	; 36
     1d2:	bf fd       	.word	0xfdbf	; ????
     1d4:	c1 2f       	mov	r28, r17
     1d6:	3d 6c       	ori	r19, 0xCD	; 205
     1d8:	74 31       	cpi	r23, 0x14	; 20
     1da:	9a bd       	out	0x2a, r25	; 42
     1dc:	56 83       	std	Z+6, r21	; 0x06
     1de:	3d da       	rcall	.-2950   	; 0xfffff65a <__eeprom_end+0xff7ef65a>
     1e0:	3d 00       	.word	0x003d	; ????
     1e2:	c7 7f       	andi	r28, 0xF7	; 247
     1e4:	11 be       	out	0x31, r1	; 49
     1e6:	d9 e4       	ldi	r29, 0x49	; 73
     1e8:	bb 4c       	sbci	r27, 0xCB	; 203
     1ea:	3e 91       	ld	r19, -X
     1ec:	6b aa       	std	Y+51, r6	; 0x33
     1ee:	aa be       	out	0x3a, r10	; 58
     1f0:	00 00       	nop
     1f2:	00 80       	ld	r0, Z
     1f4:	3f 05       	cpc	r19, r15
     1f6:	a8 4c       	sbci	r26, 0xC8	; 200
     1f8:	cd b2       	in	r12, 0x1d	; 29
     1fa:	d4 4e       	sbci	r29, 0xE4	; 228
     1fc:	b9 38       	cpi	r27, 0x89	; 137
     1fe:	36 a9       	ldd	r19, Z+54	; 0x36
     200:	02 0c       	add	r0, r2
     202:	50 b9       	out	0x00, r21	; 0
     204:	91 86       	std	Z+9, r9	; 0x09
     206:	88 08       	sbc	r8, r8
     208:	3c a6       	std	Y+44, r3	; 0x2c
     20a:	aa aa       	std	Y+50, r10	; 0x32
     20c:	2a be       	out	0x3a, r2	; 58
     20e:	00 00       	nop
     210:	00 80       	ld	r0, Z
     212:	3f 00       	.word	0x003f	; ????

00000214 <__trampolines_end>:
     214:	00 00       	nop
     216:	7a 43       	sbci	r23, 0x3A	; 58
     218:	00 00       	nop
     21a:	7a 43       	sbci	r23, 0x3A	; 58
     21c:	00 00       	nop
     21e:	7a 43       	sbci	r23, 0x3A	; 58
     220:	00 00       	nop
     222:	fa 43       	sbci	r31, 0x3A	; 58
     224:	00 00       	nop
     226:	fa 43       	sbci	r31, 0x3A	; 58
     228:	00 00       	nop
     22a:	fa 43       	sbci	r31, 0x3A	; 58
     22c:	00 a0       	ldd	r0, Z+32	; 0x20
     22e:	0c 47       	sbci	r16, 0x7C	; 124
     230:	00 a0       	ldd	r0, Z+32	; 0x20
     232:	0c 47       	sbci	r16, 0x7C	; 124
     234:	00 a0       	ldd	r0, Z+32	; 0x20
     236:	0c 47       	sbci	r16, 0x7C	; 124
     238:	00 00       	nop
     23a:	48 c3       	rjmp	.+1680   	; 0x8cc <__LOCK_REGION_LENGTH__+0x4cc>
     23c:	00 00       	nop
     23e:	48 c3       	rjmp	.+1680   	; 0x8d0 <__LOCK_REGION_LENGTH__+0x4d0>
     240:	00 00       	nop
     242:	48 c3       	rjmp	.+1680   	; 0x8d4 <__LOCK_REGION_LENGTH__+0x4d4>
     244:	0a 00       	.word	0x000a	; ????
     246:	00 19       	sub	r16, r0
     248:	01 0a       	sbc	r0, r17
     24a:	d7 23       	and	r29, r23
     24c:	3c 6f       	ori	r19, 0xFC	; 252
     24e:	12 03       	mulsu	r17, r18
     250:	3b 00       	.word	0x003b	; ????
     252:	00 7a       	andi	r16, 0xA0	; 160
     254:	44 00       	.word	0x0044	; ????
     256:	00 00       	nop
     258:	00 00       	nop
     25a:	00 00       	nop
     25c:	00 c8       	rjmp	.-4096   	; 0xfffff25e <__eeprom_end+0xff7ef25e>
     25e:	41 00       	.word	0x0041	; ????
     260:	00 fa       	bst	r0, 0
     262:	43 fa       	bst	r4, 3
     264:	00 00       	nop
     266:	00 80       	ld	r0, Z
     268:	3f 00       	.word	0x003f	; ????

0000026a <__ctors_end>:
     26a:	11 24       	eor	r1, r1
     26c:	1f be       	out	0x3f, r1	; 63
     26e:	cf ef       	ldi	r28, 0xFF	; 255
     270:	d8 e0       	ldi	r29, 0x08	; 8
     272:	de bf       	out	0x3e, r29	; 62
     274:	cd bf       	out	0x3d, r28	; 61

00000276 <__do_copy_data>:
     276:	11 e0       	ldi	r17, 0x01	; 1
     278:	a0 e0       	ldi	r26, 0x00	; 0
     27a:	b1 e0       	ldi	r27, 0x01	; 1
     27c:	e6 ec       	ldi	r30, 0xC6	; 198
     27e:	f5 e6       	ldi	r31, 0x65	; 101
     280:	02 c0       	rjmp	.+4      	; 0x286 <__do_copy_data+0x10>
     282:	05 90       	lpm	r0, Z+
     284:	0d 92       	st	X+, r0
     286:	a2 30       	cpi	r26, 0x02	; 2
     288:	b1 07       	cpc	r27, r17
     28a:	d9 f7       	brne	.-10     	; 0x282 <__do_copy_data+0xc>

0000028c <__do_clear_bss>:
     28c:	27 e0       	ldi	r18, 0x07	; 7
     28e:	a2 e0       	ldi	r26, 0x02	; 2
     290:	b1 e0       	ldi	r27, 0x01	; 1
     292:	01 c0       	rjmp	.+2      	; 0x296 <.do_clear_bss_start>

00000294 <.do_clear_bss_loop>:
     294:	1d 92       	st	X+, r1

00000296 <.do_clear_bss_start>:
     296:	a4 36       	cpi	r26, 0x64	; 100
     298:	b2 07       	cpc	r27, r18
     29a:	e1 f7       	brne	.-8      	; 0x294 <.do_clear_bss_loop>
     29c:	0e 94 54 01 	call	0x2a8	; 0x2a8 <main>
     2a0:	0c 94 e1 32 	jmp	0x65c2	; 0x65c2 <_exit>

000002a4 <__bad_interrupt>:
     2a4:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000002a8 <main>:


int main(void)
{
  // Initialize system upon power-up.
  serial_init();   // Setup serial baud rate and interrupts
     2a8:	0e 94 d7 11 	call	0x23ae	; 0x23ae <serial_init>
  settings_init(); // Load Grbl settings from EEPROM
     2ac:	0e 94 76 23 	call	0x46ec	; 0x46ec <settings_init>
  stepper_init();  // Configure stepper pins and interrupt timers
     2b0:	0e 94 37 19 	call	0x326e	; 0x326e <stepper_init>
  system_init();   // Configure pinout pins and pin-change interrupt
     2b4:	0e 94 f7 2c 	call	0x59ee	; 0x59ee <system_init>

  memset(sys_position,0,sizeof(sys_position)); // Clear machine position.
     2b8:	8c e0       	ldi	r24, 0x0C	; 12
     2ba:	ec e9       	ldi	r30, 0x9C	; 156
     2bc:	f5 e0       	ldi	r31, 0x05	; 5
     2be:	df 01       	movw	r26, r30
     2c0:	1d 92       	st	X+, r1
     2c2:	8a 95       	dec	r24
     2c4:	e9 f7       	brne	.-6      	; 0x2c0 <main+0x18>
  sei(); // Enable interrupts
     2c6:	78 94       	sei
  // Initialize system state.
  #ifdef FORCE_INITIALIZATION_ALARM
    // Force Grbl into an ALARM state upon a power-cycle or hard reset.
    sys.state = STATE_ALARM;
  #else
    sys.state = STATE_IDLE;
     2c8:	10 92 7c 05 	sts	0x057C, r1	; 0x80057c <sys>
  // cycle '$H' or kill alarm locks '$X' will disable the alarm.
  // NOTE: The startup script will run after successful completion of the homing cycle, but
  // not after disabling the alarm locks. Prevents motion startup blocks from crashing into
  // things uncontrollably. Very bad.
  #ifdef HOMING_INIT_LOCK
    if (bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE)) { sys.state = STATE_ALARM; }
     2cc:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <settings+0x45>
     2d0:	84 ff       	sbrs	r24, 4
     2d2:	03 c0       	rjmp	.+6      	; 0x2da <main+0x32>
     2d4:	81 e0       	ldi	r24, 0x01	; 1
     2d6:	80 93 7c 05 	sts	0x057C, r24	; 0x80057c <sys>
  // Grbl initialization loop upon power-up or a system abort. For the latter, all processes
  // will return to this loop to be cleanly re-initialized.
  for(;;) {

    // Reset system variables.
    uint8_t prior_state = sys.state;
     2da:	cc e7       	ldi	r28, 0x7C	; 124
     2dc:	d5 e0       	ldi	r29, 0x05	; 5
    memset(&sys, 0, sizeof(system_t)); // Clear system struct variable.
     2de:	0f 2e       	mov	r0, r31
     2e0:	f1 e1       	ldi	r31, 0x11	; 17
     2e2:	df 2e       	mov	r13, r31
     2e4:	f0 2d       	mov	r31, r0
    sys.state = prior_state;
    sys.f_override = DEFAULT_FEED_OVERRIDE;  // Set to 100%
     2e6:	14 e6       	ldi	r17, 0x64	; 100
    sys.r_override = DEFAULT_RAPID_OVERRIDE; // Set to 100%
    sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE; // Set to 100%
	memset(sys_probe_position,0,sizeof(sys_probe_position)); // Clear probe position.
     2e8:	0f 2e       	mov	r0, r31
     2ea:	f0 e9       	ldi	r31, 0x90	; 144
     2ec:	ef 2e       	mov	r14, r31
     2ee:	f5 e0       	ldi	r31, 0x05	; 5
     2f0:	ff 2e       	mov	r15, r31
     2f2:	f0 2d       	mov	r31, r0
     2f4:	0c e0       	ldi	r16, 0x0C	; 12
  // Grbl initialization loop upon power-up or a system abort. For the latter, all processes
  // will return to this loop to be cleanly re-initialized.
  for(;;) {

    // Reset system variables.
    uint8_t prior_state = sys.state;
     2f6:	88 81       	ld	r24, Y
    memset(&sys, 0, sizeof(system_t)); // Clear system struct variable.
     2f8:	fe 01       	movw	r30, r28
     2fa:	9d 2d       	mov	r25, r13
     2fc:	11 92       	st	Z+, r1
     2fe:	9a 95       	dec	r25
     300:	e9 f7       	brne	.-6      	; 0x2fc <main+0x54>
    sys.state = prior_state;
     302:	88 83       	st	Y, r24
    sys.f_override = DEFAULT_FEED_OVERRIDE;  // Set to 100%
     304:	1f 83       	std	Y+7, r17	; 0x07
    sys.r_override = DEFAULT_RAPID_OVERRIDE; // Set to 100%
     306:	18 87       	std	Y+8, r17	; 0x08
    sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE; // Set to 100%
     308:	19 87       	std	Y+9, r17	; 0x09
	memset(sys_probe_position,0,sizeof(sys_probe_position)); // Clear probe position.
     30a:	d7 01       	movw	r26, r14
     30c:	e0 2f       	mov	r30, r16
     30e:	1d 92       	st	X+, r1
     310:	ea 95       	dec	r30
     312:	e9 f7       	brne	.-6      	; 0x30e <main+0x66>
    sys_probe_state = 0;
     314:	10 92 8f 05 	sts	0x058F, r1	; 0x80058f <sys_probe_state>
    sys_rt_exec_state = 0;
     318:	10 92 8e 05 	sts	0x058E, r1	; 0x80058e <sys_rt_exec_state>
    sys_rt_exec_alarm = 0;
     31c:	10 92 a8 05 	sts	0x05A8, r1	; 0x8005a8 <sys_rt_exec_alarm>
    sys_rt_exec_motion_override = 0;
     320:	10 92 7b 05 	sts	0x057B, r1	; 0x80057b <sys_rt_exec_motion_override>
    sys_rt_exec_accessory_override = 0;
     324:	10 92 8d 05 	sts	0x058D, r1	; 0x80058d <sys_rt_exec_accessory_override>

    // Reset Grbl primary systems.
    serial_reset_read_buffer(); // Clear serial read buffer
     328:	0e 94 c1 12 	call	0x2582	; 0x2582 <serial_reset_read_buffer>
    gc_init(); // Set g-code parser to default state
     32c:	0e 94 81 05 	call	0xb02	; 0xb02 <gc_init>
    spindle_init();
     330:	0e 94 97 10 	call	0x212e	; 0x212e <spindle_init>
    coolant_init();
     334:	0e 94 ba 11 	call	0x2374	; 0x2374 <coolant_init>
    limits_init();
     338:	0e 94 e5 2b 	call	0x57ca	; 0x57ca <limits_init>
    probe_init();
     33c:	0e 94 cd 2c 	call	0x599a	; 0x599a <probe_init>
    plan_reset(); // Clear block buffer and planner variables
     340:	0e 94 11 25 	call	0x4a22	; 0x4a22 <plan_reset>
    st_reset(); // Clear stepper subsystem variables.
     344:	0e 94 04 19 	call	0x3208	; 0x3208 <st_reset>

    // Sync cleared gcode and planner positions to current system position.
    plan_sync_position();
     348:	0e 94 b3 29 	call	0x5366	; 0x5366 <plan_sync_position>
    gc_sync_position();
     34c:	0e 94 93 05 	call	0xb26	; 0xb26 <gc_sync_position>

    // Print welcome message. Indicates an initialization has occured at power-up or with a reset.
    report_init_message();
     350:	0e 94 f1 2c 	call	0x59e2	; 0x59e2 <report_init_message>

    // Start Grbl main loop. Processes program inputs and executes them.
    protocol_main_loop();
     354:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <protocol_main_loop>
     358:	ce cf       	rjmp	.-100    	; 0x2f6 <main+0x4e>

0000035a <mc_line>:
  // Sync gcode parser and planner positions to homed position.
  gc_sync_position();
  plan_sync_position();

  // If hard limits feature enabled, re-enable hard limits pin change register after homing cycle.
  limits_init();
     35a:	ef 92       	push	r14
     35c:	ff 92       	push	r15
     35e:	0f 93       	push	r16
     360:	1f 93       	push	r17
     362:	cf 93       	push	r28
     364:	df 93       	push	r29
     366:	8c 01       	movw	r16, r24
     368:	7b 01       	movw	r14, r22
     36a:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <settings+0x45>
     36e:	85 ff       	sbrs	r24, 5
     370:	07 c0       	rjmp	.+14     	; 0x380 <mc_line+0x26>
     372:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
     376:	80 32       	cpi	r24, 0x20	; 32
     378:	39 f0       	breq	.+14     	; 0x388 <mc_line+0x2e>
     37a:	c8 01       	movw	r24, r16
     37c:	0e 94 5e 2c 	call	0x58bc	; 0x58bc <limits_soft_check>
     380:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
     384:	82 30       	cpi	r24, 0x02	; 2
     386:	19 f1       	breq	.+70     	; 0x3ce <mc_line+0x74>
     388:	cc e7       	ldi	r28, 0x7C	; 124
     38a:	d5 e0       	ldi	r29, 0x05	; 5
     38c:	0e 94 9e 14 	call	0x293c	; 0x293c <protocol_execute_realtime>
     390:	89 81       	ldd	r24, Y+1	; 0x01
     392:	81 11       	cpse	r24, r1
     394:	1c c0       	rjmp	.+56     	; 0x3ce <mc_line+0x74>
     396:	0e 94 61 25 	call	0x4ac2	; 0x4ac2 <plan_check_full_buffer>
     39a:	88 23       	and	r24, r24
     39c:	19 f0       	breq	.+6      	; 0x3a4 <mc_line+0x4a>
     39e:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <protocol_auto_cycle_start>
     3a2:	f4 cf       	rjmp	.-24     	; 0x38c <mc_line+0x32>
     3a4:	b7 01       	movw	r22, r14
     3a6:	c8 01       	movw	r24, r16
     3a8:	0e 94 a0 26 	call	0x4d40	; 0x4d40 <plan_buffer_line>
     3ac:	81 11       	cpse	r24, r1
     3ae:	0f c0       	rjmp	.+30     	; 0x3ce <mc_line+0x74>
     3b0:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <settings+0x45>
     3b4:	81 ff       	sbrs	r24, 1
     3b6:	0b c0       	rjmp	.+22     	; 0x3ce <mc_line+0x74>
     3b8:	f7 01       	movw	r30, r14
     3ba:	80 85       	ldd	r24, Z+8	; 0x08
     3bc:	84 ff       	sbrs	r24, 4
     3be:	07 c0       	rjmp	.+14     	; 0x3ce <mc_line+0x74>
     3c0:	44 81       	ldd	r20, Z+4	; 0x04
     3c2:	55 81       	ldd	r21, Z+5	; 0x05
     3c4:	66 81       	ldd	r22, Z+6	; 0x06
     3c6:	77 81       	ldd	r23, Z+7	; 0x07
     3c8:	80 e1       	ldi	r24, 0x10	; 16
     3ca:	0e 94 99 11 	call	0x2332	; 0x2332 <spindle_sync>
     3ce:	df 91       	pop	r29
     3d0:	cf 91       	pop	r28
     3d2:	1f 91       	pop	r17
     3d4:	0f 91       	pop	r16
     3d6:	ff 90       	pop	r15
     3d8:	ef 90       	pop	r14
     3da:	08 95       	ret

000003dc <mc_arc>:
     3dc:	2f 92       	push	r2
     3de:	3f 92       	push	r3
     3e0:	4f 92       	push	r4
     3e2:	5f 92       	push	r5
     3e4:	6f 92       	push	r6
     3e6:	7f 92       	push	r7
     3e8:	8f 92       	push	r8
     3ea:	9f 92       	push	r9
     3ec:	af 92       	push	r10
     3ee:	bf 92       	push	r11
     3f0:	cf 92       	push	r12
     3f2:	df 92       	push	r13
     3f4:	ef 92       	push	r14
     3f6:	ff 92       	push	r15
     3f8:	0f 93       	push	r16
     3fa:	1f 93       	push	r17
     3fc:	cf 93       	push	r28
     3fe:	df 93       	push	r29
     400:	cd b7       	in	r28, 0x3d	; 61
     402:	de b7       	in	r29, 0x3e	; 62
     404:	e2 97       	sbiw	r28, 0x32	; 50
     406:	0f b6       	in	r0, 0x3f	; 63
     408:	f8 94       	cli
     40a:	de bf       	out	0x3e, r29	; 62
     40c:	0f be       	out	0x3f, r0	; 63
     40e:	cd bf       	out	0x3d, r28	; 61
     410:	9a ab       	std	Y+50, r25	; 0x32
     412:	89 ab       	std	Y+49, r24	; 0x31
     414:	78 8b       	std	Y+16, r23	; 0x10
     416:	6f 87       	std	Y+15, r22	; 0x0f
     418:	5e 87       	std	Y+14, r21	; 0x0e
     41a:	4d 87       	std	Y+13, r20	; 0x0d
     41c:	39 01       	movw	r6, r18
     41e:	ed 82       	std	Y+5, r14	; 0x05
     420:	fe 82       	std	Y+6, r15	; 0x06
     422:	0f 83       	std	Y+7, r16	; 0x07
     424:	18 87       	std	Y+8, r17	; 0x08
     426:	89 8a       	std	Y+17, r8	; 0x11
     428:	d1 2c       	mov	r13, r1
     42a:	cc 0c       	add	r12, r12
     42c:	dd 1c       	adc	r13, r13
     42e:	cc 0c       	add	r12, r12
     430:	dd 1c       	adc	r13, r13
     432:	ca 01       	movw	r24, r20
     434:	8c 0d       	add	r24, r12
     436:	9d 1d       	adc	r25, r13
     438:	9e 8b       	std	Y+22, r25	; 0x16
     43a:	8d 8b       	std	Y+21, r24	; 0x15
     43c:	d9 01       	movw	r26, r18
     43e:	ac 0d       	add	r26, r12
     440:	bd 1d       	adc	r27, r13
     442:	be a7       	std	Y+46, r27	; 0x2e
     444:	ad a7       	std	Y+45, r26	; 0x2d
     446:	2d 90       	ld	r2, X+
     448:	3d 90       	ld	r3, X+
     44a:	4d 90       	ld	r4, X+
     44c:	5c 90       	ld	r5, X
     44e:	fc 01       	movw	r30, r24
     450:	20 81       	ld	r18, Z
     452:	31 81       	ldd	r19, Z+1	; 0x01
     454:	42 81       	ldd	r20, Z+2	; 0x02
     456:	53 81       	ldd	r21, Z+3	; 0x03
     458:	c2 01       	movw	r24, r4
     45a:	b1 01       	movw	r22, r2
     45c:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
     460:	6f 8b       	std	Y+23, r22	; 0x17
     462:	78 8f       	std	Y+24, r23	; 0x18
     464:	89 8f       	std	Y+25, r24	; 0x19
     466:	9a 8f       	std	Y+26, r25	; 0x1a
     468:	0a 2d       	mov	r16, r10
     46a:	10 e0       	ldi	r17, 0x00	; 0
     46c:	00 0f       	add	r16, r16
     46e:	11 1f       	adc	r17, r17
     470:	00 0f       	add	r16, r16
     472:	11 1f       	adc	r17, r17
     474:	8d 85       	ldd	r24, Y+13	; 0x0d
     476:	9e 85       	ldd	r25, Y+14	; 0x0e
     478:	80 0f       	add	r24, r16
     47a:	91 1f       	adc	r25, r17
     47c:	9c 8f       	std	Y+28, r25	; 0x1c
     47e:	8b 8f       	std	Y+27, r24	; 0x1b
     480:	d3 01       	movw	r26, r6
     482:	a0 0f       	add	r26, r16
     484:	b1 1f       	adc	r27, r17
     486:	b8 ab       	std	Y+48, r27	; 0x30
     488:	af a7       	std	Y+47, r26	; 0x2f
     48a:	8d 90       	ld	r8, X+
     48c:	9d 90       	ld	r9, X+
     48e:	ad 90       	ld	r10, X+
     490:	bc 90       	ld	r11, X
     492:	fc 01       	movw	r30, r24
     494:	20 81       	ld	r18, Z
     496:	31 81       	ldd	r19, Z+1	; 0x01
     498:	42 81       	ldd	r20, Z+2	; 0x02
     49a:	53 81       	ldd	r21, Z+3	; 0x03
     49c:	c5 01       	movw	r24, r10
     49e:	b4 01       	movw	r22, r8
     4a0:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
     4a4:	6d 8f       	std	Y+29, r22	; 0x1d
     4a6:	7e 8f       	std	Y+30, r23	; 0x1e
     4a8:	8f 8f       	std	Y+31, r24	; 0x1f
     4aa:	98 a3       	std	Y+32, r25	; 0x20
     4ac:	d2 01       	movw	r26, r4
     4ae:	c1 01       	movw	r24, r2
     4b0:	b0 58       	subi	r27, 0x80	; 128
     4b2:	89 83       	std	Y+1, r24	; 0x01
     4b4:	9a 83       	std	Y+2, r25	; 0x02
     4b6:	ab 83       	std	Y+3, r26	; 0x03
     4b8:	bc 83       	std	Y+4, r27	; 0x04
     4ba:	d5 01       	movw	r26, r10
     4bc:	c4 01       	movw	r24, r8
     4be:	b0 58       	subi	r27, 0x80	; 128
     4c0:	89 87       	std	Y+9, r24	; 0x09
     4c2:	9a 87       	std	Y+10, r25	; 0x0a
     4c4:	ab 87       	std	Y+11, r26	; 0x0b
     4c6:	bc 87       	std	Y+12, r27	; 0x0c
     4c8:	e9 a9       	ldd	r30, Y+49	; 0x31
     4ca:	fa a9       	ldd	r31, Y+50	; 0x32
     4cc:	ec 0d       	add	r30, r12
     4ce:	fd 1d       	adc	r31, r13
     4d0:	2f 89       	ldd	r18, Y+23	; 0x17
     4d2:	38 8d       	ldd	r19, Y+24	; 0x18
     4d4:	49 8d       	ldd	r20, Y+25	; 0x19
     4d6:	5a 8d       	ldd	r21, Y+26	; 0x1a
     4d8:	60 81       	ld	r22, Z
     4da:	71 81       	ldd	r23, Z+1	; 0x01
     4dc:	82 81       	ldd	r24, Z+2	; 0x02
     4de:	93 81       	ldd	r25, Z+3	; 0x03
     4e0:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
     4e4:	6b 01       	movw	r12, r22
     4e6:	7c 01       	movw	r14, r24
     4e8:	e9 a9       	ldd	r30, Y+49	; 0x31
     4ea:	fa a9       	ldd	r31, Y+50	; 0x32
     4ec:	e0 0f       	add	r30, r16
     4ee:	f1 1f       	adc	r31, r17
     4f0:	2d 8d       	ldd	r18, Y+29	; 0x1d
     4f2:	3e 8d       	ldd	r19, Y+30	; 0x1e
     4f4:	4f 8d       	ldd	r20, Y+31	; 0x1f
     4f6:	58 a1       	ldd	r21, Y+32	; 0x20
     4f8:	60 81       	ld	r22, Z
     4fa:	71 81       	ldd	r23, Z+1	; 0x01
     4fc:	82 81       	ldd	r24, Z+2	; 0x02
     4fe:	93 81       	ldd	r25, Z+3	; 0x03
     500:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
     504:	4b 01       	movw	r8, r22
     506:	5c 01       	movw	r10, r24
     508:	a7 01       	movw	r20, r14
     50a:	96 01       	movw	r18, r12
     50c:	69 81       	ldd	r22, Y+1	; 0x01
     50e:	7a 81       	ldd	r23, Y+2	; 0x02
     510:	8b 81       	ldd	r24, Y+3	; 0x03
     512:	9c 81       	ldd	r25, Y+4	; 0x04
     514:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
     518:	2b 01       	movw	r4, r22
     51a:	3c 01       	movw	r6, r24
     51c:	a5 01       	movw	r20, r10
     51e:	94 01       	movw	r18, r8
     520:	69 85       	ldd	r22, Y+9	; 0x09
     522:	7a 85       	ldd	r23, Y+10	; 0x0a
     524:	8b 85       	ldd	r24, Y+11	; 0x0b
     526:	9c 85       	ldd	r25, Y+12	; 0x0c
     528:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
     52c:	9b 01       	movw	r18, r22
     52e:	ac 01       	movw	r20, r24
     530:	c3 01       	movw	r24, r6
     532:	b2 01       	movw	r22, r4
     534:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
     538:	2b 01       	movw	r4, r22
     53a:	3c 01       	movw	r6, r24
     53c:	a5 01       	movw	r20, r10
     53e:	94 01       	movw	r18, r8
     540:	69 81       	ldd	r22, Y+1	; 0x01
     542:	7a 81       	ldd	r23, Y+2	; 0x02
     544:	8b 81       	ldd	r24, Y+3	; 0x03
     546:	9c 81       	ldd	r25, Y+4	; 0x04
     548:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
     54c:	4b 01       	movw	r8, r22
     54e:	5c 01       	movw	r10, r24
     550:	a7 01       	movw	r20, r14
     552:	96 01       	movw	r18, r12
     554:	69 85       	ldd	r22, Y+9	; 0x09
     556:	7a 85       	ldd	r23, Y+10	; 0x0a
     558:	8b 85       	ldd	r24, Y+11	; 0x0b
     55a:	9c 85       	ldd	r25, Y+12	; 0x0c
     55c:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
     560:	9b 01       	movw	r18, r22
     562:	ac 01       	movw	r20, r24
     564:	c5 01       	movw	r24, r10
     566:	b4 01       	movw	r22, r8
     568:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
     56c:	a3 01       	movw	r20, r6
     56e:	92 01       	movw	r18, r4
     570:	0e 94 de 2e 	call	0x5dbc	; 0x5dbc <atan2>
     574:	4b 01       	movw	r8, r22
     576:	5c 01       	movw	r10, r24
     578:	28 96       	adiw	r28, 0x08	; 8
     57a:	8f ad       	ldd	r24, Y+63	; 0x3f
     57c:	28 97       	sbiw	r28, 0x08	; 8
     57e:	88 23       	and	r24, r24
     580:	a9 f0       	breq	.+42     	; 0x5ac <__LOCK_REGION_LENGTH__+0x1ac>
     582:	2d eb       	ldi	r18, 0xBD	; 189
     584:	37 e3       	ldi	r19, 0x37	; 55
     586:	46 e0       	ldi	r20, 0x06	; 6
     588:	55 eb       	ldi	r21, 0xB5	; 181
     58a:	c5 01       	movw	r24, r10
     58c:	b4 01       	movw	r22, r8
     58e:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
     592:	88 23       	and	r24, r24
     594:	fc f0       	brlt	.+62     	; 0x5d4 <__LOCK_REGION_LENGTH__+0x1d4>
     596:	2b ed       	ldi	r18, 0xDB	; 219
     598:	3f e0       	ldi	r19, 0x0F	; 15
     59a:	49 ec       	ldi	r20, 0xC9	; 201
     59c:	50 e4       	ldi	r21, 0x40	; 64
     59e:	c5 01       	movw	r24, r10
     5a0:	b4 01       	movw	r22, r8
     5a2:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
     5a6:	4b 01       	movw	r8, r22
     5a8:	5c 01       	movw	r10, r24
     5aa:	14 c0       	rjmp	.+40     	; 0x5d4 <__LOCK_REGION_LENGTH__+0x1d4>
     5ac:	2d eb       	ldi	r18, 0xBD	; 189
     5ae:	37 e3       	ldi	r19, 0x37	; 55
     5b0:	46 e0       	ldi	r20, 0x06	; 6
     5b2:	55 e3       	ldi	r21, 0x35	; 53
     5b4:	c5 01       	movw	r24, r10
     5b6:	b4 01       	movw	r22, r8
     5b8:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
     5bc:	18 16       	cp	r1, r24
     5be:	54 f0       	brlt	.+20     	; 0x5d4 <__LOCK_REGION_LENGTH__+0x1d4>
     5c0:	2b ed       	ldi	r18, 0xDB	; 219
     5c2:	3f e0       	ldi	r19, 0x0F	; 15
     5c4:	49 ec       	ldi	r20, 0xC9	; 201
     5c6:	50 e4       	ldi	r21, 0x40	; 64
     5c8:	c5 01       	movw	r24, r10
     5ca:	b4 01       	movw	r22, r8
     5cc:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
     5d0:	4b 01       	movw	r8, r22
     5d2:	5c 01       	movw	r10, r24
     5d4:	c0 90 47 07 	lds	r12, 0x0747	; 0x800747 <settings+0x39>
     5d8:	d0 90 48 07 	lds	r13, 0x0748	; 0x800748 <settings+0x3a>
     5dc:	e0 90 49 07 	lds	r14, 0x0749	; 0x800749 <settings+0x3b>
     5e0:	f0 90 4a 07 	lds	r15, 0x074A	; 0x80074a <settings+0x3c>
     5e4:	2d 81       	ldd	r18, Y+5	; 0x05
     5e6:	3e 81       	ldd	r19, Y+6	; 0x06
     5e8:	4f 81       	ldd	r20, Y+7	; 0x07
     5ea:	58 85       	ldd	r21, Y+8	; 0x08
     5ec:	ca 01       	movw	r24, r20
     5ee:	b9 01       	movw	r22, r18
     5f0:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
     5f4:	2b 01       	movw	r4, r22
     5f6:	3c 01       	movw	r6, r24
     5f8:	a7 01       	movw	r20, r14
     5fa:	96 01       	movw	r18, r12
     5fc:	c3 01       	movw	r24, r6
     5fe:	b2 01       	movw	r22, r4
     600:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
     604:	a7 01       	movw	r20, r14
     606:	96 01       	movw	r18, r12
     608:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
     60c:	0e 94 55 32 	call	0x64aa	; 0x64aa <sqrt>
     610:	6b 01       	movw	r12, r22
     612:	7c 01       	movw	r14, r24
     614:	20 e0       	ldi	r18, 0x00	; 0
     616:	30 e0       	ldi	r19, 0x00	; 0
     618:	40 e0       	ldi	r20, 0x00	; 0
     61a:	5f e3       	ldi	r21, 0x3F	; 63
     61c:	c5 01       	movw	r24, r10
     61e:	b4 01       	movw	r22, r8
     620:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
     624:	2d 81       	ldd	r18, Y+5	; 0x05
     626:	3e 81       	ldd	r19, Y+6	; 0x06
     628:	4f 81       	ldd	r20, Y+7	; 0x07
     62a:	58 85       	ldd	r21, Y+8	; 0x08
     62c:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
     630:	9f 77       	andi	r25, 0x7F	; 127
     632:	a7 01       	movw	r20, r14
     634:	96 01       	movw	r18, r12
     636:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <__divsf3>
     63a:	0e 94 43 30 	call	0x6086	; 0x6086 <floor>
     63e:	0e 94 d7 2f 	call	0x5fae	; 0x5fae <__fixunssfsi>
     642:	6b 01       	movw	r12, r22
     644:	7c 01       	movw	r14, r24
     646:	3b 01       	movw	r6, r22
     648:	61 15       	cp	r22, r1
     64a:	71 05       	cpc	r23, r1
     64c:	09 f4       	brne	.+2      	; 0x650 <__LOCK_REGION_LENGTH__+0x250>
     64e:	88 c1       	rjmp	.+784    	; 0x960 <__stack+0x61>
     650:	af 85       	ldd	r26, Y+15	; 0x0f
     652:	b8 89       	ldd	r27, Y+16	; 0x10
     654:	18 96       	adiw	r26, 0x08	; 8
     656:	1c 91       	ld	r17, X
     658:	13 ff       	sbrs	r17, 3
     65a:	18 c0       	rjmp	.+48     	; 0x68c <__LOCK_REGION_LENGTH__+0x28c>
     65c:	80 e0       	ldi	r24, 0x00	; 0
     65e:	90 e0       	ldi	r25, 0x00	; 0
     660:	0e 94 06 30 	call	0x600c	; 0x600c <__floatunsisf>
     664:	9b 01       	movw	r18, r22
     666:	ac 01       	movw	r20, r24
     668:	ef 85       	ldd	r30, Y+15	; 0x0f
     66a:	f8 89       	ldd	r31, Y+16	; 0x10
     66c:	60 81       	ld	r22, Z
     66e:	71 81       	ldd	r23, Z+1	; 0x01
     670:	82 81       	ldd	r24, Z+2	; 0x02
     672:	93 81       	ldd	r25, Z+3	; 0x03
     674:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
     678:	af 85       	ldd	r26, Y+15	; 0x0f
     67a:	b8 89       	ldd	r27, Y+16	; 0x10
     67c:	6d 93       	st	X+, r22
     67e:	7d 93       	st	X+, r23
     680:	8d 93       	st	X+, r24
     682:	9c 93       	st	X, r25
     684:	13 97       	sbiw	r26, 0x03	; 3
     686:	17 7f       	andi	r17, 0xF7	; 247
     688:	18 96       	adiw	r26, 0x08	; 8
     68a:	1c 93       	st	X, r17
     68c:	b6 01       	movw	r22, r12
     68e:	80 e0       	ldi	r24, 0x00	; 0
     690:	90 e0       	ldi	r25, 0x00	; 0
     692:	0e 94 06 30 	call	0x600c	; 0x600c <__floatunsisf>
     696:	6b 01       	movw	r12, r22
     698:	7c 01       	movw	r14, r24
     69a:	9b 01       	movw	r18, r22
     69c:	ac 01       	movw	r20, r24
     69e:	c5 01       	movw	r24, r10
     6a0:	b4 01       	movw	r22, r8
     6a2:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <__divsf3>
     6a6:	69 a7       	std	Y+41, r22	; 0x29
     6a8:	7a a7       	std	Y+42, r23	; 0x2a
     6aa:	8b a7       	std	Y+43, r24	; 0x2b
     6ac:	9c a7       	std	Y+44, r25	; 0x2c
     6ae:	b9 89       	ldd	r27, Y+17	; 0x11
     6b0:	8b 2e       	mov	r8, r27
     6b2:	91 2c       	mov	r9, r1
     6b4:	88 0c       	add	r8, r8
     6b6:	99 1c       	adc	r9, r9
     6b8:	88 0c       	add	r8, r8
     6ba:	99 1c       	adc	r9, r9
     6bc:	4d 84       	ldd	r4, Y+13	; 0x0d
     6be:	5e 84       	ldd	r5, Y+14	; 0x0e
     6c0:	48 0c       	add	r4, r8
     6c2:	59 1c       	adc	r5, r9
     6c4:	e9 a9       	ldd	r30, Y+49	; 0x31
     6c6:	fa a9       	ldd	r31, Y+50	; 0x32
     6c8:	e8 0d       	add	r30, r8
     6ca:	f9 1d       	adc	r31, r9
     6cc:	d2 01       	movw	r26, r4
     6ce:	2d 91       	ld	r18, X+
     6d0:	3d 91       	ld	r19, X+
     6d2:	4d 91       	ld	r20, X+
     6d4:	5c 91       	ld	r21, X
     6d6:	60 81       	ld	r22, Z
     6d8:	71 81       	ldd	r23, Z+1	; 0x01
     6da:	82 81       	ldd	r24, Z+2	; 0x02
     6dc:	93 81       	ldd	r25, Z+3	; 0x03
     6de:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
     6e2:	a7 01       	movw	r20, r14
     6e4:	96 01       	movw	r18, r12
     6e6:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <__divsf3>
     6ea:	69 8b       	std	Y+17, r22	; 0x11
     6ec:	7a 8b       	std	Y+18, r23	; 0x12
     6ee:	8b 8b       	std	Y+19, r24	; 0x13
     6f0:	9c 8b       	std	Y+20, r25	; 0x14
     6f2:	29 a5       	ldd	r18, Y+41	; 0x29
     6f4:	3a a5       	ldd	r19, Y+42	; 0x2a
     6f6:	4b a5       	ldd	r20, Y+43	; 0x2b
     6f8:	5c a5       	ldd	r21, Y+44	; 0x2c
     6fa:	ca 01       	movw	r24, r20
     6fc:	b9 01       	movw	r22, r18
     6fe:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
     702:	9b 01       	movw	r18, r22
     704:	ac 01       	movw	r20, r24
     706:	60 e0       	ldi	r22, 0x00	; 0
     708:	70 e0       	ldi	r23, 0x00	; 0
     70a:	80 e0       	ldi	r24, 0x00	; 0
     70c:	90 e4       	ldi	r25, 0x40	; 64
     70e:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
     712:	6b 01       	movw	r12, r22
     714:	7c 01       	movw	r14, r24
     716:	2b ea       	ldi	r18, 0xAB	; 171
     718:	3a ea       	ldi	r19, 0xAA	; 170
     71a:	4a e2       	ldi	r20, 0x2A	; 42
     71c:	5e e3       	ldi	r21, 0x3E	; 62
     71e:	69 a5       	ldd	r22, Y+41	; 0x29
     720:	7a a5       	ldd	r23, Y+42	; 0x2a
     722:	8b a5       	ldd	r24, Y+43	; 0x2b
     724:	9c a5       	ldd	r25, Y+44	; 0x2c
     726:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
     72a:	4b 01       	movw	r8, r22
     72c:	5c 01       	movw	r10, r24
     72e:	20 e0       	ldi	r18, 0x00	; 0
     730:	30 e0       	ldi	r19, 0x00	; 0
     732:	40 e8       	ldi	r20, 0x80	; 128
     734:	50 e4       	ldi	r21, 0x40	; 64
     736:	c7 01       	movw	r24, r14
     738:	b6 01       	movw	r22, r12
     73a:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
     73e:	9b 01       	movw	r18, r22
     740:	ac 01       	movw	r20, r24
     742:	c5 01       	movw	r24, r10
     744:	b4 01       	movw	r22, r8
     746:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
     74a:	69 a3       	std	Y+33, r22	; 0x21
     74c:	7a a3       	std	Y+34, r23	; 0x22
     74e:	8b a3       	std	Y+35, r24	; 0x23
     750:	9c a3       	std	Y+36, r25	; 0x24
     752:	20 e0       	ldi	r18, 0x00	; 0
     754:	30 e0       	ldi	r19, 0x00	; 0
     756:	40 e0       	ldi	r20, 0x00	; 0
     758:	5f e3       	ldi	r21, 0x3F	; 63
     75a:	c7 01       	movw	r24, r14
     75c:	b6 01       	movw	r22, r12
     75e:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
     762:	6d a3       	std	Y+37, r22	; 0x25
     764:	7e a3       	std	Y+38, r23	; 0x26
     766:	8f a3       	std	Y+39, r24	; 0x27
     768:	98 a7       	std	Y+40, r25	; 0x28
     76a:	b2 e0       	ldi	r27, 0x02	; 2
     76c:	6b 16       	cp	r6, r27
     76e:	71 04       	cpc	r7, r1
     770:	08 f4       	brcc	.+2      	; 0x774 <__LOCK_REGION_LENGTH__+0x374>
     772:	f6 c0       	rjmp	.+492    	; 0x960 <__stack+0x61>
     774:	10 e0       	ldi	r17, 0x00	; 0
     776:	22 24       	eor	r2, r2
     778:	23 94       	inc	r2
     77a:	31 2c       	mov	r3, r1
     77c:	c9 84       	ldd	r12, Y+9	; 0x09
     77e:	da 84       	ldd	r13, Y+10	; 0x0a
     780:	eb 84       	ldd	r14, Y+11	; 0x0b
     782:	fc 84       	ldd	r15, Y+12	; 0x0c
     784:	1c 30       	cpi	r17, 0x0C	; 12
     786:	08 f0       	brcs	.+2      	; 0x78a <__LOCK_REGION_LENGTH__+0x38a>
     788:	44 c0       	rjmp	.+136    	; 0x812 <__LOCK_REGION_LENGTH__+0x412>
     78a:	a7 01       	movw	r20, r14
     78c:	96 01       	movw	r18, r12
     78e:	6d a1       	ldd	r22, Y+37	; 0x25
     790:	7e a1       	ldd	r23, Y+38	; 0x26
     792:	8f a1       	ldd	r24, Y+39	; 0x27
     794:	98 a5       	ldd	r25, Y+40	; 0x28
     796:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
     79a:	4b 01       	movw	r8, r22
     79c:	5c 01       	movw	r10, r24
     79e:	29 81       	ldd	r18, Y+1	; 0x01
     7a0:	3a 81       	ldd	r19, Y+2	; 0x02
     7a2:	4b 81       	ldd	r20, Y+3	; 0x03
     7a4:	5c 81       	ldd	r21, Y+4	; 0x04
     7a6:	69 a1       	ldd	r22, Y+33	; 0x21
     7a8:	7a a1       	ldd	r23, Y+34	; 0x22
     7aa:	8b a1       	ldd	r24, Y+35	; 0x23
     7ac:	9c a1       	ldd	r25, Y+36	; 0x24
     7ae:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
     7b2:	a5 01       	movw	r20, r10
     7b4:	94 01       	movw	r18, r8
     7b6:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
     7ba:	96 2e       	mov	r9, r22
     7bc:	a7 2e       	mov	r10, r23
     7be:	b8 2e       	mov	r11, r24
     7c0:	09 2f       	mov	r16, r25
     7c2:	29 81       	ldd	r18, Y+1	; 0x01
     7c4:	3a 81       	ldd	r19, Y+2	; 0x02
     7c6:	4b 81       	ldd	r20, Y+3	; 0x03
     7c8:	5c 81       	ldd	r21, Y+4	; 0x04
     7ca:	6d a1       	ldd	r22, Y+37	; 0x25
     7cc:	7e a1       	ldd	r23, Y+38	; 0x26
     7ce:	8f a1       	ldd	r24, Y+39	; 0x27
     7d0:	98 a5       	ldd	r25, Y+40	; 0x28
     7d2:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
     7d6:	69 83       	std	Y+1, r22	; 0x01
     7d8:	7a 83       	std	Y+2, r23	; 0x02
     7da:	8b 83       	std	Y+3, r24	; 0x03
     7dc:	9c 83       	std	Y+4, r25	; 0x04
     7de:	a7 01       	movw	r20, r14
     7e0:	96 01       	movw	r18, r12
     7e2:	69 a1       	ldd	r22, Y+33	; 0x21
     7e4:	7a a1       	ldd	r23, Y+34	; 0x22
     7e6:	8b a1       	ldd	r24, Y+35	; 0x23
     7e8:	9c a1       	ldd	r25, Y+36	; 0x24
     7ea:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
     7ee:	9b 01       	movw	r18, r22
     7f0:	ac 01       	movw	r20, r24
     7f2:	69 81       	ldd	r22, Y+1	; 0x01
     7f4:	7a 81       	ldd	r23, Y+2	; 0x02
     7f6:	8b 81       	ldd	r24, Y+3	; 0x03
     7f8:	9c 81       	ldd	r25, Y+4	; 0x04
     7fa:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
     7fe:	69 83       	std	Y+1, r22	; 0x01
     800:	7a 83       	std	Y+2, r23	; 0x02
     802:	8b 83       	std	Y+3, r24	; 0x03
     804:	9c 83       	std	Y+4, r25	; 0x04
     806:	1f 5f       	subi	r17, 0xFF	; 255
     808:	c9 2c       	mov	r12, r9
     80a:	da 2c       	mov	r13, r10
     80c:	eb 2c       	mov	r14, r11
     80e:	f0 2e       	mov	r15, r16
     810:	66 c0       	rjmp	.+204    	; 0x8de <__LOCK_REGION_LENGTH__+0x4de>
     812:	b1 01       	movw	r22, r2
     814:	80 e0       	ldi	r24, 0x00	; 0
     816:	90 e0       	ldi	r25, 0x00	; 0
     818:	0e 94 06 30 	call	0x600c	; 0x600c <__floatunsisf>
     81c:	29 a5       	ldd	r18, Y+41	; 0x29
     81e:	3a a5       	ldd	r19, Y+42	; 0x2a
     820:	4b a5       	ldd	r20, Y+43	; 0x2b
     822:	5c a5       	ldd	r21, Y+44	; 0x2c
     824:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
     828:	6b 01       	movw	r12, r22
     82a:	7c 01       	movw	r14, r24
     82c:	0e 94 59 2f 	call	0x5eb2	; 0x5eb2 <cos>
     830:	6d 83       	std	Y+5, r22	; 0x05
     832:	7e 83       	std	Y+6, r23	; 0x06
     834:	8f 83       	std	Y+7, r24	; 0x07
     836:	98 87       	std	Y+8, r25	; 0x08
     838:	c7 01       	movw	r24, r14
     83a:	b6 01       	movw	r22, r12
     83c:	0e 94 47 32 	call	0x648e	; 0x648e <sin>
     840:	69 87       	std	Y+9, r22	; 0x09
     842:	7a 87       	std	Y+10, r23	; 0x0a
     844:	8b 87       	std	Y+11, r24	; 0x0b
     846:	9c 87       	std	Y+12, r25	; 0x0c
     848:	ed a5       	ldd	r30, Y+45	; 0x2d
     84a:	fe a5       	ldd	r31, Y+46	; 0x2e
     84c:	c0 80       	ld	r12, Z
     84e:	d1 80       	ldd	r13, Z+1	; 0x01
     850:	e2 80       	ldd	r14, Z+2	; 0x02
     852:	f3 80       	ldd	r15, Z+3	; 0x03
     854:	f7 fa       	bst	r15, 7
     856:	f0 94       	com	r15
     858:	f7 f8       	bld	r15, 7
     85a:	f0 94       	com	r15
     85c:	af a5       	ldd	r26, Y+47	; 0x2f
     85e:	b8 a9       	ldd	r27, Y+48	; 0x30
     860:	8d 90       	ld	r8, X+
     862:	9d 90       	ld	r9, X+
     864:	ad 90       	ld	r10, X+
     866:	bc 90       	ld	r11, X
     868:	a7 01       	movw	r20, r14
     86a:	96 01       	movw	r18, r12
     86c:	6d 81       	ldd	r22, Y+5	; 0x05
     86e:	7e 81       	ldd	r23, Y+6	; 0x06
     870:	8f 81       	ldd	r24, Y+7	; 0x07
     872:	98 85       	ldd	r25, Y+8	; 0x08
     874:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
     878:	69 83       	std	Y+1, r22	; 0x01
     87a:	7a 83       	std	Y+2, r23	; 0x02
     87c:	8b 83       	std	Y+3, r24	; 0x03
     87e:	9c 83       	std	Y+4, r25	; 0x04
     880:	a5 01       	movw	r20, r10
     882:	94 01       	movw	r18, r8
     884:	69 85       	ldd	r22, Y+9	; 0x09
     886:	7a 85       	ldd	r23, Y+10	; 0x0a
     888:	8b 85       	ldd	r24, Y+11	; 0x0b
     88a:	9c 85       	ldd	r25, Y+12	; 0x0c
     88c:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
     890:	9b 01       	movw	r18, r22
     892:	ac 01       	movw	r20, r24
     894:	69 81       	ldd	r22, Y+1	; 0x01
     896:	7a 81       	ldd	r23, Y+2	; 0x02
     898:	8b 81       	ldd	r24, Y+3	; 0x03
     89a:	9c 81       	ldd	r25, Y+4	; 0x04
     89c:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
     8a0:	69 83       	std	Y+1, r22	; 0x01
     8a2:	7a 83       	std	Y+2, r23	; 0x02
     8a4:	8b 83       	std	Y+3, r24	; 0x03
     8a6:	9c 83       	std	Y+4, r25	; 0x04
     8a8:	a7 01       	movw	r20, r14
     8aa:	96 01       	movw	r18, r12
     8ac:	69 85       	ldd	r22, Y+9	; 0x09
     8ae:	7a 85       	ldd	r23, Y+10	; 0x0a
     8b0:	8b 85       	ldd	r24, Y+11	; 0x0b
     8b2:	9c 85       	ldd	r25, Y+12	; 0x0c
     8b4:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
     8b8:	6b 01       	movw	r12, r22
     8ba:	7c 01       	movw	r14, r24
     8bc:	a5 01       	movw	r20, r10
     8be:	94 01       	movw	r18, r8
     8c0:	6d 81       	ldd	r22, Y+5	; 0x05
     8c2:	7e 81       	ldd	r23, Y+6	; 0x06
     8c4:	8f 81       	ldd	r24, Y+7	; 0x07
     8c6:	98 85       	ldd	r25, Y+8	; 0x08
     8c8:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
     8cc:	9b 01       	movw	r18, r22
     8ce:	ac 01       	movw	r20, r24
     8d0:	c7 01       	movw	r24, r14
     8d2:	b6 01       	movw	r22, r12
     8d4:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
     8d8:	6b 01       	movw	r12, r22
     8da:	7c 01       	movw	r14, r24
     8dc:	10 e0       	ldi	r17, 0x00	; 0
     8de:	2f 89       	ldd	r18, Y+23	; 0x17
     8e0:	38 8d       	ldd	r19, Y+24	; 0x18
     8e2:	49 8d       	ldd	r20, Y+25	; 0x19
     8e4:	5a 8d       	ldd	r21, Y+26	; 0x1a
     8e6:	69 81       	ldd	r22, Y+1	; 0x01
     8e8:	7a 81       	ldd	r23, Y+2	; 0x02
     8ea:	8b 81       	ldd	r24, Y+3	; 0x03
     8ec:	9c 81       	ldd	r25, Y+4	; 0x04
     8ee:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
     8f2:	ed 89       	ldd	r30, Y+21	; 0x15
     8f4:	fe 89       	ldd	r31, Y+22	; 0x16
     8f6:	60 83       	st	Z, r22
     8f8:	71 83       	std	Z+1, r23	; 0x01
     8fa:	82 83       	std	Z+2, r24	; 0x02
     8fc:	93 83       	std	Z+3, r25	; 0x03
     8fe:	2d 8d       	ldd	r18, Y+29	; 0x1d
     900:	3e 8d       	ldd	r19, Y+30	; 0x1e
     902:	4f 8d       	ldd	r20, Y+31	; 0x1f
     904:	58 a1       	ldd	r21, Y+32	; 0x20
     906:	c7 01       	movw	r24, r14
     908:	b6 01       	movw	r22, r12
     90a:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
     90e:	ab 8d       	ldd	r26, Y+27	; 0x1b
     910:	bc 8d       	ldd	r27, Y+28	; 0x1c
     912:	6d 93       	st	X+, r22
     914:	7d 93       	st	X+, r23
     916:	8d 93       	st	X+, r24
     918:	9c 93       	st	X, r25
     91a:	13 97       	sbiw	r26, 0x03	; 3
     91c:	29 89       	ldd	r18, Y+17	; 0x11
     91e:	3a 89       	ldd	r19, Y+18	; 0x12
     920:	4b 89       	ldd	r20, Y+19	; 0x13
     922:	5c 89       	ldd	r21, Y+20	; 0x14
     924:	f2 01       	movw	r30, r4
     926:	60 81       	ld	r22, Z
     928:	71 81       	ldd	r23, Z+1	; 0x01
     92a:	82 81       	ldd	r24, Z+2	; 0x02
     92c:	93 81       	ldd	r25, Z+3	; 0x03
     92e:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
     932:	d2 01       	movw	r26, r4
     934:	6d 93       	st	X+, r22
     936:	7d 93       	st	X+, r23
     938:	8d 93       	st	X+, r24
     93a:	9c 93       	st	X, r25
     93c:	13 97       	sbiw	r26, 0x03	; 3
     93e:	6f 85       	ldd	r22, Y+15	; 0x0f
     940:	78 89       	ldd	r23, Y+16	; 0x10
     942:	8d 85       	ldd	r24, Y+13	; 0x0d
     944:	9e 85       	ldd	r25, Y+14	; 0x0e
     946:	0e 94 ad 01 	call	0x35a	; 0x35a <mc_line>
     94a:	80 91 7d 05 	lds	r24, 0x057D	; 0x80057d <sys+0x1>
     94e:	81 11       	cpse	r24, r1
     950:	0d c0       	rjmp	.+26     	; 0x96c <__stack+0x6d>
     952:	bf ef       	ldi	r27, 0xFF	; 255
     954:	2b 1a       	sub	r2, r27
     956:	3b 0a       	sbc	r3, r27
     958:	62 14       	cp	r6, r2
     95a:	73 04       	cpc	r7, r3
     95c:	09 f0       	breq	.+2      	; 0x960 <__stack+0x61>
     95e:	12 cf       	rjmp	.-476    	; 0x784 <__LOCK_REGION_LENGTH__+0x384>
     960:	6f 85       	ldd	r22, Y+15	; 0x0f
     962:	78 89       	ldd	r23, Y+16	; 0x10
     964:	89 a9       	ldd	r24, Y+49	; 0x31
     966:	9a a9       	ldd	r25, Y+50	; 0x32
     968:	0e 94 ad 01 	call	0x35a	; 0x35a <mc_line>
     96c:	e2 96       	adiw	r28, 0x32	; 50
     96e:	0f b6       	in	r0, 0x3f	; 63
     970:	f8 94       	cli
     972:	de bf       	out	0x3e, r29	; 62
     974:	0f be       	out	0x3f, r0	; 63
     976:	cd bf       	out	0x3d, r28	; 61
     978:	df 91       	pop	r29
     97a:	cf 91       	pop	r28
     97c:	1f 91       	pop	r17
     97e:	0f 91       	pop	r16
     980:	ff 90       	pop	r15
     982:	ef 90       	pop	r14
     984:	df 90       	pop	r13
     986:	cf 90       	pop	r12
     988:	bf 90       	pop	r11
     98a:	af 90       	pop	r10
     98c:	9f 90       	pop	r9
     98e:	8f 90       	pop	r8
     990:	7f 90       	pop	r7
     992:	6f 90       	pop	r6
     994:	5f 90       	pop	r5
     996:	4f 90       	pop	r4
     998:	3f 90       	pop	r3
     99a:	2f 90       	pop	r2
     99c:	08 95       	ret

0000099e <mc_dwell>:
     99e:	cf 92       	push	r12
     9a0:	df 92       	push	r13
     9a2:	ef 92       	push	r14
     9a4:	ff 92       	push	r15
     9a6:	20 91 7c 05 	lds	r18, 0x057C	; 0x80057c <sys>
     9aa:	22 30       	cpi	r18, 0x02	; 2
     9ac:	49 f0       	breq	.+18     	; 0x9c0 <mc_dwell+0x22>
     9ae:	6b 01       	movw	r12, r22
     9b0:	7c 01       	movw	r14, r24
     9b2:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <protocol_buffer_synchronize>
     9b6:	40 e0       	ldi	r20, 0x00	; 0
     9b8:	c7 01       	movw	r24, r14
     9ba:	b6 01       	movw	r22, r12
     9bc:	0e 94 94 2a 	call	0x5528	; 0x5528 <delay_sec>
     9c0:	ff 90       	pop	r15
     9c2:	ef 90       	pop	r14
     9c4:	df 90       	pop	r13
     9c6:	cf 90       	pop	r12
     9c8:	08 95       	ret

000009ca <mc_probe_cycle>:


// Perform tool length probe cycle. Requires probe switch.
// NOTE: Upon probe failure, the program will be stopped and placed into ALARM state.
uint8_t mc_probe_cycle(float *target, plan_line_data_t *pl_data, uint8_t parser_flags)
{
     9ca:	df 92       	push	r13
     9cc:	ef 92       	push	r14
     9ce:	ff 92       	push	r15
     9d0:	0f 93       	push	r16
     9d2:	1f 93       	push	r17
     9d4:	cf 93       	push	r28
     9d6:	df 93       	push	r29
  // TODO: Need to update this cycle so it obeys a non-auto cycle start.
  if (sys.state == STATE_CHECK_MODE) { return(GC_PROBE_CHECK_MODE); }
     9d8:	20 91 7c 05 	lds	r18, 0x057C	; 0x80057c <sys>
     9dc:	22 30       	cpi	r18, 0x02	; 2
     9de:	09 f4       	brne	.+2      	; 0x9e2 <mc_probe_cycle+0x18>
     9e0:	5f c0       	rjmp	.+190    	; 0xaa0 <mc_probe_cycle+0xd6>
     9e2:	d4 2e       	mov	r13, r20
     9e4:	7b 01       	movw	r14, r22
     9e6:	8c 01       	movw	r16, r24

  // Finish all queued commands and empty planner buffer before starting probe cycle.
  protocol_buffer_synchronize();
     9e8:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <protocol_buffer_synchronize>
  if (sys.abort) { return(GC_PROBE_ABORT); } // Return if system reset has been issued.
     9ec:	80 91 7d 05 	lds	r24, 0x057D	; 0x80057d <sys+0x1>
     9f0:	81 11       	cpse	r24, r1
     9f2:	58 c0       	rjmp	.+176    	; 0xaa4 <mc_probe_cycle+0xda>

  // Initialize probing control variables
  uint8_t is_probe_away = bit_istrue(parser_flags,GC_PARSER_PROBE_IS_AWAY);
  uint8_t is_no_error = bit_istrue(parser_flags,GC_PARSER_PROBE_IS_NO_ERROR);
  sys.probe_succeeded = false; // Re-initialize probe history before beginning cycle.
     9f4:	10 92 81 05 	sts	0x0581, r1	; 0x800581 <sys+0x5>
  probe_configure_invert_mask(is_probe_away);
     9f8:	d3 fa       	bst	r13, 3
     9fa:	88 27       	eor	r24, r24
     9fc:	80 f9       	bld	r24, 0
     9fe:	0e 94 bb 2c 	call	0x5976	; 0x5976 <probe_configure_invert_mask>

  // After syncing, check if probe is already triggered. If so, halt and issue alarm.
  // NOTE: This probe initialization error applies to all probing cycles.
  if ( probe_get_state() ) { // Check probe pin state.
     a02:	0e 94 d3 2c 	call	0x59a6	; 0x59a6 <probe_get_state>
     a06:	88 23       	and	r24, r24
     a08:	51 f0       	breq	.+20     	; 0xa1e <mc_probe_cycle+0x54>
    system_set_exec_alarm(EXEC_ALARM_PROBE_FAIL_INITIAL);
     a0a:	84 e0       	ldi	r24, 0x04	; 4
     a0c:	0e 94 34 2e 	call	0x5c68	; 0x5c68 <system_set_exec_alarm>
    protocol_execute_realtime();
     a10:	0e 94 9e 14 	call	0x293c	; 0x293c <protocol_execute_realtime>
    probe_configure_invert_mask(false); // Re-initialize invert mask before returning.
     a14:	80 e0       	ldi	r24, 0x00	; 0
     a16:	0e 94 bb 2c 	call	0x5976	; 0x5976 <probe_configure_invert_mask>
    return(GC_PROBE_FAIL_INIT); // Nothing else to do but bail.
     a1a:	82 e0       	ldi	r24, 0x02	; 2
     a1c:	46 c0       	rjmp	.+140    	; 0xaaa <mc_probe_cycle+0xe0>
  }

  // Setup and queue probing motion. Auto cycle-start should not start the cycle.
  mc_line(target, pl_data);
     a1e:	b7 01       	movw	r22, r14
     a20:	c8 01       	movw	r24, r16
     a22:	0e 94 ad 01 	call	0x35a	; 0x35a <mc_line>

  // Activate the probing state monitor in the stepper module.
  sys_probe_state = PROBE_ACTIVE;
     a26:	81 e0       	ldi	r24, 0x01	; 1
     a28:	80 93 8f 05 	sts	0x058F, r24	; 0x80058f <sys_probe_state>

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  system_set_exec_state_flag(EXEC_CYCLE_START);
     a2c:	82 e0       	ldi	r24, 0x02	; 2
     a2e:	0e 94 21 2e 	call	0x5c42	; 0x5c42 <system_set_exec_state_flag>
  do {
    protocol_execute_realtime();
    if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
     a32:	cc e7       	ldi	r28, 0x7C	; 124
     a34:	d5 e0       	ldi	r29, 0x05	; 5
  sys_probe_state = PROBE_ACTIVE;

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  system_set_exec_state_flag(EXEC_CYCLE_START);
  do {
    protocol_execute_realtime();
     a36:	0e 94 9e 14 	call	0x293c	; 0x293c <protocol_execute_realtime>
    if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
     a3a:	89 81       	ldd	r24, Y+1	; 0x01
     a3c:	81 11       	cpse	r24, r1
     a3e:	34 c0       	rjmp	.+104    	; 0xaa8 <mc_probe_cycle+0xde>
  } while (sys.state != STATE_IDLE);
     a40:	88 81       	ld	r24, Y
     a42:	81 11       	cpse	r24, r1
     a44:	f8 cf       	rjmp	.-16     	; 0xa36 <mc_probe_cycle+0x6c>

  // Probing cycle complete!

  // Set state variables and error out, if the probe failed and cycle with error is enabled.
  if (sys_probe_state == PROBE_ACTIVE) {
     a46:	80 91 8f 05 	lds	r24, 0x058F	; 0x80058f <sys_probe_state>
     a4a:	81 30       	cpi	r24, 0x01	; 1
     a4c:	81 f4       	brne	.+32     	; 0xa6e <mc_probe_cycle+0xa4>
    if (is_no_error) { memcpy(sys_probe_position, sys_position, sizeof(sys_position)); }
     a4e:	d4 fe       	sbrs	r13, 4
     a50:	0a c0       	rjmp	.+20     	; 0xa66 <mc_probe_cycle+0x9c>
     a52:	8c e0       	ldi	r24, 0x0C	; 12
     a54:	ec e9       	ldi	r30, 0x9C	; 156
     a56:	f5 e0       	ldi	r31, 0x05	; 5
     a58:	a0 e9       	ldi	r26, 0x90	; 144
     a5a:	b5 e0       	ldi	r27, 0x05	; 5
     a5c:	01 90       	ld	r0, Z+
     a5e:	0d 92       	st	X+, r0
     a60:	8a 95       	dec	r24
     a62:	e1 f7       	brne	.-8      	; 0xa5c <mc_probe_cycle+0x92>
     a64:	07 c0       	rjmp	.+14     	; 0xa74 <mc_probe_cycle+0xaa>
    else { system_set_exec_alarm(EXEC_ALARM_PROBE_FAIL_CONTACT); }
     a66:	85 e0       	ldi	r24, 0x05	; 5
     a68:	0e 94 34 2e 	call	0x5c68	; 0x5c68 <system_set_exec_alarm>
     a6c:	03 c0       	rjmp	.+6      	; 0xa74 <mc_probe_cycle+0xaa>
  } else {
    sys.probe_succeeded = true; // Indicate to system the probing cycle completed successfully.
     a6e:	81 e0       	ldi	r24, 0x01	; 1
     a70:	80 93 81 05 	sts	0x0581, r24	; 0x800581 <sys+0x5>
  }
  sys_probe_state = PROBE_OFF; // Ensure probe state monitor is disabled.
     a74:	10 92 8f 05 	sts	0x058F, r1	; 0x80058f <sys_probe_state>
  probe_configure_invert_mask(false); // Re-initialize invert mask.
     a78:	80 e0       	ldi	r24, 0x00	; 0
     a7a:	0e 94 bb 2c 	call	0x5976	; 0x5976 <probe_configure_invert_mask>
  protocol_execute_realtime();   // Check and execute run-time commands
     a7e:	0e 94 9e 14 	call	0x293c	; 0x293c <protocol_execute_realtime>

  // Reset the stepper and planner buffers to remove the remainder of the probe motion.
  st_reset(); // Reset step segment buffer.
     a82:	0e 94 04 19 	call	0x3208	; 0x3208 <st_reset>
  plan_reset(); // Reset planner buffer. Zero planner positions. Ensure probing motion is cleared.
     a86:	0e 94 11 25 	call	0x4a22	; 0x4a22 <plan_reset>
  plan_sync_position(); // Sync planner position to current machine position.
     a8a:	0e 94 b3 29 	call	0x5366	; 0x5366 <plan_sync_position>

  #ifdef MESSAGE_PROBE_COORDINATES
    // All done! Output the probe position as message.
    report_probe_parameters();
     a8e:	0e 94 f3 2c 	call	0x59e6	; 0x59e6 <report_probe_parameters>
// Perform tool length probe cycle. Requires probe switch.
// NOTE: Upon probe failure, the program will be stopped and placed into ALARM state.
uint8_t mc_probe_cycle(float *target, plan_line_data_t *pl_data, uint8_t parser_flags)
{
  // TODO: Need to update this cycle so it obeys a non-auto cycle start.
  if (sys.state == STATE_CHECK_MODE) { return(GC_PROBE_CHECK_MODE); }
     a92:	81 e0       	ldi	r24, 0x01	; 1
     a94:	90 91 81 05 	lds	r25, 0x0581	; 0x800581 <sys+0x5>
     a98:	91 11       	cpse	r25, r1
     a9a:	07 c0       	rjmp	.+14     	; 0xaaa <mc_probe_cycle+0xe0>
     a9c:	80 e0       	ldi	r24, 0x00	; 0
     a9e:	05 c0       	rjmp	.+10     	; 0xaaa <mc_probe_cycle+0xe0>
     aa0:	80 e0       	ldi	r24, 0x00	; 0
     aa2:	03 c0       	rjmp	.+6      	; 0xaaa <mc_probe_cycle+0xe0>

  // Finish all queued commands and empty planner buffer before starting probe cycle.
  protocol_buffer_synchronize();
  if (sys.abort) { return(GC_PROBE_ABORT); } // Return if system reset has been issued.
     aa4:	82 e0       	ldi	r24, 0x02	; 2
     aa6:	01 c0       	rjmp	.+2      	; 0xaaa <mc_probe_cycle+0xe0>

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  system_set_exec_state_flag(EXEC_CYCLE_START);
  do {
    protocol_execute_realtime();
    if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
     aa8:	82 e0       	ldi	r24, 0x02	; 2
    report_probe_parameters();
  #endif

  if (sys.probe_succeeded) { return(GC_PROBE_FOUND); } // Successful probe cycle.
  else { return(GC_PROBE_FAIL_END); } // Failed to trigger probe within travel. With or without error.
}
     aaa:	df 91       	pop	r29
     aac:	cf 91       	pop	r28
     aae:	1f 91       	pop	r17
     ab0:	0f 91       	pop	r16
     ab2:	ff 90       	pop	r15
     ab4:	ef 90       	pop	r14
     ab6:	df 90       	pop	r13
     ab8:	08 95       	ret

00000aba <mc_reset>:
// lost, since there was an abrupt uncontrolled deceleration. Called at an interrupt level by
// realtime abort command and hard limits. So, keep to a minimum.
void mc_reset()
{
  // Only this function can set the system reset. Helps prevent multiple kill calls.
  if (bit_isfalse(sys_rt_exec_state, EXEC_RESET)) {
     aba:	80 91 8e 05 	lds	r24, 0x058E	; 0x80058e <sys_rt_exec_state>
     abe:	84 fd       	sbrc	r24, 4
     ac0:	1f c0       	rjmp	.+62     	; 0xb00 <mc_reset+0x46>
    system_set_exec_state_flag(EXEC_RESET);
     ac2:	80 e1       	ldi	r24, 0x10	; 16
     ac4:	0e 94 21 2e 	call	0x5c42	; 0x5c42 <system_set_exec_state_flag>

    // Kill spindle and coolant.
    spindle_stop();
     ac8:	0e 94 91 10 	call	0x2122	; 0x2122 <spindle_stop>
    coolant_stop();
     acc:	0e 94 b8 11 	call	0x2370	; 0x2370 <coolant_stop>

    // Kill steppers only if in any motion state, i.e. cycle, actively holding, or homing.
    // NOTE: If steppers are kept enabled via the step idle delay setting, this also keeps
    // the steppers enabled by avoiding the go_idle call altogether, unless the motion state is
    // violated, by which, all bets are off.
    if ((sys.state & (STATE_CYCLE | STATE_HOMING | STATE_JOG)) ||
     ad0:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
     ad4:	98 2f       	mov	r25, r24
     ad6:	9c 72       	andi	r25, 0x2C	; 44
     ad8:	21 f4       	brne	.+8      	; 0xae2 <mc_reset+0x28>
     ada:	90 91 80 05 	lds	r25, 0x0580	; 0x800580 <sys+0x4>
     ade:	96 70       	andi	r25, 0x06	; 6
     ae0:	79 f0       	breq	.+30     	; 0xb00 <mc_reset+0x46>
    		(sys.step_control & (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION))) {
      if (sys.state == STATE_HOMING) { 
     ae2:	84 30       	cpi	r24, 0x04	; 4
     ae4:	41 f4       	brne	.+16     	; 0xaf6 <mc_reset+0x3c>
        if (!sys_rt_exec_alarm) {system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_RESET); }
     ae6:	80 91 a8 05 	lds	r24, 0x05A8	; 0x8005a8 <sys_rt_exec_alarm>
     aea:	81 11       	cpse	r24, r1
     aec:	07 c0       	rjmp	.+14     	; 0xafc <mc_reset+0x42>
     aee:	86 e0       	ldi	r24, 0x06	; 6
     af0:	0e 94 34 2e 	call	0x5c68	; 0x5c68 <system_set_exec_alarm>
     af4:	03 c0       	rjmp	.+6      	; 0xafc <mc_reset+0x42>
      } else { system_set_exec_alarm(EXEC_ALARM_ABORT_CYCLE); }
     af6:	83 e0       	ldi	r24, 0x03	; 3
     af8:	0e 94 34 2e 	call	0x5c68	; 0x5c68 <system_set_exec_alarm>
      st_go_idle(); // Force kill steppers. Position has likely been lost.
     afc:	0e 94 88 16 	call	0x2d10	; 0x2d10 <st_go_idle>
     b00:	08 95       	ret

00000b02 <gc_init>:
#define FAIL(status) return(status);


void gc_init()
{
  memset(&gc_state, 0, sizeof(parser_state_t));
     b02:	80 e4       	ldi	r24, 0x40	; 64
     b04:	ea ea       	ldi	r30, 0xAA	; 170
     b06:	f5 e0       	ldi	r31, 0x05	; 5
     b08:	df 01       	movw	r26, r30
     b0a:	1d 92       	st	X+, r1
     b0c:	8a 95       	dec	r24
     b0e:	e9 f7       	brne	.-6      	; 0xb0a <gc_init+0x8>

  // Load default G54 coordinate system.
  if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) {
     b10:	6e ec       	ldi	r22, 0xCE	; 206
     b12:	75 e0       	ldi	r23, 0x05	; 5
     b14:	80 e0       	ldi	r24, 0x00	; 0
     b16:	0e 94 3f 23 	call	0x467e	; 0x467e <settings_read_coord_data>
     b1a:	81 11       	cpse	r24, r1
     b1c:	03 c0       	rjmp	.+6      	; 0xb24 <gc_init+0x22>
    report_status_message(STATUS_SETTING_READ_FAIL);
     b1e:	87 e0       	ldi	r24, 0x07	; 7
     b20:	0e 94 ee 2c 	call	0x59dc	; 0x59dc <report_status_message>
     b24:	08 95       	ret

00000b26 <gc_sync_position>:

// Sets g-code parser position in mm. Input in steps. Called by the system abort and hard
// limit pull-off routines.
void gc_sync_position()
{
  system_convert_array_steps_to_mpos(gc_state.position,sys_position);
     b26:	6c e9       	ldi	r22, 0x9C	; 156
     b28:	75 e0       	ldi	r23, 0x05	; 5
     b2a:	82 ec       	ldi	r24, 0xC2	; 194
     b2c:	95 e0       	ldi	r25, 0x05	; 5
     b2e:	0e 94 9b 2d 	call	0x5b36	; 0x5b36 <system_convert_array_steps_to_mpos>
     b32:	08 95       	ret

00000b34 <gc_execute_line>:
// characters and signed floating point values (no whitespace). Comments and block delete
// characters have been removed. In this function, all units and positions are converted and
// exported to grbl's internal functions in terms of (mm, mm/min) and absolute machine
// coordinates, respectively.
uint8_t gc_execute_line(char *line)
{
     b34:	2f 92       	push	r2
     b36:	3f 92       	push	r3
     b38:	4f 92       	push	r4
     b3a:	5f 92       	push	r5
     b3c:	6f 92       	push	r6
     b3e:	7f 92       	push	r7
     b40:	8f 92       	push	r8
     b42:	9f 92       	push	r9
     b44:	af 92       	push	r10
     b46:	bf 92       	push	r11
     b48:	cf 92       	push	r12
     b4a:	df 92       	push	r13
     b4c:	ef 92       	push	r14
     b4e:	ff 92       	push	r15
     b50:	0f 93       	push	r16
     b52:	1f 93       	push	r17
     b54:	cf 93       	push	r28
     b56:	df 93       	push	r29
     b58:	cd b7       	in	r28, 0x3d	; 61
     b5a:	de b7       	in	r29, 0x3e	; 62
     b5c:	ad 97       	sbiw	r28, 0x2d	; 45
     b5e:	0f b6       	in	r0, 0x3f	; 63
     b60:	f8 94       	cli
     b62:	de bf       	out	0x3e, r29	; 62
     b64:	0f be       	out	0x3f, r0	; 63
     b66:	cd bf       	out	0x3d, r28	; 61
     b68:	8c 01       	movw	r16, r24
     updates these modes and commands as the block line is parser and will only be used and
     executed after successful error-checking. The parser block struct also contains a block
     values struct, word tracking variables, and a non-modal commands tracker for the new
     block. This struct contains all of the necessary information to execute the block. */

  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
     b6a:	8a e3       	ldi	r24, 0x3A	; 58
     b6c:	ea ee       	ldi	r30, 0xEA	; 234
     b6e:	f5 e0       	ldi	r31, 0x05	; 5
     b70:	df 01       	movw	r26, r30
     b72:	1d 92       	st	X+, r1
     b74:	8a 95       	dec	r24
     b76:	e9 f7       	brne	.-6      	; 0xb72 <gc_execute_line+0x3e>
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
     b78:	8b e0       	ldi	r24, 0x0B	; 11
     b7a:	ea ea       	ldi	r30, 0xAA	; 170
     b7c:	f5 e0       	ldi	r31, 0x05	; 5
     b7e:	ab ee       	ldi	r26, 0xEB	; 235
     b80:	b5 e0       	ldi	r27, 0x05	; 5
     b82:	01 90       	ld	r0, Z+
     b84:	0d 92       	st	X+, r0
     b86:	8a 95       	dec	r24
     b88:	e1 f7       	brne	.-8      	; 0xb82 <gc_execute_line+0x4e>
  uint16_t command_words = 0; // Tracks G and M command words. Also used for modal group violations.
  uint16_t value_words = 0; // Tracks value words.
  uint8_t gc_parser_flags = GC_PARSER_NONE;

  // Determine if the line is a jogging motion or a normal g-code block.
  if (line[0] == '$') { // NOTE: `$J=` already parsed when passed to this function.
     b8a:	f8 01       	movw	r30, r16
     b8c:	80 81       	ld	r24, Z
     b8e:	84 32       	cpi	r24, 0x24	; 36
     b90:	11 f0       	breq	.+4      	; 0xb96 <gc_execute_line+0x62>
     b92:	0c 94 30 10 	jmp	0x2060	; 0x2060 <gc_execute_line+0x152c>
    // Set G1 and G94 enforced modes to ensure accurate error checks.
    gc_parser_flags |= GC_PARSER_JOG_MOTION;
    gc_block.modal.motion = MOTION_MODE_LINEAR;
     b96:	ea ee       	ldi	r30, 0xEA	; 234
     b98:	f5 e0       	ldi	r31, 0x05	; 5
     b9a:	81 e0       	ldi	r24, 0x01	; 1
     b9c:	81 83       	std	Z+1, r24	; 0x01
    gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
     b9e:	12 82       	std	Z+2, r1	; 0x02
  uint8_t char_counter;
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
     ba0:	83 e0       	ldi	r24, 0x03	; 3
     ba2:	89 83       	std	Y+1, r24	; 0x01
  uint8_t gc_parser_flags = GC_PARSER_NONE;

  // Determine if the line is a jogging motion or a normal g-code block.
  if (line[0] == '$') { // NOTE: `$J=` already parsed when passed to this function.
    // Set G1 and G94 enforced modes to ensure accurate error checks.
    gc_parser_flags |= GC_PARSER_JOG_MOTION;
     ba4:	f1 e0       	ldi	r31, 0x01	; 1
     ba6:	f8 a3       	std	Y+32, r31	; 0x20
					  if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
            gc_block.values.t = int_value;
						break;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
     ba8:	21 2c       	mov	r2, r1
     baa:	31 2c       	mov	r3, r1
     bac:	e1 2c       	mov	r14, r1
     bae:	f1 2c       	mov	r15, r1
     bb0:	1f 8e       	std	Y+31, r1	; 0x1f
     bb2:	1d 8e       	std	Y+29, r1	; 0x1d
     bb4:	1e 8e       	std	Y+30, r1	; 0x1e
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
     bb6:	cc 24       	eor	r12, r12
     bb8:	c3 94       	inc	r12
     bba:	d1 2c       	mov	r13, r1

        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
     bbc:	0f 2e       	mov	r0, r31
     bbe:	f1 e6       	ldi	r31, 0x61	; 97
     bc0:	8f 2e       	mov	r8, r31
     bc2:	f3 e0       	ldi	r31, 0x03	; 3
     bc4:	9f 2e       	mov	r9, r31
     bc6:	f0 2d       	mov	r31, r0
     bc8:	1c 8f       	std	Y+28, r17	; 0x1c
     bca:	0b 8f       	std	Y+27, r16	; 0x1b
     bcc:	22 c2       	rjmp	.+1092   	; 0x1012 <gc_execute_line+0x4de>

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.

    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
     bce:	9f eb       	ldi	r25, 0xBF	; 191
     bd0:	91 0f       	add	r25, r17
     bd2:	9a 31       	cpi	r25, 0x1A	; 26
     bd4:	10 f0       	brcs	.+4      	; 0xbda <gc_execute_line+0xa6>
     bd6:	0c 94 c2 0f 	jmp	0x1f84	; 0x1f84 <gc_execute_line+0x1450>
    char_counter++;
     bda:	8f 5f       	subi	r24, 0xFF	; 255
     bdc:	89 83       	std	Y+1, r24	; 0x01
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
     bde:	ae 01       	movw	r20, r28
     be0:	4e 5f       	subi	r20, 0xFE	; 254
     be2:	5f 4f       	sbci	r21, 0xFF	; 255
     be4:	be 01       	movw	r22, r28
     be6:	6f 5f       	subi	r22, 0xFF	; 255
     be8:	7f 4f       	sbci	r23, 0xFF	; 255
     bea:	8b 8d       	ldd	r24, Y+27	; 0x1b
     bec:	9c 8d       	ldd	r25, Y+28	; 0x1c
     bee:	0e 94 ce 29 	call	0x539c	; 0x539c <read_float>
     bf2:	88 23       	and	r24, r24
     bf4:	11 f4       	brne	.+4      	; 0xbfa <gc_execute_line+0xc6>
     bf6:	0c 94 c4 0f 	jmp	0x1f88	; 0x1f88 <gc_execute_line+0x1454>
    // accurate than the NIST gcode requirement of x10 when used for commands, but not quite
    // accurate enough for value words that require integers to within 0.0001. This should be
    // a good enough comprimise and catch most all non-integer errors. To make it compliant,
    // we would simply need to change the mantissa to int16, but this add compiled flash space.
    // Maybe update this later.
    int_value = trunc(value);
     bfa:	4a 80       	ldd	r4, Y+2	; 0x02
     bfc:	5b 80       	ldd	r5, Y+3	; 0x03
     bfe:	6c 80       	ldd	r6, Y+4	; 0x04
     c00:	7d 80       	ldd	r7, Y+5	; 0x05
     c02:	c3 01       	movw	r24, r6
     c04:	b2 01       	movw	r22, r4
     c06:	0e 94 99 32 	call	0x6532	; 0x6532 <trunc>
     c0a:	0e 94 d7 2f 	call	0x5fae	; 0x5fae <__fixunssfsi>
     c0e:	a6 2e       	mov	r10, r22
    mantissa =  round(100*(value - int_value)); // Compute mantissa for Gxx.x commands.
     c10:	70 e0       	ldi	r23, 0x00	; 0
     c12:	80 e0       	ldi	r24, 0x00	; 0
     c14:	90 e0       	ldi	r25, 0x00	; 0
     c16:	0e 94 08 30 	call	0x6010	; 0x6010 <__floatsisf>
     c1a:	9b 01       	movw	r18, r22
     c1c:	ac 01       	movw	r20, r24
     c1e:	c3 01       	movw	r24, r6
     c20:	b2 01       	movw	r22, r4
     c22:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
     c26:	20 e0       	ldi	r18, 0x00	; 0
     c28:	30 e0       	ldi	r19, 0x00	; 0
     c2a:	48 ec       	ldi	r20, 0xC8	; 200
     c2c:	52 e4       	ldi	r21, 0x42	; 66
     c2e:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
     c32:	0e 94 23 32 	call	0x6446	; 0x6446 <round>
     c36:	0e 94 d7 2f 	call	0x5fae	; 0x5fae <__fixunssfsi>
     c3a:	86 2f       	mov	r24, r22
     c3c:	97 2f       	mov	r25, r23
    // NOTE: Rounding must be used to catch small floating point errors.

    // Check if the g-code word is supported or errors due to modal group violations or has
    // been repeated in the g-code block. If ok, update the command or record its value.
    switch(letter) {
     c3e:	17 34       	cpi	r17, 0x47	; 71
     c40:	21 f0       	breq	.+8      	; 0xc4a <gc_execute_line+0x116>
     c42:	1d 34       	cpi	r17, 0x4D	; 77
     c44:	09 f4       	brne	.+2      	; 0xc48 <gc_execute_line+0x114>
     c46:	c1 c0       	rjmp	.+386    	; 0xdca <gc_execute_line+0x296>
     c48:	1d c1       	rjmp	.+570    	; 0xe84 <gc_execute_line+0x350>
      /* 'G' and 'M' Command Words: Parse commands and check for modal group violations.
         NOTE: Modal group numbers are defined in Table 4 of NIST RS274-NGC v3, pg.20 */

      case 'G':
        // Determine 'G' command and its modal group
        switch(int_value) {
     c4a:	4a 2c       	mov	r4, r10
     c4c:	51 2c       	mov	r5, r1
     c4e:	2f e5       	ldi	r18, 0x5F	; 95
     c50:	42 16       	cp	r4, r18
     c52:	51 04       	cpc	r5, r1
     c54:	10 f0       	brcs	.+4      	; 0xc5a <gc_execute_line+0x126>
     c56:	0c 94 c6 0f 	jmp	0x1f8c	; 0x1f8c <gc_execute_line+0x1458>
     c5a:	f2 01       	movw	r30, r4
     c5c:	ec 5c       	subi	r30, 0xCC	; 204
     c5e:	ff 4f       	sbci	r31, 0xFF	; 255
     c60:	0c 94 bf 32 	jmp	0x657e	; 0x657e <__tablejump2__>
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
     c64:	00 97       	sbiw	r24, 0x00	; 0
     c66:	11 f0       	breq	.+4      	; 0xc6c <gc_execute_line+0x138>
     c68:	0c 94 34 10 	jmp	0x2068	; 0x2068 <gc_execute_line+0x1534>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
     c6c:	3e 8d       	ldd	r19, Y+30	; 0x1e
     c6e:	33 23       	and	r19, r19
     c70:	11 f4       	brne	.+4      	; 0xc76 <gc_execute_line+0x142>
     c72:	0c 94 3c 10 	jmp	0x2078	; 0x2078 <gc_execute_line+0x1544>
     c76:	0c 94 c8 0f 	jmp	0x1f90	; 0x1f90 <gc_execute_line+0x145c>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
     c7a:	aa ee       	ldi	r26, 0xEA	; 234
     c7c:	b5 e0       	ldi	r27, 0x05	; 5
     c7e:	ac 92       	st	X, r10
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
     c80:	bc e1       	ldi	r27, 0x1C	; 28
     c82:	ab 16       	cp	r10, r27
     c84:	31 f0       	breq	.+12     	; 0xc92 <gc_execute_line+0x15e>
     c86:	ee e1       	ldi	r30, 0x1E	; 30
     c88:	ae 16       	cp	r10, r30
     c8a:	19 f0       	breq	.+6      	; 0xc92 <gc_execute_line+0x15e>
     c8c:	fc e5       	ldi	r31, 0x5C	; 92
     c8e:	af 12       	cpse	r10, r31
     c90:	85 c0       	rjmp	.+266    	; 0xd9c <gc_execute_line+0x268>
              if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); }
     c92:	00 97       	sbiw	r24, 0x00	; 0
     c94:	49 f0       	breq	.+18     	; 0xca8 <gc_execute_line+0x174>
     c96:	0a 97       	sbiw	r24, 0x0a	; 10
     c98:	39 f0       	breq	.+14     	; 0xca8 <gc_execute_line+0x174>
     c9a:	0c 94 ca 0f 	jmp	0x1f94	; 0x1f94 <gc_execute_line+0x1460>
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
     c9e:	21 e0       	ldi	r18, 0x01	; 1
     ca0:	2e 8f       	std	Y+30, r18	; 0x1e
     ca2:	02 c0       	rjmp	.+4      	; 0xca8 <gc_execute_line+0x174>
     ca4:	31 e0       	ldi	r19, 0x01	; 1
     ca6:	3e 8f       	std	Y+30, r19	; 0x1e
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
              if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); }
              gc_block.non_modal_command += mantissa;
     ca8:	6a 0d       	add	r22, r10
     caa:	aa ee       	ldi	r26, 0xEA	; 234
     cac:	b5 e0       	ldi	r27, 0x05	; 5
     cae:	6c 93       	st	X, r22
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
     cb0:	20 e0       	ldi	r18, 0x00	; 0
     cb2:	7b c0       	rjmp	.+246    	; 0xdaa <gc_execute_line+0x276>
            }                
            break;
          case 0: case 1: case 2: case 3: case 38:
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
     cb4:	be 8d       	ldd	r27, Y+30	; 0x1e
     cb6:	b1 11       	cpse	r27, r1
     cb8:	0c 94 cc 0f 	jmp	0x1f98	; 0x1f98 <gc_execute_line+0x1464>
            axis_command = AXIS_COMMAND_MOTION_MODE;
     cbc:	e2 e0       	ldi	r30, 0x02	; 2
     cbe:	ee 8f       	std	Y+30, r30	; 0x1e
            // No break. Continues to next line.
          case 80:
            word_bit = MODAL_GROUP_G1;
            gc_block.modal.motion = int_value;
     cc0:	a0 92 eb 05 	sts	0x05EB, r10	; 0x8005eb <gc_block+0x1>
            if (int_value == 38){
     cc4:	f6 e2       	ldi	r31, 0x26	; 38
     cc6:	af 12       	cpse	r10, r31
     cc8:	6b c0       	rjmp	.+214    	; 0xda0 <gc_execute_line+0x26c>
              if (!((mantissa == 20) || (mantissa == 30) || (mantissa == 40) || (mantissa == 50))) {
     cca:	84 31       	cpi	r24, 0x14	; 20
     ccc:	91 05       	cpc	r25, r1
     cce:	51 f0       	breq	.+20     	; 0xce4 <gc_execute_line+0x1b0>
     cd0:	8e 31       	cpi	r24, 0x1E	; 30
     cd2:	91 05       	cpc	r25, r1
     cd4:	39 f0       	breq	.+14     	; 0xce4 <gc_execute_line+0x1b0>
     cd6:	88 32       	cpi	r24, 0x28	; 40
     cd8:	91 05       	cpc	r25, r1
     cda:	21 f0       	breq	.+8      	; 0xce4 <gc_execute_line+0x1b0>
     cdc:	c2 97       	sbiw	r24, 0x32	; 50
     cde:	11 f0       	breq	.+4      	; 0xce4 <gc_execute_line+0x1b0>
     ce0:	0c 94 ce 0f 	jmp	0x1f9c	; 0x1f9c <gc_execute_line+0x1468>
                FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
              }
              gc_block.modal.motion += (mantissa/10)+100;
     ce4:	26 2f       	mov	r18, r22
     ce6:	37 2f       	mov	r19, r23
     ce8:	ad ec       	ldi	r26, 0xCD	; 205
     cea:	bc ec       	ldi	r27, 0xCC	; 204
     cec:	0e 94 c5 32 	call	0x658a	; 0x658a <__umulhisi3>
     cf0:	96 95       	lsr	r25
     cf2:	87 95       	ror	r24
     cf4:	96 95       	lsr	r25
     cf6:	87 95       	ror	r24
     cf8:	96 95       	lsr	r25
     cfa:	87 95       	ror	r24
     cfc:	86 57       	subi	r24, 0x76	; 118
     cfe:	80 93 eb 05 	sts	0x05EB, r24	; 0x8005eb <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE;
            // No break. Continues to next line.
          case 80:
            word_bit = MODAL_GROUP_G1;
     d02:	21 e0       	ldi	r18, 0x01	; 1
     d04:	52 c0       	rjmp	.+164    	; 0xdaa <gc_execute_line+0x276>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
            }  
            break;
          case 17: case 18: case 19:
            word_bit = MODAL_GROUP_G2;
            gc_block.modal.plane_select = int_value - 17;
     d06:	6f ee       	ldi	r22, 0xEF	; 239
     d08:	6a 0d       	add	r22, r10
     d0a:	60 93 ef 05 	sts	0x05EF, r22	; 0x8005ef <gc_block+0x5>
              gc_block.modal.motion += (mantissa/10)+100;
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
            }  
            break;
          case 17: case 18: case 19:
            word_bit = MODAL_GROUP_G2;
     d0e:	22 e0       	ldi	r18, 0x02	; 2
            gc_block.modal.plane_select = int_value - 17;
            break;
     d10:	48 c0       	rjmp	.+144    	; 0xda2 <gc_execute_line+0x26e>
          case 90: case 91:
            if (mantissa == 0) {
     d12:	00 97       	sbiw	r24, 0x00	; 0
     d14:	31 f4       	brne	.+12     	; 0xd22 <gc_execute_line+0x1ee>
              word_bit = MODAL_GROUP_G3;
              gc_block.modal.distance = int_value - 90;
     d16:	66 ea       	ldi	r22, 0xA6	; 166
     d18:	6a 0d       	add	r22, r10
     d1a:	60 93 ee 05 	sts	0x05EE, r22	; 0x8005ee <gc_block+0x4>
            word_bit = MODAL_GROUP_G2;
            gc_block.modal.plane_select = int_value - 17;
            break;
          case 90: case 91:
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3;
     d1e:	23 e0       	ldi	r18, 0x03	; 3
     d20:	44 c0       	rjmp	.+136    	; 0xdaa <gc_execute_line+0x276>
              gc_block.modal.distance = int_value - 90;
            } else {
              word_bit = MODAL_GROUP_G4;
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
     d22:	0a 97       	sbiw	r24, 0x0a	; 10
     d24:	11 f0       	breq	.+4      	; 0xd2a <gc_execute_line+0x1f6>
     d26:	0c 94 d0 0f 	jmp	0x1fa0	; 0x1fa0 <gc_execute_line+0x146c>
     d2a:	2a e5       	ldi	r18, 0x5A	; 90
     d2c:	a2 16       	cp	r10, r18
     d2e:	11 f4       	brne	.+4      	; 0xd34 <gc_execute_line+0x200>
     d30:	0c 94 d2 0f 	jmp	0x1fa4	; 0x1fa4 <gc_execute_line+0x1470>
          case 90: case 91:
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3;
              gc_block.modal.distance = int_value - 90;
            } else {
              word_bit = MODAL_GROUP_G4;
     d34:	24 e0       	ldi	r18, 0x04	; 4
     d36:	39 c0       	rjmp	.+114    	; 0xdaa <gc_execute_line+0x276>
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94:
            word_bit = MODAL_GROUP_G5;
            gc_block.modal.feed_rate = 94 - int_value;
     d38:	2e e5       	ldi	r18, 0x5E	; 94
     d3a:	2a 19       	sub	r18, r10
     d3c:	20 93 ec 05 	sts	0x05EC, r18	; 0x8005ec <gc_block+0x2>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94:
            word_bit = MODAL_GROUP_G5;
     d40:	25 e0       	ldi	r18, 0x05	; 5
            gc_block.modal.feed_rate = 94 - int_value;
            break;
     d42:	2f c0       	rjmp	.+94     	; 0xda2 <gc_execute_line+0x26e>
          case 20: case 21:
            word_bit = MODAL_GROUP_G6;
            gc_block.modal.units = 21 - int_value;
     d44:	25 e1       	ldi	r18, 0x15	; 21
     d46:	2a 19       	sub	r18, r10
     d48:	20 93 ed 05 	sts	0x05ED, r18	; 0x8005ed <gc_block+0x3>
          case 93: case 94:
            word_bit = MODAL_GROUP_G5;
            gc_block.modal.feed_rate = 94 - int_value;
            break;
          case 20: case 21:
            word_bit = MODAL_GROUP_G6;
     d4c:	26 e0       	ldi	r18, 0x06	; 6
            gc_block.modal.units = 21 - int_value;
            break;
     d4e:	29 c0       	rjmp	.+82     	; 0xda2 <gc_execute_line+0x26e>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
     d50:	3e 8d       	ldd	r19, Y+30	; 0x1e
     d52:	31 11       	cpse	r19, r1
     d54:	0c 94 d4 0f 	jmp	0x1fa8	; 0x1fa8 <gc_execute_line+0x1474>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
     d58:	41 e3       	ldi	r20, 0x31	; 49
     d5a:	a4 12       	cpse	r10, r20
     d5c:	06 c0       	rjmp	.+12     	; 0xd6a <gc_execute_line+0x236>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
     d5e:	10 92 f0 05 	sts	0x05F0, r1	; 0x8005f0 <gc_block+0x6>
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
     d62:	28 e0       	ldi	r18, 0x08	; 8
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
     d64:	83 e0       	ldi	r24, 0x03	; 3
     d66:	8e 8f       	std	Y+30, r24	; 0x1e
     d68:	20 c0       	rjmp	.+64     	; 0xdaa <gc_execute_line+0x276>
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
            } else if (mantissa == 10) { // G43.1
     d6a:	0a 97       	sbiw	r24, 0x0a	; 10
     d6c:	11 f0       	breq	.+4      	; 0xd72 <gc_execute_line+0x23e>
     d6e:	0c 94 d6 0f 	jmp	0x1fac	; 0x1fac <gc_execute_line+0x1478>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
     d72:	91 e0       	ldi	r25, 0x01	; 1
     d74:	90 93 f0 05 	sts	0x05F0, r25	; 0x8005f0 <gc_block+0x6>
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
     d78:	28 e0       	ldi	r18, 0x08	; 8
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
     d7a:	a3 e0       	ldi	r26, 0x03	; 3
     d7c:	ae 8f       	std	Y+30, r26	; 0x1e
     d7e:	15 c0       	rjmp	.+42     	; 0xdaa <gc_execute_line+0x276>
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59:
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
     d80:	6a ec       	ldi	r22, 0xCA	; 202
     d82:	6a 0d       	add	r22, r10
     d84:	60 93 f1 05 	sts	0x05F1, r22	; 0x8005f1 <gc_block+0x7>
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59:
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
     d88:	29 e0       	ldi	r18, 0x09	; 9
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
            break;
     d8a:	0b c0       	rjmp	.+22     	; 0xda2 <gc_execute_line+0x26e>
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
     d8c:	89 2b       	or	r24, r25
     d8e:	11 f0       	breq	.+4      	; 0xd94 <gc_execute_line+0x260>
     d90:	0c 94 d8 0f 	jmp	0x1fb0	; 0x1fb0 <gc_execute_line+0x147c>
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
            break;
          case 61:
            word_bit = MODAL_GROUP_G13;
     d94:	2a e0       	ldi	r18, 0x0A	; 10
     d96:	09 c0       	rjmp	.+18     	; 0xdaa <gc_execute_line+0x276>
          case 20: case 21:
            word_bit = MODAL_GROUP_G6;
            gc_block.modal.units = 21 - int_value;
            break;
          case 40:
            word_bit = MODAL_GROUP_G7;
     d98:	27 e0       	ldi	r18, 0x07	; 7
     d9a:	03 c0       	rjmp	.+6      	; 0xda2 <gc_execute_line+0x26e>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
     d9c:	20 e0       	ldi	r18, 0x00	; 0
     d9e:	01 c0       	rjmp	.+2      	; 0xda2 <gc_execute_line+0x26e>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE;
            // No break. Continues to next line.
          case 80:
            word_bit = MODAL_GROUP_G1;
     da0:	21 e0       	ldi	r18, 0x01	; 1
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
     da2:	89 2b       	or	r24, r25
     da4:	11 f0       	breq	.+4      	; 0xdaa <gc_execute_line+0x276>
     da6:	0c 94 da 0f 	jmp	0x1fb4	; 0x1fb4 <gc_execute_line+0x1480>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
     daa:	c6 01       	movw	r24, r12
     dac:	02 c0       	rjmp	.+4      	; 0xdb2 <gc_execute_line+0x27e>
     dae:	88 0f       	add	r24, r24
     db0:	99 1f       	adc	r25, r25
     db2:	2a 95       	dec	r18
     db4:	e2 f7       	brpl	.-8      	; 0xdae <gc_execute_line+0x27a>
     db6:	97 01       	movw	r18, r14
     db8:	28 23       	and	r18, r24
     dba:	39 23       	and	r19, r25
     dbc:	23 2b       	or	r18, r19
     dbe:	11 f0       	breq	.+4      	; 0xdc4 <gc_execute_line+0x290>
     dc0:	0c 94 dc 0f 	jmp	0x1fb8	; 0x1fb8 <gc_execute_line+0x1484>
        command_words |= bit(word_bit);
     dc4:	e8 2a       	or	r14, r24
     dc6:	f9 2a       	or	r15, r25
        break;
     dc8:	24 c1       	rjmp	.+584    	; 0x1012 <gc_execute_line+0x4de>

      case 'M':

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
     dca:	89 2b       	or	r24, r25
     dcc:	11 f0       	breq	.+4      	; 0xdd2 <gc_execute_line+0x29e>
     dce:	0c 94 de 0f 	jmp	0x1fbc	; 0x1fbc <gc_execute_line+0x1488>
        switch(int_value) {
     dd2:	8a 2d       	mov	r24, r10
     dd4:	90 e0       	ldi	r25, 0x00	; 0
     dd6:	8f 31       	cpi	r24, 0x1F	; 31
     dd8:	91 05       	cpc	r25, r1
     dda:	10 f0       	brcs	.+4      	; 0xde0 <gc_execute_line+0x2ac>
     ddc:	0c 94 e0 0f 	jmp	0x1fc0	; 0x1fc0 <gc_execute_line+0x148c>
     de0:	fc 01       	movw	r30, r24
     de2:	ed 56       	subi	r30, 0x6D	; 109
     de4:	ff 4f       	sbci	r31, 0xFF	; 255
     de6:	0c 94 bf 32 	jmp	0x657e	; 0x657e <__tablejump2__>
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
            switch(int_value) {
     dea:	aa 20       	and	r10, r10
     dec:	21 f0       	breq	.+8      	; 0xdf6 <gc_execute_line+0x2c2>
     dee:	b1 e0       	ldi	r27, 0x01	; 1
     df0:	ab 16       	cp	r10, r27
     df2:	99 f1       	breq	.+102    	; 0xe5a <gc_execute_line+0x326>
     df4:	05 c0       	rjmp	.+10     	; 0xe00 <gc_execute_line+0x2cc>
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
     df6:	e3 e0       	ldi	r30, 0x03	; 3
     df8:	e0 93 f2 05 	sts	0x05F2, r30	; 0x8005f2 <gc_block+0x8>

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
     dfc:	8b e0       	ldi	r24, 0x0B	; 11
            switch(int_value) {
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
     dfe:	32 c0       	rjmp	.+100    	; 0xe64 <gc_execute_line+0x330>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
     e00:	a0 92 f2 05 	sts	0x05F2, r10	; 0x8005f2 <gc_block+0x8>

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
     e04:	8b e0       	ldi	r24, 0x0B	; 11
     e06:	2e c0       	rjmp	.+92     	; 0xe64 <gc_execute_line+0x330>
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
            switch(int_value) {
     e08:	f4 e0       	ldi	r31, 0x04	; 4
     e0a:	af 16       	cp	r10, r31
     e0c:	59 f0       	breq	.+22     	; 0xe24 <gc_execute_line+0x2f0>
     e0e:	25 e0       	ldi	r18, 0x05	; 5
     e10:	a2 16       	cp	r10, r18
     e12:	69 f0       	breq	.+26     	; 0xe2e <gc_execute_line+0x2fa>
     e14:	33 e0       	ldi	r19, 0x03	; 3
     e16:	a3 12       	cpse	r10, r19
     e18:	22 c0       	rjmp	.+68     	; 0xe5e <gc_execute_line+0x32a>
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
     e1a:	80 e1       	ldi	r24, 0x10	; 16
     e1c:	80 93 f4 05 	sts	0x05F4, r24	; 0x8005f4 <gc_block+0xa>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
     e20:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
     e22:	20 c0       	rjmp	.+64     	; 0xe64 <gc_execute_line+0x330>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
     e24:	80 e2       	ldi	r24, 0x20	; 32
     e26:	80 93 f4 05 	sts	0x05F4, r24	; 0x8005f4 <gc_block+0xa>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
     e2a:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
     e2c:	1b c0       	rjmp	.+54     	; 0xe64 <gc_execute_line+0x330>
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
     e2e:	10 92 f4 05 	sts	0x05F4, r1	; 0x8005f4 <gc_block+0xa>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
     e32:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
     e34:	17 c0       	rjmp	.+46     	; 0xe64 <gc_execute_line+0x330>
            case 7: case 8: case 9:
          #else
            case 8: case 9:
          #endif
            word_bit = MODAL_GROUP_M8;
            switch(int_value) {
     e36:	48 e0       	ldi	r20, 0x08	; 8
     e38:	a4 16       	cp	r10, r20
     e3a:	21 f0       	breq	.+8      	; 0xe44 <gc_execute_line+0x310>
     e3c:	89 e0       	ldi	r24, 0x09	; 9
     e3e:	a8 16       	cp	r10, r24
     e40:	41 f0       	breq	.+16     	; 0xe52 <gc_execute_line+0x31e>
     e42:	0f c0       	rjmp	.+30     	; 0xe62 <gc_execute_line+0x32e>
              #ifdef ENABLE_M7
                case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
              #endif
              case 8: gc_block.modal.coolant |= COOLANT_FLOOD_ENABLE; break;
     e44:	80 91 f3 05 	lds	r24, 0x05F3	; 0x8005f3 <gc_block+0x9>
     e48:	80 64       	ori	r24, 0x40	; 64
     e4a:	80 93 f3 05 	sts	0x05F3, r24	; 0x8005f3 <gc_block+0x9>
          #ifdef ENABLE_M7
            case 7: case 8: case 9:
          #else
            case 8: case 9:
          #endif
            word_bit = MODAL_GROUP_M8;
     e4e:	8d e0       	ldi	r24, 0x0D	; 13
            switch(int_value) {
              #ifdef ENABLE_M7
                case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
              #endif
              case 8: gc_block.modal.coolant |= COOLANT_FLOOD_ENABLE; break;
     e50:	09 c0       	rjmp	.+18     	; 0xe64 <gc_execute_line+0x330>
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break; // M9 disables both M7 and M8.
     e52:	10 92 f3 05 	sts	0x05F3, r1	; 0x8005f3 <gc_block+0x9>
          #ifdef ENABLE_M7
            case 7: case 8: case 9:
          #else
            case 8: case 9:
          #endif
            word_bit = MODAL_GROUP_M8;
     e56:	8d e0       	ldi	r24, 0x0D	; 13
            switch(int_value) {
              #ifdef ENABLE_M7
                case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
              #endif
              case 8: gc_block.modal.coolant |= COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break; // M9 disables both M7 and M8.
     e58:	05 c0       	rjmp	.+10     	; 0xe64 <gc_execute_line+0x330>

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
     e5a:	8b e0       	ldi	r24, 0x0B	; 11
     e5c:	03 c0       	rjmp	.+6      	; 0xe64 <gc_execute_line+0x330>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
     e5e:	8c e0       	ldi	r24, 0x0C	; 12
     e60:	01 c0       	rjmp	.+2      	; 0xe64 <gc_execute_line+0x330>
          #ifdef ENABLE_M7
            case 7: case 8: case 9:
          #else
            case 8: case 9:
          #endif
            word_bit = MODAL_GROUP_M8;
     e62:	8d e0       	ldi	r24, 0x0D	; 13
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
        }

        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
     e64:	d6 01       	movw	r26, r12
     e66:	02 c0       	rjmp	.+4      	; 0xe6c <gc_execute_line+0x338>
     e68:	aa 0f       	add	r26, r26
     e6a:	bb 1f       	adc	r27, r27
     e6c:	8a 95       	dec	r24
     e6e:	e2 f7       	brpl	.-8      	; 0xe68 <gc_execute_line+0x334>
     e70:	97 01       	movw	r18, r14
     e72:	2a 23       	and	r18, r26
     e74:	3b 23       	and	r19, r27
     e76:	23 2b       	or	r18, r19
     e78:	11 f0       	breq	.+4      	; 0xe7e <gc_execute_line+0x34a>
     e7a:	0c 94 e2 0f 	jmp	0x1fc4	; 0x1fc4 <gc_execute_line+0x1490>
        command_words |= bit(word_bit);
     e7e:	ea 2a       	or	r14, r26
     e80:	fb 2a       	or	r15, r27
        break;
     e82:	c7 c0       	rjmp	.+398    	; 0x1012 <gc_execute_line+0x4de>
      default:

        /* Non-Command Words: This initial parsing phase only checks for repeats of the remaining
           legal g-code words and stores their value. Error-checking is performed later since some
           words (I,J,K,L,P,R) have multiple connotations and/or depend on the issued commands. */
        switch(letter){
     e84:	81 2f       	mov	r24, r17
     e86:	90 e0       	ldi	r25, 0x00	; 0
     e88:	fc 01       	movw	r30, r24
     e8a:	e6 54       	subi	r30, 0x46	; 70
     e8c:	f1 09       	sbc	r31, r1
     e8e:	e5 31       	cpi	r30, 0x15	; 21
     e90:	f1 05       	cpc	r31, r1
     e92:	10 f0       	brcs	.+4      	; 0xe98 <gc_execute_line+0x364>
     e94:	0c 94 e4 0f 	jmp	0x1fc8	; 0x1fc8 <gc_execute_line+0x1494>
     e98:	ee 54       	subi	r30, 0x4E	; 78
     e9a:	ff 4f       	sbci	r31, 0xFF	; 255
     e9c:	0c 94 bf 32 	jmp	0x657e	; 0x657e <__tablejump2__>
          // case 'A': // Not supported
          // case 'B': // Not supported
          // case 'C': // Not supported
          // case 'D': // Not supported
          case 'F': word_bit = WORD_F; gc_block.values.f = value; break;
     ea0:	40 92 f6 05 	sts	0x05F6, r4	; 0x8005f6 <gc_block+0xc>
     ea4:	50 92 f7 05 	sts	0x05F7, r5	; 0x8005f7 <gc_block+0xd>
     ea8:	60 92 f8 05 	sts	0x05F8, r6	; 0x8005f8 <gc_block+0xe>
     eac:	70 92 f9 05 	sts	0x05F9, r7	; 0x8005f9 <gc_block+0xf>
     eb0:	80 e0       	ldi	r24, 0x00	; 0
     eb2:	8d c0       	rjmp	.+282    	; 0xfce <gc_execute_line+0x49a>
          // case 'H': // Not supported
          case 'I': word_bit = WORD_I; gc_block.values.ijk[X_AXIS] = value; ijk_words |= (1<<X_AXIS); break;
     eb4:	40 92 fa 05 	sts	0x05FA, r4	; 0x8005fa <gc_block+0x10>
     eb8:	50 92 fb 05 	sts	0x05FB, r5	; 0x8005fb <gc_block+0x11>
     ebc:	60 92 fc 05 	sts	0x05FC, r6	; 0x8005fc <gc_block+0x12>
     ec0:	70 92 fd 05 	sts	0x05FD, r7	; 0x8005fd <gc_block+0x13>
     ec4:	bf 8d       	ldd	r27, Y+31	; 0x1f
     ec6:	b1 60       	ori	r27, 0x01	; 1
     ec8:	bf 8f       	std	Y+31, r27	; 0x1f
     eca:	81 e0       	ldi	r24, 0x01	; 1
     ecc:	80 c0       	rjmp	.+256    	; 0xfce <gc_execute_line+0x49a>
          case 'J': word_bit = WORD_J; gc_block.values.ijk[Y_AXIS] = value; ijk_words |= (1<<Y_AXIS); break;
     ece:	40 92 fe 05 	sts	0x05FE, r4	; 0x8005fe <gc_block+0x14>
     ed2:	50 92 ff 05 	sts	0x05FF, r5	; 0x8005ff <gc_block+0x15>
     ed6:	60 92 00 06 	sts	0x0600, r6	; 0x800600 <gc_block+0x16>
     eda:	70 92 01 06 	sts	0x0601, r7	; 0x800601 <gc_block+0x17>
     ede:	ef 8d       	ldd	r30, Y+31	; 0x1f
     ee0:	e2 60       	ori	r30, 0x02	; 2
     ee2:	ef 8f       	std	Y+31, r30	; 0x1f
     ee4:	82 e0       	ldi	r24, 0x02	; 2
     ee6:	73 c0       	rjmp	.+230    	; 0xfce <gc_execute_line+0x49a>
          case 'K': word_bit = WORD_K; gc_block.values.ijk[Z_AXIS] = value; ijk_words |= (1<<Z_AXIS); break;
     ee8:	40 92 02 06 	sts	0x0602, r4	; 0x800602 <gc_block+0x18>
     eec:	50 92 03 06 	sts	0x0603, r5	; 0x800603 <gc_block+0x19>
     ef0:	60 92 04 06 	sts	0x0604, r6	; 0x800604 <gc_block+0x1a>
     ef4:	70 92 05 06 	sts	0x0605, r7	; 0x800605 <gc_block+0x1b>
     ef8:	ff 8d       	ldd	r31, Y+31	; 0x1f
     efa:	f4 60       	ori	r31, 0x04	; 4
     efc:	ff 8f       	std	Y+31, r31	; 0x1f
     efe:	83 e0       	ldi	r24, 0x03	; 3
     f00:	66 c0       	rjmp	.+204    	; 0xfce <gc_execute_line+0x49a>
          case 'L': word_bit = WORD_L; gc_block.values.l = int_value; break;
     f02:	a0 92 06 06 	sts	0x0606, r10	; 0x800606 <gc_block+0x1c>
     f06:	84 e0       	ldi	r24, 0x04	; 4
     f08:	62 c0       	rjmp	.+196    	; 0xfce <gc_execute_line+0x49a>
          case 'N': word_bit = WORD_N; gc_block.values.n = trunc(value); break;
     f0a:	c3 01       	movw	r24, r6
     f0c:	b2 01       	movw	r22, r4
     f0e:	0e 94 d0 2f 	call	0x5fa0	; 0x5fa0 <__fixsfsi>
     f12:	60 93 07 06 	sts	0x0607, r22	; 0x800607 <gc_block+0x1d>
     f16:	70 93 08 06 	sts	0x0608, r23	; 0x800608 <gc_block+0x1e>
     f1a:	80 93 09 06 	sts	0x0609, r24	; 0x800609 <gc_block+0x1f>
     f1e:	90 93 0a 06 	sts	0x060A, r25	; 0x80060a <gc_block+0x20>
     f22:	85 e0       	ldi	r24, 0x05	; 5
     f24:	54 c0       	rjmp	.+168    	; 0xfce <gc_execute_line+0x49a>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
     f26:	40 92 0b 06 	sts	0x060B, r4	; 0x80060b <gc_block+0x21>
     f2a:	50 92 0c 06 	sts	0x060C, r5	; 0x80060c <gc_block+0x22>
     f2e:	60 92 0d 06 	sts	0x060D, r6	; 0x80060d <gc_block+0x23>
     f32:	70 92 0e 06 	sts	0x060E, r7	; 0x80060e <gc_block+0x24>
     f36:	86 e0       	ldi	r24, 0x06	; 6
     f38:	4a c0       	rjmp	.+148    	; 0xfce <gc_execute_line+0x49a>
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
     f3a:	40 92 0f 06 	sts	0x060F, r4	; 0x80060f <gc_block+0x25>
     f3e:	50 92 10 06 	sts	0x0610, r5	; 0x800610 <gc_block+0x26>
     f42:	60 92 11 06 	sts	0x0611, r6	; 0x800611 <gc_block+0x27>
     f46:	70 92 12 06 	sts	0x0612, r7	; 0x800612 <gc_block+0x28>
     f4a:	87 e0       	ldi	r24, 0x07	; 7
     f4c:	40 c0       	rjmp	.+128    	; 0xfce <gc_execute_line+0x49a>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
     f4e:	40 92 13 06 	sts	0x0613, r4	; 0x800613 <gc_block+0x29>
     f52:	50 92 14 06 	sts	0x0614, r5	; 0x800614 <gc_block+0x2a>
     f56:	60 92 15 06 	sts	0x0615, r6	; 0x800615 <gc_block+0x2b>
     f5a:	70 92 16 06 	sts	0x0616, r7	; 0x800616 <gc_block+0x2c>
     f5e:	88 e0       	ldi	r24, 0x08	; 8
     f60:	36 c0       	rjmp	.+108    	; 0xfce <gc_execute_line+0x49a>
          case 'T': word_bit = WORD_T; 
					  if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
     f62:	20 e0       	ldi	r18, 0x00	; 0
     f64:	30 e0       	ldi	r19, 0x00	; 0
     f66:	4f e7       	ldi	r20, 0x7F	; 127
     f68:	53 e4       	ldi	r21, 0x43	; 67
     f6a:	c3 01       	movw	r24, r6
     f6c:	b2 01       	movw	r22, r4
     f6e:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
     f72:	18 16       	cp	r1, r24
     f74:	14 f4       	brge	.+4      	; 0xf7a <gc_execute_line+0x446>
     f76:	0c 94 e6 0f 	jmp	0x1fcc	; 0x1fcc <gc_execute_line+0x1498>
            gc_block.values.t = int_value;
     f7a:	a0 92 17 06 	sts	0x0617, r10	; 0x800617 <gc_block+0x2d>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; 
     f7e:	89 e0       	ldi	r24, 0x09	; 9
					  if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
            gc_block.values.t = int_value;
						break;
     f80:	26 c0       	rjmp	.+76     	; 0xfce <gc_execute_line+0x49a>
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
     f82:	40 92 18 06 	sts	0x0618, r4	; 0x800618 <gc_block+0x2e>
     f86:	50 92 19 06 	sts	0x0619, r5	; 0x800619 <gc_block+0x2f>
     f8a:	60 92 1a 06 	sts	0x061A, r6	; 0x80061a <gc_block+0x30>
     f8e:	70 92 1b 06 	sts	0x061B, r7	; 0x80061b <gc_block+0x31>
     f92:	2d 8d       	ldd	r18, Y+29	; 0x1d
     f94:	21 60       	ori	r18, 0x01	; 1
     f96:	2d 8f       	std	Y+29, r18	; 0x1d
     f98:	8a e0       	ldi	r24, 0x0A	; 10
     f9a:	19 c0       	rjmp	.+50     	; 0xfce <gc_execute_line+0x49a>
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
     f9c:	40 92 1c 06 	sts	0x061C, r4	; 0x80061c <gc_block+0x32>
     fa0:	50 92 1d 06 	sts	0x061D, r5	; 0x80061d <gc_block+0x33>
     fa4:	60 92 1e 06 	sts	0x061E, r6	; 0x80061e <gc_block+0x34>
     fa8:	70 92 1f 06 	sts	0x061F, r7	; 0x80061f <gc_block+0x35>
     fac:	3d 8d       	ldd	r19, Y+29	; 0x1d
     fae:	32 60       	ori	r19, 0x02	; 2
     fb0:	3d 8f       	std	Y+29, r19	; 0x1d
     fb2:	8b e0       	ldi	r24, 0x0B	; 11
     fb4:	0c c0       	rjmp	.+24     	; 0xfce <gc_execute_line+0x49a>
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
     fb6:	40 92 20 06 	sts	0x0620, r4	; 0x800620 <gc_block+0x36>
     fba:	50 92 21 06 	sts	0x0621, r5	; 0x800621 <gc_block+0x37>
     fbe:	60 92 22 06 	sts	0x0622, r6	; 0x800622 <gc_block+0x38>
     fc2:	70 92 23 06 	sts	0x0623, r7	; 0x800623 <gc_block+0x39>
     fc6:	4d 8d       	ldd	r20, Y+29	; 0x1d
     fc8:	44 60       	ori	r20, 0x04	; 4
     fca:	4d 8f       	std	Y+29, r20	; 0x1d
     fcc:	8c e0       	ldi	r24, 0x0C	; 12
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
        }

        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
     fce:	56 01       	movw	r10, r12
     fd0:	08 2e       	mov	r0, r24
     fd2:	02 c0       	rjmp	.+4      	; 0xfd8 <gc_execute_line+0x4a4>
     fd4:	aa 0c       	add	r10, r10
     fd6:	bb 1c       	adc	r11, r11
     fd8:	0a 94       	dec	r0
     fda:	e2 f7       	brpl	.-8      	; 0xfd4 <gc_execute_line+0x4a0>
     fdc:	91 01       	movw	r18, r2
     fde:	2a 21       	and	r18, r10
     fe0:	3b 21       	and	r19, r11
     fe2:	23 2b       	or	r18, r19
     fe4:	11 f0       	breq	.+4      	; 0xfea <gc_execute_line+0x4b6>
     fe6:	0c 94 e8 0f 	jmp	0x1fd0	; 0x1fd0 <gc_execute_line+0x149c>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
     fea:	d4 01       	movw	r26, r8
     fec:	02 c0       	rjmp	.+4      	; 0xff2 <gc_execute_line+0x4be>
     fee:	b5 95       	asr	r27
     ff0:	a7 95       	ror	r26
     ff2:	8a 95       	dec	r24
     ff4:	e2 f7       	brpl	.-8      	; 0xfee <gc_execute_line+0x4ba>
     ff6:	a0 ff       	sbrs	r26, 0
     ff8:	0a c0       	rjmp	.+20     	; 0x100e <gc_execute_line+0x4da>
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
     ffa:	20 e0       	ldi	r18, 0x00	; 0
     ffc:	30 e0       	ldi	r19, 0x00	; 0
     ffe:	a9 01       	movw	r20, r18
    1000:	c3 01       	movw	r24, r6
    1002:	b2 01       	movw	r22, r4
    1004:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    1008:	88 23       	and	r24, r24
    100a:	0c f4       	brge	.+2      	; 0x100e <gc_execute_line+0x4da>
    100c:	e3 c7       	rjmp	.+4038   	; 0x1fd4 <gc_execute_line+0x14a0>
        }
        value_words |= bit(word_bit); // Flag to indicate parameter assigned.
    100e:	2a 28       	or	r2, r10
    1010:	3b 28       	or	r3, r11
  uint8_t int_value = 0;
  uint16_t mantissa = 0;
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
  else { char_counter = 0; }

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    1012:	89 81       	ldd	r24, Y+1	; 0x01
    1014:	eb 8d       	ldd	r30, Y+27	; 0x1b
    1016:	fc 8d       	ldd	r31, Y+28	; 0x1c
    1018:	e8 0f       	add	r30, r24
    101a:	f1 1d       	adc	r31, r1
    101c:	10 81       	ld	r17, Z
    101e:	11 11       	cpse	r17, r1
    1020:	d6 cd       	rjmp	.-1108   	; 0xbce <gc_execute_line+0x9a>

  // [0. Non-specific/common error-checks and miscellaneous setup]:

  // Determine implicit axis command conditions. Axis words have been passed, but no explicit axis
  // command has been sent. If so, set axis command to current motion mode.
  if (axis_words) {
    1022:	bd 8d       	ldd	r27, Y+29	; 0x1d
    1024:	bb 23       	and	r27, r27
    1026:	29 f0       	breq	.+10     	; 0x1032 <gc_execute_line+0x4fe>
    if (!axis_command) { axis_command = AXIS_COMMAND_MOTION_MODE; } // Assign implicit motion-mode
    1028:	ee 8d       	ldd	r30, Y+30	; 0x1e
    102a:	e1 11       	cpse	r30, r1
    102c:	02 c0       	rjmp	.+4      	; 0x1032 <gc_execute_line+0x4fe>
    102e:	f2 e0       	ldi	r31, 0x02	; 2
    1030:	fe 8f       	std	Y+30, r31	; 0x1e
  }

  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    1032:	25 fe       	sbrs	r2, 5
    1034:	0e c0       	rjmp	.+28     	; 0x1052 <gc_execute_line+0x51e>
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    1036:	80 91 07 06 	lds	r24, 0x0607	; 0x800607 <gc_block+0x1d>
    103a:	90 91 08 06 	lds	r25, 0x0608	; 0x800608 <gc_block+0x1e>
    103e:	a0 91 09 06 	lds	r26, 0x0609	; 0x800609 <gc_block+0x1f>
    1042:	b0 91 0a 06 	lds	r27, 0x060A	; 0x80060a <gc_block+0x20>
    1046:	81 38       	cpi	r24, 0x81	; 129
    1048:	96 49       	sbci	r25, 0x96	; 150
    104a:	a8 49       	sbci	r26, 0x98	; 152
    104c:	b1 05       	cpc	r27, r1
    104e:	0c f0       	brlt	.+2      	; 0x1052 <gc_execute_line+0x51e>
    1050:	c3 c7       	rjmp	.+3974   	; 0x1fd8 <gc_execute_line+0x14a4>
  // [1. Comments ]: MSG's NOT SUPPORTED. Comment handling performed by protocol.

  // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
  //   is not defined after switching to G94 from G93.
  // NOTE: For jogging, ignore prior feed rate mode. Enforce G94 and check for required F word.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    1052:	38 a1       	ldd	r19, Y+32	; 0x20
    1054:	33 23       	and	r19, r19
    1056:	e1 f0       	breq	.+56     	; 0x1090 <gc_execute_line+0x55c>
    if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); }
    1058:	20 fe       	sbrs	r2, 0
    105a:	c0 c7       	rjmp	.+3968   	; 0x1fdc <gc_execute_line+0x14a8>
    if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
    105c:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <gc_block+0x3>
    1060:	81 30       	cpi	r24, 0x01	; 1
    1062:	09 f0       	breq	.+2      	; 0x1066 <gc_execute_line+0x532>
    1064:	54 c0       	rjmp	.+168    	; 0x110e <gc_execute_line+0x5da>
    1066:	0a ee       	ldi	r16, 0xEA	; 234
    1068:	15 e0       	ldi	r17, 0x05	; 5
    106a:	23 e3       	ldi	r18, 0x33	; 51
    106c:	33 e3       	ldi	r19, 0x33	; 51
    106e:	4b ec       	ldi	r20, 0xCB	; 203
    1070:	51 e4       	ldi	r21, 0x41	; 65
    1072:	d8 01       	movw	r26, r16
    1074:	1c 96       	adiw	r26, 0x0c	; 12
    1076:	6d 91       	ld	r22, X+
    1078:	7d 91       	ld	r23, X+
    107a:	8d 91       	ld	r24, X+
    107c:	9c 91       	ld	r25, X
    107e:	1f 97       	sbiw	r26, 0x0f	; 15
    1080:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    1084:	f8 01       	movw	r30, r16
    1086:	64 87       	std	Z+12, r22	; 0x0c
    1088:	75 87       	std	Z+13, r23	; 0x0d
    108a:	86 87       	std	Z+14, r24	; 0x0e
    108c:	97 87       	std	Z+15, r25	; 0x0f
    108e:	3f c0       	rjmp	.+126    	; 0x110e <gc_execute_line+0x5da>
  } else {
    if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
    1090:	80 91 ec 05 	lds	r24, 0x05EC	; 0x8005ec <gc_block+0x2>
    1094:	81 30       	cpi	r24, 0x01	; 1
    1096:	61 f4       	brne	.+24     	; 0x10b0 <gc_execute_line+0x57c>
      // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
      if (axis_command == AXIS_COMMAND_MOTION_MODE) {
    1098:	fe 8d       	ldd	r31, Y+30	; 0x1e
    109a:	f2 30       	cpi	r31, 0x02	; 2
    109c:	c1 f5       	brne	.+112    	; 0x110e <gc_execute_line+0x5da>
        if ((gc_block.modal.motion != MOTION_MODE_NONE) && (gc_block.modal.motion != MOTION_MODE_SEEK)) {
    109e:	80 91 eb 05 	lds	r24, 0x05EB	; 0x8005eb <gc_block+0x1>
    10a2:	80 35       	cpi	r24, 0x50	; 80
    10a4:	a1 f1       	breq	.+104    	; 0x110e <gc_execute_line+0x5da>
    10a6:	88 23       	and	r24, r24
    10a8:	91 f1       	breq	.+100    	; 0x110e <gc_execute_line+0x5da>
          if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    10aa:	20 fe       	sbrs	r2, 0
    10ac:	99 c7       	rjmp	.+3890   	; 0x1fe0 <gc_execute_line+0x14ac>
    10ae:	2f c0       	rjmp	.+94     	; 0x110e <gc_execute_line+0x5da>
      // value in the block. If no F word is passed with a motion command that requires a feed rate, this will error
      // out in the motion modes error-checking. However, if no F word is passed with NO motion command that requires
      // a feed rate, we simply move on and the state feed rate value gets updated to zero and remains undefined.
    } else { // = G94
      // - In units per mm mode: If F word passed, ensure value is in mm/min, otherwise push last state value.
      if (gc_state.modal.feed_rate == FEED_RATE_MODE_UNITS_PER_MIN) { // Last state is also G94
    10b0:	80 91 ab 05 	lds	r24, 0x05AB	; 0x8005ab <gc_state+0x1>
    10b4:	81 11       	cpse	r24, r1
    10b6:	2b c0       	rjmp	.+86     	; 0x110e <gc_execute_line+0x5da>
        if (bit_istrue(value_words,bit(WORD_F))) {
    10b8:	20 fe       	sbrs	r2, 0
    10ba:	19 c0       	rjmp	.+50     	; 0x10ee <gc_execute_line+0x5ba>
          if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
    10bc:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <gc_block+0x3>
    10c0:	81 30       	cpi	r24, 0x01	; 1
    10c2:	29 f5       	brne	.+74     	; 0x110e <gc_execute_line+0x5da>
    10c4:	0a ee       	ldi	r16, 0xEA	; 234
    10c6:	15 e0       	ldi	r17, 0x05	; 5
    10c8:	23 e3       	ldi	r18, 0x33	; 51
    10ca:	33 e3       	ldi	r19, 0x33	; 51
    10cc:	4b ec       	ldi	r20, 0xCB	; 203
    10ce:	51 e4       	ldi	r21, 0x41	; 65
    10d0:	d8 01       	movw	r26, r16
    10d2:	1c 96       	adiw	r26, 0x0c	; 12
    10d4:	6d 91       	ld	r22, X+
    10d6:	7d 91       	ld	r23, X+
    10d8:	8d 91       	ld	r24, X+
    10da:	9c 91       	ld	r25, X
    10dc:	1f 97       	sbiw	r26, 0x0f	; 15
    10de:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    10e2:	f8 01       	movw	r30, r16
    10e4:	64 87       	std	Z+12, r22	; 0x0c
    10e6:	75 87       	std	Z+13, r23	; 0x0d
    10e8:	86 87       	std	Z+14, r24	; 0x0e
    10ea:	97 87       	std	Z+15, r25	; 0x0f
    10ec:	10 c0       	rjmp	.+32     	; 0x110e <gc_execute_line+0x5da>
        } else {
          gc_block.values.f = gc_state.feed_rate; // Push last state feed rate
    10ee:	80 91 b9 05 	lds	r24, 0x05B9	; 0x8005b9 <gc_state+0xf>
    10f2:	90 91 ba 05 	lds	r25, 0x05BA	; 0x8005ba <gc_state+0x10>
    10f6:	a0 91 bb 05 	lds	r26, 0x05BB	; 0x8005bb <gc_state+0x11>
    10fa:	b0 91 bc 05 	lds	r27, 0x05BC	; 0x8005bc <gc_state+0x12>
    10fe:	80 93 f6 05 	sts	0x05F6, r24	; 0x8005f6 <gc_block+0xc>
    1102:	90 93 f7 05 	sts	0x05F7, r25	; 0x8005f7 <gc_block+0xd>
    1106:	a0 93 f8 05 	sts	0x05F8, r26	; 0x8005f8 <gc_block+0xe>
    110a:	b0 93 f9 05 	sts	0x05F9, r27	; 0x8005f9 <gc_block+0xf>
    }
  }
  // bit_false(value_words,bit(WORD_F)); // NOTE: Single-meaning value word. Set at end of error-checking.

  // [4. Set spindle speed ]: S is negative (done.)
  if (bit_isfalse(value_words,bit(WORD_S))) { gc_block.values.s = gc_state.spindle_speed; }
    110e:	30 fc       	sbrc	r3, 0
    1110:	10 c0       	rjmp	.+32     	; 0x1132 <gc_execute_line+0x5fe>
    1112:	80 91 b5 05 	lds	r24, 0x05B5	; 0x8005b5 <gc_state+0xb>
    1116:	90 91 b6 05 	lds	r25, 0x05B6	; 0x8005b6 <gc_state+0xc>
    111a:	a0 91 b7 05 	lds	r26, 0x05B7	; 0x8005b7 <gc_state+0xd>
    111e:	b0 91 b8 05 	lds	r27, 0x05B8	; 0x8005b8 <gc_state+0xe>
    1122:	80 93 13 06 	sts	0x0613, r24	; 0x800613 <gc_block+0x29>
    1126:	90 93 14 06 	sts	0x0614, r25	; 0x800614 <gc_block+0x2a>
    112a:	a0 93 15 06 	sts	0x0615, r26	; 0x800615 <gc_block+0x2b>
    112e:	b0 93 16 06 	sts	0x0616, r27	; 0x800616 <gc_block+0x2c>
      }
    }
  #endif

  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    1132:	80 91 ea 05 	lds	r24, 0x05EA	; 0x8005ea <gc_block>
    1136:	84 30       	cpi	r24, 0x04	; 4
    1138:	21 f4       	brne	.+8      	; 0x1142 <gc_execute_line+0x60e>
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    113a:	26 fe       	sbrs	r2, 6
    113c:	53 c7       	rjmp	.+3750   	; 0x1fe4 <gc_execute_line+0x14b0>
    bit_false(value_words,bit(WORD_P));
    113e:	e8 94       	clt
    1140:	26 f8       	bld	r2, 6
  }

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    1142:	80 91 ef 05 	lds	r24, 0x05EF	; 0x8005ef <gc_block+0x5>
    1146:	88 23       	and	r24, r24
    1148:	49 f0       	breq	.+18     	; 0x115c <gc_execute_line+0x628>
    114a:	81 30       	cpi	r24, 0x01	; 1
    114c:	09 f4       	brne	.+2      	; 0x1150 <gc_execute_line+0x61c>
    114e:	9c c7       	rjmp	.+3896   	; 0x2088 <gc_execute_line+0x1554>
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
      axis_linear = X_AXIS;
    1150:	1b a6       	std	Y+43, r1	; 0x2b
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
    1152:	f2 e0       	ldi	r31, 0x02	; 2
    1154:	fa a3       	std	Y+34, r31	; 0x22
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
    1156:	21 e0       	ldi	r18, 0x01	; 1
    1158:	29 a3       	std	Y+33, r18	; 0x21
    115a:	9b c7       	rjmp	.+3894   	; 0x2092 <gc_execute_line+0x155e>
  }

  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    115c:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <gc_block+0x3>
    1160:	81 30       	cpi	r24, 0x01	; 1
    1162:	a1 f5       	brne	.+104    	; 0x11cc <gc_execute_line+0x698>
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
    1164:	32 e0       	ldi	r19, 0x02	; 2
    1166:	3b a7       	std	Y+43, r19	; 0x2b

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
    1168:	41 e0       	ldi	r20, 0x01	; 1
    116a:	4a a3       	std	Y+34, r20	; 0x22
  }

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
    116c:	19 a2       	std	Y+33, r1	; 0x21
    116e:	0f 2e       	mov	r0, r31
    1170:	fa ee       	ldi	r31, 0xEA	; 234
    1172:	af 2e       	mov	r10, r31
    1174:	f5 e0       	ldi	r31, 0x05	; 5
    1176:	bf 2e       	mov	r11, r31
    1178:	f0 2d       	mov	r31, r0
    117a:	00 e0       	ldi	r16, 0x00	; 0
    117c:	10 e0       	ldi	r17, 0x00	; 0
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
      if (bit_istrue(axis_words,bit(idx)) ) {
    117e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1180:	c8 2e       	mov	r12, r24
    1182:	d1 2c       	mov	r13, r1
    1184:	c6 01       	movw	r24, r12
    1186:	00 2e       	mov	r0, r16
    1188:	02 c0       	rjmp	.+4      	; 0x118e <gc_execute_line+0x65a>
    118a:	95 95       	asr	r25
    118c:	87 95       	ror	r24
    118e:	0a 94       	dec	r0
    1190:	e2 f7       	brpl	.-8      	; 0x118a <gc_execute_line+0x656>
    1192:	80 ff       	sbrs	r24, 0
    1194:	12 c0       	rjmp	.+36     	; 0x11ba <gc_execute_line+0x686>
        gc_block.values.xyz[idx] *= MM_PER_INCH;
    1196:	23 e3       	ldi	r18, 0x33	; 51
    1198:	33 e3       	ldi	r19, 0x33	; 51
    119a:	4b ec       	ldi	r20, 0xCB	; 203
    119c:	51 e4       	ldi	r21, 0x41	; 65
    119e:	d5 01       	movw	r26, r10
    11a0:	9e 96       	adiw	r26, 0x2e	; 46
    11a2:	6d 91       	ld	r22, X+
    11a4:	7d 91       	ld	r23, X+
    11a6:	8d 91       	ld	r24, X+
    11a8:	9c 91       	ld	r25, X
    11aa:	d1 97       	sbiw	r26, 0x31	; 49
    11ac:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    11b0:	f5 01       	movw	r30, r10
    11b2:	66 a7       	std	Z+46, r22	; 0x2e
    11b4:	77 a7       	std	Z+47, r23	; 0x2f
    11b6:	80 ab       	std	Z+48, r24	; 0x30
    11b8:	91 ab       	std	Z+49, r25	; 0x31
    11ba:	0f 5f       	subi	r16, 0xFF	; 255
    11bc:	1f 4f       	sbci	r17, 0xFF	; 255
    11be:	f4 e0       	ldi	r31, 0x04	; 4
    11c0:	af 0e       	add	r10, r31
    11c2:	b1 1c       	adc	r11, r1

  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    11c4:	03 30       	cpi	r16, 0x03	; 3
    11c6:	11 05       	cpc	r17, r1
    11c8:	e9 f6       	brne	.-70     	; 0x1184 <gc_execute_line+0x650>
    11ca:	05 c0       	rjmp	.+10     	; 0x11d6 <gc_execute_line+0x6a2>
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
    11cc:	22 e0       	ldi	r18, 0x02	; 2
    11ce:	2b a7       	std	Y+43, r18	; 0x2b

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
    11d0:	31 e0       	ldi	r19, 0x01	; 1
    11d2:	3a a3       	std	Y+34, r19	; 0x22
  }

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
    11d4:	19 a2       	std	Y+33, r1	; 0x21
  // [14. Cutter length compensation ]: G43 NOT SUPPORTED, but G43.1 and G49 are.
  // [G43.1 Errors]: Motion command in same line.
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    11d6:	4e 8d       	ldd	r20, Y+30	; 0x1e
    11d8:	43 30       	cpi	r20, 0x03	; 3
    11da:	41 f4       	brne	.+16     	; 0x11ec <gc_execute_line+0x6b8>
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
    11dc:	80 91 f0 05 	lds	r24, 0x05F0	; 0x8005f0 <gc_block+0x6>
    11e0:	81 30       	cpi	r24, 0x01	; 1
    11e2:	21 f4       	brne	.+8      	; 0x11ec <gc_execute_line+0x6b8>
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    11e4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    11e6:	84 30       	cpi	r24, 0x04	; 4
    11e8:	09 f0       	breq	.+2      	; 0x11ec <gc_execute_line+0x6b8>
    11ea:	fe c6       	rjmp	.+3580   	; 0x1fe8 <gc_execute_line+0x14b4>
  // TODO: An EEPROM read of the coordinate data may require a buffer sync when the cycle
  // is active. The read pauses the processor temporarily and may cause a rare crash. For
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  float block_coord_system[N_AXIS];
  memcpy(block_coord_system,gc_state.coord_system,sizeof(gc_state.coord_system));
    11ec:	8c e0       	ldi	r24, 0x0C	; 12
    11ee:	ee ec       	ldi	r30, 0xCE	; 206
    11f0:	f5 e0       	ldi	r31, 0x05	; 5
    11f2:	de 01       	movw	r26, r28
    11f4:	16 96       	adiw	r26, 0x06	; 6
    11f6:	01 90       	ld	r0, Z+
    11f8:	0d 92       	st	X+, r0
    11fa:	8a 95       	dec	r24
    11fc:	e1 f7       	brne	.-8      	; 0x11f6 <gc_execute_line+0x6c2>
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    11fe:	f1 fe       	sbrs	r15, 1
    1200:	11 c0       	rjmp	.+34     	; 0x1224 <gc_execute_line+0x6f0>
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    1202:	80 91 f1 05 	lds	r24, 0x05F1	; 0x8005f1 <gc_block+0x7>
    1206:	87 30       	cpi	r24, 0x07	; 7
    1208:	08 f0       	brcs	.+2      	; 0x120c <gc_execute_line+0x6d8>
    120a:	f0 c6       	rjmp	.+3552   	; 0x1fec <gc_execute_line+0x14b8>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    120c:	90 91 b0 05 	lds	r25, 0x05B0	; 0x8005b0 <gc_state+0x6>
    1210:	89 17       	cp	r24, r25
    1212:	41 f0       	breq	.+16     	; 0x1224 <gc_execute_line+0x6f0>
      if (!(settings_read_coord_data(gc_block.modal.coord_select,block_coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    1214:	be 01       	movw	r22, r28
    1216:	6a 5f       	subi	r22, 0xFA	; 250
    1218:	7f 4f       	sbci	r23, 0xFF	; 255
    121a:	0e 94 3f 23 	call	0x467e	; 0x467e <settings_read_coord_data>
    121e:	88 23       	and	r24, r24
    1220:	09 f4       	brne	.+2      	; 0x1224 <gc_execute_line+0x6f0>
    1222:	e6 c6       	rjmp	.+3532   	; 0x1ff0 <gc_execute_line+0x14bc>
  // [19. Remaining non-modal actions ]: Check go to predefined position, set G10, or set axis offsets.
  // NOTE: We need to separate the non-modal commands that are axis word-using (G10/G28/G30/G92), as these
  // commands all treat axis words differently. G10 as absolute offsets or computes current position as
  // the axis value, G92 similarly to G10 L20, and G28/30 as an intermediate target position that observes
  // all the current coordinate system and G92 offsets.
  switch (gc_block.non_modal_command) {
    1224:	b0 90 ea 05 	lds	r11, 0x05EA	; 0x8005ea <gc_block>
    1228:	9a e0       	ldi	r25, 0x0A	; 10
    122a:	b9 16       	cp	r11, r25
    122c:	29 f0       	breq	.+10     	; 0x1238 <gc_execute_line+0x704>
    122e:	ac e5       	ldi	r26, 0x5C	; 92
    1230:	ba 16       	cp	r11, r26
    1232:	09 f4       	brne	.+2      	; 0x1236 <gc_execute_line+0x702>
    1234:	9a c0       	rjmp	.+308    	; 0x136a <gc_execute_line+0x836>
    1236:	0e c1       	rjmp	.+540    	; 0x1454 <gc_execute_line+0x920>
    case NON_MODAL_SET_COORDINATE_DATA:
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    1238:	bd 8d       	ldd	r27, Y+29	; 0x1d
    123a:	bb 23       	and	r27, r27
    123c:	09 f4       	brne	.+2      	; 0x1240 <gc_execute_line+0x70c>
    123e:	da c6       	rjmp	.+3508   	; 0x1ff4 <gc_execute_line+0x14c0>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    1240:	c1 01       	movw	r24, r2
    1242:	80 75       	andi	r24, 0x50	; 80
    1244:	99 27       	eor	r25, r25
    1246:	89 2b       	or	r24, r25
    1248:	09 f4       	brne	.+2      	; 0x124c <gc_execute_line+0x718>
    124a:	d6 c6       	rjmp	.+3500   	; 0x1ff8 <gc_execute_line+0x14c4>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
    124c:	60 91 0b 06 	lds	r22, 0x060B	; 0x80060b <gc_block+0x21>
    1250:	70 91 0c 06 	lds	r23, 0x060C	; 0x80060c <gc_block+0x22>
    1254:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <gc_block+0x23>
    1258:	90 91 0e 06 	lds	r25, 0x060E	; 0x80060e <gc_block+0x24>
    125c:	0e 94 99 32 	call	0x6532	; 0x6532 <trunc>
    1260:	0e 94 d7 2f 	call	0x5fae	; 0x5fae <__fixunssfsi>
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    1264:	67 30       	cpi	r22, 0x07	; 7
    1266:	08 f0       	brcs	.+2      	; 0x126a <gc_execute_line+0x736>
    1268:	c9 c6       	rjmp	.+3474   	; 0x1ffc <gc_execute_line+0x14c8>
      if (gc_block.values.l != 20) {
    126a:	80 91 06 06 	lds	r24, 0x0606	; 0x800606 <gc_block+0x1c>
    126e:	84 31       	cpi	r24, 0x14	; 20
    1270:	29 f0       	breq	.+10     	; 0x127c <gc_execute_line+0x748>
        if (gc_block.values.l == 2) {
    1272:	82 30       	cpi	r24, 0x02	; 2
    1274:	09 f0       	breq	.+2      	; 0x1278 <gc_execute_line+0x744>
    1276:	c4 c6       	rjmp	.+3464   	; 0x2000 <gc_execute_line+0x14cc>
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    1278:	27 fc       	sbrc	r2, 7
    127a:	c4 c6       	rjmp	.+3464   	; 0x2004 <gc_execute_line+0x14d0>
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
      }
      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
    127c:	ef ea       	ldi	r30, 0xAF	; 175
    127e:	2e 22       	and	r2, r30

      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
    1280:	66 23       	and	r22, r22
    1282:	19 f0       	breq	.+6      	; 0x128a <gc_execute_line+0x756>
    1284:	61 50       	subi	r22, 0x01	; 1
    1286:	6b 8f       	std	Y+27, r22	; 0x1b
    1288:	03 c0       	rjmp	.+6      	; 0x1290 <gc_execute_line+0x75c>
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
    128a:	f0 91 f1 05 	lds	r31, 0x05F1	; 0x8005f1 <gc_block+0x7>
    128e:	fb 8f       	std	Y+27, r31	; 0x1b
      
      // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    1290:	6a ef       	ldi	r22, 0xFA	; 250
    1292:	75 e0       	ldi	r23, 0x05	; 5
    1294:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1296:	0e 94 3f 23 	call	0x467e	; 0x467e <settings_read_coord_data>
    129a:	88 23       	and	r24, r24
    129c:	09 f4       	brne	.+2      	; 0x12a0 <gc_execute_line+0x76c>
    129e:	b4 c6       	rjmp	.+3432   	; 0x2008 <gc_execute_line+0x14d4>

      // Pre-calculate the coordinate data changes.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
          if (gc_block.values.l == 20) {
    12a0:	20 91 06 06 	lds	r18, 0x0606	; 0x800606 <gc_block+0x1c>
    12a4:	2b a3       	std	Y+35, r18	; 0x23
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            // WPos = MPos - WCS - G92 - TLO  ->  WCS = MPos - G92 - TLO - WPos
            gc_block.values.ijk[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.ijk[idx] -= gc_state.tool_length_offset; }
    12a6:	40 90 e6 05 	lds	r4, 0x05E6	; 0x8005e6 <gc_state+0x3c>
    12aa:	50 90 e7 05 	lds	r5, 0x05E7	; 0x8005e7 <gc_state+0x3d>
    12ae:	60 90 e8 05 	lds	r6, 0x05E8	; 0x8005e8 <gc_state+0x3e>
    12b2:	70 90 e9 05 	lds	r7, 0x05E9	; 0x8005e9 <gc_state+0x3f>
    12b6:	0a ee       	ldi	r16, 0xEA	; 234
    12b8:	15 e0       	ldi	r17, 0x05	; 5
    12ba:	0f 2e       	mov	r0, r31
    12bc:	fa ea       	ldi	r31, 0xAA	; 170
    12be:	cf 2e       	mov	r12, r31
    12c0:	f5 e0       	ldi	r31, 0x05	; 5
    12c2:	df 2e       	mov	r13, r31
    12c4:	f0 2d       	mov	r31, r0
    12c6:	a1 2c       	mov	r10, r1
    12c8:	b1 2c       	mov	r11, r1
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]

      // Pre-calculate the coordinate data changes.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
    12ca:	3d 8d       	ldd	r19, Y+29	; 0x1d
    12cc:	83 2e       	mov	r8, r19
    12ce:	91 2c       	mov	r9, r1
    12d0:	c4 01       	movw	r24, r8
    12d2:	0a 2c       	mov	r0, r10
    12d4:	02 c0       	rjmp	.+4      	; 0x12da <gc_execute_line+0x7a6>
    12d6:	95 95       	asr	r25
    12d8:	87 95       	ror	r24
    12da:	0a 94       	dec	r0
    12dc:	e2 f7       	brpl	.-8      	; 0x12d6 <gc_execute_line+0x7a2>
    12de:	80 ff       	sbrs	r24, 0
    12e0:	36 c0       	rjmp	.+108    	; 0x134e <gc_execute_line+0x81a>
          if (gc_block.values.l == 20) {
    12e2:	4b a1       	ldd	r20, Y+35	; 0x23
    12e4:	44 31       	cpi	r20, 0x14	; 20
    12e6:	51 f5       	brne	.+84     	; 0x133c <gc_execute_line+0x808>
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            // WPos = MPos - WCS - G92 - TLO  ->  WCS = MPos - G92 - TLO - WPos
            gc_block.values.ijk[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
    12e8:	d6 01       	movw	r26, r12
    12ea:	d0 96       	adiw	r26, 0x30	; 48
    12ec:	2d 91       	ld	r18, X+
    12ee:	3d 91       	ld	r19, X+
    12f0:	4d 91       	ld	r20, X+
    12f2:	5c 91       	ld	r21, X
    12f4:	d3 97       	sbiw	r26, 0x33	; 51
    12f6:	58 96       	adiw	r26, 0x18	; 24
    12f8:	6d 91       	ld	r22, X+
    12fa:	7d 91       	ld	r23, X+
    12fc:	8d 91       	ld	r24, X+
    12fe:	9c 91       	ld	r25, X
    1300:	5b 97       	sbiw	r26, 0x1b	; 27
    1302:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    1306:	f8 01       	movw	r30, r16
    1308:	26 a5       	ldd	r18, Z+46	; 0x2e
    130a:	37 a5       	ldd	r19, Z+47	; 0x2f
    130c:	40 a9       	ldd	r20, Z+48	; 0x30
    130e:	51 a9       	ldd	r21, Z+49	; 0x31
    1310:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    1314:	d8 01       	movw	r26, r16
    1316:	50 96       	adiw	r26, 0x10	; 16
    1318:	6d 93       	st	X+, r22
    131a:	7d 93       	st	X+, r23
    131c:	8d 93       	st	X+, r24
    131e:	9c 93       	st	X, r25
    1320:	53 97       	sbiw	r26, 0x13	; 19
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.ijk[idx] -= gc_state.tool_length_offset; }
    1322:	b2 e0       	ldi	r27, 0x02	; 2
    1324:	ab 12       	cpse	r10, r27
    1326:	13 c0       	rjmp	.+38     	; 0x134e <gc_execute_line+0x81a>
    1328:	a3 01       	movw	r20, r6
    132a:	92 01       	movw	r18, r4
    132c:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    1330:	f8 01       	movw	r30, r16
    1332:	60 8b       	std	Z+16, r22	; 0x10
    1334:	71 8b       	std	Z+17, r23	; 0x11
    1336:	82 8b       	std	Z+18, r24	; 0x12
    1338:	93 8b       	std	Z+19, r25	; 0x13
    133a:	09 c0       	rjmp	.+18     	; 0x134e <gc_execute_line+0x81a>
          } else {
            // L2: Update coordinate system axis to programmed value.
            gc_block.values.ijk[idx] = gc_block.values.xyz[idx];
    133c:	f8 01       	movw	r30, r16
    133e:	86 a5       	ldd	r24, Z+46	; 0x2e
    1340:	97 a5       	ldd	r25, Z+47	; 0x2f
    1342:	a0 a9       	ldd	r26, Z+48	; 0x30
    1344:	b1 a9       	ldd	r27, Z+49	; 0x31
    1346:	80 8b       	std	Z+16, r24	; 0x10
    1348:	91 8b       	std	Z+17, r25	; 0x11
    134a:	a2 8b       	std	Z+18, r26	; 0x12
    134c:	b3 8b       	std	Z+19, r27	; 0x13
    134e:	ff ef       	ldi	r31, 0xFF	; 255
    1350:	af 1a       	sub	r10, r31
    1352:	bf 0a       	sbc	r11, r31
    1354:	0c 5f       	subi	r16, 0xFC	; 252
    1356:	1f 4f       	sbci	r17, 0xFF	; 255
    1358:	24 e0       	ldi	r18, 0x04	; 4
    135a:	c2 0e       	add	r12, r18
    135c:	d1 1c       	adc	r13, r1
      
      // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]

      // Pre-calculate the coordinate data changes.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    135e:	33 e0       	ldi	r19, 0x03	; 3
    1360:	a3 16       	cp	r10, r19
    1362:	b1 04       	cpc	r11, r1
    1364:	09 f0       	breq	.+2      	; 0x1368 <gc_execute_line+0x834>
    1366:	b4 cf       	rjmp	.-152    	; 0x12d0 <gc_execute_line+0x79c>
    1368:	a6 c6       	rjmp	.+3404   	; 0x20b6 <gc_execute_line+0x1582>
        } // Else, keep current stored value.
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    136a:	4d 8d       	ldd	r20, Y+29	; 0x1d
    136c:	44 23       	and	r20, r20
    136e:	09 f4       	brne	.+2      	; 0x1372 <gc_execute_line+0x83e>
    1370:	4d c6       	rjmp	.+3226   	; 0x200c <gc_execute_line+0x14d8>
    1372:	0f 2e       	mov	r0, r31
    1374:	fa ea       	ldi	r31, 0xAA	; 170
    1376:	af 2e       	mov	r10, r31
    1378:	f5 e0       	ldi	r31, 0x05	; 5
    137a:	bf 2e       	mov	r11, r31
    137c:	f0 2d       	mov	r31, r0
    137e:	4e 01       	movw	r8, r28
    1380:	86 e0       	ldi	r24, 0x06	; 6
    1382:	88 0e       	add	r8, r24
    1384:	91 1c       	adc	r9, r1
    1386:	0a ee       	ldi	r16, 0xEA	; 234
    1388:	15 e0       	ldi	r17, 0x05	; 5
    138a:	c1 2c       	mov	r12, r1
    138c:	d1 2c       	mov	r13, r1

      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        if (bit_istrue(axis_words,bit(idx)) ) {
    138e:	64 2e       	mov	r6, r20
    1390:	71 2c       	mov	r7, r1
    1392:	c3 01       	movw	r24, r6
    1394:	0c 2c       	mov	r0, r12
    1396:	02 c0       	rjmp	.+4      	; 0x139c <gc_execute_line+0x868>
    1398:	95 95       	asr	r25
    139a:	87 95       	ror	r24
    139c:	0a 94       	dec	r0
    139e:	e2 f7       	brpl	.-8      	; 0x1398 <gc_execute_line+0x864>
    13a0:	80 ff       	sbrs	r24, 0
    13a2:	3c c0       	rjmp	.+120    	; 0x141c <gc_execute_line+0x8e8>
          // WPos = MPos - WCS - G92 - TLO  ->  G92 = MPos - WCS - TLO - WPos
          gc_block.values.xyz[idx] = gc_state.position[idx]-block_coord_system[idx]-gc_block.values.xyz[idx];
    13a4:	d4 01       	movw	r26, r8
    13a6:	2d 91       	ld	r18, X+
    13a8:	3d 91       	ld	r19, X+
    13aa:	4d 91       	ld	r20, X+
    13ac:	5c 91       	ld	r21, X
    13ae:	f5 01       	movw	r30, r10
    13b0:	60 8d       	ldd	r22, Z+24	; 0x18
    13b2:	71 8d       	ldd	r23, Z+25	; 0x19
    13b4:	82 8d       	ldd	r24, Z+26	; 0x1a
    13b6:	93 8d       	ldd	r25, Z+27	; 0x1b
    13b8:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    13bc:	d8 01       	movw	r26, r16
    13be:	9e 96       	adiw	r26, 0x2e	; 46
    13c0:	2d 91       	ld	r18, X+
    13c2:	3d 91       	ld	r19, X+
    13c4:	4d 91       	ld	r20, X+
    13c6:	5c 91       	ld	r21, X
    13c8:	d1 97       	sbiw	r26, 0x31	; 49
    13ca:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    13ce:	f8 01       	movw	r30, r16
    13d0:	66 a7       	std	Z+46, r22	; 0x2e
    13d2:	77 a7       	std	Z+47, r23	; 0x2f
    13d4:	80 ab       	std	Z+48, r24	; 0x30
    13d6:	91 ab       	std	Z+49, r25	; 0x31
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
    13d8:	f2 e0       	ldi	r31, 0x02	; 2
    13da:	cf 12       	cpse	r12, r31
    13dc:	29 c0       	rjmp	.+82     	; 0x1430 <gc_execute_line+0x8fc>
    13de:	86 01       	movw	r16, r12
    13e0:	00 0f       	add	r16, r16
    13e2:	11 1f       	adc	r17, r17
    13e4:	00 0f       	add	r16, r16
    13e6:	11 1f       	adc	r17, r17
    13e8:	06 51       	subi	r16, 0x16	; 22
    13ea:	1a 4f       	sbci	r17, 0xFA	; 250
    13ec:	20 91 e6 05 	lds	r18, 0x05E6	; 0x8005e6 <gc_state+0x3c>
    13f0:	30 91 e7 05 	lds	r19, 0x05E7	; 0x8005e7 <gc_state+0x3d>
    13f4:	40 91 e8 05 	lds	r20, 0x05E8	; 0x8005e8 <gc_state+0x3e>
    13f8:	50 91 e9 05 	lds	r21, 0x05E9	; 0x8005e9 <gc_state+0x3f>
    13fc:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    1400:	d8 01       	movw	r26, r16
    1402:	9e 96       	adiw	r26, 0x2e	; 46
    1404:	6d 93       	st	X+, r22
    1406:	7d 93       	st	X+, r23
    1408:	8d 93       	st	X+, r24
    140a:	9c 93       	st	X, r25
    140c:	d1 97       	sbiw	r26, 0x31	; 49
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    140e:	10 91 eb 05 	lds	r17, 0x05EB	; 0x8005eb <gc_block+0x1>
    1412:	10 35       	cpi	r17, 0x50	; 80
    1414:	09 f4       	brne	.+2      	; 0x1418 <gc_execute_line+0x8e4>
    1416:	fc c5       	rjmp	.+3064   	; 0x2010 <gc_execute_line+0x14dc>
    1418:	1b 8e       	std	Y+27, r1	; 0x1b
    141a:	f8 c0       	rjmp	.+496    	; 0x160c <gc_execute_line+0xad8>
        if (bit_istrue(axis_words,bit(idx)) ) {
          // WPos = MPos - WCS - G92 - TLO  ->  G92 = MPos - WCS - TLO - WPos
          gc_block.values.xyz[idx] = gc_state.position[idx]-block_coord_system[idx]-gc_block.values.xyz[idx];
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
        } else {
          gc_block.values.xyz[idx] = gc_state.coord_offset[idx];
    141c:	f5 01       	movw	r30, r10
    141e:	80 a9       	ldd	r24, Z+48	; 0x30
    1420:	91 a9       	ldd	r25, Z+49	; 0x31
    1422:	a2 a9       	ldd	r26, Z+50	; 0x32
    1424:	b3 a9       	ldd	r27, Z+51	; 0x33
    1426:	f8 01       	movw	r30, r16
    1428:	86 a7       	std	Z+46, r24	; 0x2e
    142a:	97 a7       	std	Z+47, r25	; 0x2f
    142c:	a0 ab       	std	Z+48, r26	; 0x30
    142e:	b1 ab       	std	Z+49, r27	; 0x31
    1430:	ff ef       	ldi	r31, 0xFF	; 255
    1432:	cf 1a       	sub	r12, r31
    1434:	df 0a       	sbc	r13, r31
    1436:	24 e0       	ldi	r18, 0x04	; 4
    1438:	a2 0e       	add	r10, r18
    143a:	b1 1c       	adc	r11, r1
    143c:	34 e0       	ldi	r19, 0x04	; 4
    143e:	83 0e       	add	r8, r19
    1440:	91 1c       	adc	r9, r1
    1442:	0c 5f       	subi	r16, 0xFC	; 252
    1444:	1f 4f       	sbci	r17, 0xFF	; 255
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]

      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    1446:	43 e0       	ldi	r20, 0x03	; 3
    1448:	c4 16       	cp	r12, r20
    144a:	d1 04       	cpc	r13, r1
    144c:	09 f0       	breq	.+2      	; 0x1450 <gc_execute_line+0x91c>
    144e:	a1 cf       	rjmp	.-190    	; 0x1392 <gc_execute_line+0x85e>
  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes

  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    1450:	1b 8e       	std	Y+27, r1	; 0x1b
    1452:	31 c6       	rjmp	.+3170   	; 0x20b6 <gc_execute_line+0x1582>

      // At this point, the rest of the explicit axis commands treat the axis values as the traditional
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
    1454:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1456:	83 30       	cpi	r24, 0x03	; 3
    1458:	09 f4       	brne	.+2      	; 0x145c <gc_execute_line+0x928>
    145a:	90 c0       	rjmp	.+288    	; 0x157c <gc_execute_line+0xa48>
        if (axis_words) {
    145c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    145e:	99 23       	and	r25, r25
    1460:	09 f4       	brne	.+2      	; 0x1464 <gc_execute_line+0x930>
    1462:	8c c0       	rjmp	.+280    	; 0x157c <gc_execute_line+0xa48>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    1464:	a0 90 ee 05 	lds	r10, 0x05EE	; 0x8005ee <gc_block+0x4>
    1468:	0f 2e       	mov	r0, r31
    146a:	fa ea       	ldi	r31, 0xAA	; 170
    146c:	cf 2e       	mov	r12, r31
    146e:	f5 e0       	ldi	r31, 0x05	; 5
    1470:	df 2e       	mov	r13, r31
    1472:	f0 2d       	mov	r31, r0
    1474:	0a ee       	ldi	r16, 0xEA	; 234
    1476:	15 e0       	ldi	r17, 0x05	; 5
    1478:	3e 01       	movw	r6, r28
    147a:	a6 e0       	ldi	r26, 0x06	; 6
    147c:	6a 0e       	add	r6, r26
    147e:	71 1c       	adc	r7, r1
    1480:	81 2c       	mov	r8, r1
    1482:	91 2c       	mov	r9, r1
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
            if ( bit_isfalse(axis_words,bit(idx)) ) {
    1484:	49 2e       	mov	r4, r25
    1486:	51 2c       	mov	r5, r1
    1488:	9c 8e       	std	Y+28, r9	; 0x1c
    148a:	8b 8e       	std	Y+27, r8	; 0x1b
    148c:	c2 01       	movw	r24, r4
    148e:	08 2c       	mov	r0, r8
    1490:	02 c0       	rjmp	.+4      	; 0x1496 <gc_execute_line+0x962>
    1492:	95 95       	asr	r25
    1494:	87 95       	ror	r24
    1496:	0a 94       	dec	r0
    1498:	e2 f7       	brpl	.-8      	; 0x1492 <gc_execute_line+0x95e>
    149a:	80 fd       	sbrc	r24, 0
    149c:	0b c0       	rjmp	.+22     	; 0x14b4 <gc_execute_line+0x980>
              gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
    149e:	f6 01       	movw	r30, r12
    14a0:	80 8d       	ldd	r24, Z+24	; 0x18
    14a2:	91 8d       	ldd	r25, Z+25	; 0x19
    14a4:	a2 8d       	ldd	r26, Z+26	; 0x1a
    14a6:	b3 8d       	ldd	r27, Z+27	; 0x1b
    14a8:	f8 01       	movw	r30, r16
    14aa:	86 a7       	std	Z+46, r24	; 0x2e
    14ac:	97 a7       	std	Z+47, r25	; 0x2f
    14ae:	a0 ab       	std	Z+48, r26	; 0x30
    14b0:	b1 ab       	std	Z+49, r27	; 0x31
    14b2:	54 c0       	rjmp	.+168    	; 0x155c <gc_execute_line+0xa28>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
    14b4:	f5 e3       	ldi	r31, 0x35	; 53
    14b6:	bf 16       	cp	r11, r31
    14b8:	09 f4       	brne	.+2      	; 0x14bc <gc_execute_line+0x988>
    14ba:	50 c0       	rjmp	.+160    	; 0x155c <gc_execute_line+0xa28>
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    14bc:	a1 10       	cpse	r10, r1
    14be:	3b c0       	rjmp	.+118    	; 0x1536 <gc_execute_line+0xa02>
                  gc_block.values.xyz[idx] += block_coord_system[idx] + gc_state.coord_offset[idx];
    14c0:	d6 01       	movw	r26, r12
    14c2:	d0 96       	adiw	r26, 0x30	; 48
    14c4:	2d 91       	ld	r18, X+
    14c6:	3d 91       	ld	r19, X+
    14c8:	4d 91       	ld	r20, X+
    14ca:	5c 91       	ld	r21, X
    14cc:	d3 97       	sbiw	r26, 0x33	; 51
    14ce:	f3 01       	movw	r30, r6
    14d0:	60 81       	ld	r22, Z
    14d2:	71 81       	ldd	r23, Z+1	; 0x01
    14d4:	82 81       	ldd	r24, Z+2	; 0x02
    14d6:	93 81       	ldd	r25, Z+3	; 0x03
    14d8:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    14dc:	d8 01       	movw	r26, r16
    14de:	9e 96       	adiw	r26, 0x2e	; 46
    14e0:	2d 91       	ld	r18, X+
    14e2:	3d 91       	ld	r19, X+
    14e4:	4d 91       	ld	r20, X+
    14e6:	5c 91       	ld	r21, X
    14e8:	d1 97       	sbiw	r26, 0x31	; 49
    14ea:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    14ee:	9b 01       	movw	r18, r22
    14f0:	ac 01       	movw	r20, r24
    14f2:	f8 01       	movw	r30, r16
    14f4:	66 a7       	std	Z+46, r22	; 0x2e
    14f6:	77 a7       	std	Z+47, r23	; 0x2f
    14f8:	80 ab       	std	Z+48, r24	; 0x30
    14fa:	91 ab       	std	Z+49, r25	; 0x31
                  if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] += gc_state.tool_length_offset; }
    14fc:	f2 e0       	ldi	r31, 0x02	; 2
    14fe:	8f 12       	cpse	r8, r31
    1500:	2d c0       	rjmp	.+90     	; 0x155c <gc_execute_line+0xa28>
    1502:	0b 8d       	ldd	r16, Y+27	; 0x1b
    1504:	1c 8d       	ldd	r17, Y+28	; 0x1c
    1506:	00 0f       	add	r16, r16
    1508:	11 1f       	adc	r17, r17
    150a:	00 0f       	add	r16, r16
    150c:	11 1f       	adc	r17, r17
    150e:	06 51       	subi	r16, 0x16	; 22
    1510:	1a 4f       	sbci	r17, 0xFA	; 250
    1512:	60 91 e6 05 	lds	r22, 0x05E6	; 0x8005e6 <gc_state+0x3c>
    1516:	70 91 e7 05 	lds	r23, 0x05E7	; 0x8005e7 <gc_state+0x3d>
    151a:	80 91 e8 05 	lds	r24, 0x05E8	; 0x8005e8 <gc_state+0x3e>
    151e:	90 91 e9 05 	lds	r25, 0x05E9	; 0x8005e9 <gc_state+0x3f>
    1522:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    1526:	d8 01       	movw	r26, r16
    1528:	9e 96       	adiw	r26, 0x2e	; 46
    152a:	6d 93       	st	X+, r22
    152c:	7d 93       	st	X+, r23
    152e:	8d 93       	st	X+, r24
    1530:	9c 93       	st	X, r25
    1532:	d1 97       	sbiw	r26, 0x31	; 49
    1534:	23 c0       	rjmp	.+70     	; 0x157c <gc_execute_line+0xa48>
                } else {  // Incremental mode
                  gc_block.values.xyz[idx] += gc_state.position[idx];
    1536:	f6 01       	movw	r30, r12
    1538:	20 8d       	ldd	r18, Z+24	; 0x18
    153a:	31 8d       	ldd	r19, Z+25	; 0x19
    153c:	42 8d       	ldd	r20, Z+26	; 0x1a
    153e:	53 8d       	ldd	r21, Z+27	; 0x1b
    1540:	d8 01       	movw	r26, r16
    1542:	9e 96       	adiw	r26, 0x2e	; 46
    1544:	6d 91       	ld	r22, X+
    1546:	7d 91       	ld	r23, X+
    1548:	8d 91       	ld	r24, X+
    154a:	9c 91       	ld	r25, X
    154c:	d1 97       	sbiw	r26, 0x31	; 49
    154e:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    1552:	f8 01       	movw	r30, r16
    1554:	66 a7       	std	Z+46, r22	; 0x2e
    1556:	77 a7       	std	Z+47, r23	; 0x2f
    1558:	80 ab       	std	Z+48, r24	; 0x30
    155a:	91 ab       	std	Z+49, r25	; 0x31
    155c:	ff ef       	ldi	r31, 0xFF	; 255
    155e:	8f 1a       	sub	r8, r31
    1560:	9f 0a       	sbc	r9, r31
    1562:	24 e0       	ldi	r18, 0x04	; 4
    1564:	c2 0e       	add	r12, r18
    1566:	d1 1c       	adc	r13, r1
    1568:	0c 5f       	subi	r16, 0xFC	; 252
    156a:	1f 4f       	sbci	r17, 0xFF	; 255
    156c:	34 e0       	ldi	r19, 0x04	; 4
    156e:	63 0e       	add	r6, r19
    1570:	71 1c       	adc	r7, r1
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    1572:	43 e0       	ldi	r20, 0x03	; 3
    1574:	84 16       	cp	r8, r20
    1576:	91 04       	cpc	r9, r1
    1578:	09 f0       	breq	.+2      	; 0x157c <gc_execute_line+0xa48>
    157a:	86 cf       	rjmp	.-244    	; 0x1488 <gc_execute_line+0x954>
          }
        }
      }

      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {
    157c:	8e e1       	ldi	r24, 0x1E	; 30
    157e:	b8 16       	cp	r11, r24
    1580:	31 f0       	breq	.+12     	; 0x158e <gc_execute_line+0xa5a>
    1582:	95 e3       	ldi	r25, 0x35	; 53
    1584:	b9 16       	cp	r11, r25
    1586:	99 f1       	breq	.+102    	; 0x15ee <gc_execute_line+0xaba>
    1588:	ac e1       	ldi	r26, 0x1C	; 28
    158a:	ba 12       	cpse	r11, r26
    158c:	35 c0       	rjmp	.+106    	; 0x15f8 <gc_execute_line+0xac4>
        case NON_MODAL_GO_HOME_0: // G28
        case NON_MODAL_GO_HOME_1: // G30
          // [G28/30 Errors]: Cutter compensation is enabled.
          // Retreive G28/30 go-home position data (in machine coordinates) from EEPROM
          // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
          if (gc_block.non_modal_command == NON_MODAL_GO_HOME_0) {
    158e:	bc e1       	ldi	r27, 0x1C	; 28
    1590:	bb 12       	cpse	r11, r27
    1592:	09 c0       	rjmp	.+18     	; 0x15a6 <gc_execute_line+0xa72>
            if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    1594:	6a ef       	ldi	r22, 0xFA	; 250
    1596:	75 e0       	ldi	r23, 0x05	; 5
    1598:	86 e0       	ldi	r24, 0x06	; 6
    159a:	0e 94 3f 23 	call	0x467e	; 0x467e <settings_read_coord_data>
    159e:	88 23       	and	r24, r24
    15a0:	09 f4       	brne	.+2      	; 0x15a4 <gc_execute_line+0xa70>
    15a2:	38 c5       	rjmp	.+2672   	; 0x2014 <gc_execute_line+0x14e0>
    15a4:	7c c5       	rjmp	.+2808   	; 0x209e <gc_execute_line+0x156a>
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    15a6:	6a ef       	ldi	r22, 0xFA	; 250
    15a8:	75 e0       	ldi	r23, 0x05	; 5
    15aa:	87 e0       	ldi	r24, 0x07	; 7
    15ac:	0e 94 3f 23 	call	0x467e	; 0x467e <settings_read_coord_data>
    15b0:	88 23       	and	r24, r24
    15b2:	09 f4       	brne	.+2      	; 0x15b6 <gc_execute_line+0xa82>
    15b4:	31 c5       	rjmp	.+2658   	; 0x2018 <gc_execute_line+0x14e4>
    15b6:	73 c5       	rjmp	.+2790   	; 0x209e <gc_execute_line+0x156a>
          }
          if (axis_words) {
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
    15b8:	a9 01       	movw	r20, r18
    15ba:	08 2e       	mov	r0, r24
    15bc:	02 c0       	rjmp	.+4      	; 0x15c2 <gc_execute_line+0xa8e>
    15be:	55 95       	asr	r21
    15c0:	47 95       	ror	r20
    15c2:	0a 94       	dec	r0
    15c4:	e2 f7       	brpl	.-8      	; 0x15be <gc_execute_line+0xa8a>
    15c6:	40 fd       	sbrc	r20, 0
    15c8:	0a c0       	rjmp	.+20     	; 0x15de <gc_execute_line+0xaaa>
    15ca:	58 96       	adiw	r26, 0x18	; 24
    15cc:	4d 91       	ld	r20, X+
    15ce:	5d 91       	ld	r21, X+
    15d0:	6d 91       	ld	r22, X+
    15d2:	7c 91       	ld	r23, X
    15d4:	5b 97       	sbiw	r26, 0x1b	; 27
    15d6:	40 8b       	std	Z+16, r20	; 0x10
    15d8:	51 8b       	std	Z+17, r21	; 0x11
    15da:	62 8b       	std	Z+18, r22	; 0x12
    15dc:	73 8b       	std	Z+19, r23	; 0x13
    15de:	01 96       	adiw	r24, 0x01	; 1
    15e0:	14 96       	adiw	r26, 0x04	; 4
    15e2:	34 96       	adiw	r30, 0x04	; 4
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
          }
          if (axis_words) {
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
    15e4:	83 30       	cpi	r24, 0x03	; 3
    15e6:	91 05       	cpc	r25, r1
    15e8:	39 f7       	brne	.-50     	; 0x15b8 <gc_execute_line+0xa84>
  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes

  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    15ea:	1b 8e       	std	Y+27, r1	; 0x1b
    15ec:	64 c5       	rjmp	.+2760   	; 0x20b6 <gc_execute_line+0x1582>
          // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
    15ee:	80 91 eb 05 	lds	r24, 0x05EB	; 0x8005eb <gc_block+0x1>
    15f2:	82 30       	cpi	r24, 0x02	; 2
    15f4:	08 f0       	brcs	.+2      	; 0x15f8 <gc_execute_line+0xac4>
    15f6:	12 c5       	rjmp	.+2596   	; 0x201c <gc_execute_line+0x14e8>
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    15f8:	10 91 eb 05 	lds	r17, 0x05EB	; 0x8005eb <gc_block+0x1>
    15fc:	10 35       	cpi	r17, 0x50	; 80
    15fe:	29 f4       	brne	.+10     	; 0x160a <gc_execute_line+0xad6>
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    1600:	ed 8d       	ldd	r30, Y+29	; 0x1d
    1602:	e1 11       	cpse	r30, r1
    1604:	0d c5       	rjmp	.+2586   	; 0x2020 <gc_execute_line+0x14ec>
    1606:	1b 8e       	std	Y+27, r1	; 0x1b
    1608:	46 c2       	rjmp	.+1164   	; 0x1a96 <gc_execute_line+0xf62>
    160a:	1b 8e       	std	Y+27, r1	; 0x1b

  // Check remaining motion modes, if axis word are implicit (exist and not used by G10/28/30/92), or
  // was explicitly commanded in the g-code block.
  } else if ( axis_command == AXIS_COMMAND_MOTION_MODE ) {
    160c:	fe 8d       	ldd	r31, Y+30	; 0x1e
    160e:	f2 30       	cpi	r31, 0x02	; 2
    1610:	09 f0       	breq	.+2      	; 0x1614 <gc_execute_line+0xae0>
    1612:	41 c2       	rjmp	.+1154   	; 0x1a96 <gc_execute_line+0xf62>

    if (gc_block.modal.motion == MOTION_MODE_SEEK) {
    1614:	11 11       	cpse	r17, r1
    1616:	05 c0       	rjmp	.+10     	; 0x1622 <gc_execute_line+0xaee>
      // [G0 Errors]: Axis letter not configured or without real value (done.)
      // Axis words are optional. If missing, set axis command flag to ignore execution.
      if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    1618:	2d 8d       	ldd	r18, Y+29	; 0x1d
    161a:	21 11       	cpse	r18, r1
    161c:	3c c2       	rjmp	.+1144   	; 0x1a96 <gc_execute_line+0xf62>
    161e:	1e 8e       	std	Y+30, r1	; 0x1e
    1620:	3a c2       	rjmp	.+1140   	; 0x1a96 <gc_execute_line+0xf62>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    1622:	20 e0       	ldi	r18, 0x00	; 0
    1624:	30 e0       	ldi	r19, 0x00	; 0
    1626:	a9 01       	movw	r20, r18
    1628:	60 91 f6 05 	lds	r22, 0x05F6	; 0x8005f6 <gc_block+0xc>
    162c:	70 91 f7 05 	lds	r23, 0x05F7	; 0x8005f7 <gc_block+0xd>
    1630:	80 91 f8 05 	lds	r24, 0x05F8	; 0x8005f8 <gc_block+0xe>
    1634:	90 91 f9 05 	lds	r25, 0x05F9	; 0x8005f9 <gc_block+0xf>
    1638:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    163c:	88 23       	and	r24, r24
    163e:	09 f4       	brne	.+2      	; 0x1642 <gc_execute_line+0xb0e>
    1640:	f1 c4       	rjmp	.+2530   	; 0x2024 <gc_execute_line+0x14f0>

      switch (gc_block.modal.motion) {
    1642:	1c 38       	cpi	r17, 0x8C	; 140
    1644:	09 f4       	brne	.+2      	; 0x1648 <gc_execute_line+0xb14>
    1646:	0f c2       	rjmp	.+1054   	; 0x1a66 <gc_execute_line+0xf32>
    1648:	40 f4       	brcc	.+16     	; 0x165a <gc_execute_line+0xb26>
    164a:	12 30       	cpi	r17, 0x02	; 2
    164c:	a1 f0       	breq	.+40     	; 0x1676 <gc_execute_line+0xb42>
    164e:	13 30       	cpi	r17, 0x03	; 3
    1650:	a9 f0       	breq	.+42     	; 0x167c <gc_execute_line+0xb48>
    1652:	11 30       	cpi	r17, 0x01	; 1
    1654:	09 f0       	breq	.+2      	; 0x1658 <gc_execute_line+0xb24>
    1656:	1f c2       	rjmp	.+1086   	; 0x1a96 <gc_execute_line+0xf62>
    1658:	09 c0       	rjmp	.+18     	; 0x166c <gc_execute_line+0xb38>
    165a:	1e 38       	cpi	r17, 0x8E	; 142
    165c:	09 f4       	brne	.+2      	; 0x1660 <gc_execute_line+0xb2c>
    165e:	03 c2       	rjmp	.+1030   	; 0x1a66 <gc_execute_line+0xf32>
    1660:	08 f4       	brcc	.+2      	; 0x1664 <gc_execute_line+0xb30>
    1662:	fe c1       	rjmp	.+1020   	; 0x1a60 <gc_execute_line+0xf2c>
    1664:	1f 38       	cpi	r17, 0x8F	; 143
    1666:	09 f4       	brne	.+2      	; 0x166a <gc_execute_line+0xb36>
    1668:	fb c1       	rjmp	.+1014   	; 0x1a60 <gc_execute_line+0xf2c>
    166a:	15 c2       	rjmp	.+1066   	; 0x1a96 <gc_execute_line+0xf62>
        case MOTION_MODE_LINEAR:
          // [G1 Errors]: Feed rate undefined. Axis letter not configured or without real value.
          // Axis words are optional. If missing, set axis command flag to ignore execution.
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    166c:	3d 8d       	ldd	r19, Y+29	; 0x1d
    166e:	31 11       	cpse	r19, r1
    1670:	12 c2       	rjmp	.+1060   	; 0x1a96 <gc_execute_line+0xf62>
    1672:	1e 8e       	std	Y+30, r1	; 0x1e
    1674:	10 c2       	rjmp	.+1056   	; 0x1a96 <gc_execute_line+0xf62>
          break;
        case MOTION_MODE_CW_ARC: 
          gc_parser_flags |= GC_PARSER_ARC_IS_CLOCKWISE; // No break intentional.
    1676:	48 a1       	ldd	r20, Y+32	; 0x20
    1678:	44 60       	ori	r20, 0x04	; 4
    167a:	48 a3       	std	Y+32, r20	; 0x20
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.

          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    167c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    167e:	88 23       	and	r24, r24
    1680:	09 f4       	brne	.+2      	; 0x1684 <gc_execute_line+0xb50>
    1682:	d2 c4       	rjmp	.+2468   	; 0x2028 <gc_execute_line+0x14f4>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    1684:	b9 a1       	ldd	r27, Y+33	; 0x21
    1686:	ab 2f       	mov	r26, r27
    1688:	b0 e0       	ldi	r27, 0x00	; 0
    168a:	bd a7       	std	Y+45, r27	; 0x2d
    168c:	ac a7       	std	Y+44, r26	; 0x2c
    168e:	ea a1       	ldd	r30, Y+34	; 0x22
    1690:	ce 2e       	mov	r12, r30
    1692:	d1 2c       	mov	r13, r1
    1694:	81 e0       	ldi	r24, 0x01	; 1
    1696:	90 e0       	ldi	r25, 0x00	; 0
    1698:	8c 01       	movw	r16, r24
    169a:	09 a0       	ldd	r0, Y+33	; 0x21
    169c:	02 c0       	rjmp	.+4      	; 0x16a2 <gc_execute_line+0xb6e>
    169e:	00 0f       	add	r16, r16
    16a0:	11 1f       	adc	r17, r17
    16a2:	0a 94       	dec	r0
    16a4:	e2 f7       	brpl	.-8      	; 0x169e <gc_execute_line+0xb6a>
    16a6:	02 c0       	rjmp	.+4      	; 0x16ac <gc_execute_line+0xb78>
    16a8:	88 0f       	add	r24, r24
    16aa:	99 1f       	adc	r25, r25
    16ac:	ea 95       	dec	r30
    16ae:	e2 f7       	brpl	.-8      	; 0x16a8 <gc_execute_line+0xb74>
    16b0:	08 2b       	or	r16, r24
    16b2:	19 2b       	or	r17, r25
    16b4:	fd 8d       	ldd	r31, Y+29	; 0x1d
    16b6:	8f 2f       	mov	r24, r31
    16b8:	90 e0       	ldi	r25, 0x00	; 0
    16ba:	80 23       	and	r24, r16
    16bc:	91 23       	and	r25, r17
    16be:	89 2b       	or	r24, r25
    16c0:	09 f4       	brne	.+2      	; 0x16c4 <gc_execute_line+0xb90>
    16c2:	b4 c4       	rjmp	.+2408   	; 0x202c <gc_execute_line+0x14f8>

          // Calculate the change in position along each selected axis
          float x,y;
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
    16c4:	fd 01       	movw	r30, r26
    16c6:	ee 0f       	add	r30, r30
    16c8:	ff 1f       	adc	r31, r31
    16ca:	ee 0f       	add	r30, r30
    16cc:	ff 1f       	adc	r31, r31
    16ce:	e6 51       	subi	r30, 0x16	; 22
    16d0:	fa 4f       	sbci	r31, 0xFA	; 250
    16d2:	aa 0f       	add	r26, r26
    16d4:	bb 1f       	adc	r27, r27
    16d6:	aa 0f       	add	r26, r26
    16d8:	bb 1f       	adc	r27, r27
    16da:	ae 53       	subi	r26, 0x3E	; 62
    16dc:	ba 4f       	sbci	r27, 0xFA	; 250
    16de:	2d 91       	ld	r18, X+
    16e0:	3d 91       	ld	r19, X+
    16e2:	4d 91       	ld	r20, X+
    16e4:	5c 91       	ld	r21, X
    16e6:	66 a5       	ldd	r22, Z+46	; 0x2e
    16e8:	77 a5       	ldd	r23, Z+47	; 0x2f
    16ea:	80 a9       	ldd	r24, Z+48	; 0x30
    16ec:	91 a9       	ldd	r25, Z+49	; 0x31
    16ee:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    16f2:	6b a3       	std	Y+35, r22	; 0x23
    16f4:	7c a3       	std	Y+36, r23	; 0x24
    16f6:	8d a3       	std	Y+37, r24	; 0x25
    16f8:	9e a3       	std	Y+38, r25	; 0x26
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target
    16fa:	f6 01       	movw	r30, r12
    16fc:	ee 0f       	add	r30, r30
    16fe:	ff 1f       	adc	r31, r31
    1700:	ee 0f       	add	r30, r30
    1702:	ff 1f       	adc	r31, r31
    1704:	e6 51       	subi	r30, 0x16	; 22
    1706:	fa 4f       	sbci	r31, 0xFA	; 250
    1708:	d6 01       	movw	r26, r12
    170a:	aa 0f       	add	r26, r26
    170c:	bb 1f       	adc	r27, r27
    170e:	aa 0f       	add	r26, r26
    1710:	bb 1f       	adc	r27, r27
    1712:	ae 53       	subi	r26, 0x3E	; 62
    1714:	ba 4f       	sbci	r27, 0xFA	; 250
    1716:	2d 91       	ld	r18, X+
    1718:	3d 91       	ld	r19, X+
    171a:	4d 91       	ld	r20, X+
    171c:	5c 91       	ld	r21, X
    171e:	66 a5       	ldd	r22, Z+46	; 0x2e
    1720:	77 a5       	ldd	r23, Z+47	; 0x2f
    1722:	80 a9       	ldd	r24, Z+48	; 0x30
    1724:	91 a9       	ldd	r25, Z+49	; 0x31
    1726:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    172a:	6f a3       	std	Y+39, r22	; 0x27
    172c:	78 a7       	std	Y+40, r23	; 0x28
    172e:	89 a7       	std	Y+41, r24	; 0x29
    1730:	9a a7       	std	Y+42, r25	; 0x2a

          if (value_words & bit(WORD_R)) { // Arc Radius Mode
    1732:	27 fe       	sbrs	r2, 7
    1734:	ea c0       	rjmp	.+468    	; 0x190a <gc_execute_line+0xdd6>
            bit_false(value_words,bit(WORD_R));
    1736:	e8 94       	clt
    1738:	27 f8       	bld	r2, 7
            if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    173a:	4c e0       	ldi	r20, 0x0C	; 12
    173c:	50 e0       	ldi	r21, 0x00	; 0
    173e:	68 e1       	ldi	r22, 0x18	; 24
    1740:	76 e0       	ldi	r23, 0x06	; 6
    1742:	82 ec       	ldi	r24, 0xC2	; 194
    1744:	95 e0       	ldi	r25, 0x05	; 5
    1746:	0e 94 d4 32 	call	0x65a8	; 0x65a8 <memcmp>
    174a:	89 2b       	or	r24, r25
    174c:	09 f4       	brne	.+2      	; 0x1750 <gc_execute_line+0xc1c>
    174e:	70 c4       	rjmp	.+2272   	; 0x2030 <gc_execute_line+0x14fc>

            // Convert radius value to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.r *= MM_PER_INCH; }
    1750:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <gc_block+0x3>
    1754:	81 30       	cpi	r24, 0x01	; 1
    1756:	a1 f4       	brne	.+40     	; 0x1780 <gc_execute_line+0xc4c>
    1758:	0a ee       	ldi	r16, 0xEA	; 234
    175a:	15 e0       	ldi	r17, 0x05	; 5
    175c:	23 e3       	ldi	r18, 0x33	; 51
    175e:	33 e3       	ldi	r19, 0x33	; 51
    1760:	4b ec       	ldi	r20, 0xCB	; 203
    1762:	51 e4       	ldi	r21, 0x41	; 65
    1764:	d8 01       	movw	r26, r16
    1766:	95 96       	adiw	r26, 0x25	; 37
    1768:	6d 91       	ld	r22, X+
    176a:	7d 91       	ld	r23, X+
    176c:	8d 91       	ld	r24, X+
    176e:	9c 91       	ld	r25, X
    1770:	98 97       	sbiw	r26, 0x28	; 40
    1772:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    1776:	f8 01       	movw	r30, r16
    1778:	65 a3       	std	Z+37, r22	; 0x25
    177a:	76 a3       	std	Z+38, r23	; 0x26
    177c:	87 a3       	std	Z+39, r24	; 0x27
    177e:	90 a7       	std	Z+40, r25	; 0x28
                j = (y + (x * h_x2_div_d))/2
            */

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;
    1780:	80 90 0f 06 	lds	r8, 0x060F	; 0x80060f <gc_block+0x25>
    1784:	90 90 10 06 	lds	r9, 0x0610	; 0x800610 <gc_block+0x26>
    1788:	a0 90 11 06 	lds	r10, 0x0611	; 0x800611 <gc_block+0x27>
    178c:	b0 90 12 06 	lds	r11, 0x0612	; 0x800612 <gc_block+0x28>
    1790:	20 e0       	ldi	r18, 0x00	; 0
    1792:	30 e0       	ldi	r19, 0x00	; 0
    1794:	40 e8       	ldi	r20, 0x80	; 128
    1796:	50 e4       	ldi	r21, 0x40	; 64
    1798:	c5 01       	movw	r24, r10
    179a:	b4 01       	movw	r22, r8
    179c:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    17a0:	a5 01       	movw	r20, r10
    17a2:	94 01       	movw	r18, r8
    17a4:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    17a8:	4b 01       	movw	r8, r22
    17aa:	5c 01       	movw	r10, r24
    17ac:	2b a1       	ldd	r18, Y+35	; 0x23
    17ae:	3c a1       	ldd	r19, Y+36	; 0x24
    17b0:	4d a1       	ldd	r20, Y+37	; 0x25
    17b2:	5e a1       	ldd	r21, Y+38	; 0x26
    17b4:	ca 01       	movw	r24, r20
    17b6:	b9 01       	movw	r22, r18
    17b8:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    17bc:	9b 01       	movw	r18, r22
    17be:	ac 01       	movw	r20, r24
    17c0:	c5 01       	movw	r24, r10
    17c2:	b4 01       	movw	r22, r8
    17c4:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    17c8:	4b 01       	movw	r8, r22
    17ca:	5c 01       	movw	r10, r24
    17cc:	2f a1       	ldd	r18, Y+39	; 0x27
    17ce:	38 a5       	ldd	r19, Y+40	; 0x28
    17d0:	49 a5       	ldd	r20, Y+41	; 0x29
    17d2:	5a a5       	ldd	r21, Y+42	; 0x2a
    17d4:	ca 01       	movw	r24, r20
    17d6:	b9 01       	movw	r22, r18
    17d8:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    17dc:	9b 01       	movw	r18, r22
    17de:	ac 01       	movw	r20, r24
    17e0:	c5 01       	movw	r24, r10
    17e2:	b4 01       	movw	r22, r8
    17e4:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    17e8:	4b 01       	movw	r8, r22
    17ea:	5c 01       	movw	r10, r24

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    17ec:	20 e0       	ldi	r18, 0x00	; 0
    17ee:	30 e0       	ldi	r19, 0x00	; 0
    17f0:	a9 01       	movw	r20, r18
    17f2:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    17f6:	88 23       	and	r24, r24
    17f8:	0c f4       	brge	.+2      	; 0x17fc <gc_execute_line+0xcc8>
    17fa:	1c c4       	rjmp	.+2104   	; 0x2034 <gc_execute_line+0x1500>

            // Finish computing h_x2_div_d.
            h_x2_div_d = -sqrt(h_x2_div_d)/hypot_f(x,y); // == -(h * 2 / d)
    17fc:	c5 01       	movw	r24, r10
    17fe:	b4 01       	movw	r22, r8
    1800:	0e 94 55 32 	call	0x64aa	; 0x64aa <sqrt>
    1804:	4b 01       	movw	r8, r22
    1806:	5c 01       	movw	r10, r24
    1808:	2f a1       	ldd	r18, Y+39	; 0x27
    180a:	38 a5       	ldd	r19, Y+40	; 0x28
    180c:	49 a5       	ldd	r20, Y+41	; 0x29
    180e:	5a a5       	ldd	r21, Y+42	; 0x2a
    1810:	6b a1       	ldd	r22, Y+35	; 0x23
    1812:	7c a1       	ldd	r23, Y+36	; 0x24
    1814:	8d a1       	ldd	r24, Y+37	; 0x25
    1816:	9e a1       	ldd	r25, Y+38	; 0x26
    1818:	0e 94 dc 2a 	call	0x55b8	; 0x55b8 <hypot_f>
    181c:	9b 01       	movw	r18, r22
    181e:	ac 01       	movw	r20, r24
    1820:	c5 01       	movw	r24, r10
    1822:	b4 01       	movw	r22, r8
    1824:	90 58       	subi	r25, 0x80	; 128
    1826:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <__divsf3>
    182a:	4b 01       	movw	r8, r22
    182c:	5c 01       	movw	r10, r24
            // Invert the sign of h_x2_div_d if the circle is counter clockwise (see sketch below)
            if (gc_block.modal.motion == MOTION_MODE_CCW_ARC) { h_x2_div_d = -h_x2_div_d; }
    182e:	80 91 eb 05 	lds	r24, 0x05EB	; 0x8005eb <gc_block+0x1>
    1832:	83 30       	cpi	r24, 0x03	; 3
    1834:	21 f4       	brne	.+8      	; 0x183e <gc_execute_line+0xd0a>
    1836:	b7 fa       	bst	r11, 7
    1838:	b0 94       	com	r11
    183a:	b7 f8       	bld	r11, 7
    183c:	b0 94       	com	r11
            */
            // Negative R is g-code-alese for "I want a circle with more than 180 degrees of travel" (go figure!),
            // even though it is advised against ever generating such circles in a single line of g-code. By
            // inverting the sign of h_x2_div_d the center of the circles is placed on the opposite side of the line of
            // travel and thus we get the unadvisably long arcs as prescribed.
            if (gc_block.values.r < 0) {
    183e:	40 90 0f 06 	lds	r4, 0x060F	; 0x80060f <gc_block+0x25>
    1842:	50 90 10 06 	lds	r5, 0x0610	; 0x800610 <gc_block+0x26>
    1846:	60 90 11 06 	lds	r6, 0x0611	; 0x800611 <gc_block+0x27>
    184a:	70 90 12 06 	lds	r7, 0x0612	; 0x800612 <gc_block+0x28>
    184e:	20 e0       	ldi	r18, 0x00	; 0
    1850:	30 e0       	ldi	r19, 0x00	; 0
    1852:	a9 01       	movw	r20, r18
    1854:	c3 01       	movw	r24, r6
    1856:	b2 01       	movw	r22, r4
    1858:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    185c:	88 23       	and	r24, r24
    185e:	84 f4       	brge	.+32     	; 0x1880 <gc_execute_line+0xd4c>
                h_x2_div_d = -h_x2_div_d;
    1860:	b7 fa       	bst	r11, 7
    1862:	b0 94       	com	r11
    1864:	b7 f8       	bld	r11, 7
    1866:	b0 94       	com	r11
                gc_block.values.r = -gc_block.values.r; // Finished with r. Set to positive for mc_arc
    1868:	77 fa       	bst	r7, 7
    186a:	70 94       	com	r7
    186c:	77 f8       	bld	r7, 7
    186e:	70 94       	com	r7
    1870:	40 92 0f 06 	sts	0x060F, r4	; 0x80060f <gc_block+0x25>
    1874:	50 92 10 06 	sts	0x0610, r5	; 0x800610 <gc_block+0x26>
    1878:	60 92 11 06 	sts	0x0611, r6	; 0x800611 <gc_block+0x27>
    187c:	70 92 12 06 	sts	0x0612, r7	; 0x800612 <gc_block+0x28>
            }
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
    1880:	0c a5       	ldd	r16, Y+44	; 0x2c
    1882:	1d a5       	ldd	r17, Y+45	; 0x2d
    1884:	00 0f       	add	r16, r16
    1886:	11 1f       	adc	r17, r17
    1888:	00 0f       	add	r16, r16
    188a:	11 1f       	adc	r17, r17
    188c:	06 50       	subi	r16, 0x06	; 6
    188e:	1a 4f       	sbci	r17, 0xFA	; 250
    1890:	2f a1       	ldd	r18, Y+39	; 0x27
    1892:	38 a5       	ldd	r19, Y+40	; 0x28
    1894:	49 a5       	ldd	r20, Y+41	; 0x29
    1896:	5a a5       	ldd	r21, Y+42	; 0x2a
    1898:	c5 01       	movw	r24, r10
    189a:	b4 01       	movw	r22, r8
    189c:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    18a0:	9b 01       	movw	r18, r22
    18a2:	ac 01       	movw	r20, r24
    18a4:	6b a1       	ldd	r22, Y+35	; 0x23
    18a6:	7c a1       	ldd	r23, Y+36	; 0x24
    18a8:	8d a1       	ldd	r24, Y+37	; 0x25
    18aa:	9e a1       	ldd	r25, Y+38	; 0x26
    18ac:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    18b0:	20 e0       	ldi	r18, 0x00	; 0
    18b2:	30 e0       	ldi	r19, 0x00	; 0
    18b4:	40 e0       	ldi	r20, 0x00	; 0
    18b6:	5f e3       	ldi	r21, 0x3F	; 63
    18b8:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    18bc:	d8 01       	movw	r26, r16
    18be:	6d 93       	st	X+, r22
    18c0:	7d 93       	st	X+, r23
    18c2:	8d 93       	st	X+, r24
    18c4:	9c 93       	st	X, r25
    18c6:	13 97       	sbiw	r26, 0x03	; 3
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));
    18c8:	86 01       	movw	r16, r12
    18ca:	00 0f       	add	r16, r16
    18cc:	11 1f       	adc	r17, r17
    18ce:	00 0f       	add	r16, r16
    18d0:	11 1f       	adc	r17, r17
    18d2:	06 50       	subi	r16, 0x06	; 6
    18d4:	1a 4f       	sbci	r17, 0xFA	; 250
    18d6:	2b a1       	ldd	r18, Y+35	; 0x23
    18d8:	3c a1       	ldd	r19, Y+36	; 0x24
    18da:	4d a1       	ldd	r20, Y+37	; 0x25
    18dc:	5e a1       	ldd	r21, Y+38	; 0x26
    18de:	c5 01       	movw	r24, r10
    18e0:	b4 01       	movw	r22, r8
    18e2:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    18e6:	2f a1       	ldd	r18, Y+39	; 0x27
    18e8:	38 a5       	ldd	r19, Y+40	; 0x28
    18ea:	49 a5       	ldd	r20, Y+41	; 0x29
    18ec:	5a a5       	ldd	r21, Y+42	; 0x2a
    18ee:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    18f2:	20 e0       	ldi	r18, 0x00	; 0
    18f4:	30 e0       	ldi	r19, 0x00	; 0
    18f6:	40 e0       	ldi	r20, 0x00	; 0
    18f8:	5f e3       	ldi	r21, 0x3F	; 63
    18fa:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    18fe:	f8 01       	movw	r30, r16
    1900:	60 83       	st	Z, r22
    1902:	71 83       	std	Z+1, r23	; 0x01
    1904:	82 83       	std	Z+2, r24	; 0x02
    1906:	93 83       	std	Z+3, r25	; 0x03
    1908:	c6 c0       	rjmp	.+396    	; 0x1a96 <gc_execute_line+0xf62>

          } else { // Arc Center Format Offset Mode
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    190a:	ff 8d       	ldd	r31, Y+31	; 0x1f
    190c:	8f 2e       	mov	r8, r31
    190e:	91 2c       	mov	r9, r1
    1910:	08 21       	and	r16, r8
    1912:	19 21       	and	r17, r9
    1914:	01 2b       	or	r16, r17
    1916:	09 f4       	brne	.+2      	; 0x191a <gc_execute_line+0xde6>
    1918:	8f c3       	rjmp	.+1822   	; 0x2038 <gc_execute_line+0x1504>
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));
    191a:	21 ef       	ldi	r18, 0xF1	; 241
    191c:	22 22       	and	r2, r18

            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
    191e:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <gc_block+0x3>
    1922:	81 30       	cpi	r24, 0x01	; 1
    1924:	41 f5       	brne	.+80     	; 0x1976 <gc_execute_line+0xe42>
    1926:	0a ee       	ldi	r16, 0xEA	; 234
    1928:	15 e0       	ldi	r17, 0x05	; 5
    192a:	a1 2c       	mov	r10, r1
    192c:	b1 2c       	mov	r11, r1
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
    192e:	c4 01       	movw	r24, r8
    1930:	0a 2c       	mov	r0, r10
    1932:	02 c0       	rjmp	.+4      	; 0x1938 <gc_execute_line+0xe04>
    1934:	95 95       	asr	r25
    1936:	87 95       	ror	r24
    1938:	0a 94       	dec	r0
    193a:	e2 f7       	brpl	.-8      	; 0x1934 <gc_execute_line+0xe00>
    193c:	80 ff       	sbrs	r24, 0
    193e:	12 c0       	rjmp	.+36     	; 0x1964 <gc_execute_line+0xe30>
    1940:	23 e3       	ldi	r18, 0x33	; 51
    1942:	33 e3       	ldi	r19, 0x33	; 51
    1944:	4b ec       	ldi	r20, 0xCB	; 203
    1946:	51 e4       	ldi	r21, 0x41	; 65
    1948:	d8 01       	movw	r26, r16
    194a:	50 96       	adiw	r26, 0x10	; 16
    194c:	6d 91       	ld	r22, X+
    194e:	7d 91       	ld	r23, X+
    1950:	8d 91       	ld	r24, X+
    1952:	9c 91       	ld	r25, X
    1954:	53 97       	sbiw	r26, 0x13	; 19
    1956:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    195a:	f8 01       	movw	r30, r16
    195c:	60 8b       	std	Z+16, r22	; 0x10
    195e:	71 8b       	std	Z+17, r23	; 0x11
    1960:	82 8b       	std	Z+18, r24	; 0x12
    1962:	93 8b       	std	Z+19, r25	; 0x13
    1964:	ff ef       	ldi	r31, 0xFF	; 255
    1966:	af 1a       	sub	r10, r31
    1968:	bf 0a       	sbc	r11, r31
    196a:	0c 5f       	subi	r16, 0xFC	; 252
    196c:	1f 4f       	sbci	r17, 0xFF	; 255
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));

            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    196e:	23 e0       	ldi	r18, 0x03	; 3
    1970:	a2 16       	cp	r10, r18
    1972:	b1 04       	cpc	r11, r1
    1974:	e1 f6       	brne	.-72     	; 0x192e <gc_execute_line+0xdfa>
              }
            }

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
    1976:	c6 01       	movw	r24, r12
    1978:	88 0f       	add	r24, r24
    197a:	99 1f       	adc	r25, r25
    197c:	88 0f       	add	r24, r24
    197e:	99 1f       	adc	r25, r25
    1980:	dc 01       	movw	r26, r24
    1982:	a6 50       	subi	r26, 0x06	; 6
    1984:	ba 4f       	sbci	r27, 0xFA	; 250
    1986:	6d 01       	movw	r12, r26
            float target_r = hypot_f(x,y);
    1988:	2d 91       	ld	r18, X+
    198a:	3d 91       	ld	r19, X+
    198c:	4d 91       	ld	r20, X+
    198e:	5c 91       	ld	r21, X
    1990:	6f a1       	ldd	r22, Y+39	; 0x27
    1992:	78 a5       	ldd	r23, Y+40	; 0x28
    1994:	89 a5       	ldd	r24, Y+41	; 0x29
    1996:	9a a5       	ldd	r25, Y+42	; 0x2a
    1998:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    199c:	4b 01       	movw	r8, r22
    199e:	5c 01       	movw	r10, r24
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
              }
            }

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
    19a0:	0c a5       	ldd	r16, Y+44	; 0x2c
    19a2:	1d a5       	ldd	r17, Y+45	; 0x2d
    19a4:	00 0f       	add	r16, r16
    19a6:	11 1f       	adc	r17, r17
    19a8:	00 0f       	add	r16, r16
    19aa:	11 1f       	adc	r17, r17
    19ac:	06 50       	subi	r16, 0x06	; 6
    19ae:	1a 4f       	sbci	r17, 0xFA	; 250
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
            float target_r = hypot_f(x,y);
    19b0:	f8 01       	movw	r30, r16
    19b2:	20 81       	ld	r18, Z
    19b4:	31 81       	ldd	r19, Z+1	; 0x01
    19b6:	42 81       	ldd	r20, Z+2	; 0x02
    19b8:	53 81       	ldd	r21, Z+3	; 0x03
    19ba:	6b a1       	ldd	r22, Y+35	; 0x23
    19bc:	7c a1       	ldd	r23, Y+36	; 0x24
    19be:	8d a1       	ldd	r24, Y+37	; 0x25
    19c0:	9e a1       	ldd	r25, Y+38	; 0x26
    19c2:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    19c6:	a5 01       	movw	r20, r10
    19c8:	94 01       	movw	r18, r8
    19ca:	0e 94 dc 2a 	call	0x55b8	; 0x55b8 <hypot_f>
    19ce:	4b 01       	movw	r8, r22
    19d0:	5c 01       	movw	r10, r24

            // Compute arc radius for mc_arc. Defined from current location to center.
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]);
    19d2:	d6 01       	movw	r26, r12
    19d4:	2d 91       	ld	r18, X+
    19d6:	3d 91       	ld	r19, X+
    19d8:	4d 91       	ld	r20, X+
    19da:	5c 91       	ld	r21, X
    19dc:	f8 01       	movw	r30, r16
    19de:	60 81       	ld	r22, Z
    19e0:	71 81       	ldd	r23, Z+1	; 0x01
    19e2:	82 81       	ldd	r24, Z+2	; 0x02
    19e4:	93 81       	ldd	r25, Z+3	; 0x03
    19e6:	0e 94 dc 2a 	call	0x55b8	; 0x55b8 <hypot_f>
    19ea:	2b 01       	movw	r4, r22
    19ec:	3c 01       	movw	r6, r24
    19ee:	60 93 0f 06 	sts	0x060F, r22	; 0x80060f <gc_block+0x25>
    19f2:	70 93 10 06 	sts	0x0610, r23	; 0x800610 <gc_block+0x26>
    19f6:	80 93 11 06 	sts	0x0611, r24	; 0x800611 <gc_block+0x27>
    19fa:	90 93 12 06 	sts	0x0612, r25	; 0x800612 <gc_block+0x28>

            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
    19fe:	9b 01       	movw	r18, r22
    1a00:	ac 01       	movw	r20, r24
    1a02:	c5 01       	movw	r24, r10
    1a04:	b4 01       	movw	r22, r8
    1a06:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    1a0a:	4b 01       	movw	r8, r22
    1a0c:	5c 01       	movw	r10, r24
    1a0e:	e8 94       	clt
    1a10:	b7 f8       	bld	r11, 7
            if (delta_r > 0.005) {
    1a12:	2a e0       	ldi	r18, 0x0A	; 10
    1a14:	37 ed       	ldi	r19, 0xD7	; 215
    1a16:	43 ea       	ldi	r20, 0xA3	; 163
    1a18:	5b e3       	ldi	r21, 0x3B	; 59
    1a1a:	c5 01       	movw	r24, r10
    1a1c:	b4 01       	movw	r22, r8
    1a1e:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    1a22:	18 16       	cp	r1, r24
    1a24:	c4 f5       	brge	.+112    	; 0x1a96 <gc_execute_line+0xf62>
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    1a26:	20 e0       	ldi	r18, 0x00	; 0
    1a28:	30 e0       	ldi	r19, 0x00	; 0
    1a2a:	40 e0       	ldi	r20, 0x00	; 0
    1a2c:	5f e3       	ldi	r21, 0x3F	; 63
    1a2e:	c5 01       	movw	r24, r10
    1a30:	b4 01       	movw	r22, r8
    1a32:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    1a36:	18 16       	cp	r1, r24
    1a38:	0c f4       	brge	.+2      	; 0x1a3c <gc_execute_line+0xf08>
    1a3a:	00 c3       	rjmp	.+1536   	; 0x203c <gc_execute_line+0x1508>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    1a3c:	2f e6       	ldi	r18, 0x6F	; 111
    1a3e:	32 e1       	ldi	r19, 0x12	; 18
    1a40:	43 e8       	ldi	r20, 0x83	; 131
    1a42:	5a e3       	ldi	r21, 0x3A	; 58
    1a44:	c3 01       	movw	r24, r6
    1a46:	b2 01       	movw	r22, r4
    1a48:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    1a4c:	9b 01       	movw	r18, r22
    1a4e:	ac 01       	movw	r20, r24
    1a50:	c5 01       	movw	r24, r10
    1a52:	b4 01       	movw	r22, r8
    1a54:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    1a58:	18 16       	cp	r1, r24
    1a5a:	0c f4       	brge	.+2      	; 0x1a5e <gc_execute_line+0xf2a>
    1a5c:	f1 c2       	rjmp	.+1506   	; 0x2040 <gc_execute_line+0x150c>
    1a5e:	1b c0       	rjmp	.+54     	; 0x1a96 <gc_execute_line+0xf62>
            }
          }
          break;
        case MOTION_MODE_PROBE_TOWARD_NO_ERROR: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          gc_parser_flags |= GC_PARSER_PROBE_IS_NO_ERROR; // No break intentional.
    1a60:	f8 a1       	ldd	r31, Y+32	; 0x20
    1a62:	f0 61       	ori	r31, 0x10	; 16
    1a64:	f8 a3       	std	Y+32, r31	; 0x20
        case MOTION_MODE_PROBE_TOWARD: case MOTION_MODE_PROBE_AWAY:
          if ((gc_block.modal.motion == MOTION_MODE_PROBE_AWAY) || 
    1a66:	1e 58       	subi	r17, 0x8E	; 142
    1a68:	12 30       	cpi	r17, 0x02	; 2
    1a6a:	18 f4       	brcc	.+6      	; 0x1a72 <gc_execute_line+0xf3e>
              (gc_block.modal.motion == MOTION_MODE_PROBE_AWAY_NO_ERROR)) { gc_parser_flags |= GC_PARSER_PROBE_IS_AWAY; }
    1a6c:	28 a1       	ldd	r18, Y+32	; 0x20
    1a6e:	28 60       	ori	r18, 0x08	; 8
    1a70:	28 a3       	std	Y+32, r18	; 0x20
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    1a72:	3d 8d       	ldd	r19, Y+29	; 0x1d
    1a74:	33 23       	and	r19, r19
    1a76:	09 f4       	brne	.+2      	; 0x1a7a <gc_execute_line+0xf46>
    1a78:	e5 c2       	rjmp	.+1482   	; 0x2044 <gc_execute_line+0x1510>
          if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    1a7a:	4c e0       	ldi	r20, 0x0C	; 12
    1a7c:	50 e0       	ldi	r21, 0x00	; 0
    1a7e:	68 e1       	ldi	r22, 0x18	; 24
    1a80:	76 e0       	ldi	r23, 0x06	; 6
    1a82:	82 ec       	ldi	r24, 0xC2	; 194
    1a84:	95 e0       	ldi	r25, 0x05	; 5
    1a86:	0e 94 d4 32 	call	0x65a8	; 0x65a8 <memcmp>
    1a8a:	89 2b       	or	r24, r25
    1a8c:	09 f4       	brne	.+2      	; 0x1a90 <gc_execute_line+0xf5c>
    1a8e:	dc c2       	rjmp	.+1464   	; 0x2048 <gc_execute_line+0x1514>
    1a90:	02 c0       	rjmp	.+4      	; 0x1a96 <gc_execute_line+0xf62>
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    1a92:	1b 8e       	std	Y+27, r1	; 0x1b
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
            }
          } else {
            axis_command = AXIS_COMMAND_NONE; // Set to none if no intermediate motion.
    1a94:	1e 8e       	std	Y+30, r1	; 0x1e

  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    1a96:	48 a1       	ldd	r20, Y+32	; 0x20
    1a98:	41 70       	andi	r20, 0x01	; 1
    1a9a:	d4 2e       	mov	r13, r20
    1a9c:	88 a1       	ldd	r24, Y+32	; 0x20
    1a9e:	80 ff       	sbrs	r24, 0
    1aa0:	03 c0       	rjmp	.+6      	; 0x1aa8 <gc_execute_line+0xf74>
    // Jogging only uses the F feed rate and XYZ value words. N is valid, but S and T are invalid.
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)));
    1aa2:	c1 01       	movw	r24, r2
    1aa4:	8e 7d       	andi	r24, 0xDE	; 222
    1aa6:	03 c0       	rjmp	.+6      	; 0x1aae <gc_execute_line+0xf7a>
  } else {
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words.
    1aa8:	c1 01       	movw	r24, r2
    1aaa:	8e 7d       	andi	r24, 0xDE	; 222
    1aac:	9c 7f       	andi	r25, 0xFC	; 252
  }
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words.
    1aae:	ae 8d       	ldd	r26, Y+30	; 0x1e
    1ab0:	a1 11       	cpse	r26, r1
    1ab2:	93 7e       	andi	r25, 0xE3	; 227
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    1ab4:	89 2b       	or	r24, r25
    1ab6:	09 f0       	breq	.+2      	; 0x1aba <gc_execute_line+0xf86>
    1ab8:	c9 c2       	rjmp	.+1426   	; 0x204c <gc_execute_line+0x1518>
  */

  // Initialize planner data struct for motion blocks.
  plan_line_data_t plan_data;
  plan_line_data_t *pl_data = &plan_data;
  memset(pl_data,0,sizeof(plan_line_data_t)); // Zero pl_data struct
    1aba:	fe 01       	movw	r30, r28
    1abc:	72 96       	adiw	r30, 0x12	; 18
    1abe:	89 e0       	ldi	r24, 0x09	; 9
    1ac0:	df 01       	movw	r26, r30
    1ac2:	1d 92       	st	X+, r1
    1ac4:	8a 95       	dec	r24
    1ac6:	e9 f7       	brne	.-6      	; 0x1ac2 <gc_execute_line+0xf8e>

  // Intercept jog commands and complete error checking for valid jog commands and execute.
  // NOTE: G-code parser state is not updated, except the position to ensure sequential jog
  // targets are computed correctly. The final parser position after a jog is updated in
  // protocol_execute_realtime() when jogging completes or is canceled.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    1ac8:	dd 20       	and	r13, r13
    1aca:	59 f1       	breq	.+86     	; 0x1b22 <gc_execute_line+0xfee>
    // Only distance and unit modal commands and G53 absolute override command are allowed.
    // NOTE: Feed rate word and axis word checks have already been performed in STEP 3.
    if (command_words & ~(bit(MODAL_GROUP_G3) | bit(MODAL_GROUP_G6) | bit(MODAL_GROUP_G0)) ) { FAIL(STATUS_INVALID_JOG_COMMAND) };
    1acc:	b6 eb       	ldi	r27, 0xB6	; 182
    1ace:	eb 22       	and	r14, r27
    1ad0:	ef 28       	or	r14, r15
    1ad2:	09 f0       	breq	.+2      	; 0x1ad6 <gc_execute_line+0xfa2>
    1ad4:	bd c2       	rjmp	.+1402   	; 0x2050 <gc_execute_line+0x151c>
    if (!(gc_block.non_modal_command == NON_MODAL_ABSOLUTE_OVERRIDE || gc_block.non_modal_command == NON_MODAL_NO_ACTION)) { FAIL(STATUS_INVALID_JOG_COMMAND); }
    1ad6:	80 91 ea 05 	lds	r24, 0x05EA	; 0x8005ea <gc_block>
    1ada:	85 33       	cpi	r24, 0x35	; 53
    1adc:	11 f0       	breq	.+4      	; 0x1ae2 <gc_execute_line+0xfae>
    1ade:	81 11       	cpse	r24, r1
    1ae0:	b9 c2       	rjmp	.+1394   	; 0x2054 <gc_execute_line+0x1520>

    // Initialize planner data to current spindle and coolant modal state.
    pl_data->spindle_speed = gc_state.spindle_speed;
    1ae2:	ea ea       	ldi	r30, 0xAA	; 170
    1ae4:	f5 e0       	ldi	r31, 0x05	; 5
    1ae6:	83 85       	ldd	r24, Z+11	; 0x0b
    1ae8:	94 85       	ldd	r25, Z+12	; 0x0c
    1aea:	a5 85       	ldd	r26, Z+13	; 0x0d
    1aec:	b6 85       	ldd	r27, Z+14	; 0x0e
    1aee:	8e 8b       	std	Y+22, r24	; 0x16
    1af0:	9f 8b       	std	Y+23, r25	; 0x17
    1af2:	a8 8f       	std	Y+24, r26	; 0x18
    1af4:	b9 8f       	std	Y+25, r27	; 0x19
    plan_data.condition = (gc_state.modal.spindle | gc_state.modal.coolant);
    1af6:	91 85       	ldd	r25, Z+9	; 0x09
    1af8:	80 85       	ldd	r24, Z+8	; 0x08
    1afa:	89 2b       	or	r24, r25
    1afc:	8a 8f       	std	Y+26, r24	; 0x1a

    uint8_t status = jog_execute(&plan_data, &gc_block);
    1afe:	6a ee       	ldi	r22, 0xEA	; 234
    1b00:	75 e0       	ldi	r23, 0x05	; 5
    1b02:	ce 01       	movw	r24, r28
    1b04:	42 96       	adiw	r24, 0x12	; 18
    1b06:	0e 94 81 2c 	call	0x5902	; 0x5902 <jog_execute>
    if (status == STATUS_OK) { memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); }
    1b0a:	81 11       	cpse	r24, r1
    1b0c:	f1 c2       	rjmp	.+1506   	; 0x20f0 <gc_execute_line+0x15bc>
    1b0e:	9c e0       	ldi	r25, 0x0C	; 12
    1b10:	e8 e1       	ldi	r30, 0x18	; 24
    1b12:	f6 e0       	ldi	r31, 0x06	; 6
    1b14:	a2 ec       	ldi	r26, 0xC2	; 194
    1b16:	b5 e0       	ldi	r27, 0x05	; 5
    1b18:	01 90       	ld	r0, Z+
    1b1a:	0d 92       	st	X+, r0
    1b1c:	9a 95       	dec	r25
    1b1e:	e1 f7       	brne	.-8      	; 0x1b18 <gc_execute_line+0xfe4>
    1b20:	e7 c2       	rjmp	.+1486   	; 0x20f0 <gc_execute_line+0x15bc>
    return(status);
  }
  
  // If in laser mode, setup laser power based on current and past parser conditions.
  if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    1b22:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <settings+0x45>
    1b26:	81 ff       	sbrs	r24, 1
    1b28:	26 c0       	rjmp	.+76     	; 0x1b76 <gc_execute_line+0x1042>
    if ( !((gc_block.modal.motion == MOTION_MODE_LINEAR) || (gc_block.modal.motion == MOTION_MODE_CW_ARC) 
    1b2a:	80 91 eb 05 	lds	r24, 0x05EB	; 0x8005eb <gc_block+0x1>
    1b2e:	81 50       	subi	r24, 0x01	; 1
    1b30:	83 30       	cpi	r24, 0x03	; 3
    1b32:	18 f0       	brcs	.+6      	; 0x1b3a <gc_execute_line+0x1006>
        || (gc_block.modal.motion == MOTION_MODE_CCW_ARC)) ) {
      gc_parser_flags |= GC_PARSER_LASER_DISABLE;
    1b34:	e8 a1       	ldd	r30, Y+32	; 0x20
    1b36:	e0 64       	ori	r30, 0x40	; 64
    1b38:	e8 a3       	std	Y+32, r30	; 0x20
    }

    // Any motion mode with axis words is allowed to be passed from a spindle speed update. 
    // NOTE: G1 and G0 without axis words sets axis_command to none. G28/30 are intentionally omitted.
    // TODO: Check sync conditions for M3 enabled motions that don't enter the planner. (zero length).
    if (axis_words && (axis_command == AXIS_COMMAND_MOTION_MODE)) { 
    1b3a:	fd 8d       	ldd	r31, Y+29	; 0x1d
    1b3c:	ff 23       	and	r31, r31
    1b3e:	39 f0       	breq	.+14     	; 0x1b4e <gc_execute_line+0x101a>
    1b40:	2e 8d       	ldd	r18, Y+30	; 0x1e
    1b42:	22 30       	cpi	r18, 0x02	; 2
    1b44:	21 f4       	brne	.+8      	; 0x1b4e <gc_execute_line+0x101a>
      gc_parser_flags |= GC_PARSER_LASER_ISMOTION; 
    1b46:	38 a1       	ldd	r19, Y+32	; 0x20
    1b48:	30 68       	ori	r19, 0x80	; 128
    1b4a:	38 a3       	std	Y+32, r19	; 0x20
    1b4c:	14 c0       	rjmp	.+40     	; 0x1b76 <gc_execute_line+0x1042>
    } else {
      // M3 constant power laser requires planner syncs to update the laser when changing between
      // a G1/2/3 motion mode state and vice versa when there is no motion in the line.
      if (gc_state.modal.spindle == SPINDLE_ENABLE_CW) {
    1b4e:	80 91 b3 05 	lds	r24, 0x05B3	; 0x8005b3 <gc_state+0x9>
    1b52:	80 31       	cpi	r24, 0x10	; 16
    1b54:	81 f4       	brne	.+32     	; 0x1b76 <gc_execute_line+0x1042>
        if ((gc_state.modal.motion == MOTION_MODE_LINEAR) || (gc_state.modal.motion == MOTION_MODE_CW_ARC) 
    1b56:	80 91 aa 05 	lds	r24, 0x05AA	; 0x8005aa <gc_state>
    1b5a:	81 50       	subi	r24, 0x01	; 1
    1b5c:	83 30       	cpi	r24, 0x03	; 3
    1b5e:	30 f4       	brcc	.+12     	; 0x1b6c <gc_execute_line+0x1038>
            || (gc_state.modal.motion == MOTION_MODE_CCW_ARC)) {
          if (bit_istrue(gc_parser_flags,GC_PARSER_LASER_DISABLE)) { 
    1b60:	48 a1       	ldd	r20, Y+32	; 0x20
    1b62:	46 ff       	sbrs	r20, 6
    1b64:	08 c0       	rjmp	.+16     	; 0x1b76 <gc_execute_line+0x1042>
            gc_parser_flags |= GC_PARSER_LASER_FORCE_SYNC; // Change from G1/2/3 motion mode.
    1b66:	40 62       	ori	r20, 0x20	; 32
    1b68:	48 a3       	std	Y+32, r20	; 0x20
    1b6a:	05 c0       	rjmp	.+10     	; 0x1b76 <gc_execute_line+0x1042>
          }
        } else {
          // When changing to a G1 motion mode without axis words from a non-G1/2/3 motion mode.
          if (bit_isfalse(gc_parser_flags,GC_PARSER_LASER_DISABLE)) { 
    1b6c:	88 a1       	ldd	r24, Y+32	; 0x20
    1b6e:	86 fd       	sbrc	r24, 6
    1b70:	02 c0       	rjmp	.+4      	; 0x1b76 <gc_execute_line+0x1042>
            gc_parser_flags |= GC_PARSER_LASER_FORCE_SYNC;
    1b72:	80 62       	ori	r24, 0x20	; 32
    1b74:	88 a3       	std	Y+32, r24	; 0x20
    }
  }

  // [0. Non-specific/common error-checks and miscellaneous setup]:
  // NOTE: If no line number is present, the value is zero.
  gc_state.line_number = gc_block.values.n;
    1b76:	ea ea       	ldi	r30, 0xAA	; 170
    1b78:	f5 e0       	ldi	r31, 0x05	; 5
    1b7a:	aa ee       	ldi	r26, 0xEA	; 234
    1b7c:	b5 e0       	ldi	r27, 0x05	; 5
    1b7e:	5d 96       	adiw	r26, 0x1d	; 29
    1b80:	4d 91       	ld	r20, X+
    1b82:	5d 91       	ld	r21, X+
    1b84:	6d 91       	ld	r22, X+
    1b86:	7c 91       	ld	r23, X
    1b88:	90 97       	sbiw	r26, 0x20	; 32
    1b8a:	44 8b       	std	Z+20, r20	; 0x14
    1b8c:	55 8b       	std	Z+21, r21	; 0x15
    1b8e:	66 8b       	std	Z+22, r22	; 0x16
    1b90:	77 8b       	std	Z+23, r23	; 0x17
  #endif

  // [1. Comments feedback ]:  NOT SUPPORTED

  // [2. Set feed rate mode ]:
  gc_state.modal.feed_rate = gc_block.modal.feed_rate;
    1b92:	12 96       	adiw	r26, 0x02	; 2
    1b94:	8c 91       	ld	r24, X
    1b96:	81 83       	std	Z+1, r24	; 0x01
  if (gc_state.modal.feed_rate) { pl_data->condition |= PL_COND_FLAG_INVERSE_TIME; } // Set condition flag for planner use.
    1b98:	88 23       	and	r24, r24
    1b9a:	11 f0       	breq	.+4      	; 0x1ba0 <gc_execute_line+0x106c>
    1b9c:	88 e0       	ldi	r24, 0x08	; 8
    1b9e:	8a 8f       	std	Y+26, r24	; 0x1a

  // [3. Set feed rate ]:
  gc_state.feed_rate = gc_block.values.f; // Always copy this value. See feed rate error-checking.
    1ba0:	aa ee       	ldi	r26, 0xEA	; 234
    1ba2:	b5 e0       	ldi	r27, 0x05	; 5
    1ba4:	1c 96       	adiw	r26, 0x0c	; 12
    1ba6:	4d 91       	ld	r20, X+
    1ba8:	5d 91       	ld	r21, X+
    1baa:	6d 91       	ld	r22, X+
    1bac:	7c 91       	ld	r23, X
    1bae:	1f 97       	sbiw	r26, 0x0f	; 15
    1bb0:	ea ea       	ldi	r30, 0xAA	; 170
    1bb2:	f5 e0       	ldi	r31, 0x05	; 5
    1bb4:	47 87       	std	Z+15, r20	; 0x0f
    1bb6:	50 8b       	std	Z+16, r21	; 0x10
    1bb8:	61 8b       	std	Z+17, r22	; 0x11
    1bba:	72 8b       	std	Z+18, r23	; 0x12
  pl_data->feed_rate = gc_state.feed_rate; // Record data for planner use.
    1bbc:	4a 8b       	std	Y+18, r20	; 0x12
    1bbe:	5b 8b       	std	Y+19, r21	; 0x13
    1bc0:	6c 8b       	std	Y+20, r22	; 0x14
    1bc2:	7d 8b       	std	Y+21, r23	; 0x15

  // [4. Set spindle speed ]:
  if ((gc_state.spindle_speed != gc_block.values.s) || bit_istrue(gc_parser_flags,GC_PARSER_LASER_FORCE_SYNC)) {
    1bc4:	99 96       	adiw	r26, 0x29	; 41
    1bc6:	8d 90       	ld	r8, X+
    1bc8:	9d 90       	ld	r9, X+
    1bca:	ad 90       	ld	r10, X+
    1bcc:	bc 90       	ld	r11, X
    1bce:	9c 97       	sbiw	r26, 0x2c	; 44
    1bd0:	a5 01       	movw	r20, r10
    1bd2:	94 01       	movw	r18, r8
    1bd4:	63 85       	ldd	r22, Z+11	; 0x0b
    1bd6:	74 85       	ldd	r23, Z+12	; 0x0c
    1bd8:	85 85       	ldd	r24, Z+13	; 0x0d
    1bda:	96 85       	ldd	r25, Z+14	; 0x0e
    1bdc:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    1be0:	81 11       	cpse	r24, r1
    1be2:	03 c0       	rjmp	.+6      	; 0x1bea <gc_execute_line+0x10b6>
    1be4:	98 a1       	ldd	r25, Y+32	; 0x20
    1be6:	95 ff       	sbrs	r25, 5
    1be8:	23 c0       	rjmp	.+70     	; 0x1c30 <gc_execute_line+0x10fc>
    if (gc_state.modal.spindle != SPINDLE_DISABLE) { 
    1bea:	80 91 b3 05 	lds	r24, 0x05B3	; 0x8005b3 <gc_state+0x9>
    1bee:	88 23       	and	r24, r24
    1bf0:	79 f0       	breq	.+30     	; 0x1c10 <gc_execute_line+0x10dc>
      #ifdef VARIABLE_SPINDLE
        if (bit_isfalse(gc_parser_flags,GC_PARSER_LASER_ISMOTION)) {
    1bf2:	a8 a1       	ldd	r26, Y+32	; 0x20
    1bf4:	aa 23       	and	r26, r26
    1bf6:	64 f0       	brlt	.+24     	; 0x1c10 <gc_execute_line+0x10dc>
          if (bit_istrue(gc_parser_flags,GC_PARSER_LASER_DISABLE)) {
    1bf8:	a6 ff       	sbrs	r26, 6
    1bfa:	06 c0       	rjmp	.+12     	; 0x1c08 <gc_execute_line+0x10d4>
             spindle_sync(gc_state.modal.spindle, 0.0);
    1bfc:	40 e0       	ldi	r20, 0x00	; 0
    1bfe:	50 e0       	ldi	r21, 0x00	; 0
    1c00:	ba 01       	movw	r22, r20
    1c02:	0e 94 99 11 	call	0x2332	; 0x2332 <spindle_sync>
    1c06:	04 c0       	rjmp	.+8      	; 0x1c10 <gc_execute_line+0x10dc>
          } else { spindle_sync(gc_state.modal.spindle, gc_block.values.s); }
    1c08:	b5 01       	movw	r22, r10
    1c0a:	a4 01       	movw	r20, r8
    1c0c:	0e 94 99 11 	call	0x2332	; 0x2332 <spindle_sync>
        }
      #else
        spindle_sync(gc_state.modal.spindle, 0.0);
      #endif
    }
    gc_state.spindle_speed = gc_block.values.s; // Update spindle speed state.
    1c10:	80 91 13 06 	lds	r24, 0x0613	; 0x800613 <gc_block+0x29>
    1c14:	90 91 14 06 	lds	r25, 0x0614	; 0x800614 <gc_block+0x2a>
    1c18:	a0 91 15 06 	lds	r26, 0x0615	; 0x800615 <gc_block+0x2b>
    1c1c:	b0 91 16 06 	lds	r27, 0x0616	; 0x800616 <gc_block+0x2c>
    1c20:	80 93 b5 05 	sts	0x05B5, r24	; 0x8005b5 <gc_state+0xb>
    1c24:	90 93 b6 05 	sts	0x05B6, r25	; 0x8005b6 <gc_state+0xc>
    1c28:	a0 93 b7 05 	sts	0x05B7, r26	; 0x8005b7 <gc_state+0xd>
    1c2c:	b0 93 b8 05 	sts	0x05B8, r27	; 0x8005b8 <gc_state+0xe>
  }
  // NOTE: Pass zero spindle speed for all restricted laser motions.
  if (bit_isfalse(gc_parser_flags,GC_PARSER_LASER_DISABLE)) {
    1c30:	b8 a1       	ldd	r27, Y+32	; 0x20
    1c32:	b6 fd       	sbrc	r27, 6
    1c34:	0c c0       	rjmp	.+24     	; 0x1c4e <gc_execute_line+0x111a>
    pl_data->spindle_speed = gc_state.spindle_speed; // Record data for planner use. 
    1c36:	80 91 b5 05 	lds	r24, 0x05B5	; 0x8005b5 <gc_state+0xb>
    1c3a:	90 91 b6 05 	lds	r25, 0x05B6	; 0x8005b6 <gc_state+0xc>
    1c3e:	a0 91 b7 05 	lds	r26, 0x05B7	; 0x8005b7 <gc_state+0xd>
    1c42:	b0 91 b8 05 	lds	r27, 0x05B8	; 0x8005b8 <gc_state+0xe>
    1c46:	8e 8b       	std	Y+22, r24	; 0x16
    1c48:	9f 8b       	std	Y+23, r25	; 0x17
    1c4a:	a8 8f       	std	Y+24, r26	; 0x18
    1c4c:	b9 8f       	std	Y+25, r27	; 0x19
  } // else { pl_data->spindle_speed = 0.0; } // Initialized as zero already.
  
  // [5. Select tool ]: NOT SUPPORTED. Only tracks tool value.
  gc_state.tool = gc_block.values.t;
    1c4e:	ea ea       	ldi	r30, 0xAA	; 170
    1c50:	f5 e0       	ldi	r31, 0x05	; 5
    1c52:	aa ee       	ldi	r26, 0xEA	; 234
    1c54:	b5 e0       	ldi	r27, 0x05	; 5
    1c56:	9d 96       	adiw	r26, 0x2d	; 45
    1c58:	8c 91       	ld	r24, X
    1c5a:	9d 97       	sbiw	r26, 0x2d	; 45
    1c5c:	83 8b       	std	Z+19, r24	; 0x13

  // [6. Change tool ]: NOT SUPPORTED

  // [7. Spindle control ]:
  if (gc_state.modal.spindle != gc_block.modal.spindle) {
    1c5e:	1a 96       	adiw	r26, 0x0a	; 10
    1c60:	8c 91       	ld	r24, X
    1c62:	91 85       	ldd	r25, Z+9	; 0x09
    1c64:	98 17       	cp	r25, r24
    1c66:	51 f0       	breq	.+20     	; 0x1c7c <gc_execute_line+0x1148>
    // Update spindle control and apply spindle speed when enabling it in this block.
    // NOTE: All spindle state changes are synced, even in laser mode. Also, pl_data,
    // rather than gc_state, is used to manage laser state for non-laser motions.
    spindle_sync(gc_block.modal.spindle, pl_data->spindle_speed);
    1c68:	4e 89       	ldd	r20, Y+22	; 0x16
    1c6a:	5f 89       	ldd	r21, Y+23	; 0x17
    1c6c:	68 8d       	ldd	r22, Y+24	; 0x18
    1c6e:	79 8d       	ldd	r23, Y+25	; 0x19
    1c70:	0e 94 99 11 	call	0x2332	; 0x2332 <spindle_sync>
    gc_state.modal.spindle = gc_block.modal.spindle;
    1c74:	80 91 f4 05 	lds	r24, 0x05F4	; 0x8005f4 <gc_block+0xa>
    1c78:	80 93 b3 05 	sts	0x05B3, r24	; 0x8005b3 <gc_state+0x9>
  }
  pl_data->condition |= gc_state.modal.spindle; // Set condition flag for planner use.
    1c7c:	ea ea       	ldi	r30, 0xAA	; 170
    1c7e:	f5 e0       	ldi	r31, 0x05	; 5
    1c80:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1c82:	81 85       	ldd	r24, Z+9	; 0x09
    1c84:	89 2b       	or	r24, r25
    1c86:	8a 8f       	std	Y+26, r24	; 0x1a

  // [8. Coolant control ]:
  if (gc_state.modal.coolant != gc_block.modal.coolant) {
    1c88:	80 91 f3 05 	lds	r24, 0x05F3	; 0x8005f3 <gc_block+0x9>
    1c8c:	90 85       	ldd	r25, Z+8	; 0x08
    1c8e:	98 17       	cp	r25, r24
    1c90:	31 f0       	breq	.+12     	; 0x1c9e <gc_execute_line+0x116a>
    // NOTE: Coolant M-codes are modal. Only one command per line is allowed. But, multiple states
    // can exist at the same time, while coolant disable clears all states.
    coolant_sync(gc_block.modal.coolant);
    1c92:	0e 94 ca 11 	call	0x2394	; 0x2394 <coolant_sync>
    gc_state.modal.coolant = gc_block.modal.coolant;
    1c96:	80 91 f3 05 	lds	r24, 0x05F3	; 0x8005f3 <gc_block+0x9>
    1c9a:	80 93 b2 05 	sts	0x05B2, r24	; 0x8005b2 <gc_state+0x8>
  }
  pl_data->condition |= gc_state.modal.coolant; // Set condition flag for planner use.
    1c9e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1ca0:	80 91 b2 05 	lds	r24, 0x05B2	; 0x8005b2 <gc_state+0x8>
    1ca4:	89 2b       	or	r24, r25
    1ca6:	8a 8f       	std	Y+26, r24	; 0x1a
      mc_override_ctrl_update(gc_state.modal.override);
    }
  #endif

  // [10. Dwell ]:
  if (gc_block.non_modal_command == NON_MODAL_DWELL) { mc_dwell(gc_block.values.p); }
    1ca8:	80 91 ea 05 	lds	r24, 0x05EA	; 0x8005ea <gc_block>
    1cac:	84 30       	cpi	r24, 0x04	; 4
    1cae:	51 f4       	brne	.+20     	; 0x1cc4 <gc_execute_line+0x1190>
    1cb0:	60 91 0b 06 	lds	r22, 0x060B	; 0x80060b <gc_block+0x21>
    1cb4:	70 91 0c 06 	lds	r23, 0x060C	; 0x80060c <gc_block+0x22>
    1cb8:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <gc_block+0x23>
    1cbc:	90 91 0e 06 	lds	r25, 0x060E	; 0x80060e <gc_block+0x24>
    1cc0:	0e 94 cf 04 	call	0x99e	; 0x99e <mc_dwell>

  // [11. Set active plane ]:
  gc_state.modal.plane_select = gc_block.modal.plane_select;
    1cc4:	ea ea       	ldi	r30, 0xAA	; 170
    1cc6:	f5 e0       	ldi	r31, 0x05	; 5
    1cc8:	aa ee       	ldi	r26, 0xEA	; 234
    1cca:	b5 e0       	ldi	r27, 0x05	; 5
    1ccc:	15 96       	adiw	r26, 0x05	; 5
    1cce:	8c 91       	ld	r24, X
    1cd0:	15 97       	sbiw	r26, 0x05	; 5
    1cd2:	84 83       	std	Z+4, r24	; 0x04

  // [12. Set length units ]:
  gc_state.modal.units = gc_block.modal.units;
    1cd4:	13 96       	adiw	r26, 0x03	; 3
    1cd6:	8c 91       	ld	r24, X
    1cd8:	82 83       	std	Z+2, r24	; 0x02

  // [14. Cutter length compensation ]: G43.1 and G49 supported. G43 NOT SUPPORTED.
  // NOTE: If G43 were supported, its operation wouldn't be any different from G43.1 in terms
  // of execution. The error-checking step would simply load the offset value into the correct
  // axis of the block XYZ value array.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates a change.
    1cda:	ee 8d       	ldd	r30, Y+30	; 0x1e
    1cdc:	e3 30       	cpi	r30, 0x03	; 3
    1cde:	71 f5       	brne	.+92     	; 0x1d3c <gc_execute_line+0x1208>
    gc_state.modal.tool_length = gc_block.modal.tool_length;
    1ce0:	80 91 f0 05 	lds	r24, 0x05F0	; 0x8005f0 <gc_block+0x6>
    1ce4:	80 93 af 05 	sts	0x05AF, r24	; 0x8005af <gc_state+0x5>
    if (gc_state.modal.tool_length == TOOL_LENGTH_OFFSET_CANCEL) { // G49
    1ce8:	81 11       	cpse	r24, r1
    1cea:	08 c0       	rjmp	.+16     	; 0x1cfc <gc_execute_line+0x11c8>
      gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS] = 0.0;
    1cec:	10 92 20 06 	sts	0x0620, r1	; 0x800620 <gc_block+0x36>
    1cf0:	10 92 21 06 	sts	0x0621, r1	; 0x800621 <gc_block+0x37>
    1cf4:	10 92 22 06 	sts	0x0622, r1	; 0x800622 <gc_block+0x38>
    1cf8:	10 92 23 06 	sts	0x0623, r1	; 0x800623 <gc_block+0x39>
    } // else G43.1
    if ( gc_state.tool_length_offset != gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS] ) {
    1cfc:	80 90 20 06 	lds	r8, 0x0620	; 0x800620 <gc_block+0x36>
    1d00:	90 90 21 06 	lds	r9, 0x0621	; 0x800621 <gc_block+0x37>
    1d04:	a0 90 22 06 	lds	r10, 0x0622	; 0x800622 <gc_block+0x38>
    1d08:	b0 90 23 06 	lds	r11, 0x0623	; 0x800623 <gc_block+0x39>
    1d0c:	a5 01       	movw	r20, r10
    1d0e:	94 01       	movw	r18, r8
    1d10:	60 91 e6 05 	lds	r22, 0x05E6	; 0x8005e6 <gc_state+0x3c>
    1d14:	70 91 e7 05 	lds	r23, 0x05E7	; 0x8005e7 <gc_state+0x3d>
    1d18:	80 91 e8 05 	lds	r24, 0x05E8	; 0x8005e8 <gc_state+0x3e>
    1d1c:	90 91 e9 05 	lds	r25, 0x05E9	; 0x8005e9 <gc_state+0x3f>
    1d20:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    1d24:	88 23       	and	r24, r24
    1d26:	51 f0       	breq	.+20     	; 0x1d3c <gc_execute_line+0x1208>
      gc_state.tool_length_offset = gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS];
    1d28:	80 92 e6 05 	sts	0x05E6, r8	; 0x8005e6 <gc_state+0x3c>
    1d2c:	90 92 e7 05 	sts	0x05E7, r9	; 0x8005e7 <gc_state+0x3d>
    1d30:	a0 92 e8 05 	sts	0x05E8, r10	; 0x8005e8 <gc_state+0x3e>
    1d34:	b0 92 e9 05 	sts	0x05E9, r11	; 0x8005e9 <gc_state+0x3f>
      system_flag_wco_change();
    1d38:	0e 94 7a 2d 	call	0x5af4	; 0x5af4 <system_flag_wco_change>
    }
  }

  // [15. Coordinate system selection ]:
  if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    1d3c:	80 91 f1 05 	lds	r24, 0x05F1	; 0x8005f1 <gc_block+0x7>
    1d40:	90 91 b0 05 	lds	r25, 0x05B0	; 0x8005b0 <gc_state+0x6>
    1d44:	98 17       	cp	r25, r24
    1d46:	69 f0       	breq	.+26     	; 0x1d62 <gc_execute_line+0x122e>
    gc_state.modal.coord_select = gc_block.modal.coord_select;
    1d48:	80 93 b0 05 	sts	0x05B0, r24	; 0x8005b0 <gc_state+0x6>
    memcpy(gc_state.coord_system,block_coord_system,N_AXIS*sizeof(float));
    1d4c:	8c e0       	ldi	r24, 0x0C	; 12
    1d4e:	fe 01       	movw	r30, r28
    1d50:	36 96       	adiw	r30, 0x06	; 6
    1d52:	ae ec       	ldi	r26, 0xCE	; 206
    1d54:	b5 e0       	ldi	r27, 0x05	; 5
    1d56:	01 90       	ld	r0, Z+
    1d58:	0d 92       	st	X+, r0
    1d5a:	8a 95       	dec	r24
    1d5c:	e1 f7       	brne	.-8      	; 0x1d56 <gc_execute_line+0x1222>
    system_flag_wco_change();
    1d5e:	0e 94 7a 2d 	call	0x5af4	; 0x5af4 <system_flag_wco_change>

  // [16. Set path control mode ]: G61.1/G64 NOT SUPPORTED
  // gc_state.modal.control = gc_block.modal.control; // NOTE: Always default.

  // [17. Set distance mode ]:
  gc_state.modal.distance = gc_block.modal.distance;
    1d62:	ea ee       	ldi	r30, 0xEA	; 234
    1d64:	f5 e0       	ldi	r31, 0x05	; 5
    1d66:	84 81       	ldd	r24, Z+4	; 0x04
    1d68:	80 93 ad 05 	sts	0x05AD, r24	; 0x8005ad <gc_state+0x3>

  // [18. Set retract mode ]: NOT SUPPORTED

  // [19. Go to predefined position, Set G10, or Set axis offsets ]:
  switch(gc_block.non_modal_command) {
    1d6c:	80 81       	ld	r24, Z
    1d6e:	86 32       	cpi	r24, 0x26	; 38
    1d70:	09 f4       	brne	.+2      	; 0x1d74 <gc_execute_line+0x1240>
    1d72:	46 c0       	rjmp	.+140    	; 0x1e00 <gc_execute_line+0x12cc>
    1d74:	38 f4       	brcc	.+14     	; 0x1d84 <gc_execute_line+0x1250>
    1d76:	8c 31       	cpi	r24, 0x1C	; 28
    1d78:	29 f1       	breq	.+74     	; 0x1dc4 <gc_execute_line+0x1290>
    1d7a:	8e 31       	cpi	r24, 0x1E	; 30
    1d7c:	19 f1       	breq	.+70     	; 0x1dc4 <gc_execute_line+0x1290>
    1d7e:	8a 30       	cpi	r24, 0x0A	; 10
    1d80:	59 f0       	breq	.+22     	; 0x1d98 <gc_execute_line+0x1264>
    1d82:	5f c0       	rjmp	.+190    	; 0x1e42 <gc_execute_line+0x130e>
    1d84:	8c 35       	cpi	r24, 0x5C	; 92
    1d86:	09 f4       	brne	.+2      	; 0x1d8a <gc_execute_line+0x1256>
    1d88:	47 c0       	rjmp	.+142    	; 0x1e18 <gc_execute_line+0x12e4>
    1d8a:	86 36       	cpi	r24, 0x66	; 102
    1d8c:	09 f4       	brne	.+2      	; 0x1d90 <gc_execute_line+0x125c>
    1d8e:	50 c0       	rjmp	.+160    	; 0x1e30 <gc_execute_line+0x12fc>
    1d90:	88 32       	cpi	r24, 0x28	; 40
    1d92:	09 f0       	breq	.+2      	; 0x1d96 <gc_execute_line+0x1262>
    1d94:	56 c0       	rjmp	.+172    	; 0x1e42 <gc_execute_line+0x130e>
    1d96:	3a c0       	rjmp	.+116    	; 0x1e0c <gc_execute_line+0x12d8>
    case NON_MODAL_SET_COORDINATE_DATA:
      settings_write_coord_data(coord_select,gc_block.values.ijk);
    1d98:	6a ef       	ldi	r22, 0xFA	; 250
    1d9a:	75 e0       	ldi	r23, 0x05	; 5
    1d9c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1d9e:	0e 94 a5 22 	call	0x454a	; 0x454a <settings_write_coord_data>
      // Update system coordinate system if currently active.
      if (gc_state.modal.coord_select == coord_select) {
    1da2:	80 91 b0 05 	lds	r24, 0x05B0	; 0x8005b0 <gc_state+0x6>
    1da6:	fb 8d       	ldd	r31, Y+27	; 0x1b
    1da8:	8f 13       	cpse	r24, r31
    1daa:	4b c0       	rjmp	.+150    	; 0x1e42 <gc_execute_line+0x130e>
        memcpy(gc_state.coord_system,gc_block.values.ijk,N_AXIS*sizeof(float));
    1dac:	8c e0       	ldi	r24, 0x0C	; 12
    1dae:	ea ef       	ldi	r30, 0xFA	; 250
    1db0:	f5 e0       	ldi	r31, 0x05	; 5
    1db2:	ae ec       	ldi	r26, 0xCE	; 206
    1db4:	b5 e0       	ldi	r27, 0x05	; 5
    1db6:	01 90       	ld	r0, Z+
    1db8:	0d 92       	st	X+, r0
    1dba:	8a 95       	dec	r24
    1dbc:	e1 f7       	brne	.-8      	; 0x1db6 <gc_execute_line+0x1282>
        system_flag_wco_change();
    1dbe:	0e 94 7a 2d 	call	0x5af4	; 0x5af4 <system_flag_wco_change>
    1dc2:	3f c0       	rjmp	.+126    	; 0x1e42 <gc_execute_line+0x130e>
      }
      break;
    case NON_MODAL_GO_HOME_0: case NON_MODAL_GO_HOME_1:
      // Move to intermediate position before going home. Obeys current coordinate system and offsets
      // and absolute and incremental modes.
      pl_data->condition |= PL_COND_FLAG_RAPID_MOTION; // Set rapid motion condition flag.
    1dc4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1dc6:	81 60       	ori	r24, 0x01	; 1
    1dc8:	8a 8f       	std	Y+26, r24	; 0x1a
      if (axis_command) { mc_line(gc_block.values.xyz, pl_data); }
    1dca:	2e 8d       	ldd	r18, Y+30	; 0x1e
    1dcc:	22 23       	and	r18, r18
    1dce:	39 f0       	breq	.+14     	; 0x1dde <gc_execute_line+0x12aa>
    1dd0:	be 01       	movw	r22, r28
    1dd2:	6e 5e       	subi	r22, 0xEE	; 238
    1dd4:	7f 4f       	sbci	r23, 0xFF	; 255
    1dd6:	88 e1       	ldi	r24, 0x18	; 24
    1dd8:	96 e0       	ldi	r25, 0x06	; 6
    1dda:	0e 94 ad 01 	call	0x35a	; 0x35a <mc_line>
      mc_line(gc_block.values.ijk, pl_data);
    1dde:	be 01       	movw	r22, r28
    1de0:	6e 5e       	subi	r22, 0xEE	; 238
    1de2:	7f 4f       	sbci	r23, 0xFF	; 255
    1de4:	8a ef       	ldi	r24, 0xFA	; 250
    1de6:	95 e0       	ldi	r25, 0x05	; 5
    1de8:	0e 94 ad 01 	call	0x35a	; 0x35a <mc_line>
      memcpy(gc_state.position, gc_block.values.ijk, N_AXIS*sizeof(float));
    1dec:	8c e0       	ldi	r24, 0x0C	; 12
    1dee:	ea ef       	ldi	r30, 0xFA	; 250
    1df0:	f5 e0       	ldi	r31, 0x05	; 5
    1df2:	a2 ec       	ldi	r26, 0xC2	; 194
    1df4:	b5 e0       	ldi	r27, 0x05	; 5
    1df6:	01 90       	ld	r0, Z+
    1df8:	0d 92       	st	X+, r0
    1dfa:	8a 95       	dec	r24
    1dfc:	e1 f7       	brne	.-8      	; 0x1df6 <gc_execute_line+0x12c2>
      break;
    1dfe:	21 c0       	rjmp	.+66     	; 0x1e42 <gc_execute_line+0x130e>
    case NON_MODAL_SET_HOME_0:
      settings_write_coord_data(SETTING_INDEX_G28,gc_state.position);
    1e00:	62 ec       	ldi	r22, 0xC2	; 194
    1e02:	75 e0       	ldi	r23, 0x05	; 5
    1e04:	86 e0       	ldi	r24, 0x06	; 6
    1e06:	0e 94 a5 22 	call	0x454a	; 0x454a <settings_write_coord_data>
      break;
    1e0a:	1b c0       	rjmp	.+54     	; 0x1e42 <gc_execute_line+0x130e>
    case NON_MODAL_SET_HOME_1:
      settings_write_coord_data(SETTING_INDEX_G30,gc_state.position);
    1e0c:	62 ec       	ldi	r22, 0xC2	; 194
    1e0e:	75 e0       	ldi	r23, 0x05	; 5
    1e10:	87 e0       	ldi	r24, 0x07	; 7
    1e12:	0e 94 a5 22 	call	0x454a	; 0x454a <settings_write_coord_data>
      break;
    1e16:	15 c0       	rjmp	.+42     	; 0x1e42 <gc_execute_line+0x130e>
    case NON_MODAL_SET_COORDINATE_OFFSET:
      memcpy(gc_state.coord_offset,gc_block.values.xyz,sizeof(gc_block.values.xyz));
    1e18:	8c e0       	ldi	r24, 0x0C	; 12
    1e1a:	e8 e1       	ldi	r30, 0x18	; 24
    1e1c:	f6 e0       	ldi	r31, 0x06	; 6
    1e1e:	aa ed       	ldi	r26, 0xDA	; 218
    1e20:	b5 e0       	ldi	r27, 0x05	; 5
    1e22:	01 90       	ld	r0, Z+
    1e24:	0d 92       	st	X+, r0
    1e26:	8a 95       	dec	r24
    1e28:	e1 f7       	brne	.-8      	; 0x1e22 <gc_execute_line+0x12ee>
      system_flag_wco_change();
    1e2a:	0e 94 7a 2d 	call	0x5af4	; 0x5af4 <system_flag_wco_change>
      break;
    1e2e:	09 c0       	rjmp	.+18     	; 0x1e42 <gc_execute_line+0x130e>
    case NON_MODAL_RESET_COORDINATE_OFFSET:
      clear_vector(gc_state.coord_offset); // Disable G92 offsets by zeroing offset vector.
    1e30:	8c e0       	ldi	r24, 0x0C	; 12
    1e32:	ea ed       	ldi	r30, 0xDA	; 218
    1e34:	f5 e0       	ldi	r31, 0x05	; 5
    1e36:	df 01       	movw	r26, r30
    1e38:	1d 92       	st	X+, r1
    1e3a:	8a 95       	dec	r24
    1e3c:	e9 f7       	brne	.-6      	; 0x1e38 <gc_execute_line+0x1304>
      system_flag_wco_change();
    1e3e:	0e 94 7a 2d 	call	0x5af4	; 0x5af4 <system_flag_wco_change>


  // [20. Motion modes ]:
  // NOTE: Commands G10,G28,G30,G92 lock out and prevent axis words from use in motion modes.
  // Enter motion modes only if there are axis words or a motion mode command word in the block.
  gc_state.modal.motion = gc_block.modal.motion;
    1e42:	80 91 eb 05 	lds	r24, 0x05EB	; 0x8005eb <gc_block+0x1>
    1e46:	80 93 aa 05 	sts	0x05AA, r24	; 0x8005aa <gc_state>
  if (gc_state.modal.motion != MOTION_MODE_NONE) {
    1e4a:	80 35       	cpi	r24, 0x50	; 80
    1e4c:	09 f4       	brne	.+2      	; 0x1e50 <gc_execute_line+0x131c>
    1e4e:	56 c0       	rjmp	.+172    	; 0x1efc <gc_execute_line+0x13c8>
    if (axis_command == AXIS_COMMAND_MOTION_MODE) {
    1e50:	be 8d       	ldd	r27, Y+30	; 0x1e
    1e52:	b2 30       	cpi	r27, 0x02	; 2
    1e54:	09 f0       	breq	.+2      	; 0x1e58 <gc_execute_line+0x1324>
    1e56:	52 c0       	rjmp	.+164    	; 0x1efc <gc_execute_line+0x13c8>
      uint8_t gc_update_pos = GC_UPDATE_POS_TARGET;
      if (gc_state.modal.motion == MOTION_MODE_LINEAR) {
    1e58:	81 30       	cpi	r24, 0x01	; 1
    1e5a:	41 f4       	brne	.+16     	; 0x1e6c <gc_execute_line+0x1338>
        mc_line(gc_block.values.xyz, pl_data);
    1e5c:	be 01       	movw	r22, r28
    1e5e:	6e 5e       	subi	r22, 0xEE	; 238
    1e60:	7f 4f       	sbci	r23, 0xFF	; 255
    1e62:	88 e1       	ldi	r24, 0x18	; 24
    1e64:	96 e0       	ldi	r25, 0x06	; 6
    1e66:	0e 94 ad 01 	call	0x35a	; 0x35a <mc_line>
    1e6a:	3a c0       	rjmp	.+116    	; 0x1ee0 <gc_execute_line+0x13ac>
      } else if (gc_state.modal.motion == MOTION_MODE_SEEK) {
    1e6c:	81 11       	cpse	r24, r1
    1e6e:	0b c0       	rjmp	.+22     	; 0x1e86 <gc_execute_line+0x1352>
        pl_data->condition |= PL_COND_FLAG_RAPID_MOTION; // Set rapid motion condition flag.
    1e70:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1e72:	81 60       	ori	r24, 0x01	; 1
    1e74:	8a 8f       	std	Y+26, r24	; 0x1a
        mc_line(gc_block.values.xyz, pl_data);
    1e76:	be 01       	movw	r22, r28
    1e78:	6e 5e       	subi	r22, 0xEE	; 238
    1e7a:	7f 4f       	sbci	r23, 0xFF	; 255
    1e7c:	88 e1       	ldi	r24, 0x18	; 24
    1e7e:	96 e0       	ldi	r25, 0x06	; 6
    1e80:	0e 94 ad 01 	call	0x35a	; 0x35a <mc_line>
    1e84:	2d c0       	rjmp	.+90     	; 0x1ee0 <gc_execute_line+0x13ac>
      } else if ((gc_state.modal.motion == MOTION_MODE_CW_ARC) || (gc_state.modal.motion == MOTION_MODE_CCW_ARC)) {
    1e86:	82 50       	subi	r24, 0x02	; 2
    1e88:	82 30       	cpi	r24, 0x02	; 2
    1e8a:	e8 f4       	brcc	.+58     	; 0x1ec6 <gc_execute_line+0x1392>
        mc_arc(gc_block.values.xyz, pl_data, gc_state.position, gc_block.values.ijk, gc_block.values.r,
    1e8c:	e0 90 0f 06 	lds	r14, 0x060F	; 0x80060f <gc_block+0x25>
    1e90:	f0 90 10 06 	lds	r15, 0x0610	; 0x800610 <gc_block+0x26>
    1e94:	00 91 11 06 	lds	r16, 0x0611	; 0x800611 <gc_block+0x27>
    1e98:	10 91 12 06 	lds	r17, 0x0612	; 0x800612 <gc_block+0x28>
    1e9c:	e8 a1       	ldd	r30, Y+32	; 0x20
    1e9e:	e2 fb       	bst	r30, 2
    1ea0:	88 27       	eor	r24, r24
    1ea2:	80 f9       	bld	r24, 0
    1ea4:	8f 93       	push	r24
    1ea6:	8b a4       	ldd	r8, Y+43	; 0x2b
    1ea8:	aa a0       	ldd	r10, Y+34	; 0x22
    1eaa:	c9 a0       	ldd	r12, Y+33	; 0x21
    1eac:	2a ef       	ldi	r18, 0xFA	; 250
    1eae:	35 e0       	ldi	r19, 0x05	; 5
    1eb0:	42 ec       	ldi	r20, 0xC2	; 194
    1eb2:	55 e0       	ldi	r21, 0x05	; 5
    1eb4:	be 01       	movw	r22, r28
    1eb6:	6e 5e       	subi	r22, 0xEE	; 238
    1eb8:	7f 4f       	sbci	r23, 0xFF	; 255
    1eba:	88 e1       	ldi	r24, 0x18	; 24
    1ebc:	96 e0       	ldi	r25, 0x06	; 6
    1ebe:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mc_arc>
    1ec2:	0f 90       	pop	r0
    1ec4:	0d c0       	rjmp	.+26     	; 0x1ee0 <gc_execute_line+0x13ac>
            axis_0, axis_1, axis_linear, bit_istrue(gc_parser_flags,GC_PARSER_ARC_IS_CLOCKWISE));
      } else {
        // NOTE: gc_block.values.xyz is returned from mc_probe_cycle with the updated position value. So
        // upon a successful probing cycle, the machine position and the returned value should be the same.
        #ifndef ALLOW_FEED_OVERRIDE_DURING_PROBE_CYCLES
          pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
    1ec6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1ec8:	84 60       	ori	r24, 0x04	; 4
    1eca:	8a 8f       	std	Y+26, r24	; 0x1a
        #endif
        gc_update_pos = mc_probe_cycle(gc_block.values.xyz, pl_data, gc_parser_flags);
    1ecc:	48 a1       	ldd	r20, Y+32	; 0x20
    1ece:	be 01       	movw	r22, r28
    1ed0:	6e 5e       	subi	r22, 0xEE	; 238
    1ed2:	7f 4f       	sbci	r23, 0xFF	; 255
    1ed4:	88 e1       	ldi	r24, 0x18	; 24
    1ed6:	96 e0       	ldi	r25, 0x06	; 6
    1ed8:	0e 94 e5 04 	call	0x9ca	; 0x9ca <mc_probe_cycle>
      }  
     
      // As far as the parser is concerned, the position is now == target. In reality the
      // motion control system might still be processing the action and the real tool position
      // in any intermediate location.
      if (gc_update_pos == GC_UPDATE_POS_TARGET) {
    1edc:	81 11       	cpse	r24, r1
    1ede:	0a c0       	rjmp	.+20     	; 0x1ef4 <gc_execute_line+0x13c0>
        memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); // gc_state.position[] = gc_block.values.xyz[]
    1ee0:	8c e0       	ldi	r24, 0x0C	; 12
    1ee2:	e8 e1       	ldi	r30, 0x18	; 24
    1ee4:	f6 e0       	ldi	r31, 0x06	; 6
    1ee6:	a2 ec       	ldi	r26, 0xC2	; 194
    1ee8:	b5 e0       	ldi	r27, 0x05	; 5
    1eea:	01 90       	ld	r0, Z+
    1eec:	0d 92       	st	X+, r0
    1eee:	8a 95       	dec	r24
    1ef0:	e1 f7       	brne	.-8      	; 0x1eea <gc_execute_line+0x13b6>
    1ef2:	04 c0       	rjmp	.+8      	; 0x1efc <gc_execute_line+0x13c8>
      } else if (gc_update_pos == GC_UPDATE_POS_SYSTEM) {
    1ef4:	81 30       	cpi	r24, 0x01	; 1
    1ef6:	11 f4       	brne	.+4      	; 0x1efc <gc_execute_line+0x13c8>
        gc_sync_position(); // gc_state.position[] = sys_position
    1ef8:	0e 94 93 05 	call	0xb26	; 0xb26 <gc_sync_position>
  }

  // [21. Program flow ]:
  // M0,M1,M2,M30: Perform non-running program flow actions. During a program pause, the buffer may
  // refill and can only be resumed by the cycle start run-time command.
  gc_state.modal.program_flow = gc_block.modal.program_flow;
    1efc:	80 91 f2 05 	lds	r24, 0x05F2	; 0x8005f2 <gc_block+0x8>
    1f00:	80 93 b1 05 	sts	0x05B1, r24	; 0x8005b1 <gc_state+0x7>
  if (gc_state.modal.program_flow) {
    1f04:	88 23       	and	r24, r24
    1f06:	09 f4       	brne	.+2      	; 0x1f0a <gc_execute_line+0x13d6>
    1f08:	f3 c0       	rjmp	.+486    	; 0x20f0 <gc_execute_line+0x15bc>
    protocol_buffer_synchronize(); // Sync and finish all remaining buffered motions before moving on.
    1f0a:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <protocol_buffer_synchronize>
    if (gc_state.modal.program_flow == PROGRAM_FLOW_PAUSED) {
    1f0e:	80 91 b1 05 	lds	r24, 0x05B1	; 0x8005b1 <gc_state+0x7>
    1f12:	83 30       	cpi	r24, 0x03	; 3
    1f14:	51 f4       	brne	.+20     	; 0x1f2a <gc_execute_line+0x13f6>
      if (sys.state != STATE_CHECK_MODE) {
    1f16:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    1f1a:	82 30       	cpi	r24, 0x02	; 2
    1f1c:	79 f1       	breq	.+94     	; 0x1f7c <gc_execute_line+0x1448>
        system_set_exec_state_flag(EXEC_FEED_HOLD); // Use feed hold for program pause.
    1f1e:	88 e0       	ldi	r24, 0x08	; 8
    1f20:	0e 94 21 2e 	call	0x5c42	; 0x5c42 <system_set_exec_state_flag>
        protocol_execute_realtime(); // Execute suspend.
    1f24:	0e 94 9e 14 	call	0x293c	; 0x293c <protocol_execute_realtime>
    1f28:	29 c0       	rjmp	.+82     	; 0x1f7c <gc_execute_line+0x1448>
    } else { // == PROGRAM_FLOW_COMPLETED
      // Upon program complete, only a subset of g-codes reset to certain defaults, according to
      // LinuxCNC's program end descriptions and testing. Only modal groups [G-code 1,2,3,5,7,12]
      // and [M-code 7,8,9] reset to [G1,G17,G90,G94,G40,G54,M5,M9,M48]. The remaining modal groups
      // [G-code 4,6,8,10,13,14,15] and [M-code 4,5,6] and the modal words [F,S,T,H] do not reset.
      gc_state.modal.motion = MOTION_MODE_LINEAR;
    1f2a:	ea ea       	ldi	r30, 0xAA	; 170
    1f2c:	f5 e0       	ldi	r31, 0x05	; 5
    1f2e:	81 e0       	ldi	r24, 0x01	; 1
    1f30:	80 83       	st	Z, r24
      gc_state.modal.plane_select = PLANE_SELECT_XY;
    1f32:	14 82       	std	Z+4, r1	; 0x04
      gc_state.modal.distance = DISTANCE_MODE_ABSOLUTE;
    1f34:	13 82       	std	Z+3, r1	; 0x03
      gc_state.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
    1f36:	11 82       	std	Z+1, r1	; 0x01
      // gc_state.modal.cutter_comp = CUTTER_COMP_DISABLE; // Not supported.
      gc_state.modal.coord_select = 0; // G54
    1f38:	16 82       	std	Z+6, r1	; 0x06
      gc_state.modal.spindle = SPINDLE_DISABLE;
    1f3a:	11 86       	std	Z+9, r1	; 0x09
      gc_state.modal.coolant = COOLANT_DISABLE;
    1f3c:	10 86       	std	Z+8, r1	; 0x08
          gc_state.modal.override = OVERRIDE_PARKING_MOTION;
        #endif
      #endif

      #ifdef RESTORE_OVERRIDES_AFTER_PROGRAM_END
        sys.f_override = DEFAULT_FEED_OVERRIDE;
    1f3e:	ec e7       	ldi	r30, 0x7C	; 124
    1f40:	f5 e0       	ldi	r31, 0x05	; 5
    1f42:	84 e6       	ldi	r24, 0x64	; 100
    1f44:	87 83       	std	Z+7, r24	; 0x07
        sys.r_override = DEFAULT_RAPID_OVERRIDE;
    1f46:	80 87       	std	Z+8, r24	; 0x08
        sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE;
    1f48:	81 87       	std	Z+9, r24	; 0x09
      #endif

      // Execute coordinate change and spindle/coolant stop.
      if (sys.state != STATE_CHECK_MODE) {
    1f4a:	80 81       	ld	r24, Z
    1f4c:	82 30       	cpi	r24, 0x02	; 2
    1f4e:	99 f0       	breq	.+38     	; 0x1f76 <gc_execute_line+0x1442>
        if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    1f50:	6e ec       	ldi	r22, 0xCE	; 206
    1f52:	75 e0       	ldi	r23, 0x05	; 5
    1f54:	80 e0       	ldi	r24, 0x00	; 0
    1f56:	0e 94 3f 23 	call	0x467e	; 0x467e <settings_read_coord_data>
    1f5a:	88 23       	and	r24, r24
    1f5c:	09 f4       	brne	.+2      	; 0x1f60 <gc_execute_line+0x142c>
    1f5e:	7c c0       	rjmp	.+248    	; 0x2058 <gc_execute_line+0x1524>
        system_flag_wco_change(); // Set to refresh immediately just in case something altered.
    1f60:	0e 94 7a 2d 	call	0x5af4	; 0x5af4 <system_flag_wco_change>
        spindle_set_state(SPINDLE_DISABLE,0.0);
    1f64:	40 e0       	ldi	r20, 0x00	; 0
    1f66:	50 e0       	ldi	r21, 0x00	; 0
    1f68:	ba 01       	movw	r22, r20
    1f6a:	80 e0       	ldi	r24, 0x00	; 0
    1f6c:	0e 94 71 11 	call	0x22e2	; 0x22e2 <spindle_set_state>
        coolant_set_state(COOLANT_DISABLE);
    1f70:	80 e0       	ldi	r24, 0x00	; 0
    1f72:	0e 94 be 11 	call	0x237c	; 0x237c <coolant_set_state>
      }
      report_feedback_message(MESSAGE_PROGRAM_END);
    1f76:	88 e0       	ldi	r24, 0x08	; 8
    1f78:	0e 94 f0 2c 	call	0x59e0	; 0x59e0 <report_feedback_message>
    }
    gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; // Reset program flow.
    1f7c:	10 92 b1 05 	sts	0x05B1, r1	; 0x8005b1 <gc_state+0x7>
  }

  // TODO: % to denote start of program.

  return(STATUS_OK);
    1f80:	8d 2d       	mov	r24, r13
    1f82:	b6 c0       	rjmp	.+364    	; 0x20f0 <gc_execute_line+0x15bc>

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.

    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
    1f84:	81 e0       	ldi	r24, 0x01	; 1
    1f86:	b4 c0       	rjmp	.+360    	; 0x20f0 <gc_execute_line+0x15bc>
    char_counter++;
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
    1f88:	82 e0       	ldi	r24, 0x02	; 2
    1f8a:	b2 c0       	rjmp	.+356    	; 0x20f0 <gc_execute_line+0x15bc>
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
    1f8c:	84 e1       	ldi	r24, 0x14	; 20
    1f8e:	b0 c0       	rjmp	.+352    	; 0x20f0 <gc_execute_line+0x15bc>
        switch(int_value) {
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    1f90:	88 e1       	ldi	r24, 0x18	; 24
    1f92:	ae c0       	rjmp	.+348    	; 0x20f0 <gc_execute_line+0x15bc>
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
              if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); }
    1f94:	84 e1       	ldi	r24, 0x14	; 20
    1f96:	ac c0       	rjmp	.+344    	; 0x20f0 <gc_execute_line+0x15bc>
            }                
            break;
          case 0: case 1: case 2: case 3: case 38:
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    1f98:	88 e1       	ldi	r24, 0x18	; 24
    1f9a:	aa c0       	rjmp	.+340    	; 0x20f0 <gc_execute_line+0x15bc>
          case 80:
            word_bit = MODAL_GROUP_G1;
            gc_block.modal.motion = int_value;
            if (int_value == 38){
              if (!((mantissa == 20) || (mantissa == 30) || (mantissa == 40) || (mantissa == 50))) {
                FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
    1f9c:	84 e1       	ldi	r24, 0x14	; 20
    1f9e:	a8 c0       	rjmp	.+336    	; 0x20f0 <gc_execute_line+0x15bc>
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3;
              gc_block.modal.distance = int_value - 90;
            } else {
              word_bit = MODAL_GROUP_G4;
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
    1fa0:	84 e1       	ldi	r24, 0x14	; 20
    1fa2:	a6 c0       	rjmp	.+332    	; 0x20f0 <gc_execute_line+0x15bc>
    1fa4:	84 e1       	ldi	r24, 0x14	; 20
    1fa6:	a4 c0       	rjmp	.+328    	; 0x20f0 <gc_execute_line+0x15bc>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
    1fa8:	88 e1       	ldi	r24, 0x18	; 24
    1faa:	a2 c0       	rjmp	.+324    	; 0x20f0 <gc_execute_line+0x15bc>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
            } else if (mantissa == 10) { // G43.1
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
    1fac:	84 e1       	ldi	r24, 0x14	; 20
    1fae:	a0 c0       	rjmp	.+320    	; 0x20f0 <gc_execute_line+0x15bc>
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
            break;
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
    1fb0:	84 e1       	ldi	r24, 0x14	; 20
    1fb2:	9e c0       	rjmp	.+316    	; 0x20f0 <gc_execute_line+0x15bc>
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    1fb4:	87 e1       	ldi	r24, 0x17	; 23
    1fb6:	9c c0       	rjmp	.+312    	; 0x20f0 <gc_execute_line+0x15bc>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    1fb8:	85 e1       	ldi	r24, 0x15	; 21
    1fba:	9a c0       	rjmp	.+308    	; 0x20f0 <gc_execute_line+0x15bc>
        break;

      case 'M':

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
    1fbc:	87 e1       	ldi	r24, 0x17	; 23
    1fbe:	98 c0       	rjmp	.+304    	; 0x20f0 <gc_execute_line+0x15bc>
            case 56:
              word_bit = MODAL_GROUP_M9;
              gc_block.modal.override = OVERRIDE_PARKING_MOTION;
              break;
          #endif
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
    1fc0:	84 e1       	ldi	r24, 0x14	; 20
    1fc2:	96 c0       	rjmp	.+300    	; 0x20f0 <gc_execute_line+0x15bc>
        }

        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    1fc4:	85 e1       	ldi	r24, 0x15	; 21
    1fc6:	94 c0       	rjmp	.+296    	; 0x20f0 <gc_execute_line+0x15bc>
            gc_block.values.t = int_value;
						break;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
    1fc8:	84 e1       	ldi	r24, 0x14	; 20
    1fca:	92 c0       	rjmp	.+292    	; 0x20f0 <gc_execute_line+0x15bc>
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; 
					  if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
    1fcc:	86 e2       	ldi	r24, 0x26	; 38
    1fce:	90 c0       	rjmp	.+288    	; 0x20f0 <gc_execute_line+0x15bc>
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
        }

        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    1fd0:	89 e1       	ldi	r24, 0x19	; 25
    1fd2:	8e c0       	rjmp	.+284    	; 0x20f0 <gc_execute_line+0x15bc>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    1fd4:	84 e0       	ldi	r24, 0x04	; 4
    1fd6:	8c c0       	rjmp	.+280    	; 0x20f0 <gc_execute_line+0x15bc>
  }

  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    1fd8:	8b e1       	ldi	r24, 0x1B	; 27
    1fda:	8a c0       	rjmp	.+276    	; 0x20f0 <gc_execute_line+0x15bc>

  // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
  //   is not defined after switching to G94 from G93.
  // NOTE: For jogging, ignore prior feed rate mode. Enforce G94 and check for required F word.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); }
    1fdc:	86 e1       	ldi	r24, 0x16	; 22
    1fde:	88 c0       	rjmp	.+272    	; 0x20f0 <gc_execute_line+0x15bc>
  } else {
    if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
      // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
      if (axis_command == AXIS_COMMAND_MOTION_MODE) {
        if ((gc_block.modal.motion != MOTION_MODE_NONE) && (gc_block.modal.motion != MOTION_MODE_SEEK)) {
          if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    1fe0:	86 e1       	ldi	r24, 0x16	; 22
    1fe2:	86 c0       	rjmp	.+268    	; 0x20f0 <gc_execute_line+0x15bc>
    }
  #endif

  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    1fe4:	8c e1       	ldi	r24, 0x1C	; 28
    1fe6:	84 c0       	rjmp	.+264    	; 0x20f0 <gc_execute_line+0x15bc>
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    1fe8:	85 e2       	ldi	r24, 0x25	; 37
    1fea:	82 c0       	rjmp	.+260    	; 0x20f0 <gc_execute_line+0x15bc>
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  float block_coord_system[N_AXIS];
  memcpy(block_coord_system,gc_state.coord_system,sizeof(gc_state.coord_system));
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    1fec:	8d e1       	ldi	r24, 0x1D	; 29
    1fee:	80 c0       	rjmp	.+256    	; 0x20f0 <gc_execute_line+0x15bc>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
      if (!(settings_read_coord_data(gc_block.modal.coord_select,block_coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    1ff0:	87 e0       	ldi	r24, 0x07	; 7
    1ff2:	7e c0       	rjmp	.+252    	; 0x20f0 <gc_execute_line+0x15bc>
  switch (gc_block.non_modal_command) {
    case NON_MODAL_SET_COORDINATE_DATA:
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    1ff4:	8a e1       	ldi	r24, 0x1A	; 26
    1ff6:	7c c0       	rjmp	.+248    	; 0x20f0 <gc_execute_line+0x15bc>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    1ff8:	8c e1       	ldi	r24, 0x1C	; 28
    1ffa:	7a c0       	rjmp	.+244    	; 0x20f0 <gc_execute_line+0x15bc>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    1ffc:	8d e1       	ldi	r24, 0x1D	; 29
    1ffe:	78 c0       	rjmp	.+240    	; 0x20f0 <gc_execute_line+0x15bc>
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
    2000:	84 e1       	ldi	r24, 0x14	; 20
    2002:	76 c0       	rjmp	.+236    	; 0x20f0 <gc_execute_line+0x15bc>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    2004:	84 e1       	ldi	r24, 0x14	; 20
    2006:	74 c0       	rjmp	.+232    	; 0x20f0 <gc_execute_line+0x15bc>
      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
      
      // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    2008:	87 e0       	ldi	r24, 0x07	; 7
    200a:	72 c0       	rjmp	.+228    	; 0x20f0 <gc_execute_line+0x15bc>
        } // Else, keep current stored value.
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    200c:	8a e1       	ldi	r24, 0x1A	; 26
    200e:	70 c0       	rjmp	.+224    	; 0x20f0 <gc_execute_line+0x15bc>

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    2010:	8f e1       	ldi	r24, 0x1F	; 31
    2012:	6e c0       	rjmp	.+220    	; 0x20f0 <gc_execute_line+0x15bc>
        case NON_MODAL_GO_HOME_1: // G30
          // [G28/30 Errors]: Cutter compensation is enabled.
          // Retreive G28/30 go-home position data (in machine coordinates) from EEPROM
          // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
          if (gc_block.non_modal_command == NON_MODAL_GO_HOME_0) {
            if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    2014:	87 e0       	ldi	r24, 0x07	; 7
    2016:	6c c0       	rjmp	.+216    	; 0x20f0 <gc_execute_line+0x15bc>
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    2018:	87 e0       	ldi	r24, 0x07	; 7
    201a:	6a c0       	rjmp	.+212    	; 0x20f0 <gc_execute_line+0x15bc>
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
            FAIL(STATUS_GCODE_G53_INVALID_MOTION_MODE); // [G53 G0/1 not active]
    201c:	8e e1       	ldi	r24, 0x1E	; 30
    201e:	68 c0       	rjmp	.+208    	; 0x20f0 <gc_execute_line+0x15bc>

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    2020:	8f e1       	ldi	r24, 0x1F	; 31
    2022:	66 c0       	rjmp	.+204    	; 0x20f0 <gc_execute_line+0x15bc>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    2024:	86 e1       	ldi	r24, 0x16	; 22
    2026:	64 c0       	rjmp	.+200    	; 0x20f0 <gc_execute_line+0x15bc>
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.

          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    2028:	8a e1       	ldi	r24, 0x1A	; 26
    202a:	62 c0       	rjmp	.+196    	; 0x20f0 <gc_execute_line+0x15bc>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    202c:	80 e2       	ldi	r24, 0x20	; 32
    202e:	60 c0       	rjmp	.+192    	; 0x20f0 <gc_execute_line+0x15bc>
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target

          if (value_words & bit(WORD_R)) { // Arc Radius Mode
            bit_false(value_words,bit(WORD_R));
            if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    2030:	81 e2       	ldi	r24, 0x21	; 33
    2032:	5e c0       	rjmp	.+188    	; 0x20f0 <gc_execute_line+0x15bc>

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    2034:	82 e2       	ldi	r24, 0x22	; 34
    2036:	5c c0       	rjmp	.+184    	; 0x20f0 <gc_execute_line+0x15bc>
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));

          } else { // Arc Center Format Offset Mode
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    2038:	83 e2       	ldi	r24, 0x23	; 35
    203a:	5a c0       	rjmp	.+180    	; 0x20f0 <gc_execute_line+0x15bc>
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]);

            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
            if (delta_r > 0.005) {
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    203c:	81 e2       	ldi	r24, 0x21	; 33
    203e:	58 c0       	rjmp	.+176    	; 0x20f0 <gc_execute_line+0x15bc>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    2040:	81 e2       	ldi	r24, 0x21	; 33
    2042:	56 c0       	rjmp	.+172    	; 0x20f0 <gc_execute_line+0x15bc>
              (gc_block.modal.motion == MOTION_MODE_PROBE_AWAY_NO_ERROR)) { gc_parser_flags |= GC_PARSER_PROBE_IS_AWAY; }
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    2044:	8a e1       	ldi	r24, 0x1A	; 26
    2046:	54 c0       	rjmp	.+168    	; 0x20f0 <gc_execute_line+0x15bc>
          if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    2048:	81 e2       	ldi	r24, 0x21	; 33
    204a:	52 c0       	rjmp	.+164    	; 0x20f0 <gc_execute_line+0x15bc>
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)));
  } else {
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words.
  }
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words.
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    204c:	84 e2       	ldi	r24, 0x24	; 36
    204e:	50 c0       	rjmp	.+160    	; 0x20f0 <gc_execute_line+0x15bc>
  // targets are computed correctly. The final parser position after a jog is updated in
  // protocol_execute_realtime() when jogging completes or is canceled.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    // Only distance and unit modal commands and G53 absolute override command are allowed.
    // NOTE: Feed rate word and axis word checks have already been performed in STEP 3.
    if (command_words & ~(bit(MODAL_GROUP_G3) | bit(MODAL_GROUP_G6) | bit(MODAL_GROUP_G0)) ) { FAIL(STATUS_INVALID_JOG_COMMAND) };
    2050:	80 e1       	ldi	r24, 0x10	; 16
    2052:	4e c0       	rjmp	.+156    	; 0x20f0 <gc_execute_line+0x15bc>
    if (!(gc_block.non_modal_command == NON_MODAL_ABSOLUTE_OVERRIDE || gc_block.non_modal_command == NON_MODAL_NO_ACTION)) { FAIL(STATUS_INVALID_JOG_COMMAND); }
    2054:	80 e1       	ldi	r24, 0x10	; 16
    2056:	4c c0       	rjmp	.+152    	; 0x20f0 <gc_execute_line+0x15bc>
        sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE;
      #endif

      // Execute coordinate change and spindle/coolant stop.
      if (sys.state != STATE_CHECK_MODE) {
        if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    2058:	87 e0       	ldi	r24, 0x07	; 7
    205a:	4a c0       	rjmp	.+148    	; 0x20f0 <gc_execute_line+0x15bc>

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    205c:	8f e1       	ldi	r24, 0x1F	; 31
    205e:	48 c0       	rjmp	.+144    	; 0x20f0 <gc_execute_line+0x15bc>
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
  else { char_counter = 0; }
    2060:	19 82       	std	Y+1, r1	; 0x01
  uint8_t ijk_words = 0; // IJK tracking

  // Initialize command and value words and parser flags variables.
  uint16_t command_words = 0; // Tracks G and M command words. Also used for modal group violations.
  uint16_t value_words = 0; // Tracks value words.
  uint8_t gc_parser_flags = GC_PARSER_NONE;
    2062:	18 a2       	std	Y+32, r1	; 0x20
    2064:	0c 94 d4 05 	jmp	0xba8	; 0xba8 <gc_execute_line+0x74>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
    2068:	aa ee       	ldi	r26, 0xEA	; 234
    206a:	b5 e0       	ldi	r27, 0x05	; 5
    206c:	ac 92       	st	X, r10
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
    206e:	bc e1       	ldi	r27, 0x1C	; 28
    2070:	ab 12       	cpse	r10, r27
    2072:	27 c0       	rjmp	.+78     	; 0x20c2 <gc_execute_line+0x158e>
    2074:	0c 94 4b 06 	jmp	0xc96	; 0xc96 <gc_execute_line+0x162>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
    2078:	ea ee       	ldi	r30, 0xEA	; 234
    207a:	f5 e0       	ldi	r31, 0x05	; 5
    207c:	a0 82       	st	Z, r10
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
    207e:	fc e1       	ldi	r31, 0x1C	; 28
    2080:	af 12       	cpse	r10, r31
    2082:	25 c0       	rjmp	.+74     	; 0x20ce <gc_execute_line+0x159a>
    2084:	0c 94 4f 06 	jmp	0xc9e	; 0xc9e <gc_execute_line+0x16a>
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
    2088:	21 e0       	ldi	r18, 0x01	; 1
    208a:	2b a7       	std	Y+43, r18	; 0x2b
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
    208c:	1a a2       	std	Y+34, r1	; 0x22
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
    208e:	32 e0       	ldi	r19, 0x02	; 2
    2090:	39 a3       	std	Y+33, r19	; 0x21
  }

  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    2092:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <gc_block+0x3>
    2096:	81 30       	cpi	r24, 0x01	; 1
    2098:	09 f0       	breq	.+2      	; 0x209c <gc_execute_line+0x1568>
    209a:	9d c8       	rjmp	.-3782   	; 0x11d6 <gc_execute_line+0x6a2>
    209c:	68 c8       	rjmp	.-3888   	; 0x116e <gc_execute_line+0x63a>
          if (gc_block.non_modal_command == NON_MODAL_GO_HOME_0) {
            if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
          }
          if (axis_words) {
    209e:	4d 8d       	ldd	r20, Y+29	; 0x1d
    20a0:	44 23       	and	r20, r20
    20a2:	f1 f0       	breq	.+60     	; 0x20e0 <gc_execute_line+0x15ac>
    20a4:	aa ea       	ldi	r26, 0xAA	; 170
    20a6:	b5 e0       	ldi	r27, 0x05	; 5
    20a8:	ea ee       	ldi	r30, 0xEA	; 234
    20aa:	f5 e0       	ldi	r31, 0x05	; 5
    20ac:	80 e0       	ldi	r24, 0x00	; 0
    20ae:	90 e0       	ldi	r25, 0x00	; 0
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
    20b0:	24 2f       	mov	r18, r20
    20b2:	30 e0       	ldi	r19, 0x00	; 0
    20b4:	81 ca       	rjmp	.-2814   	; 0x15b8 <gc_execute_line+0xa84>
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    20b6:	10 91 eb 05 	lds	r17, 0x05EB	; 0x8005eb <gc_block+0x1>
    20ba:	10 35       	cpi	r17, 0x50	; 80
    20bc:	09 f0       	breq	.+2      	; 0x20c0 <gc_execute_line+0x158c>
    20be:	a6 ca       	rjmp	.-2740   	; 0x160c <gc_execute_line+0xad8>
    20c0:	cd cf       	rjmp	.-102    	; 0x205c <gc_execute_line+0x1528>
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
    20c2:	ae e1       	ldi	r26, 0x1E	; 30
    20c4:	aa 12       	cpse	r10, r26
    20c6:	0c 94 46 06 	jmp	0xc8c	; 0xc8c <gc_execute_line+0x158>
    20ca:	0c 94 4b 06 	jmp	0xc96	; 0xc96 <gc_execute_line+0x162>
    20ce:	be e1       	ldi	r27, 0x1E	; 30
    20d0:	ab 16       	cp	r10, r27
    20d2:	11 f4       	brne	.+4      	; 0x20d8 <gc_execute_line+0x15a4>
    20d4:	0c 94 52 06 	jmp	0xca4	; 0xca4 <gc_execute_line+0x170>
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
    20d8:	e1 e0       	ldi	r30, 0x01	; 1
    20da:	ee 8f       	std	Y+30, r30	; 0x1e
    20dc:	0c 94 46 06 	jmp	0xc8c	; 0xc8c <gc_execute_line+0x158>
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    20e0:	10 91 eb 05 	lds	r17, 0x05EB	; 0x8005eb <gc_block+0x1>
    20e4:	10 35       	cpi	r17, 0x50	; 80
    20e6:	09 f4       	brne	.+2      	; 0x20ea <gc_execute_line+0x15b6>
    20e8:	d4 cc       	rjmp	.-1624   	; 0x1a92 <gc_execute_line+0xf5e>
    20ea:	1b 8e       	std	Y+27, r1	; 0x1b
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
            }
          } else {
            axis_command = AXIS_COMMAND_NONE; // Set to none if no intermediate motion.
    20ec:	1e 8e       	std	Y+30, r1	; 0x1e
    20ee:	8e ca       	rjmp	.-2788   	; 0x160c <gc_execute_line+0xad8>
  }

  // TODO: % to denote start of program.

  return(STATUS_OK);
}
    20f0:	ad 96       	adiw	r28, 0x2d	; 45
    20f2:	0f b6       	in	r0, 0x3f	; 63
    20f4:	f8 94       	cli
    20f6:	de bf       	out	0x3e, r29	; 62
    20f8:	0f be       	out	0x3f, r0	; 63
    20fa:	cd bf       	out	0x3d, r28	; 61
    20fc:	df 91       	pop	r29
    20fe:	cf 91       	pop	r28
    2100:	1f 91       	pop	r17
    2102:	0f 91       	pop	r16
    2104:	ff 90       	pop	r15
    2106:	ef 90       	pop	r14
    2108:	df 90       	pop	r13
    210a:	cf 90       	pop	r12
    210c:	bf 90       	pop	r11
    210e:	af 90       	pop	r10
    2110:	9f 90       	pop	r9
    2112:	8f 90       	pop	r8
    2114:	7f 90       	pop	r7
    2116:	6f 90       	pop	r6
    2118:	5f 90       	pop	r5
    211a:	4f 90       	pop	r4
    211c:	3f 90       	pop	r3
    211e:	2f 90       	pop	r2
    2120:	08 95       	ret

00002122 <spindle_stop>:
// Called by various main program and ISR routines. Keep routine small, fast, and efficient.
// Called by spindle_init(), spindle_set_speed(), spindle_set_state(), and mc_reset().
void spindle_stop()
{
  #ifdef VARIABLE_SPINDLE
    SPINDLE_TCCRA_REGISTER &= ~(1<<SPINDLE_COMB_BIT); // Disable PWM. Output voltage is zero.
    2122:	e0 eb       	ldi	r30, 0xB0	; 176
    2124:	f0 e0       	ldi	r31, 0x00	; 0
    2126:	80 81       	ld	r24, Z
    2128:	8f 77       	andi	r24, 0x7F	; 127
    212a:	80 83       	st	Z, r24
    212c:	08 95       	ret

0000212e <spindle_init>:
void spindle_init()
{
  #ifdef VARIABLE_SPINDLE
    // Configure variable spindle PWM and enable pin, if requried. On the Uno, PWM and enable are
    // combined unless configured otherwise.
    SPINDLE_PWM_DDR |= (1<<SPINDLE_PWM_BIT); // Configure as PWM output pin.
    212e:	23 9a       	sbi	0x04, 3	; 4
    SPINDLE_TCCRA_REGISTER = SPINDLE_TCCRA_INIT_MASK; // Configure PWM output compare timer
    2130:	83 e0       	ldi	r24, 0x03	; 3
    2132:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    SPINDLE_TCCRB_REGISTER = SPINDLE_TCCRB_INIT_MASK;
    2136:	84 e0       	ldi	r24, 0x04	; 4
    2138:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
    #ifdef USE_SPINDLE_DIR_AS_ENABLE_PIN
      SPINDLE_ENABLE_DDR |= (1<<SPINDLE_ENABLE_BIT); // Configure as output pin.
    #else
      #ifndef ENABLE_DUAL_AXIS
        SPINDLE_DIRECTION_DDR |= (1<<SPINDLE_DIRECTION_BIT); // Configure as output pin.
    213c:	25 9a       	sbi	0x04, 5	; 4
      #endif
    #endif
    pwm_gradient = SPINDLE_PWM_RANGE/(settings.rpm_max-settings.rpm_min);
    213e:	20 91 4f 07 	lds	r18, 0x074F	; 0x80074f <settings+0x41>
    2142:	30 91 50 07 	lds	r19, 0x0750	; 0x800750 <settings+0x42>
    2146:	40 91 51 07 	lds	r20, 0x0751	; 0x800751 <settings+0x43>
    214a:	50 91 52 07 	lds	r21, 0x0752	; 0x800752 <settings+0x44>
    214e:	60 91 4b 07 	lds	r22, 0x074B	; 0x80074b <settings+0x3d>
    2152:	70 91 4c 07 	lds	r23, 0x074C	; 0x80074c <settings+0x3e>
    2156:	80 91 4d 07 	lds	r24, 0x074D	; 0x80074d <settings+0x3f>
    215a:	90 91 4e 07 	lds	r25, 0x074E	; 0x80074e <settings+0x40>
    215e:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    2162:	9b 01       	movw	r18, r22
    2164:	ac 01       	movw	r20, r24
    2166:	60 e0       	ldi	r22, 0x00	; 0
    2168:	70 e0       	ldi	r23, 0x00	; 0
    216a:	8e e7       	ldi	r24, 0x7E	; 126
    216c:	93 e4       	ldi	r25, 0x43	; 67
    216e:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <__divsf3>
    2172:	60 93 02 01 	sts	0x0102, r22	; 0x800102 <__data_end>
    2176:	70 93 03 01 	sts	0x0103, r23	; 0x800103 <__data_end+0x1>
    217a:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <__data_end+0x2>
    217e:	90 93 05 01 	sts	0x0105, r25	; 0x800105 <__data_end+0x3>
    #ifndef ENABLE_DUAL_AXIS
      SPINDLE_DIRECTION_DDR |= (1<<SPINDLE_DIRECTION_BIT); // Configure as output pin.
    #endif
  #endif

  spindle_stop();
    2182:	0e 94 91 10 	call	0x2122	; 0x2122 <spindle_stop>
    2186:	08 95       	ret

00002188 <spindle_set_speed>:
#ifdef VARIABLE_SPINDLE
  // Sets spindle speed PWM output and enable pin, if configured. Called by spindle_set_state()
  // and stepper ISR. Keep routine small and efficient.
  void spindle_set_speed(uint8_t pwm_value)
  {
    SPINDLE_OCR_REGISTER = pwm_value; // Set PWM output level.
    2188:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
        #else
          SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);
        #endif
      }
    #else
      if (pwm_value == SPINDLE_PWM_OFF_VALUE) {
    218c:	81 11       	cpse	r24, r1
    218e:	06 c0       	rjmp	.+12     	; 0x219c <spindle_set_speed+0x14>
        SPINDLE_TCCRA_REGISTER &= ~(1<<SPINDLE_COMB_BIT); // Disable PWM. Output voltage is zero.
    2190:	e0 eb       	ldi	r30, 0xB0	; 176
    2192:	f0 e0       	ldi	r31, 0x00	; 0
    2194:	80 81       	ld	r24, Z
    2196:	8f 77       	andi	r24, 0x7F	; 127
    2198:	80 83       	st	Z, r24
    219a:	08 95       	ret
      } else {
        SPINDLE_TCCRA_REGISTER |= (1<<SPINDLE_COMB_BIT); // Ensure PWM output is enabled.
    219c:	e0 eb       	ldi	r30, 0xB0	; 176
    219e:	f0 e0       	ldi	r31, 0x00	; 0
    21a0:	80 81       	ld	r24, Z
    21a2:	80 68       	ori	r24, 0x80	; 128
    21a4:	80 83       	st	Z, r24
    21a6:	08 95       	ret

000021a8 <spindle_compute_pwm_value>:
    
  #else 
  
    // Called by spindle_set_state() and step segment generator. Keep routine small and efficient.
    uint8_t spindle_compute_pwm_value(float rpm) // 328p PWM register is 8-bit.
    {
    21a8:	4f 92       	push	r4
    21aa:	5f 92       	push	r5
    21ac:	6f 92       	push	r6
    21ae:	7f 92       	push	r7
    21b0:	8f 92       	push	r8
    21b2:	9f 92       	push	r9
    21b4:	af 92       	push	r10
    21b6:	bf 92       	push	r11
    21b8:	cf 92       	push	r12
    21ba:	df 92       	push	r13
    21bc:	ef 92       	push	r14
    21be:	ff 92       	push	r15
    21c0:	2b 01       	movw	r4, r22
    21c2:	3c 01       	movw	r6, r24
      uint8_t pwm_value;
      rpm *= (0.010*sys.spindle_speed_ovr); // Scale by spindle speed override value.
      // Calculate PWM register value based on rpm max/min settings and programmed rpm.
      if ((settings.rpm_min >= settings.rpm_max) || (rpm >= settings.rpm_max)) {
    21c4:	80 90 4f 07 	lds	r8, 0x074F	; 0x80074f <settings+0x41>
    21c8:	90 90 50 07 	lds	r9, 0x0750	; 0x800750 <settings+0x42>
    21cc:	a0 90 51 07 	lds	r10, 0x0751	; 0x800751 <settings+0x43>
    21d0:	b0 90 52 07 	lds	r11, 0x0752	; 0x800752 <settings+0x44>
    21d4:	c0 90 4b 07 	lds	r12, 0x074B	; 0x80074b <settings+0x3d>
    21d8:	d0 90 4c 07 	lds	r13, 0x074C	; 0x80074c <settings+0x3e>
    21dc:	e0 90 4d 07 	lds	r14, 0x074D	; 0x80074d <settings+0x3f>
    21e0:	f0 90 4e 07 	lds	r15, 0x074E	; 0x80074e <settings+0x40>
    21e4:	a7 01       	movw	r20, r14
    21e6:	96 01       	movw	r18, r12
    21e8:	c5 01       	movw	r24, r10
    21ea:	b4 01       	movw	r22, r8
    21ec:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    21f0:	88 23       	and	r24, r24
    21f2:	cc f4       	brge	.+50     	; 0x2226 <spindle_compute_pwm_value+0x7e>
  
    // Called by spindle_set_state() and step segment generator. Keep routine small and efficient.
    uint8_t spindle_compute_pwm_value(float rpm) // 328p PWM register is 8-bit.
    {
      uint8_t pwm_value;
      rpm *= (0.010*sys.spindle_speed_ovr); // Scale by spindle speed override value.
    21f4:	60 91 85 05 	lds	r22, 0x0585	; 0x800585 <sys+0x9>
    21f8:	70 e0       	ldi	r23, 0x00	; 0
    21fa:	80 e0       	ldi	r24, 0x00	; 0
    21fc:	90 e0       	ldi	r25, 0x00	; 0
    21fe:	0e 94 08 30 	call	0x6010	; 0x6010 <__floatsisf>
    2202:	2a e0       	ldi	r18, 0x0A	; 10
    2204:	37 ed       	ldi	r19, 0xD7	; 215
    2206:	43 e2       	ldi	r20, 0x23	; 35
    2208:	5c e3       	ldi	r21, 0x3C	; 60
    220a:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    220e:	a3 01       	movw	r20, r6
    2210:	92 01       	movw	r18, r4
    2212:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    2216:	2b 01       	movw	r4, r22
    2218:	3c 01       	movw	r6, r24
      // Calculate PWM register value based on rpm max/min settings and programmed rpm.
      if ((settings.rpm_min >= settings.rpm_max) || (rpm >= settings.rpm_max)) {
    221a:	a7 01       	movw	r20, r14
    221c:	96 01       	movw	r18, r12
    221e:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    2222:	88 23       	and	r24, r24
    2224:	54 f0       	brlt	.+20     	; 0x223a <spindle_compute_pwm_value+0x92>
        // No PWM range possible. Set simple on/off spindle control pin state.
        sys.spindle_speed = settings.rpm_max;
    2226:	c0 92 89 05 	sts	0x0589, r12	; 0x800589 <sys+0xd>
    222a:	d0 92 8a 05 	sts	0x058A, r13	; 0x80058a <sys+0xe>
    222e:	e0 92 8b 05 	sts	0x058B, r14	; 0x80058b <sys+0xf>
    2232:	f0 92 8c 05 	sts	0x058C, r15	; 0x80058c <sys+0x10>
        pwm_value = SPINDLE_PWM_MAX_VALUE;
    2236:	8f ef       	ldi	r24, 0xFF	; 255
    2238:	47 c0       	rjmp	.+142    	; 0x22c8 <spindle_compute_pwm_value+0x120>
      } else if (rpm <= settings.rpm_min) {
    223a:	a5 01       	movw	r20, r10
    223c:	94 01       	movw	r18, r8
    223e:	c3 01       	movw	r24, r6
    2240:	b2 01       	movw	r22, r4
    2242:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    2246:	18 16       	cp	r1, r24
    2248:	e4 f0       	brlt	.+56     	; 0x2282 <spindle_compute_pwm_value+0xda>
        if (rpm == 0.0) { // S0 disables spindle
    224a:	20 e0       	ldi	r18, 0x00	; 0
    224c:	30 e0       	ldi	r19, 0x00	; 0
    224e:	a9 01       	movw	r20, r18
    2250:	c3 01       	movw	r24, r6
    2252:	b2 01       	movw	r22, r4
    2254:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    2258:	81 11       	cpse	r24, r1
    225a:	09 c0       	rjmp	.+18     	; 0x226e <spindle_compute_pwm_value+0xc6>
          sys.spindle_speed = 0.0;
    225c:	10 92 89 05 	sts	0x0589, r1	; 0x800589 <sys+0xd>
    2260:	10 92 8a 05 	sts	0x058A, r1	; 0x80058a <sys+0xe>
    2264:	10 92 8b 05 	sts	0x058B, r1	; 0x80058b <sys+0xf>
    2268:	10 92 8c 05 	sts	0x058C, r1	; 0x80058c <sys+0x10>
    226c:	2d c0       	rjmp	.+90     	; 0x22c8 <spindle_compute_pwm_value+0x120>
          pwm_value = SPINDLE_PWM_OFF_VALUE;
        } else { // Set minimum PWM output
          sys.spindle_speed = settings.rpm_min;
    226e:	80 92 89 05 	sts	0x0589, r8	; 0x800589 <sys+0xd>
    2272:	90 92 8a 05 	sts	0x058A, r9	; 0x80058a <sys+0xe>
    2276:	a0 92 8b 05 	sts	0x058B, r10	; 0x80058b <sys+0xf>
    227a:	b0 92 8c 05 	sts	0x058C, r11	; 0x80058c <sys+0x10>
          pwm_value = SPINDLE_PWM_MIN_VALUE;
    227e:	81 e0       	ldi	r24, 0x01	; 1
    2280:	23 c0       	rjmp	.+70     	; 0x22c8 <spindle_compute_pwm_value+0x120>
        }
      } else { 
        // Compute intermediate PWM value with linear spindle speed model.
        // NOTE: A nonlinear model could be installed here, if required, but keep it VERY light-weight.
        sys.spindle_speed = rpm;
    2282:	40 92 89 05 	sts	0x0589, r4	; 0x800589 <sys+0xd>
    2286:	50 92 8a 05 	sts	0x058A, r5	; 0x80058a <sys+0xe>
    228a:	60 92 8b 05 	sts	0x058B, r6	; 0x80058b <sys+0xf>
    228e:	70 92 8c 05 	sts	0x058C, r7	; 0x80058c <sys+0x10>
        pwm_value = floor((rpm-settings.rpm_min)*pwm_gradient) + SPINDLE_PWM_MIN_VALUE;
    2292:	a5 01       	movw	r20, r10
    2294:	94 01       	movw	r18, r8
    2296:	c3 01       	movw	r24, r6
    2298:	b2 01       	movw	r22, r4
    229a:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    229e:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__data_end>
    22a2:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__data_end+0x1>
    22a6:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__data_end+0x2>
    22aa:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__data_end+0x3>
    22ae:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    22b2:	0e 94 43 30 	call	0x6086	; 0x6086 <floor>
    22b6:	20 e0       	ldi	r18, 0x00	; 0
    22b8:	30 e0       	ldi	r19, 0x00	; 0
    22ba:	40 e8       	ldi	r20, 0x80	; 128
    22bc:	5f e3       	ldi	r21, 0x3F	; 63
    22be:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    22c2:	0e 94 d7 2f 	call	0x5fae	; 0x5fae <__fixunssfsi>
    22c6:	86 2f       	mov	r24, r22
      }
      return(pwm_value);
    }
    22c8:	ff 90       	pop	r15
    22ca:	ef 90       	pop	r14
    22cc:	df 90       	pop	r13
    22ce:	cf 90       	pop	r12
    22d0:	bf 90       	pop	r11
    22d2:	af 90       	pop	r10
    22d4:	9f 90       	pop	r9
    22d6:	8f 90       	pop	r8
    22d8:	7f 90       	pop	r7
    22da:	6f 90       	pop	r6
    22dc:	5f 90       	pop	r5
    22de:	4f 90       	pop	r4
    22e0:	08 95       	ret

000022e2 <spindle_set_state>:
  void spindle_set_state(uint8_t state, float rpm)
#else
  void _spindle_set_state(uint8_t state)
#endif
{
  if (sys.abort) { return; } // Block during abort.
    22e2:	90 91 7d 05 	lds	r25, 0x057D	; 0x80057d <sys+0x1>
    22e6:	91 11       	cpse	r25, r1
    22e8:	23 c0       	rjmp	.+70     	; 0x2330 <spindle_set_state+0x4e>

  if (state == SPINDLE_DISABLE) { // Halt or set spindle direction and rpm.
    22ea:	81 11       	cpse	r24, r1
    22ec:	0b c0       	rjmp	.+22     	; 0x2304 <spindle_set_state+0x22>
  
    #ifdef VARIABLE_SPINDLE
      sys.spindle_speed = 0.0;
    22ee:	10 92 89 05 	sts	0x0589, r1	; 0x800589 <sys+0xd>
    22f2:	10 92 8a 05 	sts	0x058A, r1	; 0x80058a <sys+0xe>
    22f6:	10 92 8b 05 	sts	0x058B, r1	; 0x80058b <sys+0xf>
    22fa:	10 92 8c 05 	sts	0x058C, r1	; 0x80058c <sys+0x10>
    #endif
    spindle_stop();
    22fe:	0e 94 91 10 	call	0x2122	; 0x2122 <spindle_stop>
    2302:	14 c0       	rjmp	.+40     	; 0x232c <spindle_set_state+0x4a>
  
  } else {
    
    #if !defined(USE_SPINDLE_DIR_AS_ENABLE_PIN) && !defined(ENABLE_DUAL_AXIS)
      if (state == SPINDLE_ENABLE_CW) {
    2304:	80 31       	cpi	r24, 0x10	; 16
    2306:	11 f4       	brne	.+4      	; 0x230c <spindle_set_state+0x2a>
        SPINDLE_DIRECTION_PORT &= ~(1<<SPINDLE_DIRECTION_BIT);
    2308:	2d 98       	cbi	0x05, 5	; 5
    230a:	0a c0       	rjmp	.+20     	; 0x2320 <spindle_set_state+0x3e>
      } else {
        SPINDLE_DIRECTION_PORT |= (1<<SPINDLE_DIRECTION_BIT);
    230c:	2d 9a       	sbi	0x05, 5	; 5
      }
    #endif
  
    #ifdef VARIABLE_SPINDLE
      // NOTE: Assumes all calls to this function is when Grbl is not moving or must remain off.
      if (settings.flags & BITFLAG_LASER_MODE) { 
    230e:	90 91 53 07 	lds	r25, 0x0753	; 0x800753 <settings+0x45>
    2312:	91 ff       	sbrs	r25, 1
    2314:	05 c0       	rjmp	.+10     	; 0x2320 <spindle_set_state+0x3e>
        if (state == SPINDLE_ENABLE_CCW) { rpm = 0.0; } // TODO: May need to be rpm_min*(100/MAX_SPINDLE_SPEED_OVERRIDE);
    2316:	80 32       	cpi	r24, 0x20	; 32
    2318:	19 f4       	brne	.+6      	; 0x2320 <spindle_set_state+0x3e>
    231a:	40 e0       	ldi	r20, 0x00	; 0
    231c:	50 e0       	ldi	r21, 0x00	; 0
    231e:	ba 01       	movw	r22, r20
      }
      spindle_set_speed(spindle_compute_pwm_value(rpm));
    2320:	cb 01       	movw	r24, r22
    2322:	ba 01       	movw	r22, r20
    2324:	0e 94 d4 10 	call	0x21a8	; 0x21a8 <spindle_compute_pwm_value>
    2328:	0e 94 c4 10 	call	0x2188	; 0x2188 <spindle_set_speed>
      #endif    
    #endif
  
  }
  
  sys.report_ovr_counter = 0; // Set to report change immediately
    232c:	10 92 87 05 	sts	0x0587, r1	; 0x800587 <sys+0xb>
    2330:	08 95       	ret

00002332 <spindle_sync>:

// G-code parser entry-point for setting spindle state. Forces a planner buffer sync and bails 
// if an abort or check-mode is active.
#ifdef VARIABLE_SPINDLE
  void spindle_sync(uint8_t state, float rpm)
  {
    2332:	cf 92       	push	r12
    2334:	df 92       	push	r13
    2336:	ef 92       	push	r14
    2338:	ff 92       	push	r15
    233a:	cf 93       	push	r28
    if (sys.state == STATE_CHECK_MODE) { return; }
    233c:	90 91 7c 05 	lds	r25, 0x057C	; 0x80057c <sys>
    2340:	92 30       	cpi	r25, 0x02	; 2
    2342:	51 f0       	breq	.+20     	; 0x2358 <spindle_sync+0x26>
    2344:	6a 01       	movw	r12, r20
    2346:	7b 01       	movw	r14, r22
    2348:	c8 2f       	mov	r28, r24
    protocol_buffer_synchronize(); // Empty planner buffer to ensure spindle is set when programmed.
    234a:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <protocol_buffer_synchronize>
    spindle_set_state(state,rpm);
    234e:	b7 01       	movw	r22, r14
    2350:	a6 01       	movw	r20, r12
    2352:	8c 2f       	mov	r24, r28
    2354:	0e 94 71 11 	call	0x22e2	; 0x22e2 <spindle_set_state>
  }
    2358:	cf 91       	pop	r28
    235a:	ff 90       	pop	r15
    235c:	ef 90       	pop	r14
    235e:	df 90       	pop	r13
    2360:	cf 90       	pop	r12
    2362:	08 95       	ret

00002364 <coolant_get_state>:
{
  uint8_t cl_state = COOLANT_STATE_DISABLE;
  #ifdef INVERT_COOLANT_FLOOD_PIN
    if (bit_isfalse(COOLANT_FLOOD_PORT,(1 << COOLANT_FLOOD_BIT))) {
  #else
    if (bit_istrue(COOLANT_FLOOD_PORT,(1 << COOLANT_FLOOD_BIT))) {
    2364:	43 9b       	sbis	0x08, 3	; 8
    2366:	02 c0       	rjmp	.+4      	; 0x236c <coolant_get_state+0x8>
  #endif
    cl_state |= COOLANT_STATE_FLOOD;
    2368:	80 e4       	ldi	r24, 0x40	; 64
    236a:	08 95       	ret


// Returns current coolant output state. Overrides may alter it from programmed state.
uint8_t coolant_get_state()
{
  uint8_t cl_state = COOLANT_STATE_DISABLE;
    236c:	80 e0       	ldi	r24, 0x00	; 0
    #endif
      cl_state |= COOLANT_STATE_MIST;
    }
  #endif
  return(cl_state);
}
    236e:	08 95       	ret

00002370 <coolant_stop>:
void coolant_stop()
{
  #ifdef INVERT_COOLANT_FLOOD_PIN
    COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
  #else
    COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
    2370:	43 98       	cbi	0x08, 3	; 8
    2372:	08 95       	ret

00002374 <coolant_init>:
#include "grbl.h"


void coolant_init()
{
  COOLANT_FLOOD_DDR |= (1 << COOLANT_FLOOD_BIT); // Configure as output pin
    2374:	3b 9a       	sbi	0x07, 3	; 7
  #ifdef ENABLE_M7
    COOLANT_MIST_DDR |= (1 << COOLANT_MIST_BIT);
  #endif
  coolant_stop();
    2376:	0e 94 b8 11 	call	0x2370	; 0x2370 <coolant_stop>
    237a:	08 95       	ret

0000237c <coolant_set_state>:
// if enabled. Also sets a flag to report an update to a coolant state.
// Called by coolant toggle override, parking restore, parking retract, sleep mode, g-code
// parser program end, and g-code parser coolant_sync().
void coolant_set_state(uint8_t mode)
{
  if (sys.abort) { return; } // Block during abort.  
    237c:	90 91 7d 05 	lds	r25, 0x057D	; 0x80057d <sys+0x1>
    2380:	91 11       	cpse	r25, r1
    2382:	07 c0       	rjmp	.+14     	; 0x2392 <coolant_set_state+0x16>
  
	if (mode & COOLANT_FLOOD_ENABLE) {
    2384:	86 ff       	sbrs	r24, 6
    2386:	02 c0       	rjmp	.+4      	; 0x238c <coolant_set_state+0x10>
		#ifdef INVERT_COOLANT_FLOOD_PIN
			COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
		#else
			COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
    2388:	43 9a       	sbi	0x08, 3	; 8
    238a:	01 c0       	rjmp	.+2      	; 0x238e <coolant_set_state+0x12>
		#endif
	} else {
	  #ifdef INVERT_COOLANT_FLOOD_PIN
			COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
		#else
			COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
    238c:	43 98       	cbi	0x08, 3	; 8
				COOLANT_MIST_PORT &= ~(1 << COOLANT_MIST_BIT);
			#endif
		}
	#endif
	
  sys.report_ovr_counter = 0; // Set to report change immediately
    238e:	10 92 87 05 	sts	0x0587, r1	; 0x800587 <sys+0xb>
    2392:	08 95       	ret

00002394 <coolant_sync>:


// G-code parser entry-point for setting coolant state. Forces a planner buffer sync and bails 
// if an abort or check-mode is active.
void coolant_sync(uint8_t mode)
{
    2394:	cf 93       	push	r28
  if (sys.state == STATE_CHECK_MODE) { return; }
    2396:	90 91 7c 05 	lds	r25, 0x057C	; 0x80057c <sys>
    239a:	92 30       	cpi	r25, 0x02	; 2
    239c:	31 f0       	breq	.+12     	; 0x23aa <coolant_sync+0x16>
    239e:	c8 2f       	mov	r28, r24
  protocol_buffer_synchronize(); // Ensure coolant turns on when specified in program.
    23a0:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <protocol_buffer_synchronize>
  coolant_set_state(mode);
    23a4:	8c 2f       	mov	r24, r28
    23a6:	0e 94 be 11 	call	0x237c	; 0x237c <coolant_set_state>
}
    23aa:	cf 91       	pop	r28
    23ac:	08 95       	ret

000023ae <serial_init>:
    if (tail == RX_RING_BUFFER) { tail = 0; }
    serial_rx_buffer_tail = tail;

    return data;
  }
}
    23ae:	e0 ec       	ldi	r30, 0xC0	; 192
    23b0:	f0 e0       	ldi	r31, 0x00	; 0
    23b2:	80 81       	ld	r24, Z
    23b4:	82 60       	ori	r24, 0x02	; 2
    23b6:	80 83       	st	Z, r24
    23b8:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
    23bc:	80 e1       	ldi	r24, 0x10	; 16
    23be:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
    23c2:	e1 ec       	ldi	r30, 0xC1	; 193
    23c4:	f0 e0       	ldi	r31, 0x00	; 0
    23c6:	80 81       	ld	r24, Z
    23c8:	88 69       	ori	r24, 0x98	; 152
    23ca:	80 83       	st	Z, r24
    23cc:	08 95       	ret

000023ce <__vector_19>:
    23ce:	1f 92       	push	r1
    23d0:	0f 92       	push	r0
    23d2:	0f b6       	in	r0, 0x3f	; 63
    23d4:	0f 92       	push	r0
    23d6:	11 24       	eor	r1, r1
    23d8:	8f 93       	push	r24
    23da:	9f 93       	push	r25
    23dc:	ef 93       	push	r30
    23de:	ff 93       	push	r31
    23e0:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <serial_tx_buffer_tail>
    23e4:	e8 2f       	mov	r30, r24
    23e6:	f0 e0       	ldi	r31, 0x00	; 0
    23e8:	ec 5d       	subi	r30, 0xDC	; 220
    23ea:	f9 4f       	sbci	r31, 0xF9	; 249
    23ec:	90 81       	ld	r25, Z
    23ee:	90 93 c6 00 	sts	0x00C6, r25	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
    23f2:	8f 5f       	subi	r24, 0xFF	; 255
    23f4:	89 36       	cpi	r24, 0x69	; 105
    23f6:	09 f4       	brne	.+2      	; 0x23fa <__vector_19+0x2c>
    23f8:	80 e0       	ldi	r24, 0x00	; 0
    23fa:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <serial_tx_buffer_tail>
    23fe:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <serial_tx_buffer_head>
    2402:	89 13       	cpse	r24, r25
    2404:	05 c0       	rjmp	.+10     	; 0x2410 <__vector_19+0x42>
    2406:	e1 ec       	ldi	r30, 0xC1	; 193
    2408:	f0 e0       	ldi	r31, 0x00	; 0
    240a:	80 81       	ld	r24, Z
    240c:	8f 7d       	andi	r24, 0xDF	; 223
    240e:	80 83       	st	Z, r24
    2410:	ff 91       	pop	r31
    2412:	ef 91       	pop	r30
    2414:	9f 91       	pop	r25
    2416:	8f 91       	pop	r24
    2418:	0f 90       	pop	r0
    241a:	0f be       	out	0x3f, r0	; 63
    241c:	0f 90       	pop	r0
    241e:	1f 90       	pop	r1
    2420:	18 95       	reti

00002422 <__vector_18>:


ISR(SERIAL_RX)
{
    2422:	1f 92       	push	r1
    2424:	0f 92       	push	r0
    2426:	0f b6       	in	r0, 0x3f	; 63
    2428:	0f 92       	push	r0
    242a:	11 24       	eor	r1, r1
    242c:	2f 93       	push	r18
    242e:	3f 93       	push	r19
    2430:	4f 93       	push	r20
    2432:	5f 93       	push	r21
    2434:	6f 93       	push	r22
    2436:	7f 93       	push	r23
    2438:	8f 93       	push	r24
    243a:	9f 93       	push	r25
    243c:	af 93       	push	r26
    243e:	bf 93       	push	r27
    2440:	ef 93       	push	r30
    2442:	ff 93       	push	r31
  uint8_t data = UDR0;
    2444:	e0 91 c6 00 	lds	r30, 0x00C6	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
  uint8_t next_head;

  // Pick off realtime command characters directly from the serial stream. These characters are
  // not passed into the main buffer, but these set system state flag bits for realtime execution.
  switch (data) {
    2448:	e1 32       	cpi	r30, 0x21	; 33
    244a:	a1 f0       	breq	.+40     	; 0x2474 <__vector_18+0x52>
    244c:	18 f4       	brcc	.+6      	; 0x2454 <__vector_18+0x32>
    244e:	e8 31       	cpi	r30, 0x18	; 24
    2450:	31 f0       	breq	.+12     	; 0x245e <__vector_18+0x3c>
    2452:	14 c0       	rjmp	.+40     	; 0x247c <__vector_18+0x5a>
    2454:	ef 33       	cpi	r30, 0x3F	; 63
    2456:	31 f0       	breq	.+12     	; 0x2464 <__vector_18+0x42>
    2458:	ee 37       	cpi	r30, 0x7E	; 126
    245a:	41 f0       	breq	.+16     	; 0x246c <__vector_18+0x4a>
    245c:	0f c0       	rjmp	.+30     	; 0x247c <__vector_18+0x5a>
    case CMD_RESET:         mc_reset(); break; // Call motion control reset routine.
    245e:	0e 94 5d 05 	call	0xaba	; 0xaba <mc_reset>
    2462:	7e c0       	rjmp	.+252    	; 0x2560 <__vector_18+0x13e>
    case CMD_STATUS_REPORT: system_set_exec_state_flag(EXEC_STATUS_REPORT); break; // Set as true
    2464:	81 e0       	ldi	r24, 0x01	; 1
    2466:	0e 94 21 2e 	call	0x5c42	; 0x5c42 <system_set_exec_state_flag>
    246a:	7a c0       	rjmp	.+244    	; 0x2560 <__vector_18+0x13e>
    case CMD_CYCLE_START:   system_set_exec_state_flag(EXEC_CYCLE_START); break; // Set as true
    246c:	82 e0       	ldi	r24, 0x02	; 2
    246e:	0e 94 21 2e 	call	0x5c42	; 0x5c42 <system_set_exec_state_flag>
    2472:	76 c0       	rjmp	.+236    	; 0x2560 <__vector_18+0x13e>
    case CMD_FEED_HOLD:     system_set_exec_state_flag(EXEC_FEED_HOLD); break; // Set as true
    2474:	88 e0       	ldi	r24, 0x08	; 8
    2476:	0e 94 21 2e 	call	0x5c42	; 0x5c42 <system_set_exec_state_flag>
    247a:	72 c0       	rjmp	.+228    	; 0x2560 <__vector_18+0x13e>
    default :
      if (data > 0x7F) { // Real-time control characters are extended ACSII only.
    247c:	ee 23       	and	r30, r30
    247e:	0c f0       	brlt	.+2      	; 0x2482 <__vector_18+0x60>
    2480:	5e c0       	rjmp	.+188    	; 0x253e <__vector_18+0x11c>
        switch(data) {
    2482:	8e 2f       	mov	r24, r30
    2484:	90 e0       	ldi	r25, 0x00	; 0
    2486:	fc 01       	movw	r30, r24
    2488:	e4 58       	subi	r30, 0x84	; 132
    248a:	f1 09       	sbc	r31, r1
    248c:	ed 31       	cpi	r30, 0x1D	; 29
    248e:	f1 05       	cpc	r31, r1
    2490:	08 f0       	brcs	.+2      	; 0x2494 <__vector_18+0x72>
    2492:	66 c0       	rjmp	.+204    	; 0x2560 <__vector_18+0x13e>
    2494:	e9 53       	subi	r30, 0x39	; 57
    2496:	ff 4f       	sbci	r31, 0xFF	; 255
    2498:	0c 94 bf 32 	jmp	0x657e	; 0x657e <__tablejump2__>
          case CMD_SAFETY_DOOR:   system_set_exec_state_flag(EXEC_SAFETY_DOOR); break; // Set as true
    249c:	80 e2       	ldi	r24, 0x20	; 32
    249e:	0e 94 21 2e 	call	0x5c42	; 0x5c42 <system_set_exec_state_flag>
    24a2:	5e c0       	rjmp	.+188    	; 0x2560 <__vector_18+0x13e>
          case CMD_JOG_CANCEL:   
            if (sys.state & STATE_JOG) { // Block all other states from invoking motion cancel.
    24a4:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    24a8:	85 ff       	sbrs	r24, 5
    24aa:	5a c0       	rjmp	.+180    	; 0x2560 <__vector_18+0x13e>
              system_set_exec_state_flag(EXEC_MOTION_CANCEL); 
    24ac:	80 e4       	ldi	r24, 0x40	; 64
    24ae:	0e 94 21 2e 	call	0x5c42	; 0x5c42 <system_set_exec_state_flag>
    24b2:	56 c0       	rjmp	.+172    	; 0x2560 <__vector_18+0x13e>
            }
            break; 
          #ifdef DEBUG
            case CMD_DEBUG_REPORT: {uint8_t sreg = SREG; cli(); bit_true(sys_rt_exec_debug,EXEC_DEBUG_REPORT); SREG = sreg;} break;
    24b4:	9f b7       	in	r25, 0x3f	; 63
    24b6:	f8 94       	cli
    24b8:	80 91 a9 05 	lds	r24, 0x05A9	; 0x8005a9 <sys_rt_exec_debug>
    24bc:	81 60       	ori	r24, 0x01	; 1
    24be:	80 93 a9 05 	sts	0x05A9, r24	; 0x8005a9 <sys_rt_exec_debug>
    24c2:	9f bf       	out	0x3f, r25	; 63
    24c4:	4d c0       	rjmp	.+154    	; 0x2560 <__vector_18+0x13e>
          #endif
          case CMD_FEED_OVR_RESET: system_set_exec_motion_override_flag(EXEC_FEED_OVR_RESET); break;
    24c6:	81 e0       	ldi	r24, 0x01	; 1
    24c8:	0e 94 40 2e 	call	0x5c80	; 0x5c80 <system_set_exec_motion_override_flag>
    24cc:	49 c0       	rjmp	.+146    	; 0x2560 <__vector_18+0x13e>
          case CMD_FEED_OVR_COARSE_PLUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_COARSE_PLUS); break;
    24ce:	82 e0       	ldi	r24, 0x02	; 2
    24d0:	0e 94 40 2e 	call	0x5c80	; 0x5c80 <system_set_exec_motion_override_flag>
    24d4:	45 c0       	rjmp	.+138    	; 0x2560 <__vector_18+0x13e>
          case CMD_FEED_OVR_COARSE_MINUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_COARSE_MINUS); break;
    24d6:	84 e0       	ldi	r24, 0x04	; 4
    24d8:	0e 94 40 2e 	call	0x5c80	; 0x5c80 <system_set_exec_motion_override_flag>
    24dc:	41 c0       	rjmp	.+130    	; 0x2560 <__vector_18+0x13e>
          case CMD_FEED_OVR_FINE_PLUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_FINE_PLUS); break;
    24de:	88 e0       	ldi	r24, 0x08	; 8
    24e0:	0e 94 40 2e 	call	0x5c80	; 0x5c80 <system_set_exec_motion_override_flag>
    24e4:	3d c0       	rjmp	.+122    	; 0x2560 <__vector_18+0x13e>
          case CMD_FEED_OVR_FINE_MINUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_FINE_MINUS); break;
    24e6:	80 e1       	ldi	r24, 0x10	; 16
    24e8:	0e 94 40 2e 	call	0x5c80	; 0x5c80 <system_set_exec_motion_override_flag>
    24ec:	39 c0       	rjmp	.+114    	; 0x2560 <__vector_18+0x13e>
          case CMD_RAPID_OVR_RESET: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_RESET); break;
    24ee:	80 e2       	ldi	r24, 0x20	; 32
    24f0:	0e 94 40 2e 	call	0x5c80	; 0x5c80 <system_set_exec_motion_override_flag>
    24f4:	35 c0       	rjmp	.+106    	; 0x2560 <__vector_18+0x13e>
          case CMD_RAPID_OVR_MEDIUM: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_MEDIUM); break;
    24f6:	80 e4       	ldi	r24, 0x40	; 64
    24f8:	0e 94 40 2e 	call	0x5c80	; 0x5c80 <system_set_exec_motion_override_flag>
    24fc:	31 c0       	rjmp	.+98     	; 0x2560 <__vector_18+0x13e>
          case CMD_RAPID_OVR_LOW: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_LOW); break;
    24fe:	80 e8       	ldi	r24, 0x80	; 128
    2500:	0e 94 40 2e 	call	0x5c80	; 0x5c80 <system_set_exec_motion_override_flag>
    2504:	2d c0       	rjmp	.+90     	; 0x2560 <__vector_18+0x13e>
          case CMD_SPINDLE_OVR_RESET: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_RESET); break;
    2506:	81 e0       	ldi	r24, 0x01	; 1
    2508:	0e 94 49 2e 	call	0x5c92	; 0x5c92 <system_set_exec_accessory_override_flag>
    250c:	29 c0       	rjmp	.+82     	; 0x2560 <__vector_18+0x13e>
          case CMD_SPINDLE_OVR_COARSE_PLUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_COARSE_PLUS); break;
    250e:	82 e0       	ldi	r24, 0x02	; 2
    2510:	0e 94 49 2e 	call	0x5c92	; 0x5c92 <system_set_exec_accessory_override_flag>
    2514:	25 c0       	rjmp	.+74     	; 0x2560 <__vector_18+0x13e>
          case CMD_SPINDLE_OVR_COARSE_MINUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_COARSE_MINUS); break;
    2516:	84 e0       	ldi	r24, 0x04	; 4
    2518:	0e 94 49 2e 	call	0x5c92	; 0x5c92 <system_set_exec_accessory_override_flag>
    251c:	21 c0       	rjmp	.+66     	; 0x2560 <__vector_18+0x13e>
          case CMD_SPINDLE_OVR_FINE_PLUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_FINE_PLUS); break;
    251e:	88 e0       	ldi	r24, 0x08	; 8
    2520:	0e 94 49 2e 	call	0x5c92	; 0x5c92 <system_set_exec_accessory_override_flag>
    2524:	1d c0       	rjmp	.+58     	; 0x2560 <__vector_18+0x13e>
          case CMD_SPINDLE_OVR_FINE_MINUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_FINE_MINUS); break;
    2526:	80 e1       	ldi	r24, 0x10	; 16
    2528:	0e 94 49 2e 	call	0x5c92	; 0x5c92 <system_set_exec_accessory_override_flag>
    252c:	19 c0       	rjmp	.+50     	; 0x2560 <__vector_18+0x13e>
          case CMD_SPINDLE_OVR_STOP: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP); break;
    252e:	80 e2       	ldi	r24, 0x20	; 32
    2530:	0e 94 49 2e 	call	0x5c92	; 0x5c92 <system_set_exec_accessory_override_flag>
    2534:	15 c0       	rjmp	.+42     	; 0x2560 <__vector_18+0x13e>
          case CMD_COOLANT_FLOOD_OVR_TOGGLE: system_set_exec_accessory_override_flag(EXEC_COOLANT_FLOOD_OVR_TOGGLE); break;
    2536:	80 e4       	ldi	r24, 0x40	; 64
    2538:	0e 94 49 2e 	call	0x5c92	; 0x5c92 <system_set_exec_accessory_override_flag>
    253c:	11 c0       	rjmp	.+34     	; 0x2560 <__vector_18+0x13e>
            case CMD_COOLANT_MIST_OVR_TOGGLE: system_set_exec_accessory_override_flag(EXEC_COOLANT_MIST_OVR_TOGGLE); break;
          #endif
        }
        // Throw away any unfound extended-ASCII character by not passing it to the serial buffer.
      } else { // Write character to buffer
        next_head = serial_rx_buffer_head + 1;
    253e:	a0 91 09 01 	lds	r26, 0x0109	; 0x800109 <serial_rx_buffer_head>
    2542:	81 e0       	ldi	r24, 0x01	; 1
    2544:	8a 0f       	add	r24, r26
        if (next_head == RX_RING_BUFFER) { next_head = 0; }
    2546:	81 38       	cpi	r24, 0x81	; 129
    2548:	09 f4       	brne	.+2      	; 0x254c <__vector_18+0x12a>
    254a:	80 e0       	ldi	r24, 0x00	; 0

        // Write data to buffer unless it is full.
        if (next_head != serial_rx_buffer_tail) {
    254c:	90 91 08 01 	lds	r25, 0x0108	; 0x800108 <serial_rx_buffer_tail>
    2550:	89 17       	cp	r24, r25
    2552:	31 f0       	breq	.+12     	; 0x2560 <__vector_18+0x13e>
          serial_rx_buffer[serial_rx_buffer_head] = data;
    2554:	b0 e0       	ldi	r27, 0x00	; 0
    2556:	a3 57       	subi	r26, 0x73	; 115
    2558:	b9 4f       	sbci	r27, 0xF9	; 249
    255a:	ec 93       	st	X, r30
          serial_rx_buffer_head = next_head;
    255c:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <serial_rx_buffer_head>
        }
      }
  }
}
    2560:	ff 91       	pop	r31
    2562:	ef 91       	pop	r30
    2564:	bf 91       	pop	r27
    2566:	af 91       	pop	r26
    2568:	9f 91       	pop	r25
    256a:	8f 91       	pop	r24
    256c:	7f 91       	pop	r23
    256e:	6f 91       	pop	r22
    2570:	5f 91       	pop	r21
    2572:	4f 91       	pop	r20
    2574:	3f 91       	pop	r19
    2576:	2f 91       	pop	r18
    2578:	0f 90       	pop	r0
    257a:	0f be       	out	0x3f, r0	; 63
    257c:	0f 90       	pop	r0
    257e:	1f 90       	pop	r1
    2580:	18 95       	reti

00002582 <serial_reset_read_buffer>:


void serial_reset_read_buffer()
{
  serial_rx_buffer_tail = serial_rx_buffer_head;
    2582:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <serial_rx_buffer_head>
    2586:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <serial_rx_buffer_tail>
    258a:	08 95       	ret

0000258c <gcode_get_byte>:

static void protocol_exec_rt_suspend();

uint8_t gcode_get_byte(void)
{
	return pgm_read_byte(p_gcode++);
    258c:	e0 91 00 01 	lds	r30, 0x0100	; 0x800100 <__data_start>
    2590:	f0 91 01 01 	lds	r31, 0x0101	; 0x800101 <__data_start+0x1>
    2594:	cf 01       	movw	r24, r30
    2596:	01 96       	adiw	r24, 0x01	; 1
    2598:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
    259c:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
    25a0:	84 91       	lpm	r24, Z
}
    25a2:	08 95       	ret

000025a4 <protocol_auto_cycle_start>:
// when one of these conditions exist respectively: There are no more blocks sent (i.e. streaming
// is finished, single commands), a command that needs to wait for the motions in the buffer to
// execute calls a buffer sync, or the planner buffer is full and ready to go.
void protocol_auto_cycle_start()
{
  if (plan_get_current_block() != NULL) { // Check if there are any blocks in the buffer.
    25a4:	0e 94 38 25 	call	0x4a70	; 0x4a70 <plan_get_current_block>
    25a8:	89 2b       	or	r24, r25
    25aa:	19 f0       	breq	.+6      	; 0x25b2 <protocol_auto_cycle_start+0xe>
    system_set_exec_state_flag(EXEC_CYCLE_START); // If so, execute them!
    25ac:	82 e0       	ldi	r24, 0x02	; 2
    25ae:	0e 94 21 2e 	call	0x5c42	; 0x5c42 <system_set_exec_state_flag>
    25b2:	08 95       	ret

000025b4 <protocol_exec_rt_system>:

// Executes run-time commands, when required. This function primarily operates as Grbl's state
// machine and controls the various real-time features Grbl has to offer.
// NOTE: Do not alter this unless you know exactly what you are doing!
void protocol_exec_rt_system()
{
    25b4:	cf 93       	push	r28
  uint8_t rt_exec; // Temp variable to avoid calling volatile multiple times.
  rt_exec = sys_rt_exec_alarm; // Copy volatile sys_rt_exec_alarm.
    25b6:	c0 91 a8 05 	lds	r28, 0x05A8	; 0x8005a8 <sys_rt_exec_alarm>
  if (rt_exec) { // Enter only if any bit flag is true
    25ba:	cc 23       	and	r28, r28
    25bc:	a9 f0       	breq	.+42     	; 0x25e8 <protocol_exec_rt_system+0x34>
    // System alarm. Everything has shutdown by something that has gone severely wrong. Report
    // the source of the error to the user. If critical, Grbl disables by entering an infinite
    // loop until system reset/abort.
    sys.state = STATE_ALARM; // Set system alarm state
    25be:	81 e0       	ldi	r24, 0x01	; 1
    25c0:	80 93 7c 05 	sts	0x057C, r24	; 0x80057c <sys>
    report_alarm_message(rt_exec);
    25c4:	8c 2f       	mov	r24, r28
    25c6:	0e 94 ef 2c 	call	0x59de	; 0x59de <report_alarm_message>
    // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
    if ((rt_exec == EXEC_ALARM_HARD_LIMIT) || (rt_exec == EXEC_ALARM_SOFT_LIMIT)) {
    25ca:	c1 50       	subi	r28, 0x01	; 1
    25cc:	c2 30       	cpi	r28, 0x02	; 2
    25ce:	50 f4       	brcc	.+20     	; 0x25e4 <protocol_exec_rt_system+0x30>
      report_feedback_message(MESSAGE_CRITICAL_EVENT);
    25d0:	81 e0       	ldi	r24, 0x01	; 1
    25d2:	0e 94 f0 2c 	call	0x59e0	; 0x59e0 <report_feedback_message>
      system_clear_exec_state_flag(EXEC_RESET); // Disable any existing reset
    25d6:	80 e1       	ldi	r24, 0x10	; 16
    25d8:	0e 94 2a 2e 	call	0x5c54	; 0x5c54 <system_clear_exec_state_flag>
        // Block everything, except reset and status reports, until user issues reset or power
        // cycles. Hard limits typically occur while unattended or not paying attention. Gives
        // the user and a GUI time to do what is needed before resetting, like killing the
        // incoming stream. The same could be said about soft limits. While the position is not
        // lost, continued streaming could cause a serious crash if by chance it gets executed.
      } while (bit_isfalse(sys_rt_exec_state,EXEC_RESET));
    25dc:	80 91 8e 05 	lds	r24, 0x058E	; 0x80058e <sys_rt_exec_state>
    25e0:	84 ff       	sbrs	r24, 4
    25e2:	fc cf       	rjmp	.-8      	; 0x25dc <protocol_exec_rt_system+0x28>
    }
    system_clear_exec_alarm(); // Clear alarm
    25e4:	0e 94 3a 2e 	call	0x5c74	; 0x5c74 <system_clear_exec_alarm>
  }

  rt_exec = sys_rt_exec_state; // Copy volatile sys_rt_exec_state.
    25e8:	c0 91 8e 05 	lds	r28, 0x058E	; 0x80058e <sys_rt_exec_state>
  if (rt_exec) {
    25ec:	cc 23       	and	r28, r28
    25ee:	09 f4       	brne	.+2      	; 0x25f2 <protocol_exec_rt_system+0x3e>
    25f0:	f8 c0       	rjmp	.+496    	; 0x27e2 <protocol_exec_rt_system+0x22e>

    // Execute system abort.
    if (rt_exec & EXEC_RESET) {
    25f2:	c4 ff       	sbrs	r28, 4
    25f4:	04 c0       	rjmp	.+8      	; 0x25fe <protocol_exec_rt_system+0x4a>
      sys.abort = true;  // Only place this is set true.
    25f6:	81 e0       	ldi	r24, 0x01	; 1
    25f8:	80 93 7d 05 	sts	0x057D, r24	; 0x80057d <sys+0x1>
      return; // Nothing else to do but exit.
    25fc:	9d c1       	rjmp	.+826    	; 0x2938 <protocol_exec_rt_system+0x384>
    }

    // Execute and serial print status
    if (rt_exec & EXEC_STATUS_REPORT) {
    25fe:	c0 ff       	sbrs	r28, 0
    2600:	05 c0       	rjmp	.+10     	; 0x260c <protocol_exec_rt_system+0x58>
      report_realtime_status();
    2602:	0e 94 f5 2c 	call	0x59ea	; 0x59ea <report_realtime_status>
      system_clear_exec_state_flag(EXEC_STATUS_REPORT);
    2606:	81 e0       	ldi	r24, 0x01	; 1
    2608:	0e 94 2a 2e 	call	0x5c54	; 0x5c54 <system_clear_exec_state_flag>
    }

    // NOTE: Once hold is initiated, the system immediately enters a suspend state to block all
    // main program processes until either reset or resumed. This ensures a hold completes safely.
    if (rt_exec & (EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR | EXEC_SLEEP)) {
    260c:	8c 2f       	mov	r24, r28
    260e:	88 7e       	andi	r24, 0xE8	; 232
    2610:	09 f4       	brne	.+2      	; 0x2614 <protocol_exec_rt_system+0x60>
    2612:	64 c0       	rjmp	.+200    	; 0x26dc <protocol_exec_rt_system+0x128>

      // State check for allowable states for hold methods.
      if (!(sys.state & (STATE_ALARM | STATE_CHECK_MODE))) {
    2614:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    2618:	98 2f       	mov	r25, r24
    261a:	93 70       	andi	r25, 0x03	; 3
    261c:	09 f0       	breq	.+2      	; 0x2620 <protocol_exec_rt_system+0x6c>
    261e:	4d c0       	rjmp	.+154    	; 0x26ba <protocol_exec_rt_system+0x106>
      
        // If in CYCLE or JOG states, immediately initiate a motion HOLD.
        if (sys.state & (STATE_CYCLE | STATE_JOG)) {
    2620:	88 72       	andi	r24, 0x28	; 40
    2622:	99 f0       	breq	.+38     	; 0x264a <protocol_exec_rt_system+0x96>
          if (!(sys.suspend & (SUSPEND_MOTION_CANCEL | SUSPEND_JOG_CANCEL))) { // Block, if already holding.
    2624:	80 91 7e 05 	lds	r24, 0x057E	; 0x80057e <sys+0x2>
    2628:	80 7c       	andi	r24, 0xC0	; 192
    262a:	79 f4       	brne	.+30     	; 0x264a <protocol_exec_rt_system+0x96>
            st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
    262c:	0e 94 59 19 	call	0x32b2	; 0x32b2 <st_update_plan_block_parameters>
            sys.step_control = STEP_CONTROL_EXECUTE_HOLD; // Initiate suspend state with active flag.
    2630:	ec e7       	ldi	r30, 0x7C	; 124
    2632:	f5 e0       	ldi	r31, 0x05	; 5
    2634:	82 e0       	ldi	r24, 0x02	; 2
    2636:	84 83       	std	Z+4, r24	; 0x04
            if (sys.state == STATE_JOG) { // Jog cancelled upon any hold event, except for sleeping.
    2638:	80 81       	ld	r24, Z
    263a:	80 32       	cpi	r24, 0x20	; 32
    263c:	31 f4       	brne	.+12     	; 0x264a <protocol_exec_rt_system+0x96>
              if (!(rt_exec & EXEC_SLEEP)) { sys.suspend |= SUSPEND_JOG_CANCEL; } 
    263e:	cc 23       	and	r28, r28
    2640:	bc f0       	brlt	.+46     	; 0x2670 <protocol_exec_rt_system+0xbc>
    2642:	92 81       	ldd	r25, Z+2	; 0x02
    2644:	90 68       	ori	r25, 0x80	; 128
    2646:	92 83       	std	Z+2, r25	; 0x02
    2648:	13 c0       	rjmp	.+38     	; 0x2670 <protocol_exec_rt_system+0xbc>
            }
          }
        }
        // If IDLE, Grbl is not in motion. Simply indicate suspend state and hold is complete.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_HOLD_COMPLETE; }
    264a:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    264e:	81 11       	cpse	r24, r1
    2650:	06 c0       	rjmp	.+12     	; 0x265e <protocol_exec_rt_system+0xaa>
    2652:	91 e0       	ldi	r25, 0x01	; 1
    2654:	90 93 7e 05 	sts	0x057E, r25	; 0x80057e <sys+0x2>

        // Execute and flag a motion cancel with deceleration and return to idle. Used primarily by probing cycle
        // to halt and cancel the remainder of the motion.
        if (rt_exec & EXEC_MOTION_CANCEL) {
    2658:	c6 fd       	sbrc	r28, 6
    265a:	05 c0       	rjmp	.+10     	; 0x2666 <protocol_exec_rt_system+0xb2>
    265c:	65 c1       	rjmp	.+714    	; 0x2928 <protocol_exec_rt_system+0x374>
    265e:	c6 ff       	sbrs	r28, 6
    2660:	07 c0       	rjmp	.+14     	; 0x2670 <protocol_exec_rt_system+0xbc>
          // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiated beforehand
          // to hold the CYCLE. Motion cancel is valid for a single planner block motion only, while jog cancel
          // will handle and clear multiple planner block motions.
          if (!(sys.state & STATE_JOG)) { sys.suspend |= SUSPEND_MOTION_CANCEL; } // NOTE: State is STATE_CYCLE.
    2662:	85 fd       	sbrc	r24, 5
    2664:	05 c0       	rjmp	.+10     	; 0x2670 <protocol_exec_rt_system+0xbc>
    2666:	ec e7       	ldi	r30, 0x7C	; 124
    2668:	f5 e0       	ldi	r31, 0x05	; 5
    266a:	92 81       	ldd	r25, Z+2	; 0x02
    266c:	90 64       	ori	r25, 0x40	; 64
    266e:	92 83       	std	Z+2, r25	; 0x02
        }

        // Execute a feed hold with deceleration, if required. Then, suspend system.
        if (rt_exec & EXEC_FEED_HOLD) {
    2670:	c3 ff       	sbrs	r28, 3
    2672:	05 c0       	rjmp	.+10     	; 0x267e <protocol_exec_rt_system+0xca>
          // Block SAFETY_DOOR, JOG, and SLEEP states from changing to HOLD state.
          if (!(sys.state & (STATE_SAFETY_DOOR | STATE_JOG | STATE_SLEEP))) { sys.state = STATE_HOLD; }
    2674:	80 7e       	andi	r24, 0xE0	; 224
    2676:	19 f4       	brne	.+6      	; 0x267e <protocol_exec_rt_system+0xca>
    2678:	80 e1       	ldi	r24, 0x10	; 16
    267a:	80 93 7c 05 	sts	0x057C, r24	; 0x80057c <sys>
        }

        // Execute a safety door stop with a feed hold and disable spindle/coolant.
        // NOTE: Safety door differs from feed holds by stopping everything no matter state, disables powered
        // devices (spindle/coolant), and blocks resuming until switch is re-engaged.
        if (rt_exec & EXEC_SAFETY_DOOR) {
    267e:	c5 ff       	sbrs	r28, 5
    2680:	1c c0       	rjmp	.+56     	; 0x26ba <protocol_exec_rt_system+0x106>
          report_feedback_message(MESSAGE_SAFETY_DOOR_AJAR);
    2682:	86 e0       	ldi	r24, 0x06	; 6
    2684:	0e 94 f0 2c 	call	0x59e0	; 0x59e0 <report_feedback_message>
          // If jogging, block safety door methods until jog cancel is complete. Just flag that it happened.
          if (!(sys.suspend & SUSPEND_JOG_CANCEL)) {
    2688:	80 91 7e 05 	lds	r24, 0x057E	; 0x80057e <sys+0x2>
    268c:	88 23       	and	r24, r24
    268e:	84 f0       	brlt	.+32     	; 0x26b0 <protocol_exec_rt_system+0xfc>
            // Check if the safety re-opened during a restore parking motion only. Ignore if
            // already retracting, parked or in sleep state.
            if (sys.state == STATE_SAFETY_DOOR) {
    2690:	90 91 7c 05 	lds	r25, 0x057C	; 0x80057c <sys>
    2694:	90 34       	cpi	r25, 0x40	; 64
    2696:	39 f4       	brne	.+14     	; 0x26a6 <protocol_exec_rt_system+0xf2>
              if (sys.suspend & SUSPEND_INITIATE_RESTORE) { // Actively restoring
    2698:	83 ff       	sbrs	r24, 3
    269a:	07 c0       	rjmp	.+14     	; 0x26aa <protocol_exec_rt_system+0xf6>
                    sys.step_control = (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION);
                    sys.suspend &= ~(SUSPEND_HOLD_COMPLETE);
                  } // else NO_MOTION is active.
                #endif
                sys.suspend &= ~(SUSPEND_RETRACT_COMPLETE | SUSPEND_INITIATE_RESTORE | SUSPEND_RESTORE_COMPLETE);
                sys.suspend |= SUSPEND_RESTART_RETRACT;
    269c:	83 7e       	andi	r24, 0xE3	; 227
    269e:	82 60       	ori	r24, 0x02	; 2
    26a0:	80 93 7e 05 	sts	0x057E, r24	; 0x80057e <sys+0x2>
    26a4:	02 c0       	rjmp	.+4      	; 0x26aa <protocol_exec_rt_system+0xf6>
              }
            }
            if (sys.state != STATE_SLEEP) { sys.state = STATE_SAFETY_DOOR; }
    26a6:	90 38       	cpi	r25, 0x80	; 128
    26a8:	19 f0       	breq	.+6      	; 0x26b0 <protocol_exec_rt_system+0xfc>
    26aa:	80 e4       	ldi	r24, 0x40	; 64
    26ac:	80 93 7c 05 	sts	0x057C, r24	; 0x80057c <sys>
          }
          // NOTE: This flag doesn't change when the door closes, unlike sys.state. Ensures any parking motions
          // are executed if the door switch closes and the state returns to HOLD.
          sys.suspend |= SUSPEND_SAFETY_DOOR_AJAR;
    26b0:	ec e7       	ldi	r30, 0x7C	; 124
    26b2:	f5 e0       	ldi	r31, 0x05	; 5
    26b4:	82 81       	ldd	r24, Z+2	; 0x02
    26b6:	80 62       	ori	r24, 0x20	; 32
    26b8:	82 83       	std	Z+2, r24	; 0x02
        }
        
      }

      if (rt_exec & EXEC_SLEEP) {
    26ba:	cc 23       	and	r28, r28
    26bc:	64 f4       	brge	.+24     	; 0x26d6 <protocol_exec_rt_system+0x122>
        if (sys.state == STATE_ALARM) { sys.suspend |= (SUSPEND_RETRACT_COMPLETE|SUSPEND_HOLD_COMPLETE); }
    26be:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    26c2:	81 30       	cpi	r24, 0x01	; 1
    26c4:	29 f4       	brne	.+10     	; 0x26d0 <protocol_exec_rt_system+0x11c>
    26c6:	ec e7       	ldi	r30, 0x7C	; 124
    26c8:	f5 e0       	ldi	r31, 0x05	; 5
    26ca:	82 81       	ldd	r24, Z+2	; 0x02
    26cc:	85 60       	ori	r24, 0x05	; 5
    26ce:	82 83       	std	Z+2, r24	; 0x02
        sys.state = STATE_SLEEP; 
    26d0:	80 e8       	ldi	r24, 0x80	; 128
    26d2:	80 93 7c 05 	sts	0x057C, r24	; 0x80057c <sys>
      }

      system_clear_exec_state_flag((EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR | EXEC_SLEEP));
    26d6:	88 ee       	ldi	r24, 0xE8	; 232
    26d8:	0e 94 2a 2e 	call	0x5c54	; 0x5c54 <system_clear_exec_state_flag>
    }

    // Execute a cycle start by starting the stepper interrupt to begin executing the blocks in queue.
    if (rt_exec & EXEC_CYCLE_START) {
    26dc:	c1 ff       	sbrs	r28, 1
    26de:	43 c0       	rjmp	.+134    	; 0x2766 <protocol_exec_rt_system+0x1b2>
      // Block if called at same time as the hold commands: feed hold, motion cancel, and safety door.
      // Ensures auto-cycle-start doesn't resume a hold without an explicit user-input.
      if (!(rt_exec & (EXEC_FEED_HOLD | EXEC_MOTION_CANCEL | EXEC_SAFETY_DOOR))) {
    26e0:	8c 2f       	mov	r24, r28
    26e2:	88 76       	andi	r24, 0x68	; 104
    26e4:	e9 f5       	brne	.+122    	; 0x2760 <protocol_exec_rt_system+0x1ac>
        // Resume door state when parking motion has retracted and door has been closed.
        if ((sys.state == STATE_SAFETY_DOOR) && !(sys.suspend & SUSPEND_SAFETY_DOOR_AJAR)) {
    26e6:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    26ea:	80 34       	cpi	r24, 0x40	; 64
    26ec:	79 f4       	brne	.+30     	; 0x270c <protocol_exec_rt_system+0x158>
    26ee:	80 91 7e 05 	lds	r24, 0x057E	; 0x80057e <sys+0x2>
    26f2:	85 fd       	sbrc	r24, 5
    26f4:	35 c0       	rjmp	.+106    	; 0x2760 <protocol_exec_rt_system+0x1ac>
          if (sys.suspend & SUSPEND_RESTORE_COMPLETE) {
    26f6:	84 ff       	sbrs	r24, 4
    26f8:	03 c0       	rjmp	.+6      	; 0x2700 <protocol_exec_rt_system+0x14c>
            sys.state = STATE_IDLE; // Set to IDLE to immediately resume the cycle.
    26fa:	10 92 7c 05 	sts	0x057C, r1	; 0x80057c <sys>
    26fe:	18 c0       	rjmp	.+48     	; 0x2730 <protocol_exec_rt_system+0x17c>
          } else if (sys.suspend & SUSPEND_RETRACT_COMPLETE) {
    2700:	82 ff       	sbrs	r24, 2
    2702:	2e c0       	rjmp	.+92     	; 0x2760 <protocol_exec_rt_system+0x1ac>
            // Flag to re-energize powered components and restore original position, if disabled by SAFETY_DOOR.
            // NOTE: For a safety door to resume, the switch must be closed, as indicated by HOLD state, and
            // the retraction execution is complete, which implies the initial feed hold is not active. To
            // restore normal operation, the restore procedures must be initiated by the following flag. Once,
            // they are complete, it will call CYCLE_START automatically to resume and exit the suspend.
            sys.suspend |= SUSPEND_INITIATE_RESTORE;
    2704:	88 60       	ori	r24, 0x08	; 8
    2706:	80 93 7e 05 	sts	0x057E, r24	; 0x80057e <sys+0x2>
    270a:	2a c0       	rjmp	.+84     	; 0x2760 <protocol_exec_rt_system+0x1ac>
          }
        }
        // Cycle start only when IDLE or when a hold is complete and ready to resume.
        if ((sys.state == STATE_IDLE) || ((sys.state & STATE_HOLD) && (sys.suspend & SUSPEND_HOLD_COMPLETE))) {
    270c:	88 23       	and	r24, r24
    270e:	81 f0       	breq	.+32     	; 0x2730 <protocol_exec_rt_system+0x17c>
    2710:	84 ff       	sbrs	r24, 4
    2712:	26 c0       	rjmp	.+76     	; 0x2760 <protocol_exec_rt_system+0x1ac>
    2714:	90 91 7e 05 	lds	r25, 0x057E	; 0x80057e <sys+0x2>
    2718:	90 ff       	sbrs	r25, 0
    271a:	22 c0       	rjmp	.+68     	; 0x2760 <protocol_exec_rt_system+0x1ac>
          if (sys.state == STATE_HOLD && sys.spindle_stop_ovr) {
    271c:	80 31       	cpi	r24, 0x10	; 16
    271e:	41 f4       	brne	.+16     	; 0x2730 <protocol_exec_rt_system+0x17c>
    2720:	80 91 86 05 	lds	r24, 0x0586	; 0x800586 <sys+0xa>
    2724:	88 23       	and	r24, r24
    2726:	21 f0       	breq	.+8      	; 0x2730 <protocol_exec_rt_system+0x17c>
            sys.spindle_stop_ovr |= SPINDLE_STOP_OVR_RESTORE_CYCLE; // Set to restore in suspend routine and cycle start after.
    2728:	88 60       	ori	r24, 0x08	; 8
    272a:	80 93 86 05 	sts	0x0586, r24	; 0x800586 <sys+0xa>
    272e:	18 c0       	rjmp	.+48     	; 0x2760 <protocol_exec_rt_system+0x1ac>
          } else {
            // Start cycle only if queued motions exist in planner buffer and the motion is not canceled.
            sys.step_control = STEP_CONTROL_NORMAL_OP; // Restore step control to normal operation
    2730:	10 92 80 05 	sts	0x0580, r1	; 0x800580 <sys+0x4>
            if (plan_get_current_block() && bit_isfalse(sys.suspend,SUSPEND_MOTION_CANCEL)) {
    2734:	0e 94 38 25 	call	0x4a70	; 0x4a70 <plan_get_current_block>
    2738:	89 2b       	or	r24, r25
    273a:	71 f0       	breq	.+28     	; 0x2758 <protocol_exec_rt_system+0x1a4>
    273c:	80 91 7e 05 	lds	r24, 0x057E	; 0x80057e <sys+0x2>
    2740:	86 fd       	sbrc	r24, 6
    2742:	0a c0       	rjmp	.+20     	; 0x2758 <protocol_exec_rt_system+0x1a4>
              sys.suspend = SUSPEND_DISABLE; // Break suspend state.
    2744:	ec e7       	ldi	r30, 0x7C	; 124
    2746:	f5 e0       	ldi	r31, 0x05	; 5
    2748:	12 82       	std	Z+2, r1	; 0x02
              sys.state = STATE_CYCLE;
    274a:	88 e0       	ldi	r24, 0x08	; 8
    274c:	80 83       	st	Z, r24
              st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
    274e:	0e 94 79 19 	call	0x32f2	; 0x32f2 <st_prep_buffer>
              st_wake_up();
    2752:	0e 94 70 16 	call	0x2ce0	; 0x2ce0 <st_wake_up>
    2756:	04 c0       	rjmp	.+8      	; 0x2760 <protocol_exec_rt_system+0x1ac>
            } else { // Otherwise, do nothing. Set and resume IDLE state.
              sys.suspend = SUSPEND_DISABLE; // Break suspend state.
    2758:	ec e7       	ldi	r30, 0x7C	; 124
    275a:	f5 e0       	ldi	r31, 0x05	; 5
    275c:	12 82       	std	Z+2, r1	; 0x02
              sys.state = STATE_IDLE;
    275e:	10 82       	st	Z, r1
            }
          }
        }
      }
      system_clear_exec_state_flag(EXEC_CYCLE_START);
    2760:	82 e0       	ldi	r24, 0x02	; 2
    2762:	0e 94 2a 2e 	call	0x5c54	; 0x5c54 <system_clear_exec_state_flag>
    }

    if (rt_exec & EXEC_CYCLE_STOP) {
    2766:	c2 ff       	sbrs	r28, 2
    2768:	3c c0       	rjmp	.+120    	; 0x27e2 <protocol_exec_rt_system+0x22e>
      // Reinitializes the cycle plan and stepper system after a feed hold for a resume. Called by
      // realtime command execution in the main program, ensuring that the planner re-plans safely.
      // NOTE: Bresenham algorithm variables are still maintained through both the planner and stepper
      // cycle reinitializations. The stepper path should continue exactly as if nothing has happened.
      // NOTE: EXEC_CYCLE_STOP is set by the stepper subsystem when a cycle or feed hold completes.
      if ((sys.state & (STATE_HOLD|STATE_SAFETY_DOOR|STATE_SLEEP)) && !(sys.soft_limit) && !(sys.suspend & SUSPEND_JOG_CANCEL)) {
    276a:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    276e:	80 7d       	andi	r24, 0xD0	; 208
    2770:	b9 f0       	breq	.+46     	; 0x27a0 <protocol_exec_rt_system+0x1ec>
    2772:	80 91 7f 05 	lds	r24, 0x057F	; 0x80057f <sys+0x3>
    2776:	81 11       	cpse	r24, r1
    2778:	13 c0       	rjmp	.+38     	; 0x27a0 <protocol_exec_rt_system+0x1ec>
    277a:	80 91 7e 05 	lds	r24, 0x057E	; 0x80057e <sys+0x2>
    277e:	88 23       	and	r24, r24
    2780:	9c f0       	brlt	.+38     	; 0x27a8 <protocol_exec_rt_system+0x1f4>
        // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until user
        // has issued a resume command or reset.
        plan_cycle_reinitialize();
    2782:	0e 94 c5 29 	call	0x538a	; 0x538a <plan_cycle_reinitialize>
        if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { sys.suspend |= SUSPEND_HOLD_COMPLETE; }
    2786:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <sys+0x4>
    278a:	81 ff       	sbrs	r24, 1
    278c:	05 c0       	rjmp	.+10     	; 0x2798 <protocol_exec_rt_system+0x1e4>
    278e:	ec e7       	ldi	r30, 0x7C	; 124
    2790:	f5 e0       	ldi	r31, 0x05	; 5
    2792:	92 81       	ldd	r25, Z+2	; 0x02
    2794:	91 60       	ori	r25, 0x01	; 1
    2796:	92 83       	std	Z+2, r25	; 0x02
        bit_false(sys.step_control,(STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION));
    2798:	89 7f       	andi	r24, 0xF9	; 249
    279a:	80 93 80 05 	sts	0x0580, r24	; 0x800580 <sys+0x4>
    279e:	1e c0       	rjmp	.+60     	; 0x27dc <protocol_exec_rt_system+0x228>
      } else {
        // Motion complete. Includes CYCLE/JOG/HOMING states and jog cancel/motion cancel/soft limit events.
        // NOTE: Motion and jog cancel both immediately return to idle after the hold completes.
        if (sys.suspend & SUSPEND_JOG_CANCEL) {   // For jog cancel, flush buffers and sync positions.
    27a0:	80 91 7e 05 	lds	r24, 0x057E	; 0x80057e <sys+0x2>
    27a4:	88 23       	and	r24, r24
    27a6:	54 f4       	brge	.+20     	; 0x27bc <protocol_exec_rt_system+0x208>
          sys.step_control = STEP_CONTROL_NORMAL_OP;
    27a8:	10 92 80 05 	sts	0x0580, r1	; 0x800580 <sys+0x4>
          plan_reset();
    27ac:	0e 94 11 25 	call	0x4a22	; 0x4a22 <plan_reset>
          st_reset();
    27b0:	0e 94 04 19 	call	0x3208	; 0x3208 <st_reset>
          gc_sync_position();
    27b4:	0e 94 93 05 	call	0xb26	; 0xb26 <gc_sync_position>
          plan_sync_position();
    27b8:	0e 94 b3 29 	call	0x5366	; 0x5366 <plan_sync_position>
        }
        if (sys.suspend & SUSPEND_SAFETY_DOOR_AJAR) { // Only occurs when safety door opens during jog.
    27bc:	80 91 7e 05 	lds	r24, 0x057E	; 0x80057e <sys+0x2>
    27c0:	85 ff       	sbrs	r24, 5
    27c2:	08 c0       	rjmp	.+16     	; 0x27d4 <protocol_exec_rt_system+0x220>
          sys.suspend &= ~(SUSPEND_JOG_CANCEL);
          sys.suspend |= SUSPEND_HOLD_COMPLETE;
    27c4:	ec e7       	ldi	r30, 0x7C	; 124
    27c6:	f5 e0       	ldi	r31, 0x05	; 5
    27c8:	8f 77       	andi	r24, 0x7F	; 127
    27ca:	81 60       	ori	r24, 0x01	; 1
    27cc:	82 83       	std	Z+2, r24	; 0x02
          sys.state = STATE_SAFETY_DOOR;
    27ce:	80 e4       	ldi	r24, 0x40	; 64
    27d0:	80 83       	st	Z, r24
    27d2:	04 c0       	rjmp	.+8      	; 0x27dc <protocol_exec_rt_system+0x228>
        } else {
          sys.suspend = SUSPEND_DISABLE;
    27d4:	ec e7       	ldi	r30, 0x7C	; 124
    27d6:	f5 e0       	ldi	r31, 0x05	; 5
    27d8:	12 82       	std	Z+2, r1	; 0x02
          sys.state = STATE_IDLE;
    27da:	10 82       	st	Z, r1
        }
      }
      system_clear_exec_state_flag(EXEC_CYCLE_STOP);
    27dc:	84 e0       	ldi	r24, 0x04	; 4
    27de:	0e 94 2a 2e 	call	0x5c54	; 0x5c54 <system_clear_exec_state_flag>
    }
  }

  // Execute overrides.
  rt_exec = sys_rt_exec_motion_override; // Copy volatile sys_rt_exec_motion_override
    27e2:	c0 91 7b 05 	lds	r28, 0x057B	; 0x80057b <sys_rt_exec_motion_override>
  if (rt_exec) {
    27e6:	cc 23       	and	r28, r28
    27e8:	81 f1       	breq	.+96     	; 0x284a <protocol_exec_rt_system+0x296>
    system_clear_exec_motion_overrides(); // Clear all motion override flags.
    27ea:	0e 94 52 2e 	call	0x5ca4	; 0x5ca4 <system_clear_exec_motion_overrides>

    uint8_t new_f_override =  sys.f_override;
    27ee:	20 91 83 05 	lds	r18, 0x0583	; 0x800583 <sys+0x7>
    if (rt_exec & EXEC_FEED_OVR_RESET) { new_f_override = DEFAULT_FEED_OVERRIDE; }
    27f2:	c0 ff       	sbrs	r28, 0
    27f4:	02 c0       	rjmp	.+4      	; 0x27fa <protocol_exec_rt_system+0x246>
    27f6:	84 e6       	ldi	r24, 0x64	; 100
    27f8:	01 c0       	rjmp	.+2      	; 0x27fc <protocol_exec_rt_system+0x248>
  // Execute overrides.
  rt_exec = sys_rt_exec_motion_override; // Copy volatile sys_rt_exec_motion_override
  if (rt_exec) {
    system_clear_exec_motion_overrides(); // Clear all motion override flags.

    uint8_t new_f_override =  sys.f_override;
    27fa:	82 2f       	mov	r24, r18
    if (rt_exec & EXEC_FEED_OVR_RESET) { new_f_override = DEFAULT_FEED_OVERRIDE; }
    if (rt_exec & EXEC_FEED_OVR_COARSE_PLUS) { new_f_override += FEED_OVERRIDE_COARSE_INCREMENT; }
    27fc:	c1 fd       	sbrc	r28, 1
    27fe:	86 5f       	subi	r24, 0xF6	; 246
    if (rt_exec & EXEC_FEED_OVR_COARSE_MINUS) { new_f_override -= FEED_OVERRIDE_COARSE_INCREMENT; }
    2800:	c2 fd       	sbrc	r28, 2
    2802:	8a 50       	subi	r24, 0x0A	; 10
    if (rt_exec & EXEC_FEED_OVR_FINE_PLUS) { new_f_override += FEED_OVERRIDE_FINE_INCREMENT; }
    2804:	c3 fd       	sbrc	r28, 3
    2806:	8f 5f       	subi	r24, 0xFF	; 255
    if (rt_exec & EXEC_FEED_OVR_FINE_MINUS) { new_f_override -= FEED_OVERRIDE_FINE_INCREMENT; }
    2808:	c4 fd       	sbrc	r28, 4
    280a:	81 50       	subi	r24, 0x01	; 1
    new_f_override = min(new_f_override,MAX_FEED_RATE_OVERRIDE);
    280c:	89 3c       	cpi	r24, 0xC9	; 201
    280e:	08 f0       	brcs	.+2      	; 0x2812 <protocol_exec_rt_system+0x25e>
    2810:	88 ec       	ldi	r24, 0xC8	; 200
    new_f_override = max(new_f_override,MIN_FEED_RATE_OVERRIDE);
    2812:	8a 30       	cpi	r24, 0x0A	; 10
    2814:	08 f4       	brcc	.+2      	; 0x2818 <protocol_exec_rt_system+0x264>
    2816:	8a e0       	ldi	r24, 0x0A	; 10

    uint8_t new_r_override = sys.r_override;
    2818:	30 91 84 05 	lds	r19, 0x0584	; 0x800584 <sys+0x8>
    if (rt_exec & EXEC_RAPID_OVR_RESET) { new_r_override = DEFAULT_RAPID_OVERRIDE; }
    281c:	c5 ff       	sbrs	r28, 5
    281e:	02 c0       	rjmp	.+4      	; 0x2824 <protocol_exec_rt_system+0x270>
    2820:	94 e6       	ldi	r25, 0x64	; 100
    2822:	01 c0       	rjmp	.+2      	; 0x2826 <protocol_exec_rt_system+0x272>
    if (rt_exec & EXEC_FEED_OVR_FINE_PLUS) { new_f_override += FEED_OVERRIDE_FINE_INCREMENT; }
    if (rt_exec & EXEC_FEED_OVR_FINE_MINUS) { new_f_override -= FEED_OVERRIDE_FINE_INCREMENT; }
    new_f_override = min(new_f_override,MAX_FEED_RATE_OVERRIDE);
    new_f_override = max(new_f_override,MIN_FEED_RATE_OVERRIDE);

    uint8_t new_r_override = sys.r_override;
    2824:	93 2f       	mov	r25, r19
    if (rt_exec & EXEC_RAPID_OVR_RESET) { new_r_override = DEFAULT_RAPID_OVERRIDE; }
    if (rt_exec & EXEC_RAPID_OVR_MEDIUM) { new_r_override = RAPID_OVERRIDE_MEDIUM; }
    2826:	c6 fd       	sbrc	r28, 6
    2828:	92 e3       	ldi	r25, 0x32	; 50
    if (rt_exec & EXEC_RAPID_OVR_LOW) { new_r_override = RAPID_OVERRIDE_LOW; }
    282a:	cc 23       	and	r28, r28
    282c:	0c f4       	brge	.+2      	; 0x2830 <protocol_exec_rt_system+0x27c>
    282e:	99 e1       	ldi	r25, 0x19	; 25

    if ((new_f_override != sys.f_override) || (new_r_override != sys.r_override)) {
    2830:	28 13       	cpse	r18, r24
    2832:	02 c0       	rjmp	.+4      	; 0x2838 <protocol_exec_rt_system+0x284>
    2834:	93 17       	cp	r25, r19
    2836:	49 f0       	breq	.+18     	; 0x284a <protocol_exec_rt_system+0x296>
      sys.f_override = new_f_override;
    2838:	ec e7       	ldi	r30, 0x7C	; 124
    283a:	f5 e0       	ldi	r31, 0x05	; 5
    283c:	87 83       	std	Z+7, r24	; 0x07
      sys.r_override = new_r_override;
    283e:	90 87       	std	Z+8, r25	; 0x08
      sys.report_ovr_counter = 0; // Set to report change immediately
    2840:	13 86       	std	Z+11, r1	; 0x0b
      plan_update_velocity_profile_parameters();
    2842:	0e 94 e6 25 	call	0x4bcc	; 0x4bcc <plan_update_velocity_profile_parameters>
      plan_cycle_reinitialize();
    2846:	0e 94 c5 29 	call	0x538a	; 0x538a <plan_cycle_reinitialize>
    }
  }

  rt_exec = sys_rt_exec_accessory_override;
    284a:	c0 91 8d 05 	lds	r28, 0x058D	; 0x80058d <sys_rt_exec_accessory_override>
  if (rt_exec) {
    284e:	cc 23       	and	r28, r28
    2850:	09 f4       	brne	.+2      	; 0x2854 <protocol_exec_rt_system+0x2a0>
    2852:	58 c0       	rjmp	.+176    	; 0x2904 <protocol_exec_rt_system+0x350>
    system_clear_exec_accessory_overrides(); // Clear all accessory override flags.
    2854:	0e 94 58 2e 	call	0x5cb0	; 0x5cb0 <system_clear_exec_accessory_overrides>

    // NOTE: Unlike motion overrides, spindle overrides do not require a planner reinitialization.
    uint8_t last_s_override =  sys.spindle_speed_ovr;
    2858:	90 91 85 05 	lds	r25, 0x0585	; 0x800585 <sys+0x9>
    if (rt_exec & EXEC_SPINDLE_OVR_RESET) { last_s_override = DEFAULT_SPINDLE_SPEED_OVERRIDE; }
    285c:	c0 ff       	sbrs	r28, 0
    285e:	02 c0       	rjmp	.+4      	; 0x2864 <protocol_exec_rt_system+0x2b0>
    2860:	84 e6       	ldi	r24, 0x64	; 100
    2862:	01 c0       	rjmp	.+2      	; 0x2866 <protocol_exec_rt_system+0x2b2>
  rt_exec = sys_rt_exec_accessory_override;
  if (rt_exec) {
    system_clear_exec_accessory_overrides(); // Clear all accessory override flags.

    // NOTE: Unlike motion overrides, spindle overrides do not require a planner reinitialization.
    uint8_t last_s_override =  sys.spindle_speed_ovr;
    2864:	89 2f       	mov	r24, r25
    if (rt_exec & EXEC_SPINDLE_OVR_RESET) { last_s_override = DEFAULT_SPINDLE_SPEED_OVERRIDE; }
    if (rt_exec & EXEC_SPINDLE_OVR_COARSE_PLUS) { last_s_override += SPINDLE_OVERRIDE_COARSE_INCREMENT; }
    2866:	c1 fd       	sbrc	r28, 1
    2868:	86 5f       	subi	r24, 0xF6	; 246
    if (rt_exec & EXEC_SPINDLE_OVR_COARSE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_COARSE_INCREMENT; }
    286a:	c2 fd       	sbrc	r28, 2
    286c:	8a 50       	subi	r24, 0x0A	; 10
    if (rt_exec & EXEC_SPINDLE_OVR_FINE_PLUS) { last_s_override += SPINDLE_OVERRIDE_FINE_INCREMENT; }
    286e:	c3 fd       	sbrc	r28, 3
    2870:	8f 5f       	subi	r24, 0xFF	; 255
    if (rt_exec & EXEC_SPINDLE_OVR_FINE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_FINE_INCREMENT; }
    2872:	c4 fd       	sbrc	r28, 4
    2874:	81 50       	subi	r24, 0x01	; 1
    last_s_override = min(last_s_override,MAX_SPINDLE_SPEED_OVERRIDE);
    2876:	89 3c       	cpi	r24, 0xC9	; 201
    2878:	08 f0       	brcs	.+2      	; 0x287c <protocol_exec_rt_system+0x2c8>
    287a:	88 ec       	ldi	r24, 0xC8	; 200
    last_s_override = max(last_s_override,MIN_SPINDLE_SPEED_OVERRIDE);
    287c:	8a 30       	cpi	r24, 0x0A	; 10
    287e:	08 f4       	brcc	.+2      	; 0x2882 <protocol_exec_rt_system+0x2ce>
    2880:	8a e0       	ldi	r24, 0x0A	; 10

    if (last_s_override != sys.spindle_speed_ovr) {
    2882:	98 17       	cp	r25, r24
    2884:	b9 f0       	breq	.+46     	; 0x28b4 <protocol_exec_rt_system+0x300>
      sys.spindle_speed_ovr = last_s_override;
    2886:	ec e7       	ldi	r30, 0x7C	; 124
    2888:	f5 e0       	ldi	r31, 0x05	; 5
    288a:	81 87       	std	Z+9, r24	; 0x09
      // NOTE: Spindle speed overrides during HOLD state are taken care of by suspend function.
      if (sys.state == STATE_IDLE) { spindle_set_state(gc_state.modal.spindle, gc_state.spindle_speed); }
    288c:	80 81       	ld	r24, Z
    288e:	81 11       	cpse	r24, r1
    2890:	0a c0       	rjmp	.+20     	; 0x28a6 <protocol_exec_rt_system+0x2f2>
    2892:	ea ea       	ldi	r30, 0xAA	; 170
    2894:	f5 e0       	ldi	r31, 0x05	; 5
    2896:	43 85       	ldd	r20, Z+11	; 0x0b
    2898:	54 85       	ldd	r21, Z+12	; 0x0c
    289a:	65 85       	ldd	r22, Z+13	; 0x0d
    289c:	76 85       	ldd	r23, Z+14	; 0x0e
    289e:	81 85       	ldd	r24, Z+9	; 0x09
    28a0:	0e 94 71 11 	call	0x22e2	; 0x22e2 <spindle_set_state>
    28a4:	05 c0       	rjmp	.+10     	; 0x28b0 <protocol_exec_rt_system+0x2fc>
			else { bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM); }
    28a6:	ec e7       	ldi	r30, 0x7C	; 124
    28a8:	f5 e0       	ldi	r31, 0x05	; 5
    28aa:	84 81       	ldd	r24, Z+4	; 0x04
    28ac:	88 60       	ori	r24, 0x08	; 8
    28ae:	84 83       	std	Z+4, r24	; 0x04
      sys.report_ovr_counter = 0; // Set to report change immediately
    28b0:	10 92 87 05 	sts	0x0587, r1	; 0x800587 <sys+0xb>
    }

    if (rt_exec & EXEC_SPINDLE_OVR_STOP) {
    28b4:	c5 ff       	sbrs	r28, 5
    28b6:	12 c0       	rjmp	.+36     	; 0x28dc <protocol_exec_rt_system+0x328>
      // Spindle stop override allowed only while in HOLD state.
      // NOTE: Report counters are set in spindle_set_state() when spindle stop is executed.
      if (sys.state == STATE_HOLD) {
    28b8:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    28bc:	80 31       	cpi	r24, 0x10	; 16
    28be:	71 f4       	brne	.+28     	; 0x28dc <protocol_exec_rt_system+0x328>
        if (!(sys.spindle_stop_ovr)) { sys.spindle_stop_ovr = SPINDLE_STOP_OVR_INITIATE; }
    28c0:	80 91 86 05 	lds	r24, 0x0586	; 0x800586 <sys+0xa>
    28c4:	81 11       	cpse	r24, r1
    28c6:	04 c0       	rjmp	.+8      	; 0x28d0 <protocol_exec_rt_system+0x31c>
    28c8:	82 e0       	ldi	r24, 0x02	; 2
    28ca:	80 93 86 05 	sts	0x0586, r24	; 0x800586 <sys+0xa>
    28ce:	29 c0       	rjmp	.+82     	; 0x2922 <protocol_exec_rt_system+0x36e>
        else if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_ENABLED) { sys.spindle_stop_ovr |= SPINDLE_STOP_OVR_RESTORE; }
    28d0:	80 ff       	sbrs	r24, 0
    28d2:	27 c0       	rjmp	.+78     	; 0x2922 <protocol_exec_rt_system+0x36e>
    28d4:	84 60       	ori	r24, 0x04	; 4
    28d6:	80 93 86 05 	sts	0x0586, r24	; 0x800586 <sys+0xa>
    28da:	23 c0       	rjmp	.+70     	; 0x2922 <protocol_exec_rt_system+0x36e>
    }

    // NOTE: Since coolant state always performs a planner sync whenever it changes, the current
    // run state can be determined by checking the parser state.
    // NOTE: Coolant overrides only operate during IDLE, CYCLE, HOLD, and JOG states. Ignored otherwise.
    if (rt_exec & (EXEC_COOLANT_FLOOD_OVR_TOGGLE | EXEC_COOLANT_MIST_OVR_TOGGLE)) {
    28dc:	c0 7c       	andi	r28, 0xC0	; 192
    28de:	91 f0       	breq	.+36     	; 0x2904 <protocol_exec_rt_system+0x350>
      if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_JOG))) {
    28e0:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    28e4:	88 23       	and	r24, r24
    28e6:	11 f0       	breq	.+4      	; 0x28ec <protocol_exec_rt_system+0x338>
    28e8:	88 73       	andi	r24, 0x38	; 56
    28ea:	61 f0       	breq	.+24     	; 0x2904 <protocol_exec_rt_system+0x350>
        uint8_t coolant_state = gc_state.modal.coolant;
    28ec:	c0 91 b2 05 	lds	r28, 0x05B2	; 0x8005b2 <gc_state+0x8>
          if (rt_exec & EXEC_COOLANT_FLOOD_OVR_TOGGLE) {
            if (coolant_state & COOLANT_FLOOD_ENABLE) { bit_false(coolant_state,COOLANT_FLOOD_ENABLE); }
            else { coolant_state |= COOLANT_FLOOD_ENABLE; }
          }
        #else
          if (coolant_state & COOLANT_FLOOD_ENABLE) { bit_false(coolant_state,COOLANT_FLOOD_ENABLE); }
    28f0:	c6 ff       	sbrs	r28, 6
    28f2:	02 c0       	rjmp	.+4      	; 0x28f8 <protocol_exec_rt_system+0x344>
    28f4:	cf 7b       	andi	r28, 0xBF	; 191
    28f6:	01 c0       	rjmp	.+2      	; 0x28fa <protocol_exec_rt_system+0x346>
          else { coolant_state |= COOLANT_FLOOD_ENABLE; }
    28f8:	c0 64       	ori	r28, 0x40	; 64
        #endif
        coolant_set_state(coolant_state); // Report counter set in coolant_set_state().
    28fa:	8c 2f       	mov	r24, r28
    28fc:	0e 94 be 11 	call	0x237c	; 0x237c <coolant_set_state>
        gc_state.modal.coolant = coolant_state;
    2900:	c0 93 b2 05 	sts	0x05B2, r28	; 0x8005b2 <gc_state+0x8>
      }
    }
  }

  #ifdef DEBUG
    if (sys_rt_exec_debug) {
    2904:	80 91 a9 05 	lds	r24, 0x05A9	; 0x8005a9 <sys_rt_exec_debug>
    2908:	88 23       	and	r24, r24
    290a:	21 f0       	breq	.+8      	; 0x2914 <protocol_exec_rt_system+0x360>
      report_realtime_debug();
    290c:	0e 94 f6 2c 	call	0x59ec	; 0x59ec <report_realtime_debug>
      sys_rt_exec_debug = 0;
    2910:	10 92 a9 05 	sts	0x05A9, r1	; 0x8005a9 <sys_rt_exec_debug>
    }
  #endif

  // Reload step segment buffer
  if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_SAFETY_DOOR | STATE_HOMING | STATE_SLEEP| STATE_JOG)) {
    2914:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    2918:	8c 7f       	andi	r24, 0xFC	; 252
    291a:	71 f0       	breq	.+28     	; 0x2938 <protocol_exec_rt_system+0x384>
    st_prep_buffer();
    291c:	0e 94 79 19 	call	0x32f2	; 0x32f2 <st_prep_buffer>
    2920:	0b c0       	rjmp	.+22     	; 0x2938 <protocol_exec_rt_system+0x384>
    }

    // NOTE: Since coolant state always performs a planner sync whenever it changes, the current
    // run state can be determined by checking the parser state.
    // NOTE: Coolant overrides only operate during IDLE, CYCLE, HOLD, and JOG states. Ignored otherwise.
    if (rt_exec & (EXEC_COOLANT_FLOOD_OVR_TOGGLE | EXEC_COOLANT_MIST_OVR_TOGGLE)) {
    2922:	c0 7c       	andi	r28, 0xC0	; 192
    2924:	19 f7       	brne	.-58     	; 0x28ec <protocol_exec_rt_system+0x338>
    2926:	03 c0       	rjmp	.+6      	; 0x292e <protocol_exec_rt_system+0x37a>
          // will handle and clear multiple planner block motions.
          if (!(sys.state & STATE_JOG)) { sys.suspend |= SUSPEND_MOTION_CANCEL; } // NOTE: State is STATE_CYCLE.
        }

        // Execute a feed hold with deceleration, if required. Then, suspend system.
        if (rt_exec & EXEC_FEED_HOLD) {
    2928:	c3 fd       	sbrc	r28, 3
    292a:	a6 ce       	rjmp	.-692    	; 0x2678 <protocol_exec_rt_system+0xc4>
    292c:	a8 ce       	rjmp	.-688    	; 0x267e <protocol_exec_rt_system+0xca>
      }
    }
  }

  #ifdef DEBUG
    if (sys_rt_exec_debug) {
    292e:	80 91 a9 05 	lds	r24, 0x05A9	; 0x8005a9 <sys_rt_exec_debug>
    2932:	88 23       	and	r24, r24
    2934:	99 f3       	breq	.-26     	; 0x291c <protocol_exec_rt_system+0x368>
    2936:	ea cf       	rjmp	.-44     	; 0x290c <protocol_exec_rt_system+0x358>
  // Reload step segment buffer
  if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_SAFETY_DOOR | STATE_HOMING | STATE_SLEEP| STATE_JOG)) {
    st_prep_buffer();
  }

}
    2938:	cf 91       	pop	r28
    293a:	08 95       	ret

0000293c <protocol_execute_realtime>:
// also provides a controlled way to execute certain tasks without having two or more instances of
// the same task, such as the planner recalculating the buffer upon a feedhold or overrides.
// NOTE: The sys_rt_exec_state variable flags are set by any process, step or serial interrupts, pinouts,
// limit switches, or the main program.
void protocol_execute_realtime()
{
    293c:	7f 92       	push	r7
    293e:	8f 92       	push	r8
    2940:	9f 92       	push	r9
    2942:	af 92       	push	r10
    2944:	bf 92       	push	r11
    2946:	cf 92       	push	r12
    2948:	df 92       	push	r13
    294a:	ef 92       	push	r14
    294c:	ff 92       	push	r15
    294e:	0f 93       	push	r16
    2950:	1f 93       	push	r17
    2952:	cf 93       	push	r28
    2954:	df 93       	push	r29
  protocol_exec_rt_system();
    2956:	0e 94 da 12 	call	0x25b4	; 0x25b4 <protocol_exec_rt_system>
  if (sys.suspend) { protocol_exec_rt_suspend(); }
    295a:	80 91 7e 05 	lds	r24, 0x057E	; 0x80057e <sys+0x2>
    295e:	88 23       	and	r24, r24
    2960:	09 f4       	brne	.+2      	; 0x2964 <protocol_execute_realtime+0x28>
    2962:	01 c1       	rjmp	.+514    	; 0x2b66 <protocol_execute_realtime+0x22a>
    #ifdef USE_LINE_NUMBERS
      pl_data->line_number = PARKING_MOTION_LINE_NUMBER;
    #endif
  #endif

  plan_block_t *block = plan_get_current_block();
    2964:	0e 94 38 25 	call	0x4a70	; 0x4a70 <plan_get_current_block>
    2968:	ec 01       	movw	r28, r24
  uint8_t restore_condition;
  #ifdef VARIABLE_SPINDLE
    float restore_spindle_speed;
    if (block == NULL) {
    296a:	89 2b       	or	r24, r25
    296c:	51 f4       	brne	.+20     	; 0x2982 <protocol_execute_realtime+0x46>
      restore_condition = (gc_state.modal.spindle | gc_state.modal.coolant);
    296e:	ea ea       	ldi	r30, 0xAA	; 170
    2970:	f5 e0       	ldi	r31, 0x05	; 5
    2972:	d1 84       	ldd	r13, Z+9	; 0x09
    2974:	80 85       	ldd	r24, Z+8	; 0x08
    2976:	d8 2a       	or	r13, r24
      restore_spindle_speed = gc_state.spindle_speed;
    2978:	83 84       	ldd	r8, Z+11	; 0x0b
    297a:	94 84       	ldd	r9, Z+12	; 0x0c
    297c:	a5 84       	ldd	r10, Z+13	; 0x0d
    297e:	b6 84       	ldd	r11, Z+14	; 0x0e
    2980:	0b c0       	rjmp	.+22     	; 0x2998 <protocol_execute_realtime+0x5c>
    } else {
      restore_condition = (block->condition & PL_COND_SPINDLE_MASK) | coolant_get_state();
    2982:	89 89       	ldd	r24, Y+17	; 0x11
    2984:	18 2f       	mov	r17, r24
    2986:	10 73       	andi	r17, 0x30	; 48
    2988:	0e 94 b2 11 	call	0x2364	; 0x2364 <coolant_get_state>
    298c:	d8 2e       	mov	r13, r24
    298e:	d1 2a       	or	r13, r17
      restore_spindle_speed = block->spindle_speed;
    2990:	8e a4       	ldd	r8, Y+46	; 0x2e
    2992:	9f a4       	ldd	r9, Y+47	; 0x2f
    2994:	a8 a8       	ldd	r10, Y+48	; 0x30
    2996:	b9 a8       	ldd	r11, Y+49	; 0x31
    }
    #ifdef DISABLE_LASER_DURING_HOLD
      if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) { 
    2998:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <settings+0x45>
    299c:	81 ff       	sbrs	r24, 1
    299e:	03 c0       	rjmp	.+6      	; 0x29a6 <protocol_execute_realtime+0x6a>
        system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP);
    29a0:	80 e2       	ldi	r24, 0x20	; 32
    29a2:	0e 94 49 2e 	call	0x5c92	; 0x5c92 <system_set_exec_accessory_override_flag>
  #else
    if (block == NULL) { restore_condition = (gc_state.modal.spindle | gc_state.modal.coolant); }
    else { restore_condition = (block->condition & PL_COND_SPINDLE_MASK) | coolant_get_state(); }
  #endif

  while (sys.suspend) {
    29a6:	90 91 7e 05 	lds	r25, 0x057E	; 0x80057e <sys+0x2>
    29aa:	99 23       	and	r25, r25
    29ac:	09 f4       	brne	.+2      	; 0x29b0 <protocol_execute_realtime+0x74>
    29ae:	db c0       	rjmp	.+438    	; 0x2b66 <protocol_execute_realtime+0x22a>

    if (sys.abort) { return; }
    29b0:	80 91 7d 05 	lds	r24, 0x057D	; 0x80057d <sys+0x1>
    29b4:	81 11       	cpse	r24, r1
    29b6:	d7 c0       	rjmp	.+430    	; 0x2b66 <protocol_execute_realtime+0x22a>
    // Block until initial hold is complete and the machine has stopped motion.
    if (sys.suspend & SUSPEND_HOLD_COMPLETE) {

      // Parking manager. Handles de/re-energizing, switch state checks, and parking motions for 
      // the safety door and sleep states.
      if (sys.state & (STATE_SAFETY_DOOR | STATE_SLEEP)) {
    29b8:	cc e7       	ldi	r28, 0x7C	; 124
    29ba:	d5 e0       	ldi	r29, 0x05	; 5
          }
        } else {
          // Handles spindle state during hold. NOTE: Spindle speed overrides may be altered during hold state.
          // NOTE: STEP_CONTROL_UPDATE_SPINDLE_PWM is automatically reset upon resume in step generator.
          if (bit_istrue(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
            spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    29bc:	8d 2d       	mov	r24, r13
    29be:	80 73       	andi	r24, 0x30	; 48
    29c0:	c8 2e       	mov	r12, r24
            } else {
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
            }
          // Handles restoring of spindle state
          } else if (sys.spindle_stop_ovr & (SPINDLE_STOP_OVR_RESTORE | SPINDLE_STOP_OVR_RESTORE_CYCLE)) {
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    29c2:	0a ea       	ldi	r16, 0xAA	; 170
    29c4:	15 e0       	ldi	r17, 0x05	; 5
              report_feedback_message(MESSAGE_SPINDLE_RESTORE);
              if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    29c6:	0f 2e       	mov	r0, r31
    29c8:	f3 e5       	ldi	r31, 0x53	; 83
    29ca:	ef 2e       	mov	r14, r31
    29cc:	f7 e0       	ldi	r31, 0x07	; 7
    29ce:	ff 2e       	mov	r15, r31
    29d0:	f0 2d       	mov	r31, r0
        if (sys.spindle_stop_ovr) {
          // Handles beginning of spindle stop
          if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_INITIATE) {
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
              spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_ENABLED; // Set stop override state to enabled, if de-energized.
    29d2:	77 24       	eor	r7, r7
    29d4:	73 94       	inc	r7
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
              // Block if safety door re-opened during prior restore actions.
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
                // NOTE: Laser mode will honor this delay. An exhaust system is often controlled by this pin.
                coolant_set_state((restore_condition & (PL_COND_FLAG_COOLANT_FLOOD | PL_COND_FLAG_COOLANT_MIST)));
    29d6:	ed 2d       	mov	r30, r13
    29d8:	e0 7c       	andi	r30, 0xC0	; 192
    29da:	de 2e       	mov	r13, r30
    29dc:	03 c0       	rjmp	.+6      	; 0x29e4 <protocol_execute_realtime+0xa8>
    else { restore_condition = (block->condition & PL_COND_SPINDLE_MASK) | coolant_get_state(); }
  #endif

  while (sys.suspend) {

    if (sys.abort) { return; }
    29de:	29 81       	ldd	r18, Y+1	; 0x01
    29e0:	21 11       	cpse	r18, r1
    29e2:	c1 c0       	rjmp	.+386    	; 0x2b66 <protocol_execute_realtime+0x22a>

    // Block until initial hold is complete and the machine has stopped motion.
    if (sys.suspend & SUSPEND_HOLD_COMPLETE) {
    29e4:	90 ff       	sbrs	r25, 0
    29e6:	b2 c0       	rjmp	.+356    	; 0x2b4c <protocol_execute_realtime+0x210>

      // Parking manager. Handles de/re-energizing, switch state checks, and parking motions for 
      // the safety door and sleep states.
      if (sys.state & (STATE_SAFETY_DOOR | STATE_SLEEP)) {
    29e8:	28 81       	ld	r18, Y
    29ea:	32 2f       	mov	r19, r18
    29ec:	30 7c       	andi	r19, 0xC0	; 192
    29ee:	09 f4       	brne	.+2      	; 0x29f2 <protocol_execute_realtime+0xb6>
    29f0:	71 c0       	rjmp	.+226    	; 0x2ad4 <protocol_execute_realtime+0x198>
      
        // Handles retraction motions and de-energizing.
        if (bit_isfalse(sys.suspend,SUSPEND_RETRACT_COMPLETE)) {
    29f2:	92 fd       	sbrc	r25, 2
    29f4:	0f c0       	rjmp	.+30     	; 0x2a14 <protocol_execute_realtime+0xd8>

          // Ensure any prior spindle stop override is disabled at start of safety door routine.
          sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED;
    29f6:	1a 86       	std	Y+10, r1	; 0x0a

          #ifndef PARKING_ENABLE

            spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
    29f8:	40 e0       	ldi	r20, 0x00	; 0
    29fa:	50 e0       	ldi	r21, 0x00	; 0
    29fc:	ba 01       	movw	r22, r20
    29fe:	80 e0       	ldi	r24, 0x00	; 0
    2a00:	0e 94 71 11 	call	0x22e2	; 0x22e2 <spindle_set_state>
            coolant_set_state(COOLANT_DISABLE);     // De-energize
    2a04:	80 e0       	ldi	r24, 0x00	; 0
    2a06:	0e 94 be 11 	call	0x237c	; 0x237c <coolant_set_state>
            }

          #endif

          sys.suspend &= ~(SUSPEND_RESTART_RETRACT);
          sys.suspend |= SUSPEND_RETRACT_COMPLETE;
    2a0a:	8a 81       	ldd	r24, Y+2	; 0x02
    2a0c:	8d 7f       	andi	r24, 0xFD	; 253
    2a0e:	84 60       	ori	r24, 0x04	; 4
    2a10:	8a 83       	std	Y+2, r24	; 0x02
    2a12:	9c c0       	rjmp	.+312    	; 0x2b4c <protocol_execute_realtime+0x210>

        } else {

          
          if (sys.state == STATE_SLEEP) {
    2a14:	20 38       	cpi	r18, 0x80	; 128
    2a16:	d1 f4       	brne	.+52     	; 0x2a4c <protocol_execute_realtime+0x110>
            report_feedback_message(MESSAGE_SLEEP_MODE);
    2a18:	8b e0       	ldi	r24, 0x0B	; 11
    2a1a:	0e 94 f0 2c 	call	0x59e0	; 0x59e0 <report_feedback_message>
            // Spindle and coolant should already be stopped, but do it again just to be sure.
            spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
    2a1e:	40 e0       	ldi	r20, 0x00	; 0
    2a20:	50 e0       	ldi	r21, 0x00	; 0
    2a22:	ba 01       	movw	r22, r20
    2a24:	80 e0       	ldi	r24, 0x00	; 0
    2a26:	0e 94 71 11 	call	0x22e2	; 0x22e2 <spindle_set_state>
            coolant_set_state(COOLANT_DISABLE); // De-energize
    2a2a:	80 e0       	ldi	r24, 0x00	; 0
    2a2c:	0e 94 be 11 	call	0x237c	; 0x237c <coolant_set_state>
            st_go_idle(); // Disable steppers
    2a30:	0e 94 88 16 	call	0x2d10	; 0x2d10 <st_go_idle>
            while (!(sys.abort)) { protocol_exec_rt_system(); } // Do nothing until reset.
    2a34:	80 91 7d 05 	lds	r24, 0x057D	; 0x80057d <sys+0x1>
    2a38:	81 11       	cpse	r24, r1
    2a3a:	95 c0       	rjmp	.+298    	; 0x2b66 <protocol_execute_realtime+0x22a>
    2a3c:	cc e7       	ldi	r28, 0x7C	; 124
    2a3e:	d5 e0       	ldi	r29, 0x05	; 5
    2a40:	0e 94 da 12 	call	0x25b4	; 0x25b4 <protocol_exec_rt_system>
    2a44:	89 81       	ldd	r24, Y+1	; 0x01
    2a46:	88 23       	and	r24, r24
    2a48:	d9 f3       	breq	.-10     	; 0x2a40 <protocol_execute_realtime+0x104>
    2a4a:	8d c0       	rjmp	.+282    	; 0x2b66 <protocol_execute_realtime+0x22a>
            return; // Abort received. Return to re-initialize.
          }    
          
          // Allows resuming from parking/safety door. Actively checks if safety door is closed and ready to resume.
          if (sys.state == STATE_SAFETY_DOOR) {
    2a4c:	20 34       	cpi	r18, 0x40	; 64
    2a4e:	39 f4       	brne	.+14     	; 0x2a5e <protocol_execute_realtime+0x122>
            if (!(system_check_safety_door_ajar())) {
    2a50:	0e 94 54 2d 	call	0x5aa8	; 0x5aa8 <system_check_safety_door_ajar>
    2a54:	81 11       	cpse	r24, r1
    2a56:	03 c0       	rjmp	.+6      	; 0x2a5e <protocol_execute_realtime+0x122>
              sys.suspend &= ~(SUSPEND_SAFETY_DOOR_AJAR); // Reset door ajar flag to denote ready to resume.
    2a58:	8a 81       	ldd	r24, Y+2	; 0x02
    2a5a:	8f 7d       	andi	r24, 0xDF	; 223
    2a5c:	8a 83       	std	Y+2, r24	; 0x02
            }
          }

          // Handles parking restore and safety door resume.
          if (sys.suspend & SUSPEND_INITIATE_RESTORE) {
    2a5e:	8a 81       	ldd	r24, Y+2	; 0x02
    2a60:	83 ff       	sbrs	r24, 3
    2a62:	74 c0       	rjmp	.+232    	; 0x2b4c <protocol_execute_realtime+0x210>
                }
              }
            #endif

            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    2a64:	f8 01       	movw	r30, r16
    2a66:	91 85       	ldd	r25, Z+9	; 0x09
    2a68:	99 23       	and	r25, r25
    2a6a:	d1 f0       	breq	.+52     	; 0x2aa0 <protocol_execute_realtime+0x164>
              // Block if safety door re-opened during prior restore actions.
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    2a6c:	81 fd       	sbrc	r24, 1
    2a6e:	74 c0       	rjmp	.+232    	; 0x2b58 <protocol_execute_realtime+0x21c>
                if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    2a70:	f7 01       	movw	r30, r14
    2a72:	80 81       	ld	r24, Z
    2a74:	81 ff       	sbrs	r24, 1
    2a76:	08 c0       	rjmp	.+16     	; 0x2a88 <protocol_execute_realtime+0x14c>
                  // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
                  bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    2a78:	8c 81       	ldd	r24, Y+4	; 0x04
    2a7a:	88 60       	ori	r24, 0x08	; 8
    2a7c:	8c 83       	std	Y+4, r24	; 0x04
                  spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
                  delay_sec(SAFETY_DOOR_SPINDLE_DELAY, DELAY_MODE_SYS_SUSPEND);
                }
              }
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
    2a7e:	f8 01       	movw	r30, r16
    2a80:	80 85       	ldd	r24, Z+8	; 0x08
    2a82:	81 11       	cpse	r24, r1
    2a84:	14 c0       	rjmp	.+40     	; 0x2aae <protocol_execute_realtime+0x172>
    2a86:	6d c0       	rjmp	.+218    	; 0x2b62 <protocol_execute_realtime+0x226>
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
                if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
                  // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
                  bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
                } else {
                  spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    2a88:	b5 01       	movw	r22, r10
    2a8a:	a4 01       	movw	r20, r8
    2a8c:	8c 2d       	mov	r24, r12
    2a8e:	0e 94 71 11 	call	0x22e2	; 0x22e2 <spindle_set_state>
                  delay_sec(SAFETY_DOOR_SPINDLE_DELAY, DELAY_MODE_SYS_SUSPEND);
    2a92:	47 2d       	mov	r20, r7
    2a94:	60 e0       	ldi	r22, 0x00	; 0
    2a96:	70 e0       	ldi	r23, 0x00	; 0
    2a98:	80 e8       	ldi	r24, 0x80	; 128
    2a9a:	90 e4       	ldi	r25, 0x40	; 64
    2a9c:	0e 94 94 2a 	call	0x5528	; 0x5528 <delay_sec>
                }
              }
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
    2aa0:	f8 01       	movw	r30, r16
    2aa2:	80 85       	ldd	r24, Z+8	; 0x08
    2aa4:	88 23       	and	r24, r24
    2aa6:	69 f0       	breq	.+26     	; 0x2ac2 <protocol_execute_realtime+0x186>
              // Block if safety door re-opened during prior restore actions.
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    2aa8:	8a 81       	ldd	r24, Y+2	; 0x02
    2aaa:	81 fd       	sbrc	r24, 1
    2aac:	4f c0       	rjmp	.+158    	; 0x2b4c <protocol_execute_realtime+0x210>
                // NOTE: Laser mode will honor this delay. An exhaust system is often controlled by this pin.
                coolant_set_state((restore_condition & (PL_COND_FLAG_COOLANT_FLOOD | PL_COND_FLAG_COOLANT_MIST)));
    2aae:	8d 2d       	mov	r24, r13
    2ab0:	0e 94 be 11 	call	0x237c	; 0x237c <coolant_set_state>
                delay_sec(SAFETY_DOOR_COOLANT_DELAY, DELAY_MODE_SYS_SUSPEND);
    2ab4:	47 2d       	mov	r20, r7
    2ab6:	60 e0       	ldi	r22, 0x00	; 0
    2ab8:	70 e0       	ldi	r23, 0x00	; 0
    2aba:	80 e8       	ldi	r24, 0x80	; 128
    2abc:	9f e3       	ldi	r25, 0x3F	; 63
    2abe:	0e 94 94 2a 	call	0x5528	; 0x5528 <delay_sec>
                  mc_parking_motion(restore_target, pl_data);
                }
              }
            #endif

            if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    2ac2:	8a 81       	ldd	r24, Y+2	; 0x02
    2ac4:	81 fd       	sbrc	r24, 1
    2ac6:	42 c0       	rjmp	.+132    	; 0x2b4c <protocol_execute_realtime+0x210>
              sys.suspend |= SUSPEND_RESTORE_COMPLETE;
    2ac8:	80 61       	ori	r24, 0x10	; 16
    2aca:	8a 83       	std	Y+2, r24	; 0x02
              system_set_exec_state_flag(EXEC_CYCLE_START); // Set to resume program.
    2acc:	82 e0       	ldi	r24, 0x02	; 2
    2ace:	0e 94 21 2e 	call	0x5c42	; 0x5c42 <system_set_exec_state_flag>
    2ad2:	3c c0       	rjmp	.+120    	; 0x2b4c <protocol_execute_realtime+0x210>

      } else {

        // Feed hold manager. Controls spindle stop override states.
        // NOTE: Hold ensured as completed by condition check at the beginning of suspend routine.
        if (sys.spindle_stop_ovr) {
    2ad4:	9a 85       	ldd	r25, Y+10	; 0x0a
    2ad6:	99 23       	and	r25, r25
    2ad8:	71 f1       	breq	.+92     	; 0x2b36 <protocol_execute_realtime+0x1fa>
          // Handles beginning of spindle stop
          if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_INITIATE) {
    2ada:	91 ff       	sbrs	r25, 1
    2adc:	0e c0       	rjmp	.+28     	; 0x2afa <protocol_execute_realtime+0x1be>
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    2ade:	f8 01       	movw	r30, r16
    2ae0:	81 85       	ldd	r24, Z+9	; 0x09
    2ae2:	88 23       	and	r24, r24
    2ae4:	41 f0       	breq	.+16     	; 0x2af6 <protocol_execute_realtime+0x1ba>
              spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
    2ae6:	40 e0       	ldi	r20, 0x00	; 0
    2ae8:	50 e0       	ldi	r21, 0x00	; 0
    2aea:	ba 01       	movw	r22, r20
    2aec:	80 e0       	ldi	r24, 0x00	; 0
    2aee:	0e 94 71 11 	call	0x22e2	; 0x22e2 <spindle_set_state>
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_ENABLED; // Set stop override state to enabled, if de-energized.
    2af2:	7a 86       	std	Y+10, r7	; 0x0a
    2af4:	2b c0       	rjmp	.+86     	; 0x2b4c <protocol_execute_realtime+0x210>
            } else {
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
    2af6:	1a 86       	std	Y+10, r1	; 0x0a
    2af8:	29 c0       	rjmp	.+82     	; 0x2b4c <protocol_execute_realtime+0x210>
            }
          // Handles restoring of spindle state
          } else if (sys.spindle_stop_ovr & (SPINDLE_STOP_OVR_RESTORE | SPINDLE_STOP_OVR_RESTORE_CYCLE)) {
    2afa:	9c 70       	andi	r25, 0x0C	; 12
    2afc:	39 f1       	breq	.+78     	; 0x2b4c <protocol_execute_realtime+0x210>
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    2afe:	f8 01       	movw	r30, r16
    2b00:	81 85       	ldd	r24, Z+9	; 0x09
    2b02:	88 23       	and	r24, r24
    2b04:	81 f0       	breq	.+32     	; 0x2b26 <protocol_execute_realtime+0x1ea>
              report_feedback_message(MESSAGE_SPINDLE_RESTORE);
    2b06:	8a e0       	ldi	r24, 0x0A	; 10
    2b08:	0e 94 f0 2c 	call	0x59e0	; 0x59e0 <report_feedback_message>
              if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    2b0c:	f7 01       	movw	r30, r14
    2b0e:	80 81       	ld	r24, Z
    2b10:	81 ff       	sbrs	r24, 1
    2b12:	04 c0       	rjmp	.+8      	; 0x2b1c <protocol_execute_realtime+0x1e0>
                // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
                bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    2b14:	8c 81       	ldd	r24, Y+4	; 0x04
    2b16:	88 60       	ori	r24, 0x08	; 8
    2b18:	8c 83       	std	Y+4, r24	; 0x04
    2b1a:	05 c0       	rjmp	.+10     	; 0x2b26 <protocol_execute_realtime+0x1ea>
              } else {
                spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    2b1c:	b5 01       	movw	r22, r10
    2b1e:	a4 01       	movw	r20, r8
    2b20:	8c 2d       	mov	r24, r12
    2b22:	0e 94 71 11 	call	0x22e2	; 0x22e2 <spindle_set_state>
              }
            }
            if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_RESTORE_CYCLE) {
    2b26:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b28:	83 ff       	sbrs	r24, 3
    2b2a:	03 c0       	rjmp	.+6      	; 0x2b32 <protocol_execute_realtime+0x1f6>
              system_set_exec_state_flag(EXEC_CYCLE_START);  // Set to resume program.
    2b2c:	82 e0       	ldi	r24, 0x02	; 2
    2b2e:	0e 94 21 2e 	call	0x5c42	; 0x5c42 <system_set_exec_state_flag>
            }
            sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
    2b32:	1a 86       	std	Y+10, r1	; 0x0a
    2b34:	0b c0       	rjmp	.+22     	; 0x2b4c <protocol_execute_realtime+0x210>
          }
        } else {
          // Handles spindle state during hold. NOTE: Spindle speed overrides may be altered during hold state.
          // NOTE: STEP_CONTROL_UPDATE_SPINDLE_PWM is automatically reset upon resume in step generator.
          if (bit_istrue(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
    2b36:	8c 81       	ldd	r24, Y+4	; 0x04
    2b38:	83 ff       	sbrs	r24, 3
    2b3a:	08 c0       	rjmp	.+16     	; 0x2b4c <protocol_execute_realtime+0x210>
            spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    2b3c:	b5 01       	movw	r22, r10
    2b3e:	a4 01       	movw	r20, r8
    2b40:	8c 2d       	mov	r24, r12
    2b42:	0e 94 71 11 	call	0x22e2	; 0x22e2 <spindle_set_state>
            bit_false(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    2b46:	8c 81       	ldd	r24, Y+4	; 0x04
    2b48:	87 7f       	andi	r24, 0xF7	; 247
    2b4a:	8c 83       	std	Y+4, r24	; 0x04
        }

      }
    }

    protocol_exec_rt_system();
    2b4c:	0e 94 da 12 	call	0x25b4	; 0x25b4 <protocol_exec_rt_system>
  #else
    if (block == NULL) { restore_condition = (gc_state.modal.spindle | gc_state.modal.coolant); }
    else { restore_condition = (block->condition & PL_COND_SPINDLE_MASK) | coolant_get_state(); }
  #endif

  while (sys.suspend) {
    2b50:	9a 81       	ldd	r25, Y+2	; 0x02
    2b52:	91 11       	cpse	r25, r1
    2b54:	44 cf       	rjmp	.-376    	; 0x29de <protocol_execute_realtime+0xa2>
    2b56:	07 c0       	rjmp	.+14     	; 0x2b66 <protocol_execute_realtime+0x22a>
                  spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
                  delay_sec(SAFETY_DOOR_SPINDLE_DELAY, DELAY_MODE_SYS_SUSPEND);
                }
              }
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
    2b58:	f8 01       	movw	r30, r16
    2b5a:	80 85       	ldd	r24, Z+8	; 0x08
    2b5c:	81 11       	cpse	r24, r1
    2b5e:	f6 cf       	rjmp	.-20     	; 0x2b4c <protocol_execute_realtime+0x210>
    2b60:	b0 cf       	rjmp	.-160    	; 0x2ac2 <protocol_execute_realtime+0x186>
                  mc_parking_motion(restore_target, pl_data);
                }
              }
            #endif

            if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    2b62:	8a 81       	ldd	r24, Y+2	; 0x02
    2b64:	b1 cf       	rjmp	.-158    	; 0x2ac8 <protocol_execute_realtime+0x18c>
// limit switches, or the main program.
void protocol_execute_realtime()
{
  protocol_exec_rt_system();
  if (sys.suspend) { protocol_exec_rt_suspend(); }
}
    2b66:	df 91       	pop	r29
    2b68:	cf 91       	pop	r28
    2b6a:	1f 91       	pop	r17
    2b6c:	0f 91       	pop	r16
    2b6e:	ff 90       	pop	r15
    2b70:	ef 90       	pop	r14
    2b72:	df 90       	pop	r13
    2b74:	cf 90       	pop	r12
    2b76:	bf 90       	pop	r11
    2b78:	af 90       	pop	r10
    2b7a:	9f 90       	pop	r9
    2b7c:	8f 90       	pop	r8
    2b7e:	7f 90       	pop	r7
    2b80:	08 95       	ret

00002b82 <protocol_main_loop>:

/*
  GRBL PRIMARY LOOP:
*/
void protocol_main_loop()
{
    2b82:	ff 92       	push	r15
    2b84:	0f 93       	push	r16
    2b86:	1f 93       	push	r17
    2b88:	cf 93       	push	r28
    2b8a:	df 93       	push	r29
  // Perform some machine checks to make sure everything is good to go.
  #ifdef CHECK_LIMITS_AT_INIT
    if (bit_istrue(settings.flags, BITFLAG_HARD_LIMIT_ENABLE)) {
    2b8c:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <settings+0x45>
    2b90:	83 ff       	sbrs	r24, 3
    2b92:	0a c0       	rjmp	.+20     	; 0x2ba8 <protocol_main_loop+0x26>
      if (limits_get_state()) {
    2b94:	0e 94 fd 2b 	call	0x57fa	; 0x57fa <limits_get_state>
    2b98:	88 23       	and	r24, r24
    2b9a:	31 f0       	breq	.+12     	; 0x2ba8 <protocol_main_loop+0x26>
        sys.state = STATE_ALARM; // Ensure alarm state is active.
    2b9c:	81 e0       	ldi	r24, 0x01	; 1
    2b9e:	80 93 7c 05 	sts	0x057C, r24	; 0x80057c <sys>
        report_feedback_message(MESSAGE_CHECK_LIMITS);
    2ba2:	87 e0       	ldi	r24, 0x07	; 7
    2ba4:	0e 94 f0 2c 	call	0x59e0	; 0x59e0 <report_feedback_message>
  #endif
  
  // Check for and report alarm state after a reset, error, or an initial power up.
  // NOTE: Sleep mode disables the stepper drivers and position can't be guaranteed.
  // Re-initialize the sleep state as an ALARM mode to ensure user homes or acknowledges.
  if (sys.state & (STATE_ALARM | STATE_SLEEP)) {
    2ba8:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    2bac:	81 78       	andi	r24, 0x81	; 129
    2bae:	61 f0       	breq	.+24     	; 0x2bc8 <protocol_main_loop+0x46>
    report_feedback_message(MESSAGE_ALARM_LOCK);
    2bb0:	82 e0       	ldi	r24, 0x02	; 2
    2bb2:	0e 94 f0 2c 	call	0x59e0	; 0x59e0 <report_feedback_message>
    sys.state = STATE_ALARM; // Ensure alarm state is set.
    2bb6:	81 e0       	ldi	r24, 0x01	; 1
    2bb8:	80 93 7c 05 	sts	0x057C, r24	; 0x80057c <sys>
		  {
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            line_flags |= LINE_FLAG_COMMENT_PARENTHESES;
    2bbc:	c0 e0       	ldi	r28, 0x00	; 0
    2bbe:	d0 e0       	ldi	r29, 0x00	; 0
    // this indicates that g-code streaming has either filled the planner buffer or has
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();

    protocol_execute_realtime();  // Runtime command check point.
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    2bc0:	0c e7       	ldi	r16, 0x7C	; 124
    2bc2:	15 e0       	ldi	r17, 0x05	; 5
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    2bc4:	f1 2c       	mov	r15, r1
    2bc6:	64 c0       	rjmp	.+200    	; 0x2c90 <protocol_main_loop+0x10e>
  if (sys.state & (STATE_ALARM | STATE_SLEEP)) {
    report_feedback_message(MESSAGE_ALARM_LOCK);
    sys.state = STATE_ALARM; // Ensure alarm state is set.
  } else {
    // Check if the safety door is open.
    sys.state = STATE_IDLE;
    2bc8:	10 92 7c 05 	sts	0x057C, r1	; 0x80057c <sys>
    if (system_check_safety_door_ajar()) {
    2bcc:	0e 94 54 2d 	call	0x5aa8	; 0x5aa8 <system_check_safety_door_ajar>
    2bd0:	88 23       	and	r24, r24
    2bd2:	39 f0       	breq	.+14     	; 0x2be2 <protocol_main_loop+0x60>
      bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
    2bd4:	80 91 8e 05 	lds	r24, 0x058E	; 0x80058e <sys_rt_exec_state>
    2bd8:	80 62       	ori	r24, 0x20	; 32
    2bda:	80 93 8e 05 	sts	0x058E, r24	; 0x80058e <sys_rt_exec_state>
      protocol_execute_realtime(); // Enter safety door mode. Should return as IDLE state.
    2bde:	0e 94 9e 14 	call	0x293c	; 0x293c <protocol_execute_realtime>
    }
    // All systems go!
    system_execute_startup(line); // Execute startup script.
    2be2:	8a e0       	ldi	r24, 0x0A	; 10
    2be4:	91 e0       	ldi	r25, 0x01	; 1
    2be6:	0e 94 56 2d 	call	0x5aac	; 0x5aac <system_execute_startup>
    2bea:	e8 cf       	rjmp	.-48     	; 0x2bbc <protocol_main_loop+0x3a>
    while((c = serial_read()) != SERIAL_NO_DATA) 
#else
    while((c = gcode_get_byte()) != SERIAL_NO_DATA)
#endif
	{
      if ((c == '\n') || (c == '\r')) 
    2bec:	8a 30       	cpi	r24, 0x0A	; 10
    2bee:	11 f0       	breq	.+4      	; 0x2bf4 <protocol_main_loop+0x72>
    2bf0:	8d 30       	cpi	r24, 0x0D	; 13
    2bf2:	31 f5       	brne	.+76     	; 0x2c40 <protocol_main_loop+0xbe>
	  { // End of line reached

        protocol_execute_realtime(); // Runtime command check point.
    2bf4:	0e 94 9e 14 	call	0x293c	; 0x293c <protocol_execute_realtime>
		
        if (sys.abort) 
    2bf8:	f8 01       	movw	r30, r16
    2bfa:	81 81       	ldd	r24, Z+1	; 0x01
    2bfc:	81 11       	cpse	r24, r1
    2bfe:	55 c0       	rjmp	.+170    	; 0x2caa <protocol_main_loop+0x128>
		{ 
			return;
		} // Bail to calling function upon system abort

        line[char_counter] = 0; // Set string termination character.
    2c00:	ec 2f       	mov	r30, r28
    2c02:	f0 e0       	ldi	r31, 0x00	; 0
    2c04:	e6 5f       	subi	r30, 0xF6	; 246
    2c06:	fe 4f       	sbci	r31, 0xFE	; 254
    2c08:	10 82       	st	Z, r1
		#ifdef REPORT_ECHO_LINE_RECEIVED
          report_echo_line_received(line);
        #endif
		
        // Direct and execute one line of formatted input, and report status of execution.
        if (line_flags & LINE_FLAG_OVERFLOW) 
    2c0a:	d0 ff       	sbrs	r29, 0
    2c0c:	06 c0       	rjmp	.+12     	; 0x2c1a <protocol_main_loop+0x98>
		{
          // Report line overflow error.
          report_status_message(STATUS_OVERFLOW);
    2c0e:	8b e0       	ldi	r24, 0x0B	; 11
    2c10:	0e 94 ee 2c 	call	0x59dc	; 0x59dc <report_status_message>
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    2c14:	cf 2d       	mov	r28, r15
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    2c16:	d0 e0       	ldi	r29, 0x00	; 0
    2c18:	3b c0       	rjmp	.+118    	; 0x2c90 <protocol_main_loop+0x10e>
		{
          // Grbl '$' system command
          report_status_message(system_execute_line(line));
        }
#endif
		else if (sys.state & (STATE_ALARM | STATE_JOG)) 
    2c1a:	f8 01       	movw	r30, r16
    2c1c:	80 81       	ld	r24, Z
    2c1e:	81 72       	andi	r24, 0x21	; 33
    2c20:	31 f0       	breq	.+12     	; 0x2c2e <protocol_main_loop+0xac>
		{
          // Everything else is gcode. Block if in alarm or jog mode.
          report_status_message(STATUS_SYSTEM_GC_LOCK);
    2c22:	89 e0       	ldi	r24, 0x09	; 9
    2c24:	0e 94 ee 2c 	call	0x59dc	; 0x59dc <report_status_message>
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    2c28:	cf 2d       	mov	r28, r15
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    2c2a:	d0 e0       	ldi	r29, 0x00	; 0
    2c2c:	31 c0       	rjmp	.+98     	; 0x2c90 <protocol_main_loop+0x10e>
          report_status_message(STATUS_SYSTEM_GC_LOCK);
        } 
		else 
		{
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
    2c2e:	8a e0       	ldi	r24, 0x0A	; 10
    2c30:	91 e0       	ldi	r25, 0x01	; 1
    2c32:	0e 94 9a 05 	call	0xb34	; 0xb34 <gc_execute_line>
    2c36:	0e 94 ee 2c 	call	0x59dc	; 0x59dc <report_status_message>
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    2c3a:	cf 2d       	mov	r28, r15
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    2c3c:	d0 e0       	ldi	r29, 0x00	; 0
    2c3e:	28 c0       	rjmp	.+80     	; 0x2c90 <protocol_main_loop+0x10e>
        char_counter = 0;
      } 
	  else 
      {
        if (line_flags) 
    2c40:	dd 23       	and	r29, r29
    2c42:	21 f0       	breq	.+8      	; 0x2c4c <protocol_main_loop+0xca>
		{
          // Throw away all (except EOL) comment characters and overflow characters.
          if (c == ')') 
    2c44:	89 32       	cpi	r24, 0x29	; 41
    2c46:	21 f5       	brne	.+72     	; 0x2c90 <protocol_main_loop+0x10e>
		  {
            // End of '()' comment. Resume line allowed.
            if (line_flags & LINE_FLAG_COMMENT_PARENTHESES)
			{ 
				line_flags &= ~(LINE_FLAG_COMMENT_PARENTHESES); 
    2c48:	dd 7f       	andi	r29, 0xFD	; 253
    2c4a:	22 c0       	rjmp	.+68     	; 0x2c90 <protocol_main_loop+0x10e>
			}
          }
        } 
		else 
		{
          if (c <= ' ') 
    2c4c:	81 32       	cpi	r24, 0x21	; 33
    2c4e:	00 f1       	brcs	.+64     	; 0x2c90 <protocol_main_loop+0x10e>
		  {
            // Throw away whitepace and control characters
          } 
		  else if (c == '/') 
    2c50:	8f 32       	cpi	r24, 0x2F	; 47
    2c52:	f1 f0       	breq	.+60     	; 0x2c90 <protocol_main_loop+0x10e>
		  {
            // Block delete NOT SUPPORTED. Ignore character.
            // NOTE: If supported, would simply need to check the system if block delete is enabled.
          } 
		  else if (c == '(') 
    2c54:	88 32       	cpi	r24, 0x28	; 40
    2c56:	b9 f0       	breq	.+46     	; 0x2c86 <protocol_main_loop+0x104>
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            line_flags |= LINE_FLAG_COMMENT_PARENTHESES;
          } 
		  else if (c == ';') 
    2c58:	8b 33       	cpi	r24, 0x3B	; 59
    2c5a:	b9 f0       	breq	.+46     	; 0x2c8a <protocol_main_loop+0x108>
            // NOTE: This maybe installed to tell Grbl when a program is running vs manual input,
            // where, during a program, the system auto-cycle start will continue to execute
            // everything until the next '%' sign. This will help fix resuming issues with certain
            // functions that empty the planner buffer to execute its task on-time.
          } 
		  else if (char_counter >= (LINE_BUFFER_SIZE-1)) 
    2c5c:	cf 34       	cpi	r28, 0x4F	; 79
    2c5e:	b8 f4       	brcc	.+46     	; 0x2c8e <protocol_main_loop+0x10c>
		  {
            // Detect line buffer overflow and set flag.
            line_flags |= LINE_FLAG_OVERFLOW;
          } 
		  else if (c >= 'a' && c <= 'z') 
    2c60:	9f e9       	ldi	r25, 0x9F	; 159
    2c62:	98 0f       	add	r25, r24
    2c64:	9a 31       	cpi	r25, 0x1A	; 26
    2c66:	40 f4       	brcc	.+16     	; 0x2c78 <protocol_main_loop+0xf6>
		  { // Upcase lowercase
            line[char_counter++] = c-'a'+'A';
    2c68:	ec 2f       	mov	r30, r28
    2c6a:	f0 e0       	ldi	r31, 0x00	; 0
    2c6c:	e6 5f       	subi	r30, 0xF6	; 246
    2c6e:	fe 4f       	sbci	r31, 0xFE	; 254
    2c70:	80 52       	subi	r24, 0x20	; 32
    2c72:	80 83       	st	Z, r24
    2c74:	cf 5f       	subi	r28, 0xFF	; 255
    2c76:	0c c0       	rjmp	.+24     	; 0x2c90 <protocol_main_loop+0x10e>
          } 
		  else 
		  {
            line[char_counter++] = c;
    2c78:	ec 2f       	mov	r30, r28
    2c7a:	f0 e0       	ldi	r31, 0x00	; 0
    2c7c:	e6 5f       	subi	r30, 0xF6	; 246
    2c7e:	fe 4f       	sbci	r31, 0xFE	; 254
    2c80:	80 83       	st	Z, r24
    2c82:	cf 5f       	subi	r28, 0xFF	; 255
    2c84:	05 c0       	rjmp	.+10     	; 0x2c90 <protocol_main_loop+0x10e>
		  {
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            line_flags |= LINE_FLAG_COMMENT_PARENTHESES;
    2c86:	d2 e0       	ldi	r29, 0x02	; 2
    2c88:	03 c0       	rjmp	.+6      	; 0x2c90 <protocol_main_loop+0x10e>
          } 
		  else if (c == ';') 
		  {
            // NOTE: ';' comment to EOL is a LinuxCNC definition. Not NIST.
            line_flags |= LINE_FLAG_COMMENT_SEMICOLON;
    2c8a:	d4 e0       	ldi	r29, 0x04	; 4
    2c8c:	01 c0       	rjmp	.+2      	; 0x2c90 <protocol_main_loop+0x10e>
            // functions that empty the planner buffer to execute its task on-time.
          } 
		  else if (char_counter >= (LINE_BUFFER_SIZE-1)) 
		  {
            // Detect line buffer overflow and set flag.
            line_flags |= LINE_FLAG_OVERFLOW;
    2c8e:	d1 e0       	ldi	r29, 0x01	; 1
    // Process one line of incoming serial data, as the data becomes available. Performs an
    // initial filtering by removing spaces and comments and capitalizing all letters.
#ifndef STANDALONE_CTRL
    while((c = serial_read()) != SERIAL_NO_DATA) 
#else
    while((c = gcode_get_byte()) != SERIAL_NO_DATA)
    2c90:	0e 94 c6 12 	call	0x258c	; 0x258c <gcode_get_byte>
    2c94:	8f 3f       	cpi	r24, 0xFF	; 255
    2c96:	09 f0       	breq	.+2      	; 0x2c9a <protocol_main_loop+0x118>
    2c98:	a9 cf       	rjmp	.-174    	; 0x2bec <protocol_main_loop+0x6a>
    }

    // If there are no more characters in the serial read buffer to be processed and executed,
    // this indicates that g-code streaming has either filled the planner buffer or has
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();
    2c9a:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <protocol_auto_cycle_start>

    protocol_execute_realtime();  // Runtime command check point.
    2c9e:	0e 94 9e 14 	call	0x293c	; 0x293c <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    2ca2:	f8 01       	movw	r30, r16
    2ca4:	81 81       	ldd	r24, Z+1	; 0x01
    2ca6:	88 23       	and	r24, r24
    2ca8:	99 f3       	breq	.-26     	; 0x2c90 <protocol_main_loop+0x10e>
  }

  return; /* Never reached */
}
    2caa:	df 91       	pop	r29
    2cac:	cf 91       	pop	r28
    2cae:	1f 91       	pop	r17
    2cb0:	0f 91       	pop	r16
    2cb2:	ff 90       	pop	r15
    2cb4:	08 95       	ret

00002cb6 <protocol_buffer_synchronize>:


// Block until all buffered steps are executed or in a cycle state. Works with feed hold
// during a synchronize call, if it should happen. Also, waits for clean cycle end.
void protocol_buffer_synchronize()
{
    2cb6:	cf 93       	push	r28
    2cb8:	df 93       	push	r29
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
    2cba:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <protocol_auto_cycle_start>
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    if (sys.abort) { return; } // Check for system abort
    2cbe:	cc e7       	ldi	r28, 0x7C	; 124
    2cc0:	d5 e0       	ldi	r29, 0x05	; 5
void protocol_buffer_synchronize()
{
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    2cc2:	0e 94 9e 14 	call	0x293c	; 0x293c <protocol_execute_realtime>
    if (sys.abort) { return; } // Check for system abort
    2cc6:	89 81       	ldd	r24, Y+1	; 0x01
    2cc8:	81 11       	cpse	r24, r1
    2cca:	07 c0       	rjmp	.+14     	; 0x2cda <protocol_buffer_synchronize+0x24>
  } while (plan_get_current_block() || (sys.state == STATE_CYCLE));
    2ccc:	0e 94 38 25 	call	0x4a70	; 0x4a70 <plan_get_current_block>
    2cd0:	89 2b       	or	r24, r25
    2cd2:	b9 f7       	brne	.-18     	; 0x2cc2 <protocol_buffer_synchronize+0xc>
    2cd4:	88 81       	ld	r24, Y
    2cd6:	88 30       	cpi	r24, 0x08	; 8
    2cd8:	a1 f3       	breq	.-24     	; 0x2cc2 <protocol_buffer_synchronize+0xc>
}
    2cda:	df 91       	pop	r29
    2cdc:	cf 91       	pop	r28
    2cde:	08 95       	ret

00002ce0 <st_wake_up>:
// Stepper state initialization. Cycle should only start if the st.cycle_start flag is
// enabled. Startup init and limits call this function but shouldn't start the cycle.
void st_wake_up()
{
  // Enable stepper drivers.
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    2ce0:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <settings+0x45>
    2ce4:	82 ff       	sbrs	r24, 2
    2ce6:	02 c0       	rjmp	.+4      	; 0x2cec <st_wake_up+0xc>
    2ce8:	28 9a       	sbi	0x05, 0	; 5
    2cea:	01 c0       	rjmp	.+2      	; 0x2cee <st_wake_up+0xe>
  else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    2cec:	28 98       	cbi	0x05, 0	; 5

  // Initialize stepper output bits to ensure first ISR call does not step.
  st.step_outbits = step_port_invert_mask;
    2cee:	e4 e9       	ldi	r30, 0x94	; 148
    2cf0:	f1 e0       	ldi	r31, 0x01	; 1
    2cf2:	80 91 90 01 	lds	r24, 0x0190	; 0x800190 <step_port_invert_mask>
    2cf6:	86 87       	std	Z+14, r24	; 0x0e
    st.step_pulse_time = -(((settings.pulse_microseconds+STEP_PULSE_DELAY-2)*TICKS_PER_MICROSECOND) >> 3);
    // Set delay between direction pin write and step command.
    OCR0A = -(((settings.pulse_microseconds)*TICKS_PER_MICROSECOND) >> 3);
  #else // Normal operation
    // Set step pulse time. Ad hoc computation from oscilloscope. Uses two's complement.
    st.step_pulse_time = -(((settings.pulse_microseconds-2)*TICKS_PER_MICROSECOND) >> 3);
    2cf8:	80 91 3e 07 	lds	r24, 0x073E	; 0x80073e <settings+0x30>
    2cfc:	88 0f       	add	r24, r24
    2cfe:	84 50       	subi	r24, 0x04	; 4
    2d00:	81 95       	neg	r24
    2d02:	85 87       	std	Z+13, r24	; 0x0d
  #endif

  // Enable Stepper Driver Interrupt
  TIMSK1 |= (1<<OCIE1A);
    2d04:	ef e6       	ldi	r30, 0x6F	; 111
    2d06:	f0 e0       	ldi	r31, 0x00	; 0
    2d08:	80 81       	ld	r24, Z
    2d0a:	82 60       	ori	r24, 0x02	; 2
    2d0c:	80 83       	st	Z, r24
    2d0e:	08 95       	ret

00002d10 <st_go_idle>:

// Stepper shutdown
void st_go_idle()
{
  // Disable Stepper Driver Interrupt. Allow Stepper Port Reset Interrupt to finish, if active.
  TIMSK1 &= ~(1<<OCIE1A); // Disable Timer1 interrupt
    2d10:	ef e6       	ldi	r30, 0x6F	; 111
    2d12:	f0 e0       	ldi	r31, 0x00	; 0
    2d14:	80 81       	ld	r24, Z
    2d16:	8d 7f       	andi	r24, 0xFD	; 253
    2d18:	80 83       	st	Z, r24
  TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Reset clock to no prescaling.
    2d1a:	e1 e8       	ldi	r30, 0x81	; 129
    2d1c:	f0 e0       	ldi	r31, 0x00	; 0
    2d1e:	80 81       	ld	r24, Z
    2d20:	88 7f       	andi	r24, 0xF8	; 248
    2d22:	81 60       	ori	r24, 0x01	; 1
    2d24:	80 83       	st	Z, r24
  busy = false;
    2d26:	10 92 8e 01 	sts	0x018E, r1	; 0x80018e <busy>

  // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
  bool pin_state = false; // Keep enabled.
  if (((settings.stepper_idle_lock_time != 0xff) || sys_rt_exec_alarm || sys.state == STATE_SLEEP) && sys.state != STATE_HOMING) {
    2d2a:	80 91 41 07 	lds	r24, 0x0741	; 0x800741 <settings+0x33>
    2d2e:	8f 3f       	cpi	r24, 0xFF	; 255
    2d30:	49 f4       	brne	.+18     	; 0x2d44 <st_go_idle+0x34>
    2d32:	90 91 a8 05 	lds	r25, 0x05A8	; 0x8005a8 <sys_rt_exec_alarm>
    2d36:	91 11       	cpse	r25, r1
    2d38:	05 c0       	rjmp	.+10     	; 0x2d44 <st_go_idle+0x34>
    2d3a:	90 91 7c 05 	lds	r25, 0x057C	; 0x80057c <sys>
    2d3e:	90 38       	cpi	r25, 0x80	; 128
    2d40:	81 f4       	brne	.+32     	; 0x2d62 <st_go_idle+0x52>
    2d42:	04 c0       	rjmp	.+8      	; 0x2d4c <st_go_idle+0x3c>
    2d44:	90 91 7c 05 	lds	r25, 0x057C	; 0x80057c <sys>
    2d48:	94 30       	cpi	r25, 0x04	; 4
    2d4a:	59 f0       	breq	.+22     	; 0x2d62 <st_go_idle+0x52>
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    2d4c:	90 e0       	ldi	r25, 0x00	; 0
    2d4e:	0e 94 d1 2a 	call	0x55a2	; 0x55a2 <delay_ms>
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    2d52:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <settings+0x45>
    2d56:	82 fd       	sbrc	r24, 2
    2d58:	02 c0       	rjmp	.+4      	; 0x2d5e <st_go_idle+0x4e>
  if (pin_state) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    2d5a:	28 9a       	sbi	0x05, 0	; 5
    2d5c:	08 95       	ret
  else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    2d5e:	28 98       	cbi	0x05, 0	; 5
}
    2d60:	08 95       	ret
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    2d62:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <settings+0x45>
    2d66:	82 ff       	sbrs	r24, 2
    2d68:	fa cf       	rjmp	.-12     	; 0x2d5e <st_go_idle+0x4e>
    2d6a:	f7 cf       	rjmp	.-18     	; 0x2d5a <st_go_idle+0x4a>

00002d6c <__vector_11>:
*/
// TODO: Replace direct updating of the int32 position counters in the ISR somehow. Perhaps use smaller
// int8 variables and update position counters only when a segment completes. This can get complicated
// with probing and homing cycles that require true real-time positions.
ISR(TIMER1_COMPA_vect)
{
    2d6c:	1f 92       	push	r1
    2d6e:	0f 92       	push	r0
    2d70:	0f b6       	in	r0, 0x3f	; 63
    2d72:	0f 92       	push	r0
    2d74:	11 24       	eor	r1, r1
    2d76:	2f 93       	push	r18
    2d78:	3f 93       	push	r19
    2d7a:	4f 93       	push	r20
    2d7c:	5f 93       	push	r21
    2d7e:	6f 93       	push	r22
    2d80:	7f 93       	push	r23
    2d82:	8f 93       	push	r24
    2d84:	9f 93       	push	r25
    2d86:	af 93       	push	r26
    2d88:	bf 93       	push	r27
    2d8a:	cf 93       	push	r28
    2d8c:	df 93       	push	r29
    2d8e:	ef 93       	push	r30
    2d90:	ff 93       	push	r31
  if (busy) { return; } // The busy-flag is used to avoid reentering this interrupt
    2d92:	80 91 8e 01 	lds	r24, 0x018E	; 0x80018e <busy>
    2d96:	81 11       	cpse	r24, r1
    2d98:	ce c1       	rjmp	.+924    	; 0x3136 <__vector_11+0x3ca>

  // Set the direction pins a couple of nanoseconds before we step the steppers
  DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | (st.dir_outbits & DIRECTION_MASK);
    2d9a:	8b b1       	in	r24, 0x0b	; 11
    2d9c:	e4 e9       	ldi	r30, 0x94	; 148
    2d9e:	f1 e0       	ldi	r31, 0x01	; 1
    2da0:	97 85       	ldd	r25, Z+15	; 0x0f
    2da2:	90 7e       	andi	r25, 0xE0	; 224
    2da4:	8f 71       	andi	r24, 0x1F	; 31
    2da6:	89 2b       	or	r24, r25
    2da8:	8b b9       	out	0x0b, r24	; 11
    st.step_bits = (STEP_PORT & ~STEP_MASK) | st.step_outbits; // Store out_bits to prevent overwriting.
    #ifdef ENABLE_DUAL_AXIS
      st.step_bits_dual = (STEP_PORT_DUAL & ~STEP_MASK_DUAL) | st.step_outbits_dual;
    #endif
  #else  // Normal operation
    STEP_PORT = (STEP_PORT & ~STEP_MASK) | st.step_outbits;
    2daa:	8b b1       	in	r24, 0x0b	; 11
    2dac:	83 7e       	andi	r24, 0xE3	; 227
    2dae:	96 85       	ldd	r25, Z+14	; 0x0e
    2db0:	89 2b       	or	r24, r25
    2db2:	8b b9       	out	0x0b, r24	; 11
    #endif
  #endif

  // Enable step pulse reset timer so that The Stepper Port Reset Interrupt can reset the signal after
  // exactly settings.pulse_microseconds microseconds, independent of the main Timer1 prescaler.
  TCNT0 = st.step_pulse_time; // Reload Timer0 counter
    2db4:	85 85       	ldd	r24, Z+13	; 0x0d
    2db6:	86 bd       	out	0x26, r24	; 38
  TCCR0B = (1<<CS01); // Begin Timer0. Full speed, 1/8 prescaler
    2db8:	82 e0       	ldi	r24, 0x02	; 2
    2dba:	85 bd       	out	0x25, r24	; 37

  busy = true;
    2dbc:	81 e0       	ldi	r24, 0x01	; 1
    2dbe:	80 93 8e 01 	sts	0x018E, r24	; 0x80018e <busy>
  sei(); // Re-enable interrupts to allow Stepper Port Reset Interrupt to fire on-time.
    2dc2:	78 94       	sei
         // NOTE: The remaining code in this ISR will finish before returning to main program.

  // If there is no step segment, attempt to pop one from the stepper buffer
  if (st.exec_segment == NULL) {
    2dc4:	81 a1       	ldd	r24, Z+33	; 0x21
    2dc6:	92 a1       	ldd	r25, Z+34	; 0x22
    2dc8:	89 2b       	or	r24, r25
    2dca:	09 f0       	breq	.+2      	; 0x2dce <__vector_11+0x62>
    2dcc:	a7 c0       	rjmp	.+334    	; 0x2f1c <__vector_11+0x1b0>
    // Anything in the buffer? If so, load and initialize next step segment.
    if (segment_buffer_head != segment_buffer_tail) {
    2dce:	80 91 93 01 	lds	r24, 0x0193	; 0x800193 <segment_buffer_tail>
    2dd2:	90 91 92 01 	lds	r25, 0x0192	; 0x800192 <segment_buffer_head>
    2dd6:	98 17       	cp	r25, r24
    2dd8:	09 f4       	brne	.+2      	; 0x2ddc <__vector_11+0x70>
    2dda:	90 c0       	rjmp	.+288    	; 0x2efc <__vector_11+0x190>
      // Initialize new step segment and load number of steps to execute
      st.exec_segment = &segment_buffer[segment_buffer_tail];
    2ddc:	e0 91 93 01 	lds	r30, 0x0193	; 0x800193 <segment_buffer_tail>
    2de0:	a4 e9       	ldi	r26, 0x94	; 148
    2de2:	b1 e0       	ldi	r27, 0x01	; 1
    2de4:	87 e0       	ldi	r24, 0x07	; 7
    2de6:	e8 9f       	mul	r30, r24
    2de8:	f0 01       	movw	r30, r0
    2dea:	11 24       	eor	r1, r1
    2dec:	e9 54       	subi	r30, 0x49	; 73
    2dee:	fe 4f       	sbci	r31, 0xFE	; 254
    2df0:	92 96       	adiw	r26, 0x22	; 34
    2df2:	fc 93       	st	X, r31
    2df4:	ee 93       	st	-X, r30
    2df6:	91 97       	sbiw	r26, 0x21	; 33
        // With AMASS is disabled, set timer prescaler for segments with slow step frequencies (< 250Hz).
        TCCR1B = (TCCR1B & ~(0x07<<CS10)) | (st.exec_segment->prescaler<<CS10);
      #endif

      // Initialize step segment timing per step and load number of steps to execute.
      OCR1A = st.exec_segment->cycles_per_tick;
    2df8:	82 81       	ldd	r24, Z+2	; 0x02
    2dfa:	93 81       	ldd	r25, Z+3	; 0x03
    2dfc:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
    2e00:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
      st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
    2e04:	80 81       	ld	r24, Z
    2e06:	91 81       	ldd	r25, Z+1	; 0x01
    2e08:	5d 96       	adiw	r26, 0x1d	; 29
    2e0a:	9c 93       	st	X, r25
    2e0c:	8e 93       	st	-X, r24
    2e0e:	5c 97       	sbiw	r26, 0x1c	; 28
      // If the new segment starts a new planner block, initialize stepper variables and counters.
      // NOTE: When the segment data index changes, this indicates a new planner block.
      if ( st.exec_block_index != st.exec_segment->st_block_index ) {
    2e10:	84 81       	ldd	r24, Z+4	; 0x04
    2e12:	5e 96       	adiw	r26, 0x1e	; 30
    2e14:	9c 91       	ld	r25, X
    2e16:	5e 97       	sbiw	r26, 0x1e	; 30
    2e18:	98 17       	cp	r25, r24
    2e1a:	49 f1       	breq	.+82     	; 0x2e6e <__vector_11+0x102>
        st.exec_block_index = st.exec_segment->st_block_index;
    2e1c:	ed 01       	movw	r28, r26
    2e1e:	8e 8f       	std	Y+30, r24	; 0x1e
        st.exec_block = &st_block_buffer[st.exec_block_index];
    2e20:	90 e0       	ldi	r25, 0x00	; 0
    2e22:	88 0f       	add	r24, r24
    2e24:	99 1f       	adc	r25, r25
    2e26:	dc 01       	movw	r26, r24
    2e28:	aa 0f       	add	r26, r26
    2e2a:	bb 1f       	adc	r27, r27
    2e2c:	aa 0f       	add	r26, r26
    2e2e:	bb 1f       	adc	r27, r27
    2e30:	aa 0f       	add	r26, r26
    2e32:	bb 1f       	adc	r27, r27
    2e34:	8a 0f       	add	r24, r26
    2e36:	9b 1f       	adc	r25, r27
    2e38:	dc 01       	movw	r26, r24
    2e3a:	af 51       	subi	r26, 0x1F	; 31
    2e3c:	be 4f       	sbci	r27, 0xFE	; 254
    2e3e:	b8 a3       	std	Y+32, r27	; 0x20
    2e40:	af 8f       	std	Y+31, r26	; 0x1f

        // Initialize Bresenham line and distance counters
        st.counter_x = st.counter_y = st.counter_z = (st.exec_block->step_event_count >> 1);
    2e42:	1c 96       	adiw	r26, 0x0c	; 12
    2e44:	8d 91       	ld	r24, X+
    2e46:	9d 91       	ld	r25, X+
    2e48:	0d 90       	ld	r0, X+
    2e4a:	bc 91       	ld	r27, X
    2e4c:	a0 2d       	mov	r26, r0
    2e4e:	b6 95       	lsr	r27
    2e50:	a7 95       	ror	r26
    2e52:	97 95       	ror	r25
    2e54:	87 95       	ror	r24
    2e56:	88 87       	std	Y+8, r24	; 0x08
    2e58:	99 87       	std	Y+9, r25	; 0x09
    2e5a:	aa 87       	std	Y+10, r26	; 0x0a
    2e5c:	bb 87       	std	Y+11, r27	; 0x0b
    2e5e:	8c 83       	std	Y+4, r24	; 0x04
    2e60:	9d 83       	std	Y+5, r25	; 0x05
    2e62:	ae 83       	std	Y+6, r26	; 0x06
    2e64:	bf 83       	std	Y+7, r27	; 0x07
    2e66:	88 83       	st	Y, r24
    2e68:	99 83       	std	Y+1, r25	; 0x01
    2e6a:	aa 83       	std	Y+2, r26	; 0x02
    2e6c:	bb 83       	std	Y+3, r27	; 0x03
      }
      st.dir_outbits = st.exec_block->direction_bits ^ dir_port_invert_mask;
    2e6e:	a4 e9       	ldi	r26, 0x94	; 148
    2e70:	b1 e0       	ldi	r27, 0x01	; 1
    2e72:	5f 96       	adiw	r26, 0x1f	; 31
    2e74:	cd 91       	ld	r28, X+
    2e76:	dc 91       	ld	r29, X
    2e78:	90 97       	sbiw	r26, 0x20	; 32
    2e7a:	98 89       	ldd	r25, Y+16	; 0x10
    2e7c:	80 91 8f 01 	lds	r24, 0x018F	; 0x80018f <dir_port_invert_mask>
    2e80:	89 27       	eor	r24, r25
    2e82:	1f 96       	adiw	r26, 0x0f	; 15
    2e84:	8c 93       	st	X, r24
    2e86:	1f 97       	sbiw	r26, 0x0f	; 15
        st.dir_outbits_dual = st.exec_block->direction_bits_dual ^ dir_port_invert_mask_dual;
      #endif

      #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
        // With AMASS enabled, adjust Bresenham axis increment counters according to AMASS level.
        st.steps[X_AXIS] = st.exec_block->steps[X_AXIS] >> st.exec_segment->amass_level;
    2e88:	48 81       	ld	r20, Y
    2e8a:	59 81       	ldd	r21, Y+1	; 0x01
    2e8c:	6a 81       	ldd	r22, Y+2	; 0x02
    2e8e:	7b 81       	ldd	r23, Y+3	; 0x03
    2e90:	05 80       	ldd	r0, Z+5	; 0x05
    2e92:	04 c0       	rjmp	.+8      	; 0x2e9c <__vector_11+0x130>
    2e94:	76 95       	lsr	r23
    2e96:	67 95       	ror	r22
    2e98:	57 95       	ror	r21
    2e9a:	47 95       	ror	r20
    2e9c:	0a 94       	dec	r0
    2e9e:	d2 f7       	brpl	.-12     	; 0x2e94 <__vector_11+0x128>
    2ea0:	50 96       	adiw	r26, 0x10	; 16
    2ea2:	4d 93       	st	X+, r20
    2ea4:	5d 93       	st	X+, r21
    2ea6:	6d 93       	st	X+, r22
    2ea8:	7c 93       	st	X, r23
    2eaa:	53 97       	sbiw	r26, 0x13	; 19
        st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.exec_segment->amass_level;
    2eac:	4c 81       	ldd	r20, Y+4	; 0x04
    2eae:	5d 81       	ldd	r21, Y+5	; 0x05
    2eb0:	6e 81       	ldd	r22, Y+6	; 0x06
    2eb2:	7f 81       	ldd	r23, Y+7	; 0x07
    2eb4:	05 80       	ldd	r0, Z+5	; 0x05
    2eb6:	04 c0       	rjmp	.+8      	; 0x2ec0 <__vector_11+0x154>
    2eb8:	76 95       	lsr	r23
    2eba:	67 95       	ror	r22
    2ebc:	57 95       	ror	r21
    2ebe:	47 95       	ror	r20
    2ec0:	0a 94       	dec	r0
    2ec2:	d2 f7       	brpl	.-12     	; 0x2eb8 <__vector_11+0x14c>
    2ec4:	54 96       	adiw	r26, 0x14	; 20
    2ec6:	4d 93       	st	X+, r20
    2ec8:	5d 93       	st	X+, r21
    2eca:	6d 93       	st	X+, r22
    2ecc:	7c 93       	st	X, r23
    2ece:	57 97       	sbiw	r26, 0x17	; 23
        st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.exec_segment->amass_level;
    2ed0:	48 85       	ldd	r20, Y+8	; 0x08
    2ed2:	59 85       	ldd	r21, Y+9	; 0x09
    2ed4:	6a 85       	ldd	r22, Y+10	; 0x0a
    2ed6:	7b 85       	ldd	r23, Y+11	; 0x0b
    2ed8:	05 80       	ldd	r0, Z+5	; 0x05
    2eda:	04 c0       	rjmp	.+8      	; 0x2ee4 <__vector_11+0x178>
    2edc:	76 95       	lsr	r23
    2ede:	67 95       	ror	r22
    2ee0:	57 95       	ror	r21
    2ee2:	47 95       	ror	r20
    2ee4:	0a 94       	dec	r0
    2ee6:	d2 f7       	brpl	.-12     	; 0x2edc <__vector_11+0x170>
    2ee8:	58 96       	adiw	r26, 0x18	; 24
    2eea:	4d 93       	st	X+, r20
    2eec:	5d 93       	st	X+, r21
    2eee:	6d 93       	st	X+, r22
    2ef0:	7c 93       	st	X, r23
    2ef2:	5b 97       	sbiw	r26, 0x1b	; 27
      #endif

      #ifdef VARIABLE_SPINDLE
        // Set real-time spindle output as segment is loaded, just prior to the first step.
        spindle_set_speed(st.exec_segment->spindle_pwm);
    2ef4:	86 81       	ldd	r24, Z+6	; 0x06
    2ef6:	0e 94 c4 10 	call	0x2188	; 0x2188 <spindle_set_speed>
    2efa:	10 c0       	rjmp	.+32     	; 0x2f1c <__vector_11+0x1b0>
      #endif

    } else {
      // Segment buffer empty. Shutdown.
      st_go_idle();
    2efc:	0e 94 88 16 	call	0x2d10	; 0x2d10 <st_go_idle>
      #ifdef VARIABLE_SPINDLE
        // Ensure pwm is set properly upon completion of rate-controlled motion.
        if (st.exec_block->is_pwm_rate_adjusted) { spindle_set_speed(SPINDLE_PWM_OFF_VALUE); }
    2f00:	e0 91 b3 01 	lds	r30, 0x01B3	; 0x8001b3 <st+0x1f>
    2f04:	f0 91 b4 01 	lds	r31, 0x01B4	; 0x8001b4 <st+0x20>
    2f08:	81 89       	ldd	r24, Z+17	; 0x11
    2f0a:	88 23       	and	r24, r24
    2f0c:	19 f0       	breq	.+6      	; 0x2f14 <__vector_11+0x1a8>
    2f0e:	80 e0       	ldi	r24, 0x00	; 0
    2f10:	0e 94 c4 10 	call	0x2188	; 0x2188 <spindle_set_speed>
      #endif
      system_set_exec_state_flag(EXEC_CYCLE_STOP); // Flag main program for cycle end
    2f14:	84 e0       	ldi	r24, 0x04	; 4
    2f16:	0e 94 21 2e 	call	0x5c42	; 0x5c42 <system_set_exec_state_flag>
      return; // Nothing to do but exit.
    2f1a:	0d c1       	rjmp	.+538    	; 0x3136 <__vector_11+0x3ca>
    }
  }


  // Check probing state.
  if (sys_probe_state == PROBE_ACTIVE) { probe_state_monitor(); }
    2f1c:	80 91 8f 05 	lds	r24, 0x058F	; 0x80058f <sys_probe_state>
    2f20:	81 30       	cpi	r24, 0x01	; 1
    2f22:	11 f4       	brne	.+4      	; 0x2f28 <__vector_11+0x1bc>
    2f24:	0e 94 d9 2c 	call	0x59b2	; 0x59b2 <probe_state_monitor>

  // Reset step out bits.
  st.step_outbits = 0;
    2f28:	e4 e9       	ldi	r30, 0x94	; 148
    2f2a:	f1 e0       	ldi	r31, 0x01	; 1
    2f2c:	16 86       	std	Z+14, r1	; 0x0e
    st.step_outbits_dual = 0;
  #endif

  // Execute step displacement profile by Bresenham line algorithm
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_x += st.steps[X_AXIS];
    2f2e:	40 81       	ld	r20, Z
    2f30:	51 81       	ldd	r21, Z+1	; 0x01
    2f32:	62 81       	ldd	r22, Z+2	; 0x02
    2f34:	73 81       	ldd	r23, Z+3	; 0x03
    2f36:	80 89       	ldd	r24, Z+16	; 0x10
    2f38:	91 89       	ldd	r25, Z+17	; 0x11
    2f3a:	a2 89       	ldd	r26, Z+18	; 0x12
    2f3c:	b3 89       	ldd	r27, Z+19	; 0x13
    2f3e:	84 0f       	add	r24, r20
    2f40:	95 1f       	adc	r25, r21
    2f42:	a6 1f       	adc	r26, r22
    2f44:	b7 1f       	adc	r27, r23
    2f46:	80 83       	st	Z, r24
    2f48:	91 83       	std	Z+1, r25	; 0x01
    2f4a:	a2 83       	std	Z+2, r26	; 0x02
    2f4c:	b3 83       	std	Z+3, r27	; 0x03
  #else
    st.counter_x += st.exec_block->steps[X_AXIS];
  #endif
  if (st.counter_x > st.exec_block->step_event_count) {
    2f4e:	07 8c       	ldd	r0, Z+31	; 0x1f
    2f50:	f0 a1       	ldd	r31, Z+32	; 0x20
    2f52:	e0 2d       	mov	r30, r0
    2f54:	44 85       	ldd	r20, Z+12	; 0x0c
    2f56:	55 85       	ldd	r21, Z+13	; 0x0d
    2f58:	66 85       	ldd	r22, Z+14	; 0x0e
    2f5a:	77 85       	ldd	r23, Z+15	; 0x0f
    2f5c:	48 17       	cp	r20, r24
    2f5e:	59 07       	cpc	r21, r25
    2f60:	6a 07       	cpc	r22, r26
    2f62:	7b 07       	cpc	r23, r27
    2f64:	70 f5       	brcc	.+92     	; 0x2fc2 <__vector_11+0x256>
    st.step_outbits |= (1<<X_STEP_BIT);
    2f66:	c4 e9       	ldi	r28, 0x94	; 148
    2f68:	d1 e0       	ldi	r29, 0x01	; 1
    2f6a:	24 e0       	ldi	r18, 0x04	; 4
    2f6c:	2e 87       	std	Y+14, r18	; 0x0e
    #if defined(ENABLE_DUAL_AXIS) && (DUAL_AXIS_SELECT == X_AXIS)
      st.step_outbits_dual = (1<<DUAL_STEP_BIT);
    #endif
    st.counter_x -= st.exec_block->step_event_count;
    2f6e:	44 85       	ldd	r20, Z+12	; 0x0c
    2f70:	55 85       	ldd	r21, Z+13	; 0x0d
    2f72:	66 85       	ldd	r22, Z+14	; 0x0e
    2f74:	77 85       	ldd	r23, Z+15	; 0x0f
    2f76:	84 1b       	sub	r24, r20
    2f78:	95 0b       	sbc	r25, r21
    2f7a:	a6 0b       	sbc	r26, r22
    2f7c:	b7 0b       	sbc	r27, r23
    2f7e:	88 83       	st	Y, r24
    2f80:	99 83       	std	Y+1, r25	; 0x01
    2f82:	aa 83       	std	Y+2, r26	; 0x02
    2f84:	bb 83       	std	Y+3, r27	; 0x03
    if (st.exec_block->direction_bits & (1<<X_DIRECTION_BIT)) { sys_position[X_AXIS]--; }
    2f86:	80 89       	ldd	r24, Z+16	; 0x10
    2f88:	85 ff       	sbrs	r24, 5
    2f8a:	0e c0       	rjmp	.+28     	; 0x2fa8 <__vector_11+0x23c>
    2f8c:	cc e9       	ldi	r28, 0x9C	; 156
    2f8e:	d5 e0       	ldi	r29, 0x05	; 5
    2f90:	88 81       	ld	r24, Y
    2f92:	99 81       	ldd	r25, Y+1	; 0x01
    2f94:	aa 81       	ldd	r26, Y+2	; 0x02
    2f96:	bb 81       	ldd	r27, Y+3	; 0x03
    2f98:	01 97       	sbiw	r24, 0x01	; 1
    2f9a:	a1 09       	sbc	r26, r1
    2f9c:	b1 09       	sbc	r27, r1
    2f9e:	88 83       	st	Y, r24
    2fa0:	99 83       	std	Y+1, r25	; 0x01
    2fa2:	aa 83       	std	Y+2, r26	; 0x02
    2fa4:	bb 83       	std	Y+3, r27	; 0x03
    2fa6:	0d c0       	rjmp	.+26     	; 0x2fc2 <__vector_11+0x256>
    else { sys_position[X_AXIS]++; }
    2fa8:	cc e9       	ldi	r28, 0x9C	; 156
    2faa:	d5 e0       	ldi	r29, 0x05	; 5
    2fac:	88 81       	ld	r24, Y
    2fae:	99 81       	ldd	r25, Y+1	; 0x01
    2fb0:	aa 81       	ldd	r26, Y+2	; 0x02
    2fb2:	bb 81       	ldd	r27, Y+3	; 0x03
    2fb4:	01 96       	adiw	r24, 0x01	; 1
    2fb6:	a1 1d       	adc	r26, r1
    2fb8:	b1 1d       	adc	r27, r1
    2fba:	88 83       	st	Y, r24
    2fbc:	99 83       	std	Y+1, r25	; 0x01
    2fbe:	aa 83       	std	Y+2, r26	; 0x02
    2fc0:	bb 83       	std	Y+3, r27	; 0x03
  }
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_y += st.steps[Y_AXIS];
    2fc2:	c4 e9       	ldi	r28, 0x94	; 148
    2fc4:	d1 e0       	ldi	r29, 0x01	; 1
    2fc6:	4c 81       	ldd	r20, Y+4	; 0x04
    2fc8:	5d 81       	ldd	r21, Y+5	; 0x05
    2fca:	6e 81       	ldd	r22, Y+6	; 0x06
    2fcc:	7f 81       	ldd	r23, Y+7	; 0x07
    2fce:	8c 89       	ldd	r24, Y+20	; 0x14
    2fd0:	9d 89       	ldd	r25, Y+21	; 0x15
    2fd2:	ae 89       	ldd	r26, Y+22	; 0x16
    2fd4:	bf 89       	ldd	r27, Y+23	; 0x17
    2fd6:	84 0f       	add	r24, r20
    2fd8:	95 1f       	adc	r25, r21
    2fda:	a6 1f       	adc	r26, r22
    2fdc:	b7 1f       	adc	r27, r23
    2fde:	8c 83       	std	Y+4, r24	; 0x04
    2fe0:	9d 83       	std	Y+5, r25	; 0x05
    2fe2:	ae 83       	std	Y+6, r26	; 0x06
    2fe4:	bf 83       	std	Y+7, r27	; 0x07
  #else
    st.counter_y += st.exec_block->steps[Y_AXIS];
  #endif
  if (st.counter_y > st.exec_block->step_event_count) {
    2fe6:	44 85       	ldd	r20, Z+12	; 0x0c
    2fe8:	55 85       	ldd	r21, Z+13	; 0x0d
    2fea:	66 85       	ldd	r22, Z+14	; 0x0e
    2fec:	77 85       	ldd	r23, Z+15	; 0x0f
    2fee:	48 17       	cp	r20, r24
    2ff0:	59 07       	cpc	r21, r25
    2ff2:	6a 07       	cpc	r22, r26
    2ff4:	7b 07       	cpc	r23, r27
    2ff6:	68 f5       	brcc	.+90     	; 0x3052 <__vector_11+0x2e6>
    st.step_outbits |= (1<<Y_STEP_BIT);
    2ff8:	2e 85       	ldd	r18, Y+14	; 0x0e
    2ffa:	28 60       	ori	r18, 0x08	; 8
    2ffc:	2e 87       	std	Y+14, r18	; 0x0e
    #if defined(ENABLE_DUAL_AXIS) && (DUAL_AXIS_SELECT == Y_AXIS)
      st.step_outbits_dual = (1<<DUAL_STEP_BIT);
    #endif
    st.counter_y -= st.exec_block->step_event_count;
    2ffe:	44 85       	ldd	r20, Z+12	; 0x0c
    3000:	55 85       	ldd	r21, Z+13	; 0x0d
    3002:	66 85       	ldd	r22, Z+14	; 0x0e
    3004:	77 85       	ldd	r23, Z+15	; 0x0f
    3006:	84 1b       	sub	r24, r20
    3008:	95 0b       	sbc	r25, r21
    300a:	a6 0b       	sbc	r26, r22
    300c:	b7 0b       	sbc	r27, r23
    300e:	8c 83       	std	Y+4, r24	; 0x04
    3010:	9d 83       	std	Y+5, r25	; 0x05
    3012:	ae 83       	std	Y+6, r26	; 0x06
    3014:	bf 83       	std	Y+7, r27	; 0x07
    if (st.exec_block->direction_bits & (1<<Y_DIRECTION_BIT)) { sys_position[Y_AXIS]--; }
    3016:	80 89       	ldd	r24, Z+16	; 0x10
    3018:	86 ff       	sbrs	r24, 6
    301a:	0e c0       	rjmp	.+28     	; 0x3038 <__vector_11+0x2cc>
    301c:	cc e9       	ldi	r28, 0x9C	; 156
    301e:	d5 e0       	ldi	r29, 0x05	; 5
    3020:	8c 81       	ldd	r24, Y+4	; 0x04
    3022:	9d 81       	ldd	r25, Y+5	; 0x05
    3024:	ae 81       	ldd	r26, Y+6	; 0x06
    3026:	bf 81       	ldd	r27, Y+7	; 0x07
    3028:	01 97       	sbiw	r24, 0x01	; 1
    302a:	a1 09       	sbc	r26, r1
    302c:	b1 09       	sbc	r27, r1
    302e:	8c 83       	std	Y+4, r24	; 0x04
    3030:	9d 83       	std	Y+5, r25	; 0x05
    3032:	ae 83       	std	Y+6, r26	; 0x06
    3034:	bf 83       	std	Y+7, r27	; 0x07
    3036:	0d c0       	rjmp	.+26     	; 0x3052 <__vector_11+0x2e6>
    else { sys_position[Y_AXIS]++; }
    3038:	cc e9       	ldi	r28, 0x9C	; 156
    303a:	d5 e0       	ldi	r29, 0x05	; 5
    303c:	8c 81       	ldd	r24, Y+4	; 0x04
    303e:	9d 81       	ldd	r25, Y+5	; 0x05
    3040:	ae 81       	ldd	r26, Y+6	; 0x06
    3042:	bf 81       	ldd	r27, Y+7	; 0x07
    3044:	01 96       	adiw	r24, 0x01	; 1
    3046:	a1 1d       	adc	r26, r1
    3048:	b1 1d       	adc	r27, r1
    304a:	8c 83       	std	Y+4, r24	; 0x04
    304c:	9d 83       	std	Y+5, r25	; 0x05
    304e:	ae 83       	std	Y+6, r26	; 0x06
    3050:	bf 83       	std	Y+7, r27	; 0x07
  }
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_z += st.steps[Z_AXIS];
    3052:	c4 e9       	ldi	r28, 0x94	; 148
    3054:	d1 e0       	ldi	r29, 0x01	; 1
    3056:	48 85       	ldd	r20, Y+8	; 0x08
    3058:	59 85       	ldd	r21, Y+9	; 0x09
    305a:	6a 85       	ldd	r22, Y+10	; 0x0a
    305c:	7b 85       	ldd	r23, Y+11	; 0x0b
    305e:	88 8d       	ldd	r24, Y+24	; 0x18
    3060:	99 8d       	ldd	r25, Y+25	; 0x19
    3062:	aa 8d       	ldd	r26, Y+26	; 0x1a
    3064:	bb 8d       	ldd	r27, Y+27	; 0x1b
    3066:	84 0f       	add	r24, r20
    3068:	95 1f       	adc	r25, r21
    306a:	a6 1f       	adc	r26, r22
    306c:	b7 1f       	adc	r27, r23
    306e:	88 87       	std	Y+8, r24	; 0x08
    3070:	99 87       	std	Y+9, r25	; 0x09
    3072:	aa 87       	std	Y+10, r26	; 0x0a
    3074:	bb 87       	std	Y+11, r27	; 0x0b
  #else
    st.counter_z += st.exec_block->steps[Z_AXIS];
  #endif
  if (st.counter_z > st.exec_block->step_event_count) {
    3076:	44 85       	ldd	r20, Z+12	; 0x0c
    3078:	55 85       	ldd	r21, Z+13	; 0x0d
    307a:	66 85       	ldd	r22, Z+14	; 0x0e
    307c:	77 85       	ldd	r23, Z+15	; 0x0f
    307e:	48 17       	cp	r20, r24
    3080:	59 07       	cpc	r21, r25
    3082:	6a 07       	cpc	r22, r26
    3084:	7b 07       	cpc	r23, r27
    3086:	68 f5       	brcc	.+90     	; 0x30e2 <__vector_11+0x376>
    st.step_outbits |= (1<<Z_STEP_BIT);
    3088:	2e 85       	ldd	r18, Y+14	; 0x0e
    308a:	20 61       	ori	r18, 0x10	; 16
    308c:	2e 87       	std	Y+14, r18	; 0x0e
    st.counter_z -= st.exec_block->step_event_count;
    308e:	44 85       	ldd	r20, Z+12	; 0x0c
    3090:	55 85       	ldd	r21, Z+13	; 0x0d
    3092:	66 85       	ldd	r22, Z+14	; 0x0e
    3094:	77 85       	ldd	r23, Z+15	; 0x0f
    3096:	84 1b       	sub	r24, r20
    3098:	95 0b       	sbc	r25, r21
    309a:	a6 0b       	sbc	r26, r22
    309c:	b7 0b       	sbc	r27, r23
    309e:	88 87       	std	Y+8, r24	; 0x08
    30a0:	99 87       	std	Y+9, r25	; 0x09
    30a2:	aa 87       	std	Y+10, r26	; 0x0a
    30a4:	bb 87       	std	Y+11, r27	; 0x0b
    if (st.exec_block->direction_bits & (1<<Z_DIRECTION_BIT)) { sys_position[Z_AXIS]--; }
    30a6:	80 89       	ldd	r24, Z+16	; 0x10
    30a8:	88 23       	and	r24, r24
    30aa:	74 f4       	brge	.+28     	; 0x30c8 <__vector_11+0x35c>
    30ac:	ec e9       	ldi	r30, 0x9C	; 156
    30ae:	f5 e0       	ldi	r31, 0x05	; 5
    30b0:	80 85       	ldd	r24, Z+8	; 0x08
    30b2:	91 85       	ldd	r25, Z+9	; 0x09
    30b4:	a2 85       	ldd	r26, Z+10	; 0x0a
    30b6:	b3 85       	ldd	r27, Z+11	; 0x0b
    30b8:	01 97       	sbiw	r24, 0x01	; 1
    30ba:	a1 09       	sbc	r26, r1
    30bc:	b1 09       	sbc	r27, r1
    30be:	80 87       	std	Z+8, r24	; 0x08
    30c0:	91 87       	std	Z+9, r25	; 0x09
    30c2:	a2 87       	std	Z+10, r26	; 0x0a
    30c4:	b3 87       	std	Z+11, r27	; 0x0b
    30c6:	0d c0       	rjmp	.+26     	; 0x30e2 <__vector_11+0x376>
    else { sys_position[Z_AXIS]++; }
    30c8:	ec e9       	ldi	r30, 0x9C	; 156
    30ca:	f5 e0       	ldi	r31, 0x05	; 5
    30cc:	80 85       	ldd	r24, Z+8	; 0x08
    30ce:	91 85       	ldd	r25, Z+9	; 0x09
    30d0:	a2 85       	ldd	r26, Z+10	; 0x0a
    30d2:	b3 85       	ldd	r27, Z+11	; 0x0b
    30d4:	01 96       	adiw	r24, 0x01	; 1
    30d6:	a1 1d       	adc	r26, r1
    30d8:	b1 1d       	adc	r27, r1
    30da:	80 87       	std	Z+8, r24	; 0x08
    30dc:	91 87       	std	Z+9, r25	; 0x09
    30de:	a2 87       	std	Z+10, r26	; 0x0a
    30e0:	b3 87       	std	Z+11, r27	; 0x0b
  }

  // During a homing cycle, lock out and prevent desired axes from moving.
  if (sys.state == STATE_HOMING) { 
    30e2:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    30e6:	84 30       	cpi	r24, 0x04	; 4
    30e8:	39 f4       	brne	.+14     	; 0x30f8 <__vector_11+0x38c>
    st.step_outbits &= sys.homing_axis_lock;
    30ea:	e4 e9       	ldi	r30, 0x94	; 148
    30ec:	f1 e0       	ldi	r31, 0x01	; 1
    30ee:	96 85       	ldd	r25, Z+14	; 0x0e
    30f0:	80 91 82 05 	lds	r24, 0x0582	; 0x800582 <sys+0x6>
    30f4:	89 23       	and	r24, r25
    30f6:	86 87       	std	Z+14, r24	; 0x0e
    #ifdef ENABLE_DUAL_AXIS
      st.step_outbits_dual &= sys.homing_axis_lock_dual;
    #endif
  }

  st.step_count--; // Decrement step events count
    30f8:	e4 e9       	ldi	r30, 0x94	; 148
    30fa:	f1 e0       	ldi	r31, 0x01	; 1
    30fc:	84 8d       	ldd	r24, Z+28	; 0x1c
    30fe:	95 8d       	ldd	r25, Z+29	; 0x1d
    3100:	01 97       	sbiw	r24, 0x01	; 1
    3102:	95 8f       	std	Z+29, r25	; 0x1d
    3104:	84 8f       	std	Z+28, r24	; 0x1c
  if (st.step_count == 0) {
    3106:	89 2b       	or	r24, r25
    3108:	69 f4       	brne	.+26     	; 0x3124 <__vector_11+0x3b8>
    // Segment is complete. Discard current segment and advance segment indexing.
    st.exec_segment = NULL;
    310a:	10 92 b6 01 	sts	0x01B6, r1	; 0x8001b6 <st+0x22>
    310e:	10 92 b5 01 	sts	0x01B5, r1	; 0x8001b5 <st+0x21>
    if ( ++segment_buffer_tail == SEGMENT_BUFFER_SIZE) { segment_buffer_tail = 0; }
    3112:	80 91 93 01 	lds	r24, 0x0193	; 0x800193 <segment_buffer_tail>
    3116:	8f 5f       	subi	r24, 0xFF	; 255
    3118:	80 93 93 01 	sts	0x0193, r24	; 0x800193 <segment_buffer_tail>
    311c:	86 30       	cpi	r24, 0x06	; 6
    311e:	11 f4       	brne	.+4      	; 0x3124 <__vector_11+0x3b8>
    3120:	10 92 93 01 	sts	0x0193, r1	; 0x800193 <segment_buffer_tail>
  }

  st.step_outbits ^= step_port_invert_mask;  // Apply step port invert mask
    3124:	e4 e9       	ldi	r30, 0x94	; 148
    3126:	f1 e0       	ldi	r31, 0x01	; 1
    3128:	96 85       	ldd	r25, Z+14	; 0x0e
    312a:	80 91 90 01 	lds	r24, 0x0190	; 0x800190 <step_port_invert_mask>
    312e:	89 27       	eor	r24, r25
    3130:	86 87       	std	Z+14, r24	; 0x0e
  #ifdef ENABLE_DUAL_AXIS
    st.step_outbits_dual ^= step_port_invert_mask_dual;
  #endif
  busy = false;
    3132:	10 92 8e 01 	sts	0x018E, r1	; 0x80018e <busy>
}
    3136:	ff 91       	pop	r31
    3138:	ef 91       	pop	r30
    313a:	df 91       	pop	r29
    313c:	cf 91       	pop	r28
    313e:	bf 91       	pop	r27
    3140:	af 91       	pop	r26
    3142:	9f 91       	pop	r25
    3144:	8f 91       	pop	r24
    3146:	7f 91       	pop	r23
    3148:	6f 91       	pop	r22
    314a:	5f 91       	pop	r21
    314c:	4f 91       	pop	r20
    314e:	3f 91       	pop	r19
    3150:	2f 91       	pop	r18
    3152:	0f 90       	pop	r0
    3154:	0f be       	out	0x3f, r0	; 63
    3156:	0f 90       	pop	r0
    3158:	1f 90       	pop	r1
    315a:	18 95       	reti

0000315c <__vector_16>:
*/
// This interrupt is enabled by ISR_TIMER1_COMPAREA when it sets the motor port bits to execute
// a step. This ISR resets the motor port after a short period (settings.pulse_microseconds)
// completing one step cycle.
ISR(TIMER0_OVF_vect)
{
    315c:	1f 92       	push	r1
    315e:	0f 92       	push	r0
    3160:	0f b6       	in	r0, 0x3f	; 63
    3162:	0f 92       	push	r0
    3164:	11 24       	eor	r1, r1
    3166:	8f 93       	push	r24
    3168:	9f 93       	push	r25
  // Reset stepping pins (leave the direction pins)
  STEP_PORT = (STEP_PORT & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK);
    316a:	8b b1       	in	r24, 0x0b	; 11
    316c:	90 91 90 01 	lds	r25, 0x0190	; 0x800190 <step_port_invert_mask>
    3170:	9c 71       	andi	r25, 0x1C	; 28
    3172:	83 7e       	andi	r24, 0xE3	; 227
    3174:	89 2b       	or	r24, r25
    3176:	8b b9       	out	0x0b, r24	; 11
  #ifdef ENABLE_DUAL_AXIS
    STEP_PORT_DUAL = (STEP_PORT_DUAL & ~STEP_MASK_DUAL) | (step_port_invert_mask_dual & STEP_MASK_DUAL);
  #endif
  TCCR0B = 0; // Disable Timer0 to prevent re-entering this interrupt when it's not needed.
    3178:	15 bc       	out	0x25, r1	; 37
}
    317a:	9f 91       	pop	r25
    317c:	8f 91       	pop	r24
    317e:	0f 90       	pop	r0
    3180:	0f be       	out	0x3f, r0	; 63
    3182:	0f 90       	pop	r0
    3184:	1f 90       	pop	r1
    3186:	18 95       	reti

00003188 <st_generate_step_dir_invert_masks>:
#endif


// Generates the step and direction port invert masks used in the Stepper Interrupt Driver.
void st_generate_step_dir_invert_masks()
{
    3188:	ef 92       	push	r14
    318a:	ff 92       	push	r15
    318c:	0f 93       	push	r16
    318e:	1f 93       	push	r17
    3190:	cf 93       	push	r28
    3192:	df 93       	push	r29
  uint8_t idx;
  step_port_invert_mask = 0;
    3194:	10 92 90 01 	sts	0x0190, r1	; 0x800190 <step_port_invert_mask>
  dir_port_invert_mask = 0;
    3198:	10 92 8f 01 	sts	0x018F, r1	; 0x80018f <dir_port_invert_mask>
    319c:	c0 e0       	ldi	r28, 0x00	; 0
    319e:	d0 e0       	ldi	r29, 0x00	; 0
  for (idx=0; idx<N_AXIS; idx++) {
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    31a0:	0e e0       	ldi	r16, 0x0E	; 14
    31a2:	17 e0       	ldi	r17, 0x07	; 7
    31a4:	ec 2e       	mov	r14, r28
    31a6:	fc 2e       	mov	r15, r28
    31a8:	f8 01       	movw	r30, r16
    31aa:	81 a9       	ldd	r24, Z+49	; 0x31
    31ac:	90 e0       	ldi	r25, 0x00	; 0
    31ae:	0c 2e       	mov	r0, r28
    31b0:	02 c0       	rjmp	.+4      	; 0x31b6 <st_generate_step_dir_invert_masks+0x2e>
    31b2:	95 95       	asr	r25
    31b4:	87 95       	ror	r24
    31b6:	0a 94       	dec	r0
    31b8:	e2 f7       	brpl	.-8      	; 0x31b2 <st_generate_step_dir_invert_masks+0x2a>
    31ba:	80 ff       	sbrs	r24, 0
    31bc:	08 c0       	rjmp	.+16     	; 0x31ce <st_generate_step_dir_invert_masks+0x46>
    31be:	8c 2f       	mov	r24, r28
    31c0:	0e 94 83 23 	call	0x4706	; 0x4706 <get_step_pin_mask>
    31c4:	90 91 90 01 	lds	r25, 0x0190	; 0x800190 <step_port_invert_mask>
    31c8:	89 2b       	or	r24, r25
    31ca:	80 93 90 01 	sts	0x0190, r24	; 0x800190 <step_port_invert_mask>
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
    31ce:	f8 01       	movw	r30, r16
    31d0:	82 a9       	ldd	r24, Z+50	; 0x32
    31d2:	90 e0       	ldi	r25, 0x00	; 0
    31d4:	02 c0       	rjmp	.+4      	; 0x31da <st_generate_step_dir_invert_masks+0x52>
    31d6:	95 95       	asr	r25
    31d8:	87 95       	ror	r24
    31da:	fa 94       	dec	r15
    31dc:	e2 f7       	brpl	.-8      	; 0x31d6 <st_generate_step_dir_invert_masks+0x4e>
    31de:	80 ff       	sbrs	r24, 0
    31e0:	08 c0       	rjmp	.+16     	; 0x31f2 <st_generate_step_dir_invert_masks+0x6a>
    31e2:	8e 2d       	mov	r24, r14
    31e4:	0e 94 8d 23 	call	0x471a	; 0x471a <get_direction_pin_mask>
    31e8:	90 91 8f 01 	lds	r25, 0x018F	; 0x80018f <dir_port_invert_mask>
    31ec:	89 2b       	or	r24, r25
    31ee:	80 93 8f 01 	sts	0x018F, r24	; 0x80018f <dir_port_invert_mask>
    31f2:	21 96       	adiw	r28, 0x01	; 1
void st_generate_step_dir_invert_masks()
{
  uint8_t idx;
  step_port_invert_mask = 0;
  dir_port_invert_mask = 0;
  for (idx=0; idx<N_AXIS; idx++) {
    31f4:	c3 30       	cpi	r28, 0x03	; 3
    31f6:	d1 05       	cpc	r29, r1
    31f8:	a9 f6       	brne	.-86     	; 0x31a4 <st_generate_step_dir_invert_masks+0x1c>
    dir_port_invert_mask_dual = 0;
    // NOTE: Dual axis invert uses the N_AXIS bit to set step and direction invert pins.    
    if (bit_istrue(settings.step_invert_mask,bit(N_AXIS))) { step_port_invert_mask_dual = (1<<DUAL_STEP_BIT); }
    if (bit_istrue(settings.dir_invert_mask,bit(N_AXIS))) { dir_port_invert_mask_dual = (1<<DUAL_DIRECTION_BIT); }
  #endif
}
    31fa:	df 91       	pop	r29
    31fc:	cf 91       	pop	r28
    31fe:	1f 91       	pop	r17
    3200:	0f 91       	pop	r16
    3202:	ff 90       	pop	r15
    3204:	ef 90       	pop	r14
    3206:	08 95       	ret

00003208 <st_reset>:


// Reset and clear stepper subsystem variables
void st_reset()
{
    3208:	cf 93       	push	r28
    320a:	df 93       	push	r29
  // Initialize stepper driver idle state.
  st_go_idle();
    320c:	0e 94 88 16 	call	0x2d10	; 0x2d10 <st_go_idle>

  // Initialize stepper algorithm variables.
  memset(&prep, 0, sizeof(st_prep_t));
    3210:	80 e3       	ldi	r24, 0x30	; 48
    3212:	ea e5       	ldi	r30, 0x5A	; 90
    3214:	f1 e0       	ldi	r31, 0x01	; 1
    3216:	df 01       	movw	r26, r30
    3218:	1d 92       	st	X+, r1
    321a:	8a 95       	dec	r24
    321c:	e9 f7       	brne	.-6      	; 0x3218 <st_reset+0x10>
  memset(&st, 0, sizeof(stepper_t));
    321e:	c4 e9       	ldi	r28, 0x94	; 148
    3220:	d1 e0       	ldi	r29, 0x01	; 1
    3222:	83 e2       	ldi	r24, 0x23	; 35
    3224:	fe 01       	movw	r30, r28
    3226:	11 92       	st	Z+, r1
    3228:	8a 95       	dec	r24
    322a:	e9 f7       	brne	.-6      	; 0x3226 <st_reset+0x1e>
  st.exec_segment = NULL;
  pl_block = NULL;  // Planner block pointer used by segment buffer
    322c:	10 92 8d 01 	sts	0x018D, r1	; 0x80018d <pl_block+0x1>
    3230:	10 92 8c 01 	sts	0x018C, r1	; 0x80018c <pl_block>
  segment_buffer_tail = 0;
    3234:	10 92 93 01 	sts	0x0193, r1	; 0x800193 <segment_buffer_tail>
  segment_buffer_head = 0; // empty = tail
    3238:	10 92 92 01 	sts	0x0192, r1	; 0x800192 <segment_buffer_head>
  segment_next_head = 1;
    323c:	81 e0       	ldi	r24, 0x01	; 1
    323e:	80 93 91 01 	sts	0x0191, r24	; 0x800191 <segment_next_head>
  busy = false;
    3242:	10 92 8e 01 	sts	0x018E, r1	; 0x80018e <busy>

  st_generate_step_dir_invert_masks();
    3246:	0e 94 c4 18 	call	0x3188	; 0x3188 <st_generate_step_dir_invert_masks>
  st.dir_outbits = dir_port_invert_mask; // Initialize direction bits to default.
    324a:	80 91 8f 01 	lds	r24, 0x018F	; 0x80018f <dir_port_invert_mask>
    324e:	8f 87       	std	Y+15, r24	; 0x0f

  // Initialize step and direction port pins.
  STEP_PORT = (STEP_PORT & ~STEP_MASK) | step_port_invert_mask;
    3250:	8b b1       	in	r24, 0x0b	; 11
    3252:	83 7e       	andi	r24, 0xE3	; 227
    3254:	90 91 90 01 	lds	r25, 0x0190	; 0x800190 <step_port_invert_mask>
    3258:	89 2b       	or	r24, r25
    325a:	8b b9       	out	0x0b, r24	; 11
  DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | dir_port_invert_mask;
    325c:	8b b1       	in	r24, 0x0b	; 11
    325e:	8f 71       	andi	r24, 0x1F	; 31
    3260:	90 91 8f 01 	lds	r25, 0x018F	; 0x80018f <dir_port_invert_mask>
    3264:	89 2b       	or	r24, r25
    3266:	8b b9       	out	0x0b, r24	; 11
  #ifdef ENABLE_DUAL_AXIS
    st.dir_outbits_dual = dir_port_invert_mask_dual;
    STEP_PORT_DUAL = (STEP_PORT_DUAL & ~STEP_MASK_DUAL) | step_port_invert_mask_dual;
    DIRECTION_PORT_DUAL = (DIRECTION_PORT_DUAL & ~DIRECTION_MASK_DUAL) | dir_port_invert_mask_dual;
  #endif
}
    3268:	df 91       	pop	r29
    326a:	cf 91       	pop	r28
    326c:	08 95       	ret

0000326e <stepper_init>:

// Initialize and start the stepper motor subsystem
void stepper_init()
{
  // Configure step and direction interface pins
  STEP_DDR |= STEP_MASK;
    326e:	8a b1       	in	r24, 0x0a	; 10
    3270:	8c 61       	ori	r24, 0x1C	; 28
    3272:	8a b9       	out	0x0a, r24	; 10
  STEPPERS_DISABLE_DDR |= 1<<STEPPERS_DISABLE_BIT;
    3274:	20 9a       	sbi	0x04, 0	; 4
  DIRECTION_DDR |= DIRECTION_MASK;
    3276:	8a b1       	in	r24, 0x0a	; 10
    3278:	80 6e       	ori	r24, 0xE0	; 224
    327a:	8a b9       	out	0x0a, r24	; 10
    STEP_DDR_DUAL |= STEP_MASK_DUAL;
    DIRECTION_DDR_DUAL |= DIRECTION_MASK_DUAL;
  #endif

  // Configure Timer 1: Stepper Driver Interrupt
  TCCR1B &= ~(1<<WGM13); // waveform generation = 0100 = CTC
    327c:	e1 e8       	ldi	r30, 0x81	; 129
    327e:	f0 e0       	ldi	r31, 0x00	; 0
    3280:	80 81       	ld	r24, Z
    3282:	8f 7e       	andi	r24, 0xEF	; 239
    3284:	80 83       	st	Z, r24
  TCCR1B |=  (1<<WGM12);
    3286:	80 81       	ld	r24, Z
    3288:	88 60       	ori	r24, 0x08	; 8
    328a:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<WGM11) | (1<<WGM10));
    328c:	e0 e8       	ldi	r30, 0x80	; 128
    328e:	f0 e0       	ldi	r31, 0x00	; 0
    3290:	80 81       	ld	r24, Z
    3292:	8c 7f       	andi	r24, 0xFC	; 252
    3294:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<COM1A1) | (1<<COM1A0) | (1<<COM1B1) | (1<<COM1B0)); // Disconnect OC1 output
    3296:	80 81       	ld	r24, Z
    3298:	8f 70       	andi	r24, 0x0F	; 15
    329a:	80 83       	st	Z, r24
  // TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Set in st_go_idle().
  // TIMSK1 &= ~(1<<OCIE1A);  // Set in st_go_idle().

  // Configure Timer 0: Stepper Port Reset Interrupt
  TIMSK0 &= ~((1<<OCIE0B) | (1<<OCIE0A) | (1<<TOIE0)); // Disconnect OC0 outputs and OVF interrupt.
    329c:	ee e6       	ldi	r30, 0x6E	; 110
    329e:	f0 e0       	ldi	r31, 0x00	; 0
    32a0:	80 81       	ld	r24, Z
    32a2:	88 7f       	andi	r24, 0xF8	; 248
    32a4:	80 83       	st	Z, r24
  TCCR0A = 0; // Normal operation
    32a6:	14 bc       	out	0x24, r1	; 36
  TCCR0B = 0; // Disable Timer0 until needed
    32a8:	15 bc       	out	0x25, r1	; 37
  TIMSK0 |= (1<<TOIE0); // Enable Timer0 overflow interrupt
    32aa:	80 81       	ld	r24, Z
    32ac:	81 60       	ori	r24, 0x01	; 1
    32ae:	80 83       	st	Z, r24
    32b0:	08 95       	ret

000032b2 <st_update_plan_block_parameters>:
}


// Called by planner_recalculate() when the executing block is updated by the new plan.
void st_update_plan_block_parameters()
{
    32b2:	cf 93       	push	r28
    32b4:	df 93       	push	r29
  if (pl_block != NULL) { // Ignore if at start of a new block.
    32b6:	c0 91 8c 01 	lds	r28, 0x018C	; 0x80018c <pl_block>
    32ba:	d0 91 8d 01 	lds	r29, 0x018D	; 0x80018d <pl_block+0x1>
    32be:	20 97       	sbiw	r28, 0x00	; 0
    32c0:	a9 f0       	breq	.+42     	; 0x32ec <st_update_plan_block_parameters+0x3a>
    prep.recalculate_flag |= PREP_FLAG_RECALCULATE;
    32c2:	ea e5       	ldi	r30, 0x5A	; 90
    32c4:	f1 e0       	ldi	r31, 0x01	; 1
    32c6:	81 81       	ldd	r24, Z+1	; 0x01
    32c8:	81 60       	ori	r24, 0x01	; 1
    32ca:	81 83       	std	Z+1, r24	; 0x01
    pl_block->entry_speed_sqr = prep.current_speed*prep.current_speed; // Update entry speed.
    32cc:	67 89       	ldd	r22, Z+23	; 0x17
    32ce:	70 8d       	ldd	r23, Z+24	; 0x18
    32d0:	81 8d       	ldd	r24, Z+25	; 0x19
    32d2:	92 8d       	ldd	r25, Z+26	; 0x1a
    32d4:	9b 01       	movw	r18, r22
    32d6:	ac 01       	movw	r20, r24
    32d8:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    32dc:	6a 8b       	std	Y+18, r22	; 0x12
    32de:	7b 8b       	std	Y+19, r23	; 0x13
    32e0:	8c 8b       	std	Y+20, r24	; 0x14
    32e2:	9d 8b       	std	Y+21, r25	; 0x15
    pl_block = NULL; // Flag st_prep_segment() to load and check active velocity profile.
    32e4:	10 92 8d 01 	sts	0x018D, r1	; 0x80018d <pl_block+0x1>
    32e8:	10 92 8c 01 	sts	0x018C, r1	; 0x80018c <pl_block>
  }
}
    32ec:	df 91       	pop	r29
    32ee:	cf 91       	pop	r28
    32f0:	08 95       	ret

000032f2 <st_prep_buffer>:
   longer than the time it takes the stepper algorithm to empty it before refilling it.
   Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.
   NOTE: Computation units are in steps, millimeters, and minutes.
*/
void st_prep_buffer()
{
    32f2:	2f 92       	push	r2
    32f4:	3f 92       	push	r3
    32f6:	4f 92       	push	r4
    32f8:	5f 92       	push	r5
    32fa:	6f 92       	push	r6
    32fc:	7f 92       	push	r7
    32fe:	8f 92       	push	r8
    3300:	9f 92       	push	r9
    3302:	af 92       	push	r10
    3304:	bf 92       	push	r11
    3306:	cf 92       	push	r12
    3308:	df 92       	push	r13
    330a:	ef 92       	push	r14
    330c:	ff 92       	push	r15
    330e:	0f 93       	push	r16
    3310:	1f 93       	push	r17
    3312:	cf 93       	push	r28
    3314:	df 93       	push	r29
    3316:	cd b7       	in	r28, 0x3d	; 61
    3318:	de b7       	in	r29, 0x3e	; 62
    331a:	ea 97       	sbiw	r28, 0x3a	; 58
    331c:	0f b6       	in	r0, 0x3f	; 63
    331e:	f8 94       	cli
    3320:	de bf       	out	0x3e, r29	; 62
    3322:	0f be       	out	0x3f, r0	; 63
    3324:	cd bf       	out	0x3d, r28	; 61
  // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }
    3326:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <sys+0x4>
    332a:	80 ff       	sbrs	r24, 0
    332c:	02 c0       	rjmp	.+4      	; 0x3332 <st_prep_buffer+0x40>
    332e:	0c 94 c0 21 	jmp	0x4380	; 0x4380 <st_prep_buffer+0x108e>
          mm_var = mm_remaining - prep.maximum_speed*time_var;
          if (mm_var < prep.decelerate_after) { // End of cruise.
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
    3332:	22 e0       	ldi	r18, 0x02	; 2
    3334:	2a af       	std	Y+58, r18	; 0x3a
    3336:	29 af       	std	Y+57, r18	; 0x39
    3338:	e5 c7       	rjmp	.+4042   	; 0x4304 <st_prep_buffer+0x1012>
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }

  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.

    // Determine if we need to load a new planner block or if the block needs to be recomputed.
    if (pl_block == NULL) {
    333a:	80 91 8c 01 	lds	r24, 0x018C	; 0x80018c <pl_block>
    333e:	90 91 8d 01 	lds	r25, 0x018D	; 0x80018d <pl_block+0x1>
    3342:	89 2b       	or	r24, r25
    3344:	09 f0       	breq	.+2      	; 0x3348 <st_prep_buffer+0x56>
    3346:	3a c3       	rjmp	.+1652   	; 0x39bc <st_prep_buffer+0x6ca>

      // Query planner for a queued block
      if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) { pl_block = plan_get_system_motion_block(); }
    3348:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <sys+0x4>
    334c:	82 ff       	sbrs	r24, 2
    334e:	07 c0       	rjmp	.+14     	; 0x335e <st_prep_buffer+0x6c>
    3350:	0e 94 2f 25 	call	0x4a5e	; 0x4a5e <plan_get_system_motion_block>
    3354:	90 93 8d 01 	sts	0x018D, r25	; 0x80018d <pl_block+0x1>
    3358:	80 93 8c 01 	sts	0x018C, r24	; 0x80018c <pl_block>
    335c:	06 c0       	rjmp	.+12     	; 0x336a <st_prep_buffer+0x78>
      else { pl_block = plan_get_current_block(); }
    335e:	0e 94 38 25 	call	0x4a70	; 0x4a70 <plan_get_current_block>
    3362:	90 93 8d 01 	sts	0x018D, r25	; 0x80018d <pl_block+0x1>
    3366:	80 93 8c 01 	sts	0x018C, r24	; 0x80018c <pl_block>
      if (pl_block == NULL) { return; } // No planner blocks. Exit.
    336a:	00 91 8c 01 	lds	r16, 0x018C	; 0x80018c <pl_block>
    336e:	10 91 8d 01 	lds	r17, 0x018D	; 0x80018d <pl_block+0x1>
    3372:	01 15       	cp	r16, r1
    3374:	11 05       	cpc	r17, r1
    3376:	11 f4       	brne	.+4      	; 0x337c <st_prep_buffer+0x8a>
    3378:	0c 94 c0 21 	jmp	0x4380	; 0x4380 <st_prep_buffer+0x108e>

      // Check if we need to only recompute the velocity profile or load a new block.
      if (prep.recalculate_flag & PREP_FLAG_RECALCULATE) {
    337c:	f0 90 5b 01 	lds	r15, 0x015B	; 0x80015b <prep+0x1>
    3380:	8f 2d       	mov	r24, r15
    3382:	81 70       	andi	r24, 0x01	; 1
    3384:	f0 fe       	sbrs	r15, 0
    3386:	03 c0       	rjmp	.+6      	; 0x338e <st_prep_buffer+0x9c>

        #ifdef PARKING_ENABLE
          if (prep.recalculate_flag & PREP_FLAG_PARKING) { prep.recalculate_flag &= ~(PREP_FLAG_RECALCULATE); }
          else { prep.recalculate_flag = false; }
        #else
          prep.recalculate_flag = false;
    3388:	10 92 5b 01 	sts	0x015B, r1	; 0x80015b <prep+0x1>
    338c:	f6 c0       	rjmp	.+492    	; 0x357a <st_prep_buffer+0x288>


// Increments the step segment buffer block data ring buffer.
static uint8_t st_next_block_index(uint8_t block_index)
{
  block_index++;
    338e:	aa e5       	ldi	r26, 0x5A	; 90
    3390:	b1 e0       	ldi	r27, 0x01	; 1
    3392:	9c 91       	ld	r25, X
    3394:	9f 5f       	subi	r25, 0xFF	; 255
  if ( block_index == (SEGMENT_BUFFER_SIZE-1) ) { return(0); }
    3396:	95 30       	cpi	r25, 0x05	; 5
    3398:	09 f0       	breq	.+2      	; 0x339c <st_prep_buffer+0xaa>
  return(block_index);
    339a:	89 2f       	mov	r24, r25
        #endif

      } else {

        // Load the Bresenham stepping data for the block.
        prep.st_block_index = st_next_block_index(prep.st_block_index);
    339c:	ea e5       	ldi	r30, 0x5A	; 90
    339e:	f1 e0       	ldi	r31, 0x01	; 1
    33a0:	80 83       	st	Z, r24

        // Prepare and copy Bresenham algorithm segment data from the new planner block, so that
        // when the segment buffer completes the planner block, it may be discarded when the
        // segment buffer finishes the prepped block, but the stepper ISR is still executing it.
        st_prep_block = &st_block_buffer[prep.st_block_index];
    33a2:	90 e0       	ldi	r25, 0x00	; 0
    33a4:	fc 01       	movw	r30, r24
    33a6:	ee 0f       	add	r30, r30
    33a8:	ff 1f       	adc	r31, r31
    33aa:	9f 01       	movw	r18, r30
    33ac:	22 0f       	add	r18, r18
    33ae:	33 1f       	adc	r19, r19
    33b0:	22 0f       	add	r18, r18
    33b2:	33 1f       	adc	r19, r19
    33b4:	22 0f       	add	r18, r18
    33b6:	33 1f       	adc	r19, r19
    33b8:	e2 0f       	add	r30, r18
    33ba:	f3 1f       	adc	r31, r19
    33bc:	ef 51       	subi	r30, 0x1F	; 31
    33be:	fe 4f       	sbci	r31, 0xFE	; 254
    33c0:	f0 93 8b 01 	sts	0x018B, r31	; 0x80018b <st_prep_block+0x1>
    33c4:	e0 93 8a 01 	sts	0x018A, r30	; 0x80018a <st_prep_block>
        st_prep_block->direction_bits = pl_block->direction_bits;
    33c8:	d8 01       	movw	r26, r16
    33ca:	50 96       	adiw	r26, 0x10	; 16
    33cc:	2c 91       	ld	r18, X
    33ce:	50 97       	sbiw	r26, 0x10	; 16
    33d0:	20 8b       	std	Z+16, r18	; 0x10
    33d2:	98 01       	movw	r18, r16
    33d4:	24 5f       	subi	r18, 0xF4	; 244
    33d6:	3f 4f       	sbci	r19, 0xFF	; 255
          st_prep_block->step_event_count = (pl_block->step_event_count << 1);
        #else
          // With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS
          // level, such that we never divide beyond the original data anywhere in the algorithm.
          // If the original data is divided, we can lose a step from integer roundoff.
          for (idx=0; idx<N_AXIS; idx++) { st_prep_block->steps[idx] = pl_block->steps[idx] << MAX_AMASS_LEVEL; }
    33d8:	4d 91       	ld	r20, X+
    33da:	5d 91       	ld	r21, X+
    33dc:	6d 91       	ld	r22, X+
    33de:	7d 91       	ld	r23, X+
    33e0:	44 0f       	add	r20, r20
    33e2:	55 1f       	adc	r21, r21
    33e4:	66 1f       	adc	r22, r22
    33e6:	77 1f       	adc	r23, r23
    33e8:	44 0f       	add	r20, r20
    33ea:	55 1f       	adc	r21, r21
    33ec:	66 1f       	adc	r22, r22
    33ee:	77 1f       	adc	r23, r23
    33f0:	44 0f       	add	r20, r20
    33f2:	55 1f       	adc	r21, r21
    33f4:	66 1f       	adc	r22, r22
    33f6:	77 1f       	adc	r23, r23
    33f8:	41 93       	st	Z+, r20
    33fa:	51 93       	st	Z+, r21
    33fc:	61 93       	st	Z+, r22
    33fe:	71 93       	st	Z+, r23
    3400:	a2 17       	cp	r26, r18
    3402:	b3 07       	cpc	r27, r19
    3404:	49 f7       	brne	.-46     	; 0x33d8 <st_prep_buffer+0xe6>
          st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
    3406:	88 0f       	add	r24, r24
    3408:	99 1f       	adc	r25, r25
    340a:	fc 01       	movw	r30, r24
    340c:	ee 0f       	add	r30, r30
    340e:	ff 1f       	adc	r31, r31
    3410:	ee 0f       	add	r30, r30
    3412:	ff 1f       	adc	r31, r31
    3414:	ee 0f       	add	r30, r30
    3416:	ff 1f       	adc	r31, r31
    3418:	8e 0f       	add	r24, r30
    341a:	9f 1f       	adc	r25, r31
    341c:	9c 01       	movw	r18, r24
    341e:	2f 51       	subi	r18, 0x1F	; 31
    3420:	3e 4f       	sbci	r19, 0xFE	; 254
    3422:	f8 01       	movw	r30, r16
    3424:	84 85       	ldd	r24, Z+12	; 0x0c
    3426:	95 85       	ldd	r25, Z+13	; 0x0d
    3428:	a6 85       	ldd	r26, Z+14	; 0x0e
    342a:	b7 85       	ldd	r27, Z+15	; 0x0f
    342c:	88 0f       	add	r24, r24
    342e:	99 1f       	adc	r25, r25
    3430:	aa 1f       	adc	r26, r26
    3432:	bb 1f       	adc	r27, r27
    3434:	88 0f       	add	r24, r24
    3436:	99 1f       	adc	r25, r25
    3438:	aa 1f       	adc	r26, r26
    343a:	bb 1f       	adc	r27, r27
    343c:	88 0f       	add	r24, r24
    343e:	99 1f       	adc	r25, r25
    3440:	aa 1f       	adc	r26, r26
    3442:	bb 1f       	adc	r27, r27
    3444:	f9 01       	movw	r30, r18
    3446:	84 87       	std	Z+12, r24	; 0x0c
    3448:	95 87       	std	Z+13, r25	; 0x0d
    344a:	a6 87       	std	Z+14, r26	; 0x0e
    344c:	b7 87       	std	Z+15, r27	; 0x0f
        #endif

        // Initialize segment buffer data for generating the segments.
        prep.steps_remaining = (float)pl_block->step_event_count;
    344e:	d8 01       	movw	r26, r16
    3450:	1c 96       	adiw	r26, 0x0c	; 12
    3452:	6d 91       	ld	r22, X+
    3454:	7d 91       	ld	r23, X+
    3456:	8d 91       	ld	r24, X+
    3458:	9c 91       	ld	r25, X
    345a:	1f 97       	sbiw	r26, 0x0f	; 15
    345c:	0e 94 06 30 	call	0x600c	; 0x600c <__floatunsisf>
    3460:	60 93 60 01 	sts	0x0160, r22	; 0x800160 <prep+0x6>
    3464:	70 93 61 01 	sts	0x0161, r23	; 0x800161 <prep+0x7>
    3468:	80 93 62 01 	sts	0x0162, r24	; 0x800162 <prep+0x8>
    346c:	90 93 63 01 	sts	0x0163, r25	; 0x800163 <prep+0x9>
        prep.step_per_mm = prep.steps_remaining/pl_block->millimeters;
    3470:	f8 01       	movw	r30, r16
    3472:	26 8d       	ldd	r18, Z+30	; 0x1e
    3474:	37 8d       	ldd	r19, Z+31	; 0x1f
    3476:	40 a1       	ldd	r20, Z+32	; 0x20
    3478:	51 a1       	ldd	r21, Z+33	; 0x21
    347a:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <__divsf3>
    347e:	9b 01       	movw	r18, r22
    3480:	ac 01       	movw	r20, r24
    3482:	60 93 64 01 	sts	0x0164, r22	; 0x800164 <prep+0xa>
    3486:	70 93 65 01 	sts	0x0165, r23	; 0x800165 <prep+0xb>
    348a:	80 93 66 01 	sts	0x0166, r24	; 0x800166 <prep+0xc>
    348e:	90 93 67 01 	sts	0x0167, r25	; 0x800167 <prep+0xd>
        prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm;
    3492:	60 e0       	ldi	r22, 0x00	; 0
    3494:	70 e0       	ldi	r23, 0x00	; 0
    3496:	80 ea       	ldi	r24, 0xA0	; 160
    3498:	9f e3       	ldi	r25, 0x3F	; 63
    349a:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <__divsf3>
    349e:	60 93 68 01 	sts	0x0168, r22	; 0x800168 <prep+0xe>
    34a2:	70 93 69 01 	sts	0x0169, r23	; 0x800169 <prep+0xf>
    34a6:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <prep+0x10>
    34aa:	90 93 6b 01 	sts	0x016B, r25	; 0x80016b <prep+0x11>
        prep.dt_remainder = 0.0; // Reset for new segment block
    34ae:	10 92 5c 01 	sts	0x015C, r1	; 0x80015c <prep+0x2>
    34b2:	10 92 5d 01 	sts	0x015D, r1	; 0x80015d <prep+0x3>
    34b6:	10 92 5e 01 	sts	0x015E, r1	; 0x80015e <prep+0x4>
    34ba:	10 92 5f 01 	sts	0x015F, r1	; 0x80015f <prep+0x5>

        if ((sys.step_control & STEP_CONTROL_EXECUTE_HOLD) || (prep.recalculate_flag & PREP_FLAG_DECEL_OVERRIDE)) {
    34be:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <sys+0x4>
    34c2:	81 fd       	sbrc	r24, 1
    34c4:	02 c0       	rjmp	.+4      	; 0x34ca <st_prep_buffer+0x1d8>
    34c6:	f3 fe       	sbrs	r15, 3
    34c8:	20 c0       	rjmp	.+64     	; 0x350a <st_prep_buffer+0x218>
          // New block loaded mid-hold. Override planner block entry speed to enforce deceleration.
          prep.current_speed = prep.exit_speed;
    34ca:	60 91 79 01 	lds	r22, 0x0179	; 0x800179 <prep+0x1f>
    34ce:	70 91 7a 01 	lds	r23, 0x017A	; 0x80017a <prep+0x20>
    34d2:	80 91 7b 01 	lds	r24, 0x017B	; 0x80017b <prep+0x21>
    34d6:	90 91 7c 01 	lds	r25, 0x017C	; 0x80017c <prep+0x22>
    34da:	60 93 71 01 	sts	0x0171, r22	; 0x800171 <prep+0x17>
    34de:	70 93 72 01 	sts	0x0172, r23	; 0x800172 <prep+0x18>
    34e2:	80 93 73 01 	sts	0x0173, r24	; 0x800173 <prep+0x19>
    34e6:	90 93 74 01 	sts	0x0174, r25	; 0x800174 <prep+0x1a>
          pl_block->entry_speed_sqr = prep.exit_speed*prep.exit_speed;
    34ea:	9b 01       	movw	r18, r22
    34ec:	ac 01       	movw	r20, r24
    34ee:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    34f2:	d8 01       	movw	r26, r16
    34f4:	52 96       	adiw	r26, 0x12	; 18
    34f6:	6d 93       	st	X+, r22
    34f8:	7d 93       	st	X+, r23
    34fa:	8d 93       	st	X+, r24
    34fc:	9c 93       	st	X, r25
    34fe:	55 97       	sbiw	r26, 0x15	; 21
          prep.recalculate_flag &= ~(PREP_FLAG_DECEL_OVERRIDE);
    3500:	8f 2d       	mov	r24, r15
    3502:	87 7f       	andi	r24, 0xF7	; 247
    3504:	80 93 5b 01 	sts	0x015B, r24	; 0x80015b <prep+0x1>
    3508:	0f c0       	rjmp	.+30     	; 0x3528 <st_prep_buffer+0x236>
        } else {
          prep.current_speed = sqrt(pl_block->entry_speed_sqr);
    350a:	f8 01       	movw	r30, r16
    350c:	62 89       	ldd	r22, Z+18	; 0x12
    350e:	73 89       	ldd	r23, Z+19	; 0x13
    3510:	84 89       	ldd	r24, Z+20	; 0x14
    3512:	95 89       	ldd	r25, Z+21	; 0x15
    3514:	0e 94 55 32 	call	0x64aa	; 0x64aa <sqrt>
    3518:	60 93 71 01 	sts	0x0171, r22	; 0x800171 <prep+0x17>
    351c:	70 93 72 01 	sts	0x0172, r23	; 0x800172 <prep+0x18>
    3520:	80 93 73 01 	sts	0x0173, r24	; 0x800173 <prep+0x19>
    3524:	90 93 74 01 	sts	0x0174, r25	; 0x800174 <prep+0x1a>
        }
        
        #ifdef VARIABLE_SPINDLE
          // Setup laser mode variables. PWM rate adjusted motions will always complete a motion with the
          // spindle off. 
          st_prep_block->is_pwm_rate_adjusted = false;
    3528:	00 91 8a 01 	lds	r16, 0x018A	; 0x80018a <st_prep_block>
    352c:	10 91 8b 01 	lds	r17, 0x018B	; 0x80018b <st_prep_block+0x1>
    3530:	d8 01       	movw	r26, r16
    3532:	51 96       	adiw	r26, 0x11	; 17
    3534:	1c 92       	st	X, r1
          if (settings.flags & BITFLAG_LASER_MODE) {
    3536:	e3 e5       	ldi	r30, 0x53	; 83
    3538:	f7 e0       	ldi	r31, 0x07	; 7
    353a:	80 81       	ld	r24, Z
    353c:	81 ff       	sbrs	r24, 1
    353e:	1d c0       	rjmp	.+58     	; 0x357a <st_prep_buffer+0x288>
            if (pl_block->condition & PL_COND_FLAG_SPINDLE_CCW) { 
    3540:	e0 91 8c 01 	lds	r30, 0x018C	; 0x80018c <pl_block>
    3544:	f0 91 8d 01 	lds	r31, 0x018D	; 0x80018d <pl_block+0x1>
    3548:	81 89       	ldd	r24, Z+17	; 0x11
    354a:	85 ff       	sbrs	r24, 5
    354c:	16 c0       	rjmp	.+44     	; 0x357a <st_prep_buffer+0x288>
              // Pre-compute inverse programmed rate to speed up PWM updating per step segment.
              prep.inv_rate = 1.0/pl_block->programmed_rate;
    354e:	22 a5       	ldd	r18, Z+42	; 0x2a
    3550:	33 a5       	ldd	r19, Z+43	; 0x2b
    3552:	44 a5       	ldd	r20, Z+44	; 0x2c
    3554:	55 a5       	ldd	r21, Z+45	; 0x2d
    3556:	60 e0       	ldi	r22, 0x00	; 0
    3558:	70 e0       	ldi	r23, 0x00	; 0
    355a:	80 e8       	ldi	r24, 0x80	; 128
    355c:	9f e3       	ldi	r25, 0x3F	; 63
    355e:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <__divsf3>
    3562:	60 93 85 01 	sts	0x0185, r22	; 0x800185 <prep+0x2b>
    3566:	70 93 86 01 	sts	0x0186, r23	; 0x800186 <prep+0x2c>
    356a:	80 93 87 01 	sts	0x0187, r24	; 0x800187 <prep+0x2d>
    356e:	90 93 88 01 	sts	0x0188, r25	; 0x800188 <prep+0x2e>
              st_prep_block->is_pwm_rate_adjusted = true; 
    3572:	e1 e0       	ldi	r30, 0x01	; 1
    3574:	d8 01       	movw	r26, r16
    3576:	51 96       	adiw	r26, 0x11	; 17
    3578:	ec 93       	st	X, r30
			 Compute the velocity profile of a new planner block based on its entry and exit
			 speeds, or recompute the profile of a partially-completed planner block if the
			 planner has updated it. For a commanded forced-deceleration, such as from a feed
			 hold, override the planner velocities and decelerate to the target exit speed.
			*/
			prep.mm_complete = 0.0; // Default velocity profile complete at 0.0mm from end of block.
    357a:	10 92 6d 01 	sts	0x016D, r1	; 0x80016d <prep+0x13>
    357e:	10 92 6e 01 	sts	0x016E, r1	; 0x80016e <prep+0x14>
    3582:	10 92 6f 01 	sts	0x016F, r1	; 0x80016f <prep+0x15>
    3586:	10 92 70 01 	sts	0x0170, r1	; 0x800170 <prep+0x16>
			float inv_2_accel = 0.5/pl_block->acceleration;
    358a:	00 91 8c 01 	lds	r16, 0x018C	; 0x80018c <pl_block>
    358e:	10 91 8d 01 	lds	r17, 0x018D	; 0x80018d <pl_block+0x1>
    3592:	d8 01       	movw	r26, r16
    3594:	5a 96       	adiw	r26, 0x1a	; 26
    3596:	8d 90       	ld	r8, X+
    3598:	9d 90       	ld	r9, X+
    359a:	ad 90       	ld	r10, X+
    359c:	bc 90       	ld	r11, X
    359e:	5d 97       	sbiw	r26, 0x1d	; 29
    35a0:	a5 01       	movw	r20, r10
    35a2:	94 01       	movw	r18, r8
    35a4:	60 e0       	ldi	r22, 0x00	; 0
    35a6:	70 e0       	ldi	r23, 0x00	; 0
    35a8:	80 e0       	ldi	r24, 0x00	; 0
    35aa:	9f e3       	ldi	r25, 0x3F	; 63
    35ac:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <__divsf3>
    35b0:	69 83       	std	Y+1, r22	; 0x01
    35b2:	7a 83       	std	Y+2, r23	; 0x02
    35b4:	8b 83       	std	Y+3, r24	; 0x03
    35b6:	9c 83       	std	Y+4, r25	; 0x04
			if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { // [Forced Deceleration to Zero Velocity]
    35b8:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <sys+0x4>
    35bc:	81 ff       	sbrs	r24, 1
    35be:	55 c0       	rjmp	.+170    	; 0x366a <st_prep_buffer+0x378>
				// Compute velocity profile parameters for a feed hold in-progress. This profile overrides
				// the planner block profile, enforcing a deceleration to zero speed.
				prep.ramp_type = RAMP_DECEL;
    35c0:	b2 e0       	ldi	r27, 0x02	; 2
    35c2:	b0 93 6c 01 	sts	0x016C, r27	; 0x80016c <prep+0x12>
				// Compute decelerate distance relative to end of block.
				float decel_dist = pl_block->millimeters - inv_2_accel*pl_block->entry_speed_sqr;
    35c6:	f8 01       	movw	r30, r16
    35c8:	46 8c       	ldd	r4, Z+30	; 0x1e
    35ca:	57 8c       	ldd	r5, Z+31	; 0x1f
    35cc:	60 a0       	ldd	r6, Z+32	; 0x20
    35ce:	71 a0       	ldd	r7, Z+33	; 0x21
    35d0:	c2 88       	ldd	r12, Z+18	; 0x12
    35d2:	d3 88       	ldd	r13, Z+19	; 0x13
    35d4:	e4 88       	ldd	r14, Z+20	; 0x14
    35d6:	f5 88       	ldd	r15, Z+21	; 0x15
    35d8:	a7 01       	movw	r20, r14
    35da:	96 01       	movw	r18, r12
    35dc:	69 81       	ldd	r22, Y+1	; 0x01
    35de:	7a 81       	ldd	r23, Y+2	; 0x02
    35e0:	8b 81       	ldd	r24, Y+3	; 0x03
    35e2:	9c 81       	ldd	r25, Y+4	; 0x04
    35e4:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    35e8:	9b 01       	movw	r18, r22
    35ea:	ac 01       	movw	r20, r24
    35ec:	c3 01       	movw	r24, r6
    35ee:	b2 01       	movw	r22, r4
    35f0:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    35f4:	69 83       	std	Y+1, r22	; 0x01
    35f6:	7a 83       	std	Y+2, r23	; 0x02
    35f8:	8b 83       	std	Y+3, r24	; 0x03
    35fa:	9c 83       	std	Y+4, r25	; 0x04
				if (decel_dist < 0.0) {
    35fc:	20 e0       	ldi	r18, 0x00	; 0
    35fe:	30 e0       	ldi	r19, 0x00	; 0
    3600:	a9 01       	movw	r20, r18
    3602:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    3606:	88 23       	and	r24, r24
    3608:	dc f4       	brge	.+54     	; 0x3640 <st_prep_buffer+0x34e>
					// Deceleration through entire planner block. End of feed hold is not in this block.
					prep.exit_speed = sqrt(pl_block->entry_speed_sqr-2*pl_block->acceleration*pl_block->millimeters);
    360a:	a5 01       	movw	r20, r10
    360c:	94 01       	movw	r18, r8
    360e:	c5 01       	movw	r24, r10
    3610:	b4 01       	movw	r22, r8
    3612:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    3616:	a3 01       	movw	r20, r6
    3618:	92 01       	movw	r18, r4
    361a:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    361e:	9b 01       	movw	r18, r22
    3620:	ac 01       	movw	r20, r24
    3622:	c7 01       	movw	r24, r14
    3624:	b6 01       	movw	r22, r12
    3626:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    362a:	0e 94 55 32 	call	0x64aa	; 0x64aa <sqrt>
    362e:	60 93 79 01 	sts	0x0179, r22	; 0x800179 <prep+0x1f>
    3632:	70 93 7a 01 	sts	0x017A, r23	; 0x80017a <prep+0x20>
    3636:	80 93 7b 01 	sts	0x017B, r24	; 0x80017b <prep+0x21>
    363a:	90 93 7c 01 	sts	0x017C, r25	; 0x80017c <prep+0x22>
    363e:	b9 c1       	rjmp	.+882    	; 0x39b2 <st_prep_buffer+0x6c0>
				} else {
					prep.mm_complete = decel_dist; // End of feed hold.
    3640:	29 81       	ldd	r18, Y+1	; 0x01
    3642:	3a 81       	ldd	r19, Y+2	; 0x02
    3644:	4b 81       	ldd	r20, Y+3	; 0x03
    3646:	5c 81       	ldd	r21, Y+4	; 0x04
    3648:	20 93 6d 01 	sts	0x016D, r18	; 0x80016d <prep+0x13>
    364c:	30 93 6e 01 	sts	0x016E, r19	; 0x80016e <prep+0x14>
    3650:	40 93 6f 01 	sts	0x016F, r20	; 0x80016f <prep+0x15>
    3654:	50 93 70 01 	sts	0x0170, r21	; 0x800170 <prep+0x16>
					prep.exit_speed = 0.0;
    3658:	10 92 79 01 	sts	0x0179, r1	; 0x800179 <prep+0x1f>
    365c:	10 92 7a 01 	sts	0x017A, r1	; 0x80017a <prep+0x20>
    3660:	10 92 7b 01 	sts	0x017B, r1	; 0x80017b <prep+0x21>
    3664:	10 92 7c 01 	sts	0x017C, r1	; 0x80017c <prep+0x22>
    3668:	a4 c1       	rjmp	.+840    	; 0x39b2 <st_prep_buffer+0x6c0>
				}
			} else { // [Normal Operation]
				// Compute or recompute velocity profile parameters of the prepped planner block.
				prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
    366a:	10 92 6c 01 	sts	0x016C, r1	; 0x80016c <prep+0x12>
				prep.accelerate_until = pl_block->millimeters;
    366e:	d8 01       	movw	r26, r16
    3670:	5e 96       	adiw	r26, 0x1e	; 30
    3672:	4d 91       	ld	r20, X+
    3674:	5d 91       	ld	r21, X+
    3676:	6d 91       	ld	r22, X+
    3678:	7c 91       	ld	r23, X
    367a:	91 97       	sbiw	r26, 0x21	; 33
    367c:	40 93 7d 01 	sts	0x017D, r20	; 0x80017d <prep+0x23>
    3680:	50 93 7e 01 	sts	0x017E, r21	; 0x80017e <prep+0x24>
    3684:	60 93 7f 01 	sts	0x017F, r22	; 0x80017f <prep+0x25>
    3688:	70 93 80 01 	sts	0x0180, r23	; 0x800180 <prep+0x26>

				float exit_speed_sqr;
				float nominal_speed;
        if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
    368c:	82 ff       	sbrs	r24, 2
    368e:	0d c0       	rjmp	.+26     	; 0x36aa <st_prep_buffer+0x3b8>
          prep.exit_speed = exit_speed_sqr = 0.0; // Enforce stop at end of system motion.
    3690:	10 92 79 01 	sts	0x0179, r1	; 0x800179 <prep+0x1f>
    3694:	10 92 7a 01 	sts	0x017A, r1	; 0x80017a <prep+0x20>
    3698:	10 92 7b 01 	sts	0x017B, r1	; 0x80017b <prep+0x21>
    369c:	10 92 7c 01 	sts	0x017C, r1	; 0x80017c <prep+0x22>
    36a0:	19 86       	std	Y+9, r1	; 0x09
    36a2:	1a 86       	std	Y+10, r1	; 0x0a
    36a4:	1b 86       	std	Y+11, r1	; 0x0b
    36a6:	1c 86       	std	Y+12, r1	; 0x0c
    36a8:	10 c0       	rjmp	.+32     	; 0x36ca <st_prep_buffer+0x3d8>
        } else {
          exit_speed_sqr = plan_get_exec_block_exit_speed_sqr();
    36aa:	0e 94 48 25 	call	0x4a90	; 0x4a90 <plan_get_exec_block_exit_speed_sqr>
    36ae:	69 87       	std	Y+9, r22	; 0x09
    36b0:	7a 87       	std	Y+10, r23	; 0x0a
    36b2:	8b 87       	std	Y+11, r24	; 0x0b
    36b4:	9c 87       	std	Y+12, r25	; 0x0c
          prep.exit_speed = sqrt(exit_speed_sqr);
    36b6:	0e 94 55 32 	call	0x64aa	; 0x64aa <sqrt>
    36ba:	60 93 79 01 	sts	0x0179, r22	; 0x800179 <prep+0x1f>
    36be:	70 93 7a 01 	sts	0x017A, r23	; 0x80017a <prep+0x20>
    36c2:	80 93 7b 01 	sts	0x017B, r24	; 0x80017b <prep+0x21>
    36c6:	90 93 7c 01 	sts	0x017C, r25	; 0x80017c <prep+0x22>
        }

        nominal_speed = plan_compute_profile_nominal_speed(pl_block);
    36ca:	80 91 8c 01 	lds	r24, 0x018C	; 0x80018c <pl_block>
    36ce:	90 91 8d 01 	lds	r25, 0x018D	; 0x80018d <pl_block+0x1>
    36d2:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <plan_compute_profile_nominal_speed>
    36d6:	4b 01       	movw	r8, r22
    36d8:	5c 01       	movw	r10, r24
				float nominal_speed_sqr = nominal_speed*nominal_speed;
    36da:	9b 01       	movw	r18, r22
    36dc:	ac 01       	movw	r20, r24
    36de:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    36e2:	6d 83       	std	Y+5, r22	; 0x05
    36e4:	7e 83       	std	Y+6, r23	; 0x06
    36e6:	8f 83       	std	Y+7, r24	; 0x07
    36e8:	98 87       	std	Y+8, r25	; 0x08
				float intersect_distance =
								0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
    36ea:	00 91 8c 01 	lds	r16, 0x018C	; 0x80018c <pl_block>
    36ee:	10 91 8d 01 	lds	r17, 0x018D	; 0x80018d <pl_block+0x1>
    36f2:	f8 01       	movw	r30, r16
    36f4:	c6 8c       	ldd	r12, Z+30	; 0x1e
    36f6:	d7 8c       	ldd	r13, Z+31	; 0x1f
    36f8:	e0 a0       	ldd	r14, Z+32	; 0x20
    36fa:	f1 a0       	ldd	r15, Z+33	; 0x21
    36fc:	42 88       	ldd	r4, Z+18	; 0x12
    36fe:	53 88       	ldd	r5, Z+19	; 0x13
    3700:	64 88       	ldd	r6, Z+20	; 0x14
    3702:	75 88       	ldd	r7, Z+21	; 0x15

        if (pl_block->entry_speed_sqr > nominal_speed_sqr) { // Only occurs during override reductions.
    3704:	a3 01       	movw	r20, r6
    3706:	92 01       	movw	r18, r4
    3708:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    370c:	88 23       	and	r24, r24
    370e:	0c f0       	brlt	.+2      	; 0x3712 <st_prep_buffer+0x420>
    3710:	79 c0       	rjmp	.+242    	; 0x3804 <st_prep_buffer+0x512>
          prep.accelerate_until = pl_block->millimeters - inv_2_accel*(pl_block->entry_speed_sqr-nominal_speed_sqr);
    3712:	2d 81       	ldd	r18, Y+5	; 0x05
    3714:	3e 81       	ldd	r19, Y+6	; 0x06
    3716:	4f 81       	ldd	r20, Y+7	; 0x07
    3718:	58 85       	ldd	r21, Y+8	; 0x08
    371a:	c3 01       	movw	r24, r6
    371c:	b2 01       	movw	r22, r4
    371e:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    3722:	29 81       	ldd	r18, Y+1	; 0x01
    3724:	3a 81       	ldd	r19, Y+2	; 0x02
    3726:	4b 81       	ldd	r20, Y+3	; 0x03
    3728:	5c 81       	ldd	r21, Y+4	; 0x04
    372a:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    372e:	9b 01       	movw	r18, r22
    3730:	ac 01       	movw	r20, r24
    3732:	c7 01       	movw	r24, r14
    3734:	b6 01       	movw	r22, r12
    3736:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    373a:	60 93 7d 01 	sts	0x017D, r22	; 0x80017d <prep+0x23>
    373e:	70 93 7e 01 	sts	0x017E, r23	; 0x80017e <prep+0x24>
    3742:	80 93 7f 01 	sts	0x017F, r24	; 0x80017f <prep+0x25>
    3746:	90 93 80 01 	sts	0x0180, r25	; 0x800180 <prep+0x26>
          if (prep.accelerate_until <= 0.0) { // Deceleration-only.
    374a:	20 e0       	ldi	r18, 0x00	; 0
    374c:	30 e0       	ldi	r19, 0x00	; 0
    374e:	a9 01       	movw	r20, r18
    3750:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    3754:	18 16       	cp	r1, r24
    3756:	94 f1       	brlt	.+100    	; 0x37bc <st_prep_buffer+0x4ca>
            prep.ramp_type = RAMP_DECEL;
    3758:	f2 e0       	ldi	r31, 0x02	; 2
    375a:	f0 93 6c 01 	sts	0x016C, r31	; 0x80016c <prep+0x12>
            // prep.decelerate_after = pl_block->millimeters;
            // prep.maximum_speed = prep.current_speed;

            // Compute override block exit speed since it doesn't match the planner exit speed.
            prep.exit_speed = sqrt(pl_block->entry_speed_sqr - 2*pl_block->acceleration*pl_block->millimeters);
    375e:	d8 01       	movw	r26, r16
    3760:	5a 96       	adiw	r26, 0x1a	; 26
    3762:	cd 90       	ld	r12, X+
    3764:	dd 90       	ld	r13, X+
    3766:	ed 90       	ld	r14, X+
    3768:	fc 90       	ld	r15, X
    376a:	5d 97       	sbiw	r26, 0x1d	; 29
    376c:	a7 01       	movw	r20, r14
    376e:	96 01       	movw	r18, r12
    3770:	c7 01       	movw	r24, r14
    3772:	b6 01       	movw	r22, r12
    3774:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    3778:	f8 01       	movw	r30, r16
    377a:	26 8d       	ldd	r18, Z+30	; 0x1e
    377c:	37 8d       	ldd	r19, Z+31	; 0x1f
    377e:	40 a1       	ldd	r20, Z+32	; 0x20
    3780:	51 a1       	ldd	r21, Z+33	; 0x21
    3782:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    3786:	9b 01       	movw	r18, r22
    3788:	ac 01       	movw	r20, r24
    378a:	d8 01       	movw	r26, r16
    378c:	52 96       	adiw	r26, 0x12	; 18
    378e:	6d 91       	ld	r22, X+
    3790:	7d 91       	ld	r23, X+
    3792:	8d 91       	ld	r24, X+
    3794:	9c 91       	ld	r25, X
    3796:	55 97       	sbiw	r26, 0x15	; 21
    3798:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    379c:	0e 94 55 32 	call	0x64aa	; 0x64aa <sqrt>
    37a0:	60 93 79 01 	sts	0x0179, r22	; 0x800179 <prep+0x1f>
    37a4:	70 93 7a 01 	sts	0x017A, r23	; 0x80017a <prep+0x20>
    37a8:	80 93 7b 01 	sts	0x017B, r24	; 0x80017b <prep+0x21>
    37ac:	90 93 7c 01 	sts	0x017C, r25	; 0x80017c <prep+0x22>
            prep.recalculate_flag |= PREP_FLAG_DECEL_OVERRIDE; // Flag to load next block as deceleration override.
    37b0:	80 91 5b 01 	lds	r24, 0x015B	; 0x80015b <prep+0x1>
    37b4:	88 60       	ori	r24, 0x08	; 8
    37b6:	80 93 5b 01 	sts	0x015B, r24	; 0x80015b <prep+0x1>
    37ba:	fb c0       	rjmp	.+502    	; 0x39b2 <st_prep_buffer+0x6c0>
            // Can be tricky since entry speed will be current speed, as in feed holds.
            // Also, look into near-zero speed handling issues with this.

          } else {
            // Decelerate to cruise or cruise-decelerate types. Guaranteed to intersect updated plan.
            prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr); // Should always be >= 0.0 due to planner reinit.
    37bc:	29 85       	ldd	r18, Y+9	; 0x09
    37be:	3a 85       	ldd	r19, Y+10	; 0x0a
    37c0:	4b 85       	ldd	r20, Y+11	; 0x0b
    37c2:	5c 85       	ldd	r21, Y+12	; 0x0c
    37c4:	6d 81       	ldd	r22, Y+5	; 0x05
    37c6:	7e 81       	ldd	r23, Y+6	; 0x06
    37c8:	8f 81       	ldd	r24, Y+7	; 0x07
    37ca:	98 85       	ldd	r25, Y+8	; 0x08
    37cc:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    37d0:	29 81       	ldd	r18, Y+1	; 0x01
    37d2:	3a 81       	ldd	r19, Y+2	; 0x02
    37d4:	4b 81       	ldd	r20, Y+3	; 0x03
    37d6:	5c 81       	ldd	r21, Y+4	; 0x04
    37d8:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    37dc:	60 93 81 01 	sts	0x0181, r22	; 0x800181 <prep+0x27>
    37e0:	70 93 82 01 	sts	0x0182, r23	; 0x800182 <prep+0x28>
    37e4:	80 93 83 01 	sts	0x0183, r24	; 0x800183 <prep+0x29>
    37e8:	90 93 84 01 	sts	0x0184, r25	; 0x800184 <prep+0x2a>
            prep.maximum_speed = nominal_speed;
    37ec:	80 92 75 01 	sts	0x0175, r8	; 0x800175 <prep+0x1b>
    37f0:	90 92 76 01 	sts	0x0176, r9	; 0x800176 <prep+0x1c>
    37f4:	a0 92 77 01 	sts	0x0177, r10	; 0x800177 <prep+0x1d>
    37f8:	b0 92 78 01 	sts	0x0178, r11	; 0x800178 <prep+0x1e>
            prep.ramp_type = RAMP_DECEL_OVERRIDE;
    37fc:	b3 e0       	ldi	r27, 0x03	; 3
    37fe:	b0 93 6c 01 	sts	0x016C, r27	; 0x80016c <prep+0x12>
    3802:	d7 c0       	rjmp	.+430    	; 0x39b2 <st_prep_buffer+0x6c0>
          prep.exit_speed = sqrt(exit_speed_sqr);
        }

        nominal_speed = plan_compute_profile_nominal_speed(pl_block);
				float nominal_speed_sqr = nominal_speed*nominal_speed;
				float intersect_distance =
    3804:	29 85       	ldd	r18, Y+9	; 0x09
    3806:	3a 85       	ldd	r19, Y+10	; 0x0a
    3808:	4b 85       	ldd	r20, Y+11	; 0x0b
    380a:	5c 85       	ldd	r21, Y+12	; 0x0c
    380c:	c3 01       	movw	r24, r6
    380e:	b2 01       	movw	r22, r4
    3810:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    3814:	29 81       	ldd	r18, Y+1	; 0x01
    3816:	3a 81       	ldd	r19, Y+2	; 0x02
    3818:	4b 81       	ldd	r20, Y+3	; 0x03
    381a:	5c 81       	ldd	r21, Y+4	; 0x04
    381c:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    3820:	a7 01       	movw	r20, r14
    3822:	96 01       	movw	r18, r12
    3824:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    3828:	20 e0       	ldi	r18, 0x00	; 0
    382a:	30 e0       	ldi	r19, 0x00	; 0
    382c:	40 e0       	ldi	r20, 0x00	; 0
    382e:	5f e3       	ldi	r21, 0x3F	; 63
    3830:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    3834:	2b 01       	movw	r4, r22
    3836:	3c 01       	movw	r6, r24
            // Decelerate to cruise or cruise-decelerate types. Guaranteed to intersect updated plan.
            prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr); // Should always be >= 0.0 due to planner reinit.
            prep.maximum_speed = nominal_speed;
            prep.ramp_type = RAMP_DECEL_OVERRIDE;
          }
				} else if (intersect_distance > 0.0) {
    3838:	20 e0       	ldi	r18, 0x00	; 0
    383a:	30 e0       	ldi	r19, 0x00	; 0
    383c:	a9 01       	movw	r20, r18
    383e:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    3842:	18 16       	cp	r1, r24
    3844:	0c f0       	brlt	.+2      	; 0x3848 <st_prep_buffer+0x556>
    3846:	9d c0       	rjmp	.+314    	; 0x3982 <st_prep_buffer+0x690>
					if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
    3848:	a3 01       	movw	r20, r6
    384a:	92 01       	movw	r18, r4
    384c:	c7 01       	movw	r24, r14
    384e:	b6 01       	movw	r22, r12
    3850:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    3854:	18 16       	cp	r1, r24
    3856:	0c f0       	brlt	.+2      	; 0x385a <st_prep_buffer+0x568>
    3858:	90 c0       	rjmp	.+288    	; 0x397a <st_prep_buffer+0x688>
						// NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.
						prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
    385a:	29 85       	ldd	r18, Y+9	; 0x09
    385c:	3a 85       	ldd	r19, Y+10	; 0x0a
    385e:	4b 85       	ldd	r20, Y+11	; 0x0b
    3860:	5c 85       	ldd	r21, Y+12	; 0x0c
    3862:	6d 81       	ldd	r22, Y+5	; 0x05
    3864:	7e 81       	ldd	r23, Y+6	; 0x06
    3866:	8f 81       	ldd	r24, Y+7	; 0x07
    3868:	98 85       	ldd	r25, Y+8	; 0x08
    386a:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    386e:	29 81       	ldd	r18, Y+1	; 0x01
    3870:	3a 81       	ldd	r19, Y+2	; 0x02
    3872:	4b 81       	ldd	r20, Y+3	; 0x03
    3874:	5c 81       	ldd	r21, Y+4	; 0x04
    3876:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    387a:	9b 01       	movw	r18, r22
    387c:	ac 01       	movw	r20, r24
    387e:	60 93 81 01 	sts	0x0181, r22	; 0x800181 <prep+0x27>
    3882:	70 93 82 01 	sts	0x0182, r23	; 0x800182 <prep+0x28>
    3886:	80 93 83 01 	sts	0x0183, r24	; 0x800183 <prep+0x29>
    388a:	90 93 84 01 	sts	0x0184, r25	; 0x800184 <prep+0x2a>
						if (prep.decelerate_after < intersect_distance) { // Trapezoid type
    388e:	c3 01       	movw	r24, r6
    3890:	b2 01       	movw	r22, r4
    3892:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    3896:	18 16       	cp	r1, r24
    3898:	f4 f5       	brge	.+124    	; 0x3916 <st_prep_buffer+0x624>
							prep.maximum_speed = nominal_speed;
    389a:	80 92 75 01 	sts	0x0175, r8	; 0x800175 <prep+0x1b>
    389e:	90 92 76 01 	sts	0x0176, r9	; 0x800176 <prep+0x1c>
    38a2:	a0 92 77 01 	sts	0x0177, r10	; 0x800177 <prep+0x1d>
    38a6:	b0 92 78 01 	sts	0x0178, r11	; 0x800178 <prep+0x1e>
							if (pl_block->entry_speed_sqr == nominal_speed_sqr) {
    38aa:	f8 01       	movw	r30, r16
    38ac:	42 88       	ldd	r4, Z+18	; 0x12
    38ae:	53 88       	ldd	r5, Z+19	; 0x13
    38b0:	64 88       	ldd	r6, Z+20	; 0x14
    38b2:	75 88       	ldd	r7, Z+21	; 0x15
    38b4:	a3 01       	movw	r20, r6
    38b6:	92 01       	movw	r18, r4
    38b8:	6d 81       	ldd	r22, Y+5	; 0x05
    38ba:	7e 81       	ldd	r23, Y+6	; 0x06
    38bc:	8f 81       	ldd	r24, Y+7	; 0x07
    38be:	98 85       	ldd	r25, Y+8	; 0x08
    38c0:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    38c4:	81 11       	cpse	r24, r1
    38c6:	04 c0       	rjmp	.+8      	; 0x38d0 <st_prep_buffer+0x5de>
								// Cruise-deceleration or cruise-only type.
								prep.ramp_type = RAMP_CRUISE;
    38c8:	f1 e0       	ldi	r31, 0x01	; 1
    38ca:	f0 93 6c 01 	sts	0x016C, r31	; 0x80016c <prep+0x12>
    38ce:	71 c0       	rjmp	.+226    	; 0x39b2 <st_prep_buffer+0x6c0>
							} else {
								// Full-trapezoid or acceleration-cruise types
								prep.accelerate_until -= inv_2_accel*(nominal_speed_sqr-pl_block->entry_speed_sqr);
    38d0:	a3 01       	movw	r20, r6
    38d2:	92 01       	movw	r18, r4
    38d4:	6d 81       	ldd	r22, Y+5	; 0x05
    38d6:	7e 81       	ldd	r23, Y+6	; 0x06
    38d8:	8f 81       	ldd	r24, Y+7	; 0x07
    38da:	98 85       	ldd	r25, Y+8	; 0x08
    38dc:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    38e0:	29 81       	ldd	r18, Y+1	; 0x01
    38e2:	3a 81       	ldd	r19, Y+2	; 0x02
    38e4:	4b 81       	ldd	r20, Y+3	; 0x03
    38e6:	5c 81       	ldd	r21, Y+4	; 0x04
    38e8:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    38ec:	9b 01       	movw	r18, r22
    38ee:	ac 01       	movw	r20, r24
    38f0:	60 91 7d 01 	lds	r22, 0x017D	; 0x80017d <prep+0x23>
    38f4:	70 91 7e 01 	lds	r23, 0x017E	; 0x80017e <prep+0x24>
    38f8:	80 91 7f 01 	lds	r24, 0x017F	; 0x80017f <prep+0x25>
    38fc:	90 91 80 01 	lds	r25, 0x0180	; 0x800180 <prep+0x26>
    3900:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    3904:	60 93 7d 01 	sts	0x017D, r22	; 0x80017d <prep+0x23>
    3908:	70 93 7e 01 	sts	0x017E, r23	; 0x80017e <prep+0x24>
    390c:	80 93 7f 01 	sts	0x017F, r24	; 0x80017f <prep+0x25>
    3910:	90 93 80 01 	sts	0x0180, r25	; 0x800180 <prep+0x26>
    3914:	4e c0       	rjmp	.+156    	; 0x39b2 <st_prep_buffer+0x6c0>
							}
						} else { // Triangle type
							prep.accelerate_until = intersect_distance;
    3916:	40 92 7d 01 	sts	0x017D, r4	; 0x80017d <prep+0x23>
    391a:	50 92 7e 01 	sts	0x017E, r5	; 0x80017e <prep+0x24>
    391e:	60 92 7f 01 	sts	0x017F, r6	; 0x80017f <prep+0x25>
    3922:	70 92 80 01 	sts	0x0180, r7	; 0x800180 <prep+0x26>
							prep.decelerate_after = intersect_distance;
    3926:	40 92 81 01 	sts	0x0181, r4	; 0x800181 <prep+0x27>
    392a:	50 92 82 01 	sts	0x0182, r5	; 0x800182 <prep+0x28>
    392e:	60 92 83 01 	sts	0x0183, r6	; 0x800183 <prep+0x29>
    3932:	70 92 84 01 	sts	0x0184, r7	; 0x800184 <prep+0x2a>
							prep.maximum_speed = sqrt(2.0*pl_block->acceleration*intersect_distance+exit_speed_sqr);
    3936:	d8 01       	movw	r26, r16
    3938:	5a 96       	adiw	r26, 0x1a	; 26
    393a:	cd 90       	ld	r12, X+
    393c:	dd 90       	ld	r13, X+
    393e:	ed 90       	ld	r14, X+
    3940:	fc 90       	ld	r15, X
    3942:	5d 97       	sbiw	r26, 0x1d	; 29
    3944:	a7 01       	movw	r20, r14
    3946:	96 01       	movw	r18, r12
    3948:	c7 01       	movw	r24, r14
    394a:	b6 01       	movw	r22, r12
    394c:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    3950:	a3 01       	movw	r20, r6
    3952:	92 01       	movw	r18, r4
    3954:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    3958:	29 85       	ldd	r18, Y+9	; 0x09
    395a:	3a 85       	ldd	r19, Y+10	; 0x0a
    395c:	4b 85       	ldd	r20, Y+11	; 0x0b
    395e:	5c 85       	ldd	r21, Y+12	; 0x0c
    3960:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    3964:	0e 94 55 32 	call	0x64aa	; 0x64aa <sqrt>
    3968:	60 93 75 01 	sts	0x0175, r22	; 0x800175 <prep+0x1b>
    396c:	70 93 76 01 	sts	0x0176, r23	; 0x800176 <prep+0x1c>
    3970:	80 93 77 01 	sts	0x0177, r24	; 0x800177 <prep+0x1d>
    3974:	90 93 78 01 	sts	0x0178, r25	; 0x800178 <prep+0x1e>
    3978:	1c c0       	rjmp	.+56     	; 0x39b2 <st_prep_buffer+0x6c0>
						}
					} else { // Deceleration-only type
            prep.ramp_type = RAMP_DECEL;
    397a:	b2 e0       	ldi	r27, 0x02	; 2
    397c:	b0 93 6c 01 	sts	0x016C, r27	; 0x80016c <prep+0x12>
    3980:	18 c0       	rjmp	.+48     	; 0x39b2 <st_prep_buffer+0x6c0>
            // prep.decelerate_after = pl_block->millimeters;
            // prep.maximum_speed = prep.current_speed;
					}
				} else { // Acceleration-only type
					prep.accelerate_until = 0.0;
    3982:	10 92 7d 01 	sts	0x017D, r1	; 0x80017d <prep+0x23>
    3986:	10 92 7e 01 	sts	0x017E, r1	; 0x80017e <prep+0x24>
    398a:	10 92 7f 01 	sts	0x017F, r1	; 0x80017f <prep+0x25>
    398e:	10 92 80 01 	sts	0x0180, r1	; 0x800180 <prep+0x26>
					// prep.decelerate_after = 0.0;
					prep.maximum_speed = prep.exit_speed;
    3992:	80 91 79 01 	lds	r24, 0x0179	; 0x800179 <prep+0x1f>
    3996:	90 91 7a 01 	lds	r25, 0x017A	; 0x80017a <prep+0x20>
    399a:	a0 91 7b 01 	lds	r26, 0x017B	; 0x80017b <prep+0x21>
    399e:	b0 91 7c 01 	lds	r27, 0x017C	; 0x80017c <prep+0x22>
    39a2:	80 93 75 01 	sts	0x0175, r24	; 0x800175 <prep+0x1b>
    39a6:	90 93 76 01 	sts	0x0176, r25	; 0x800176 <prep+0x1c>
    39aa:	a0 93 77 01 	sts	0x0177, r26	; 0x800177 <prep+0x1d>
    39ae:	b0 93 78 01 	sts	0x0178, r27	; 0x800178 <prep+0x1e>
				}
			}
      
      #ifdef VARIABLE_SPINDLE
        bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM); // Force update whenever updating block.
    39b2:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <sys+0x4>
    39b6:	88 60       	ori	r24, 0x08	; 8
    39b8:	80 93 80 05 	sts	0x0580, r24	; 0x800580 <sys+0x4>
      #endif
    }
    
    // Initialize new segment
    segment_t *prep_segment = &segment_buffer[segment_buffer_head];
    39bc:	e0 91 92 01 	lds	r30, 0x0192	; 0x800192 <segment_buffer_head>

    // Set new segment to point to the current segment data block.
    prep_segment->st_block_index = prep.st_block_index;
    39c0:	2e 2f       	mov	r18, r30
    39c2:	30 e0       	ldi	r19, 0x00	; 0
    39c4:	3a a7       	std	Y+42, r19	; 0x2a
    39c6:	29 a7       	std	Y+41, r18	; 0x29
    39c8:	37 e0       	ldi	r19, 0x07	; 7
    39ca:	e3 9f       	mul	r30, r19
    39cc:	f0 01       	movw	r30, r0
    39ce:	11 24       	eor	r1, r1
    39d0:	e9 54       	subi	r30, 0x49	; 73
    39d2:	fe 4f       	sbci	r31, 0xFE	; 254
    39d4:	aa e5       	ldi	r26, 0x5A	; 90
    39d6:	b1 e0       	ldi	r27, 0x01	; 1
    39d8:	8c 91       	ld	r24, X
    39da:	84 83       	std	Z+4, r24	; 0x04
    float dt_max = DT_SEGMENT; // Maximum segment time
    float dt = 0.0; // Initialize segment time
    float time_var = dt_max; // Time worker variable
    float mm_var; // mm-Distance worker variable
    float speed_var; // Speed worker variable
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    39dc:	e0 91 8c 01 	lds	r30, 0x018C	; 0x80018c <pl_block>
    39e0:	f0 91 8d 01 	lds	r31, 0x018D	; 0x80018d <pl_block+0x1>
    39e4:	fc 8f       	std	Y+28, r31	; 0x1c
    39e6:	eb 8f       	std	Y+27, r30	; 0x1b
    39e8:	f6 8d       	ldd	r31, Z+30	; 0x1e
    39ea:	fb a7       	std	Y+43, r31	; 0x2b
    39ec:	ab 8d       	ldd	r26, Y+27	; 0x1b
    39ee:	bc 8d       	ldd	r27, Y+28	; 0x1c
    39f0:	5f 96       	adiw	r26, 0x1f	; 31
    39f2:	bc 91       	ld	r27, X
    39f4:	bc a7       	std	Y+44, r27	; 0x2c
    39f6:	eb 8d       	ldd	r30, Y+27	; 0x1b
    39f8:	fc 8d       	ldd	r31, Y+28	; 0x1c
    39fa:	f0 a1       	ldd	r31, Z+32	; 0x20
    39fc:	fd a7       	std	Y+45, r31	; 0x2d
    39fe:	ab 8d       	ldd	r26, Y+27	; 0x1b
    3a00:	bc 8d       	ldd	r27, Y+28	; 0x1c
    3a02:	91 96       	adiw	r26, 0x21	; 33
    3a04:	bc 91       	ld	r27, X
    3a06:	be a7       	std	Y+46, r27	; 0x2e
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    3a08:	20 91 68 01 	lds	r18, 0x0168	; 0x800168 <prep+0xe>
    3a0c:	30 91 69 01 	lds	r19, 0x0169	; 0x800169 <prep+0xf>
    3a10:	40 91 6a 01 	lds	r20, 0x016A	; 0x80016a <prep+0x10>
    3a14:	50 91 6b 01 	lds	r21, 0x016B	; 0x80016b <prep+0x11>
    3a18:	6b a5       	ldd	r22, Y+43	; 0x2b
    3a1a:	7c a5       	ldd	r23, Y+44	; 0x2c
    3a1c:	8f 2f       	mov	r24, r31
    3a1e:	9b 2f       	mov	r25, r27
    3a20:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    3a24:	69 a3       	std	Y+33, r22	; 0x21
    3a26:	7a a3       	std	Y+34, r23	; 0x22
    3a28:	8b a3       	std	Y+35, r24	; 0x23
    3a2a:	9c a3       	std	Y+36, r25	; 0x24
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }
    3a2c:	20 e0       	ldi	r18, 0x00	; 0
    3a2e:	30 e0       	ldi	r19, 0x00	; 0
    3a30:	a9 01       	movw	r20, r18
    3a32:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    3a36:	88 23       	and	r24, r24
    3a38:	24 f4       	brge	.+8      	; 0x3a42 <st_prep_buffer+0x750>
    3a3a:	19 a2       	std	Y+33, r1	; 0x21
    3a3c:	1a a2       	std	Y+34, r1	; 0x22
    3a3e:	1b a2       	std	Y+35, r1	; 0x23
    3a40:	1c a2       	std	Y+36, r1	; 0x24

    do {
      switch (prep.ramp_type) {
        case RAMP_DECEL_OVERRIDE:
          speed_var = pl_block->acceleration*time_var;
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
    3a42:	20 91 75 01 	lds	r18, 0x0175	; 0x800175 <prep+0x1b>
    3a46:	30 91 76 01 	lds	r19, 0x0176	; 0x800176 <prep+0x1c>
    3a4a:	40 91 77 01 	lds	r20, 0x0177	; 0x800177 <prep+0x1d>
    3a4e:	50 91 78 01 	lds	r21, 0x0178	; 0x800178 <prep+0x1e>
    3a52:	2f 8b       	std	Y+23, r18	; 0x17
    3a54:	38 8f       	std	Y+24, r19	; 0x18
    3a56:	49 8f       	std	Y+25, r20	; 0x19
    3a58:	5a 8f       	std	Y+26, r21	; 0x1a
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
    3a5a:	30 91 7d 01 	lds	r19, 0x017D	; 0x80017d <prep+0x23>
    3a5e:	3d 8f       	std	Y+29, r19	; 0x1d
    3a60:	40 91 7e 01 	lds	r20, 0x017E	; 0x80017e <prep+0x24>
    3a64:	4e 8f       	std	Y+30, r20	; 0x1e
    3a66:	50 91 7f 01 	lds	r21, 0x017F	; 0x80017f <prep+0x25>
    3a6a:	5f 8f       	std	Y+31, r21	; 0x1f
    3a6c:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <prep+0x26>
    3a70:	88 a3       	std	Y+32, r24	; 0x20
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    3a72:	90 91 81 01 	lds	r25, 0x0181	; 0x800181 <prep+0x27>
    3a76:	9d a3       	std	Y+37, r25	; 0x25
    3a78:	a0 91 82 01 	lds	r26, 0x0182	; 0x800182 <prep+0x28>
    3a7c:	ae a3       	std	Y+38, r26	; 0x26
    3a7e:	b0 91 83 01 	lds	r27, 0x0183	; 0x800183 <prep+0x29>
    3a82:	bf a3       	std	Y+39, r27	; 0x27
    3a84:	e0 91 84 01 	lds	r30, 0x0184	; 0x800184 <prep+0x2a>
    3a88:	e8 a7       	std	Y+40, r30	; 0x28
    3a8a:	10 91 6c 01 	lds	r17, 0x016C	; 0x80016c <prep+0x12>
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
    3a8e:	f0 91 6d 01 	lds	r31, 0x016D	; 0x80016d <prep+0x13>
    3a92:	fb 8b       	std	Y+19, r31	; 0x13
    3a94:	20 91 6e 01 	lds	r18, 0x016E	; 0x80016e <prep+0x14>
    3a98:	2c 8b       	std	Y+20, r18	; 0x14
    3a9a:	30 91 6f 01 	lds	r19, 0x016F	; 0x80016f <prep+0x15>
    3a9e:	3d 8b       	std	Y+21, r19	; 0x15
    3aa0:	40 91 70 01 	lds	r20, 0x0170	; 0x800170 <prep+0x16>
    3aa4:	4e 8b       	std	Y+22, r20	; 0x16
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
            }
          }
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    3aa6:	80 91 79 01 	lds	r24, 0x0179	; 0x800179 <prep+0x1f>
    3aaa:	90 91 7a 01 	lds	r25, 0x017A	; 0x80017a <prep+0x20>
    3aae:	a0 91 7b 01 	lds	r26, 0x017B	; 0x80017b <prep+0x21>
    3ab2:	b0 91 7c 01 	lds	r27, 0x017C	; 0x80017c <prep+0x22>
    3ab6:	8f a7       	std	Y+47, r24	; 0x2f
    3ab8:	98 ab       	std	Y+48, r25	; 0x30
    3aba:	a9 ab       	std	Y+49, r26	; 0x31
    3abc:	ba ab       	std	Y+50, r27	; 0x32
    3abe:	2d a1       	ldd	r18, Y+37	; 0x25
    3ac0:	3e a1       	ldd	r19, Y+38	; 0x26
    3ac2:	4f a1       	ldd	r20, Y+39	; 0x27
    3ac4:	5e 2f       	mov	r21, r30
    3ac6:	6d 8d       	ldd	r22, Y+29	; 0x1d
    3ac8:	7e 8d       	ldd	r23, Y+30	; 0x1e
    3aca:	8f 8d       	ldd	r24, Y+31	; 0x1f
    3acc:	98 a1       	ldd	r25, Y+32	; 0x20
    3ace:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    3ad2:	81 11       	cpse	r24, r1
    3ad4:	02 c0       	rjmp	.+4      	; 0x3ada <st_prep_buffer+0x7e8>
    3ad6:	8a ad       	ldd	r24, Y+58	; 0x3a
    3ad8:	01 c0       	rjmp	.+2      	; 0x3adc <st_prep_buffer+0x7ea>
    3ada:	81 e0       	ldi	r24, 0x01	; 1
    3adc:	3b a4       	ldd	r3, Y+43	; 0x2b
    3ade:	2c a4       	ldd	r2, Y+44	; 0x2c
    3ae0:	5d a4       	ldd	r5, Y+45	; 0x2d
    3ae2:	4e a4       	ldd	r4, Y+46	; 0x2e
    3ae4:	9e e3       	ldi	r25, 0x3E	; 62
    3ae6:	99 83       	std	Y+1, r25	; 0x01
    3ae8:	0f 2e       	mov	r0, r31
    3aea:	f3 ec       	ldi	r31, 0xC3	; 195
    3aec:	6f 2e       	mov	r6, r31
    3aee:	f0 2d       	mov	r31, r0
    3af0:	0f 2e       	mov	r0, r31
    3af2:	fe e2       	ldi	r31, 0x2E	; 46
    3af4:	7f 2e       	mov	r7, r31
    3af6:	f0 2d       	mov	r31, r0
    3af8:	09 e3       	ldi	r16, 0x39	; 57
    3afa:	81 2c       	mov	r8, r1
    3afc:	91 2c       	mov	r9, r1
    3afe:	54 01       	movw	r10, r8
    3b00:	ae e3       	ldi	r26, 0x3E	; 62
    3b02:	ad 83       	std	Y+5, r26	; 0x05
    3b04:	b3 ec       	ldi	r27, 0xC3	; 195
    3b06:	b9 87       	std	Y+9, r27	; 0x09
    3b08:	ee e2       	ldi	r30, 0x2E	; 46
    3b0a:	ed 87       	std	Y+13, r30	; 0x0d
    3b0c:	f9 e3       	ldi	r31, 0x39	; 57
    3b0e:	fe 87       	std	Y+14, r31	; 0x0e
    3b10:	8f ab       	std	Y+55, r24	; 0x37
    3b12:	f3 2c       	mov	r15, r3
    3b14:	37 2c       	mov	r3, r7
    3b16:	e2 2c       	mov	r14, r2
    3b18:	26 2c       	mov	r2, r6
    3b1a:	d5 2c       	mov	r13, r5
    3b1c:	c4 2c       	mov	r12, r4
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }

    do {
      switch (prep.ramp_type) {
    3b1e:	11 30       	cpi	r17, 0x01	; 1
    3b20:	09 f4       	brne	.+2      	; 0x3b24 <st_prep_buffer+0x832>
    3b22:	1f c1       	rjmp	.+574    	; 0x3d62 <st_prep_buffer+0xa70>
    3b24:	08 f4       	brcc	.+2      	; 0x3b28 <st_prep_buffer+0x836>
    3b26:	96 c0       	rjmp	.+300    	; 0x3c54 <st_prep_buffer+0x962>
    3b28:	13 30       	cpi	r17, 0x03	; 3
    3b2a:	09 f0       	breq	.+2      	; 0x3b2e <st_prep_buffer+0x83c>
    3b2c:	57 c1       	rjmp	.+686    	; 0x3ddc <st_prep_buffer+0xaea>
        case RAMP_DECEL_OVERRIDE:
          speed_var = pl_block->acceleration*time_var;
    3b2e:	ab 8d       	ldd	r26, Y+27	; 0x1b
    3b30:	bc 8d       	ldd	r27, Y+28	; 0x1c
    3b32:	5a 96       	adiw	r26, 0x1a	; 26
    3b34:	2d 91       	ld	r18, X+
    3b36:	3d 91       	ld	r19, X+
    3b38:	4d 91       	ld	r20, X+
    3b3a:	5c 91       	ld	r21, X
    3b3c:	5d 97       	sbiw	r26, 0x1d	; 29
    3b3e:	69 81       	ldd	r22, Y+1	; 0x01
    3b40:	72 2d       	mov	r23, r2
    3b42:	83 2d       	mov	r24, r3
    3b44:	90 2f       	mov	r25, r16
    3b46:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    3b4a:	6f 87       	std	Y+15, r22	; 0x0f
    3b4c:	78 8b       	std	Y+16, r23	; 0x10
    3b4e:	89 8b       	std	Y+17, r24	; 0x11
    3b50:	9a 8b       	std	Y+18, r25	; 0x12
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
    3b52:	40 90 71 01 	lds	r4, 0x0171	; 0x800171 <prep+0x17>
    3b56:	50 90 72 01 	lds	r5, 0x0172	; 0x800172 <prep+0x18>
    3b5a:	60 90 73 01 	lds	r6, 0x0173	; 0x800173 <prep+0x19>
    3b5e:	70 90 74 01 	lds	r7, 0x0174	; 0x800174 <prep+0x1a>
    3b62:	2f 89       	ldd	r18, Y+23	; 0x17
    3b64:	38 8d       	ldd	r19, Y+24	; 0x18
    3b66:	49 8d       	ldd	r20, Y+25	; 0x19
    3b68:	5a 8d       	ldd	r21, Y+26	; 0x1a
    3b6a:	c3 01       	movw	r24, r6
    3b6c:	b2 01       	movw	r22, r4
    3b6e:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    3b72:	9b 01       	movw	r18, r22
    3b74:	ac 01       	movw	r20, r24
    3b76:	6f 85       	ldd	r22, Y+15	; 0x0f
    3b78:	78 89       	ldd	r23, Y+16	; 0x10
    3b7a:	89 89       	ldd	r24, Y+17	; 0x11
    3b7c:	9a 89       	ldd	r25, Y+18	; 0x12
    3b7e:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    3b82:	88 23       	and	r24, r24
    3b84:	a4 f1       	brlt	.+104    	; 0x3bee <st_prep_buffer+0x8fc>
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    3b86:	2d 8d       	ldd	r18, Y+29	; 0x1d
    3b88:	3e 8d       	ldd	r19, Y+30	; 0x1e
    3b8a:	4f 8d       	ldd	r20, Y+31	; 0x1f
    3b8c:	58 a1       	ldd	r21, Y+32	; 0x20
    3b8e:	6b a5       	ldd	r22, Y+43	; 0x2b
    3b90:	7c a5       	ldd	r23, Y+44	; 0x2c
    3b92:	8d a5       	ldd	r24, Y+45	; 0x2d
    3b94:	9e a5       	ldd	r25, Y+46	; 0x2e
    3b96:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    3b9a:	9b 01       	movw	r18, r22
    3b9c:	ac 01       	movw	r20, r24
    3b9e:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    3ba2:	6b 01       	movw	r12, r22
    3ba4:	7c 01       	movw	r14, r24
    3ba6:	2f 89       	ldd	r18, Y+23	; 0x17
    3ba8:	38 8d       	ldd	r19, Y+24	; 0x18
    3baa:	49 8d       	ldd	r20, Y+25	; 0x19
    3bac:	5a 8d       	ldd	r21, Y+26	; 0x1a
    3bae:	c3 01       	movw	r24, r6
    3bb0:	b2 01       	movw	r22, r4
    3bb2:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    3bb6:	9b 01       	movw	r18, r22
    3bb8:	ac 01       	movw	r20, r24
    3bba:	c7 01       	movw	r24, r14
    3bbc:	b6 01       	movw	r22, r12
    3bbe:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <__divsf3>
    3bc2:	69 83       	std	Y+1, r22	; 0x01
    3bc4:	27 2e       	mov	r2, r23
    3bc6:	38 2e       	mov	r3, r24
    3bc8:	09 2f       	mov	r16, r25
            prep.ramp_type = RAMP_CRUISE;
            prep.current_speed = prep.maximum_speed;
    3bca:	2f 89       	ldd	r18, Y+23	; 0x17
    3bcc:	38 8d       	ldd	r19, Y+24	; 0x18
    3bce:	49 8d       	ldd	r20, Y+25	; 0x19
    3bd0:	5a 8d       	ldd	r21, Y+26	; 0x1a
    3bd2:	20 93 71 01 	sts	0x0171, r18	; 0x800171 <prep+0x17>
    3bd6:	30 93 72 01 	sts	0x0172, r19	; 0x800172 <prep+0x18>
    3bda:	40 93 73 01 	sts	0x0173, r20	; 0x800173 <prep+0x19>
    3bde:	50 93 74 01 	sts	0x0174, r21	; 0x800174 <prep+0x1a>
      switch (prep.ramp_type) {
        case RAMP_DECEL_OVERRIDE:
          speed_var = pl_block->acceleration*time_var;
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
    3be2:	fd 8c       	ldd	r15, Y+29	; 0x1d
    3be4:	ee 8c       	ldd	r14, Y+30	; 0x1e
    3be6:	df 8c       	ldd	r13, Y+31	; 0x1f
    3be8:	c8 a0       	ldd	r12, Y+32	; 0x20
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            prep.ramp_type = RAMP_CRUISE;
    3bea:	18 ad       	ldd	r17, Y+56	; 0x38
    3bec:	8e c1       	rjmp	.+796    	; 0x3f0a <st_prep_buffer+0xc18>
            prep.current_speed = prep.maximum_speed;
          } else { // Mid-deceleration override ramp.
            mm_remaining -= time_var*(prep.current_speed - 0.5*speed_var);
    3bee:	20 e0       	ldi	r18, 0x00	; 0
    3bf0:	30 e0       	ldi	r19, 0x00	; 0
    3bf2:	40 e0       	ldi	r20, 0x00	; 0
    3bf4:	5f e3       	ldi	r21, 0x3F	; 63
    3bf6:	6f 85       	ldd	r22, Y+15	; 0x0f
    3bf8:	78 89       	ldd	r23, Y+16	; 0x10
    3bfa:	89 89       	ldd	r24, Y+17	; 0x11
    3bfc:	9a 89       	ldd	r25, Y+18	; 0x12
    3bfe:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    3c02:	9b 01       	movw	r18, r22
    3c04:	ac 01       	movw	r20, r24
    3c06:	c3 01       	movw	r24, r6
    3c08:	b2 01       	movw	r22, r4
    3c0a:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    3c0e:	29 81       	ldd	r18, Y+1	; 0x01
    3c10:	32 2d       	mov	r19, r2
    3c12:	43 2d       	mov	r20, r3
    3c14:	50 2f       	mov	r21, r16
    3c16:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    3c1a:	9b 01       	movw	r18, r22
    3c1c:	ac 01       	movw	r20, r24
    3c1e:	6f 2d       	mov	r22, r15
    3c20:	7e 2d       	mov	r23, r14
    3c22:	8d 2d       	mov	r24, r13
    3c24:	9c 2d       	mov	r25, r12
    3c26:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    3c2a:	f6 2e       	mov	r15, r22
    3c2c:	e7 2e       	mov	r14, r23
    3c2e:	d8 2e       	mov	r13, r24
    3c30:	c9 2e       	mov	r12, r25
            prep.current_speed -= speed_var;
    3c32:	2f 85       	ldd	r18, Y+15	; 0x0f
    3c34:	38 89       	ldd	r19, Y+16	; 0x10
    3c36:	49 89       	ldd	r20, Y+17	; 0x11
    3c38:	5a 89       	ldd	r21, Y+18	; 0x12
    3c3a:	c3 01       	movw	r24, r6
    3c3c:	b2 01       	movw	r22, r4
    3c3e:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    3c42:	60 93 71 01 	sts	0x0171, r22	; 0x800171 <prep+0x17>
    3c46:	70 93 72 01 	sts	0x0172, r23	; 0x800172 <prep+0x18>
    3c4a:	80 93 73 01 	sts	0x0173, r24	; 0x800173 <prep+0x19>
    3c4e:	90 93 74 01 	sts	0x0174, r25	; 0x800174 <prep+0x1a>
    3c52:	5b c1       	rjmp	.+694    	; 0x3f0a <st_prep_buffer+0xc18>
          }
          break;
        case RAMP_ACCEL:
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
    3c54:	ab 8d       	ldd	r26, Y+27	; 0x1b
    3c56:	bc 8d       	ldd	r27, Y+28	; 0x1c
    3c58:	5a 96       	adiw	r26, 0x1a	; 26
    3c5a:	2d 91       	ld	r18, X+
    3c5c:	3d 91       	ld	r19, X+
    3c5e:	4d 91       	ld	r20, X+
    3c60:	5c 91       	ld	r21, X
    3c62:	5d 97       	sbiw	r26, 0x1d	; 29
    3c64:	69 81       	ldd	r22, Y+1	; 0x01
    3c66:	72 2d       	mov	r23, r2
    3c68:	83 2d       	mov	r24, r3
    3c6a:	90 2f       	mov	r25, r16
    3c6c:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    3c70:	6f 87       	std	Y+15, r22	; 0x0f
    3c72:	78 8b       	std	Y+16, r23	; 0x10
    3c74:	89 8b       	std	Y+17, r24	; 0x11
    3c76:	9a 8b       	std	Y+18, r25	; 0x12
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
    3c78:	40 90 71 01 	lds	r4, 0x0171	; 0x800171 <prep+0x17>
    3c7c:	50 90 72 01 	lds	r5, 0x0172	; 0x800172 <prep+0x18>
    3c80:	60 90 73 01 	lds	r6, 0x0173	; 0x800173 <prep+0x19>
    3c84:	70 90 74 01 	lds	r7, 0x0174	; 0x800174 <prep+0x1a>
    3c88:	20 e0       	ldi	r18, 0x00	; 0
    3c8a:	30 e0       	ldi	r19, 0x00	; 0
    3c8c:	40 e0       	ldi	r20, 0x00	; 0
    3c8e:	5f e3       	ldi	r21, 0x3F	; 63
    3c90:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    3c94:	a3 01       	movw	r20, r6
    3c96:	92 01       	movw	r18, r4
    3c98:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    3c9c:	29 81       	ldd	r18, Y+1	; 0x01
    3c9e:	32 2d       	mov	r19, r2
    3ca0:	43 2d       	mov	r20, r3
    3ca2:	50 2f       	mov	r21, r16
    3ca4:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    3ca8:	9b 01       	movw	r18, r22
    3caa:	ac 01       	movw	r20, r24
    3cac:	6f 2d       	mov	r22, r15
    3cae:	7e 2d       	mov	r23, r14
    3cb0:	8d 2d       	mov	r24, r13
    3cb2:	9c 2d       	mov	r25, r12
    3cb4:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    3cb8:	f6 2e       	mov	r15, r22
    3cba:	e7 2e       	mov	r14, r23
    3cbc:	d8 2e       	mov	r13, r24
    3cbe:	c9 2e       	mov	r12, r25
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    3cc0:	26 2f       	mov	r18, r22
    3cc2:	37 2f       	mov	r19, r23
    3cc4:	48 2f       	mov	r20, r24
    3cc6:	59 2f       	mov	r21, r25
    3cc8:	6d 8d       	ldd	r22, Y+29	; 0x1d
    3cca:	7e 8d       	ldd	r23, Y+30	; 0x1e
    3ccc:	8f 8d       	ldd	r24, Y+31	; 0x1f
    3cce:	98 a1       	ldd	r25, Y+32	; 0x20
    3cd0:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    3cd4:	18 16       	cp	r1, r24
    3cd6:	a4 f5       	brge	.+104    	; 0x3d40 <st_prep_buffer+0xa4e>
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    3cd8:	2d 8d       	ldd	r18, Y+29	; 0x1d
    3cda:	3e 8d       	ldd	r19, Y+30	; 0x1e
    3cdc:	4f 8d       	ldd	r20, Y+31	; 0x1f
    3cde:	58 a1       	ldd	r21, Y+32	; 0x20
    3ce0:	6b a5       	ldd	r22, Y+43	; 0x2b
    3ce2:	7c a5       	ldd	r23, Y+44	; 0x2c
    3ce4:	8d a5       	ldd	r24, Y+45	; 0x2d
    3ce6:	9e a5       	ldd	r25, Y+46	; 0x2e
    3ce8:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    3cec:	9b 01       	movw	r18, r22
    3cee:	ac 01       	movw	r20, r24
    3cf0:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    3cf4:	6b 01       	movw	r12, r22
    3cf6:	7c 01       	movw	r14, r24
    3cf8:	a3 01       	movw	r20, r6
    3cfa:	92 01       	movw	r18, r4
    3cfc:	6f 89       	ldd	r22, Y+23	; 0x17
    3cfe:	78 8d       	ldd	r23, Y+24	; 0x18
    3d00:	89 8d       	ldd	r24, Y+25	; 0x19
    3d02:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3d04:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    3d08:	9b 01       	movw	r18, r22
    3d0a:	ac 01       	movw	r20, r24
    3d0c:	c7 01       	movw	r24, r14
    3d0e:	b6 01       	movw	r22, r12
    3d10:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <__divsf3>
    3d14:	69 83       	std	Y+1, r22	; 0x01
    3d16:	27 2e       	mov	r2, r23
    3d18:	38 2e       	mov	r3, r24
    3d1a:	09 2f       	mov	r16, r25
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
    3d1c:	2f 89       	ldd	r18, Y+23	; 0x17
    3d1e:	38 8d       	ldd	r19, Y+24	; 0x18
    3d20:	49 8d       	ldd	r20, Y+25	; 0x19
    3d22:	5a 8d       	ldd	r21, Y+26	; 0x1a
    3d24:	20 93 71 01 	sts	0x0171, r18	; 0x800171 <prep+0x17>
    3d28:	30 93 72 01 	sts	0x0172, r19	; 0x800172 <prep+0x18>
    3d2c:	40 93 73 01 	sts	0x0173, r20	; 0x800173 <prep+0x19>
    3d30:	50 93 74 01 	sts	0x0174, r21	; 0x800174 <prep+0x1a>
    3d34:	1f a9       	ldd	r17, Y+55	; 0x37
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
    3d36:	fd 8c       	ldd	r15, Y+29	; 0x1d
    3d38:	ee 8c       	ldd	r14, Y+30	; 0x1e
    3d3a:	df 8c       	ldd	r13, Y+31	; 0x1f
    3d3c:	c8 a0       	ldd	r12, Y+32	; 0x20
    3d3e:	e5 c0       	rjmp	.+458    	; 0x3f0a <st_prep_buffer+0xc18>
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
          } else { // Acceleration only.
            prep.current_speed += speed_var;
    3d40:	a3 01       	movw	r20, r6
    3d42:	92 01       	movw	r18, r4
    3d44:	6f 85       	ldd	r22, Y+15	; 0x0f
    3d46:	78 89       	ldd	r23, Y+16	; 0x10
    3d48:	89 89       	ldd	r24, Y+17	; 0x11
    3d4a:	9a 89       	ldd	r25, Y+18	; 0x12
    3d4c:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    3d50:	60 93 71 01 	sts	0x0171, r22	; 0x800171 <prep+0x17>
    3d54:	70 93 72 01 	sts	0x0172, r23	; 0x800172 <prep+0x18>
    3d58:	80 93 73 01 	sts	0x0173, r24	; 0x800173 <prep+0x19>
    3d5c:	90 93 74 01 	sts	0x0174, r25	; 0x800174 <prep+0x1a>
    3d60:	d4 c0       	rjmp	.+424    	; 0x3f0a <st_prep_buffer+0xc18>
          break;
        case RAMP_CRUISE:
          // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.
          // NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not change. To
          //   prevent this, simply enforce a minimum speed threshold in the planner.
          mm_var = mm_remaining - prep.maximum_speed*time_var;
    3d62:	2f 89       	ldd	r18, Y+23	; 0x17
    3d64:	38 8d       	ldd	r19, Y+24	; 0x18
    3d66:	49 8d       	ldd	r20, Y+25	; 0x19
    3d68:	5a 8d       	ldd	r21, Y+26	; 0x1a
    3d6a:	69 81       	ldd	r22, Y+1	; 0x01
    3d6c:	72 2d       	mov	r23, r2
    3d6e:	83 2d       	mov	r24, r3
    3d70:	90 2f       	mov	r25, r16
    3d72:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    3d76:	9b 01       	movw	r18, r22
    3d78:	ac 01       	movw	r20, r24
    3d7a:	6f 2d       	mov	r22, r15
    3d7c:	7e 2d       	mov	r23, r14
    3d7e:	8d 2d       	mov	r24, r13
    3d80:	9c 2d       	mov	r25, r12
    3d82:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    3d86:	46 2e       	mov	r4, r22
    3d88:	57 2e       	mov	r5, r23
    3d8a:	68 2e       	mov	r6, r24
    3d8c:	79 2e       	mov	r7, r25
          if (mm_var < prep.decelerate_after) { // End of cruise.
    3d8e:	26 2f       	mov	r18, r22
    3d90:	37 2f       	mov	r19, r23
    3d92:	48 2f       	mov	r20, r24
    3d94:	59 2f       	mov	r21, r25
    3d96:	6d a1       	ldd	r22, Y+37	; 0x25
    3d98:	7e a1       	ldd	r23, Y+38	; 0x26
    3d9a:	8f a1       	ldd	r24, Y+39	; 0x27
    3d9c:	98 a5       	ldd	r25, Y+40	; 0x28
    3d9e:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    3da2:	18 16       	cp	r1, r24
    3da4:	0c f0       	brlt	.+2      	; 0x3da8 <st_prep_buffer+0xab6>
    3da6:	ad c0       	rjmp	.+346    	; 0x3f02 <st_prep_buffer+0xc10>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
    3da8:	2d a1       	ldd	r18, Y+37	; 0x25
    3daa:	3e a1       	ldd	r19, Y+38	; 0x26
    3dac:	4f a1       	ldd	r20, Y+39	; 0x27
    3dae:	58 a5       	ldd	r21, Y+40	; 0x28
    3db0:	6f 2d       	mov	r22, r15
    3db2:	7e 2d       	mov	r23, r14
    3db4:	8d 2d       	mov	r24, r13
    3db6:	9c 2d       	mov	r25, r12
    3db8:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    3dbc:	2f 89       	ldd	r18, Y+23	; 0x17
    3dbe:	38 8d       	ldd	r19, Y+24	; 0x18
    3dc0:	49 8d       	ldd	r20, Y+25	; 0x19
    3dc2:	5a 8d       	ldd	r21, Y+26	; 0x1a
    3dc4:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <__divsf3>
    3dc8:	69 83       	std	Y+1, r22	; 0x01
    3dca:	27 2e       	mov	r2, r23
    3dcc:	38 2e       	mov	r3, r24
    3dce:	09 2f       	mov	r16, r25
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
    3dd0:	fd a0       	ldd	r15, Y+37	; 0x25
    3dd2:	ee a0       	ldd	r14, Y+38	; 0x26
    3dd4:	df a0       	ldd	r13, Y+39	; 0x27
    3dd6:	c8 a4       	ldd	r12, Y+40	; 0x28
            prep.ramp_type = RAMP_DECEL;
    3dd8:	19 ad       	ldd	r17, Y+57	; 0x39
    3dda:	97 c0       	rjmp	.+302    	; 0x3f0a <st_prep_buffer+0xc18>
            mm_remaining = mm_var;
          }
          break;
        default: // case RAMP_DECEL:
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
    3ddc:	ab 8d       	ldd	r26, Y+27	; 0x1b
    3dde:	bc 8d       	ldd	r27, Y+28	; 0x1c
    3de0:	5a 96       	adiw	r26, 0x1a	; 26
    3de2:	2d 91       	ld	r18, X+
    3de4:	3d 91       	ld	r19, X+
    3de6:	4d 91       	ld	r20, X+
    3de8:	5c 91       	ld	r21, X
    3dea:	5d 97       	sbiw	r26, 0x1d	; 29
    3dec:	69 81       	ldd	r22, Y+1	; 0x01
    3dee:	72 2d       	mov	r23, r2
    3df0:	83 2d       	mov	r24, r3
    3df2:	90 2f       	mov	r25, r16
    3df4:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    3df8:	6f 87       	std	Y+15, r22	; 0x0f
    3dfa:	78 8b       	std	Y+16, r23	; 0x10
    3dfc:	89 8b       	std	Y+17, r24	; 0x11
    3dfe:	9a 8b       	std	Y+18, r25	; 0x12
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
    3e00:	40 90 71 01 	lds	r4, 0x0171	; 0x800171 <prep+0x17>
    3e04:	50 90 72 01 	lds	r5, 0x0172	; 0x800172 <prep+0x18>
    3e08:	60 90 73 01 	lds	r6, 0x0173	; 0x800173 <prep+0x19>
    3e0c:	70 90 74 01 	lds	r7, 0x0174	; 0x800174 <prep+0x1a>
    3e10:	a3 01       	movw	r20, r6
    3e12:	92 01       	movw	r18, r4
    3e14:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    3e18:	88 23       	and	r24, r24
    3e1a:	0c f0       	brlt	.+2      	; 0x3e1e <st_prep_buffer+0xb2c>
    3e1c:	3f c0       	rjmp	.+126    	; 0x3e9c <st_prep_buffer+0xbaa>
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
    3e1e:	20 e0       	ldi	r18, 0x00	; 0
    3e20:	30 e0       	ldi	r19, 0x00	; 0
    3e22:	40 e0       	ldi	r20, 0x00	; 0
    3e24:	5f e3       	ldi	r21, 0x3F	; 63
    3e26:	6f 85       	ldd	r22, Y+15	; 0x0f
    3e28:	78 89       	ldd	r23, Y+16	; 0x10
    3e2a:	89 89       	ldd	r24, Y+17	; 0x11
    3e2c:	9a 89       	ldd	r25, Y+18	; 0x12
    3e2e:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    3e32:	9b 01       	movw	r18, r22
    3e34:	ac 01       	movw	r20, r24
    3e36:	c3 01       	movw	r24, r6
    3e38:	b2 01       	movw	r22, r4
    3e3a:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    3e3e:	29 81       	ldd	r18, Y+1	; 0x01
    3e40:	32 2d       	mov	r19, r2
    3e42:	43 2d       	mov	r20, r3
    3e44:	50 2f       	mov	r21, r16
    3e46:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    3e4a:	9b 01       	movw	r18, r22
    3e4c:	ac 01       	movw	r20, r24
    3e4e:	6f 2d       	mov	r22, r15
    3e50:	7e 2d       	mov	r23, r14
    3e52:	8d 2d       	mov	r24, r13
    3e54:	9c 2d       	mov	r25, r12
    3e56:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    3e5a:	6b ab       	std	Y+51, r22	; 0x33
    3e5c:	7c ab       	std	Y+52, r23	; 0x34
    3e5e:	8d ab       	std	Y+53, r24	; 0x35
    3e60:	9e ab       	std	Y+54, r25	; 0x36
            if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
    3e62:	2b 89       	ldd	r18, Y+19	; 0x13
    3e64:	3c 89       	ldd	r19, Y+20	; 0x14
    3e66:	4d 89       	ldd	r20, Y+21	; 0x15
    3e68:	5e 89       	ldd	r21, Y+22	; 0x16
    3e6a:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    3e6e:	18 16       	cp	r1, r24
    3e70:	ac f4       	brge	.+42     	; 0x3e9c <st_prep_buffer+0xbaa>
              mm_remaining = mm_var;
              prep.current_speed -= speed_var;
    3e72:	2f 85       	ldd	r18, Y+15	; 0x0f
    3e74:	38 89       	ldd	r19, Y+16	; 0x10
    3e76:	49 89       	ldd	r20, Y+17	; 0x11
    3e78:	5a 89       	ldd	r21, Y+18	; 0x12
    3e7a:	c3 01       	movw	r24, r6
    3e7c:	b2 01       	movw	r22, r4
    3e7e:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    3e82:	60 93 71 01 	sts	0x0171, r22	; 0x800171 <prep+0x17>
    3e86:	70 93 72 01 	sts	0x0172, r23	; 0x800172 <prep+0x18>
    3e8a:	80 93 73 01 	sts	0x0173, r24	; 0x800173 <prep+0x19>
    3e8e:	90 93 74 01 	sts	0x0174, r25	; 0x800174 <prep+0x1a>
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
              mm_remaining = mm_var;
    3e92:	fb a8       	ldd	r15, Y+51	; 0x33
    3e94:	ec a8       	ldd	r14, Y+52	; 0x34
    3e96:	dd a8       	ldd	r13, Y+53	; 0x35
    3e98:	ce a8       	ldd	r12, Y+54	; 0x36
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
    3e9a:	37 c0       	rjmp	.+110    	; 0x3f0a <st_prep_buffer+0xc18>
            }
          }
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    3e9c:	2b 89       	ldd	r18, Y+19	; 0x13
    3e9e:	3c 89       	ldd	r19, Y+20	; 0x14
    3ea0:	4d 89       	ldd	r20, Y+21	; 0x15
    3ea2:	5e 89       	ldd	r21, Y+22	; 0x16
    3ea4:	6f 2d       	mov	r22, r15
    3ea6:	7e 2d       	mov	r23, r14
    3ea8:	8d 2d       	mov	r24, r13
    3eaa:	9c 2d       	mov	r25, r12
    3eac:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    3eb0:	9b 01       	movw	r18, r22
    3eb2:	ac 01       	movw	r20, r24
    3eb4:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    3eb8:	6b 01       	movw	r12, r22
    3eba:	7c 01       	movw	r14, r24
    3ebc:	2f a5       	ldd	r18, Y+47	; 0x2f
    3ebe:	38 a9       	ldd	r19, Y+48	; 0x30
    3ec0:	49 a9       	ldd	r20, Y+49	; 0x31
    3ec2:	5a a9       	ldd	r21, Y+50	; 0x32
    3ec4:	c3 01       	movw	r24, r6
    3ec6:	b2 01       	movw	r22, r4
    3ec8:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    3ecc:	9b 01       	movw	r18, r22
    3ece:	ac 01       	movw	r20, r24
    3ed0:	c7 01       	movw	r24, r14
    3ed2:	b6 01       	movw	r22, r12
    3ed4:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <__divsf3>
    3ed8:	69 83       	std	Y+1, r22	; 0x01
    3eda:	27 2e       	mov	r2, r23
    3edc:	38 2e       	mov	r3, r24
    3ede:	09 2f       	mov	r16, r25
          mm_remaining = prep.mm_complete;
          prep.current_speed = prep.exit_speed;
    3ee0:	2f a5       	ldd	r18, Y+47	; 0x2f
    3ee2:	38 a9       	ldd	r19, Y+48	; 0x30
    3ee4:	49 a9       	ldd	r20, Y+49	; 0x31
    3ee6:	5a a9       	ldd	r21, Y+50	; 0x32
    3ee8:	20 93 71 01 	sts	0x0171, r18	; 0x800171 <prep+0x17>
    3eec:	30 93 72 01 	sts	0x0172, r19	; 0x800172 <prep+0x18>
    3ef0:	40 93 73 01 	sts	0x0173, r20	; 0x800173 <prep+0x19>
    3ef4:	50 93 74 01 	sts	0x0174, r21	; 0x800174 <prep+0x1a>
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
            }
          }
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
          mm_remaining = prep.mm_complete;
    3ef8:	fb 88       	ldd	r15, Y+19	; 0x13
    3efa:	ec 88       	ldd	r14, Y+20	; 0x14
    3efc:	dd 88       	ldd	r13, Y+21	; 0x15
    3efe:	ce 88       	ldd	r12, Y+22	; 0x16
    3f00:	04 c0       	rjmp	.+8      	; 0x3f0a <st_prep_buffer+0xc18>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
          } else { // Cruising only.
            mm_remaining = mm_var;
    3f02:	f4 2c       	mov	r15, r4
    3f04:	e5 2c       	mov	r14, r5
    3f06:	d6 2c       	mov	r13, r6
    3f08:	c7 2c       	mov	r12, r7
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
          mm_remaining = prep.mm_complete;
          prep.current_speed = prep.exit_speed;
      }
      dt += time_var; // Add computed ramp time to total segment time.
    3f0a:	29 81       	ldd	r18, Y+1	; 0x01
    3f0c:	32 2d       	mov	r19, r2
    3f0e:	43 2d       	mov	r20, r3
    3f10:	50 2f       	mov	r21, r16
    3f12:	c5 01       	movw	r24, r10
    3f14:	b4 01       	movw	r22, r8
    3f16:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    3f1a:	4b 01       	movw	r8, r22
    3f1c:	5c 01       	movw	r10, r24
      if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.
    3f1e:	9b 01       	movw	r18, r22
    3f20:	ac 01       	movw	r20, r24
    3f22:	6d 81       	ldd	r22, Y+5	; 0x05
    3f24:	79 85       	ldd	r23, Y+9	; 0x09
    3f26:	8d 85       	ldd	r24, Y+13	; 0x0d
    3f28:	9e 85       	ldd	r25, Y+14	; 0x0e
    3f2a:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    3f2e:	18 16       	cp	r1, r24
    3f30:	6c f4       	brge	.+26     	; 0x3f4c <st_prep_buffer+0xc5a>
    3f32:	a5 01       	movw	r20, r10
    3f34:	94 01       	movw	r18, r8
    3f36:	6d 81       	ldd	r22, Y+5	; 0x05
    3f38:	79 85       	ldd	r23, Y+9	; 0x09
    3f3a:	8d 85       	ldd	r24, Y+13	; 0x0d
    3f3c:	9e 85       	ldd	r25, Y+14	; 0x0e
    3f3e:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    3f42:	69 83       	std	Y+1, r22	; 0x01
    3f44:	27 2e       	mov	r2, r23
    3f46:	38 2e       	mov	r3, r24
    3f48:	09 2f       	mov	r16, r25
    3f4a:	29 c0       	rjmp	.+82     	; 0x3f9e <st_prep_buffer+0xcac>
      else {
        if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
    3f4c:	29 a1       	ldd	r18, Y+33	; 0x21
    3f4e:	3a a1       	ldd	r19, Y+34	; 0x22
    3f50:	4b a1       	ldd	r20, Y+35	; 0x23
    3f52:	5c a1       	ldd	r21, Y+36	; 0x24
    3f54:	6f 2d       	mov	r22, r15
    3f56:	7e 2d       	mov	r23, r14
    3f58:	8d 2d       	mov	r24, r13
    3f5a:	9c 2d       	mov	r25, r12
    3f5c:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    3f60:	18 16       	cp	r1, r24
    3f62:	3c f0       	brlt	.+14     	; 0x3f72 <st_prep_buffer+0xc80>
    3f64:	3f 2c       	mov	r3, r15
    3f66:	2e 2c       	mov	r2, r14
    3f68:	5d 2c       	mov	r5, r13
    3f6a:	4c 2c       	mov	r4, r12
    3f6c:	10 93 6c 01 	sts	0x016C, r17	; 0x80016c <prep+0x12>
    3f70:	29 c0       	rjmp	.+82     	; 0x3fc4 <st_prep_buffer+0xcd2>
          // Increase segment time to ensure at least one step in segment. Override and loop
          // through distance calculations until minimum_mm or mm_complete.
          dt_max += DT_SEGMENT;
    3f72:	2e e3       	ldi	r18, 0x3E	; 62
    3f74:	33 ec       	ldi	r19, 0xC3	; 195
    3f76:	4e e2       	ldi	r20, 0x2E	; 46
    3f78:	59 e3       	ldi	r21, 0x39	; 57
    3f7a:	6d 81       	ldd	r22, Y+5	; 0x05
    3f7c:	79 85       	ldd	r23, Y+9	; 0x09
    3f7e:	8d 85       	ldd	r24, Y+13	; 0x0d
    3f80:	9e 85       	ldd	r25, Y+14	; 0x0e
    3f82:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    3f86:	6d 83       	std	Y+5, r22	; 0x05
    3f88:	79 87       	std	Y+9, r23	; 0x09
    3f8a:	8d 87       	std	Y+13, r24	; 0x0d
    3f8c:	9e 87       	std	Y+14, r25	; 0x0e
          time_var = dt_max - dt;
    3f8e:	a5 01       	movw	r20, r10
    3f90:	94 01       	movw	r18, r8
    3f92:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    3f96:	69 83       	std	Y+1, r22	; 0x01
    3f98:	27 2e       	mov	r2, r23
    3f9a:	38 2e       	mov	r3, r24
    3f9c:	09 2f       	mov	r16, r25
        } else {
          break; // **Complete** Exit loop. Segment execution time maxed.
        }
      }
    } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
    3f9e:	2b 89       	ldd	r18, Y+19	; 0x13
    3fa0:	3c 89       	ldd	r19, Y+20	; 0x14
    3fa2:	4d 89       	ldd	r20, Y+21	; 0x15
    3fa4:	5e 89       	ldd	r21, Y+22	; 0x16
    3fa6:	6f 2d       	mov	r22, r15
    3fa8:	7e 2d       	mov	r23, r14
    3faa:	8d 2d       	mov	r24, r13
    3fac:	9c 2d       	mov	r25, r12
    3fae:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    3fb2:	18 16       	cp	r1, r24
    3fb4:	0c f4       	brge	.+2      	; 0x3fb8 <st_prep_buffer+0xcc6>
    3fb6:	b3 cd       	rjmp	.-1178   	; 0x3b1e <st_prep_buffer+0x82c>
    3fb8:	3f 2c       	mov	r3, r15
    3fba:	2e 2c       	mov	r2, r14
    3fbc:	5d 2c       	mov	r5, r13
    3fbe:	4c 2c       	mov	r4, r12
    3fc0:	10 93 6c 01 	sts	0x016C, r17	; 0x80016c <prep+0x12>
    #ifdef VARIABLE_SPINDLE
      /* -----------------------------------------------------------------------------------
        Compute spindle speed PWM output for step segment
      */
      
      if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
    3fc4:	e0 91 8a 01 	lds	r30, 0x018A	; 0x80018a <st_prep_block>
    3fc8:	f0 91 8b 01 	lds	r31, 0x018B	; 0x80018b <st_prep_block+0x1>
    3fcc:	81 89       	ldd	r24, Z+17	; 0x11
    3fce:	81 11       	cpse	r24, r1
    3fd0:	c1 c1       	rjmp	.+898    	; 0x4354 <st_prep_buffer+0x1062>
    3fd2:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <sys+0x4>
    3fd6:	83 fd       	sbrc	r24, 3
    3fd8:	cd c1       	rjmp	.+922    	; 0x4374 <st_prep_buffer+0x1082>
    3fda:	14 c0       	rjmp	.+40     	; 0x4004 <st_prep_buffer+0xd12>
          float rpm = pl_block->spindle_speed;
          // NOTE: Feed and rapid overrides are independent of PWM value and do not alter laser power/rate.        
          if (st_prep_block->is_pwm_rate_adjusted) { rpm *= (prep.current_speed * prep.inv_rate); }
          // If current_speed is zero, then may need to be rpm_min*(100/MAX_SPINDLE_SPEED_OVERRIDE)
          // but this would be instantaneous only and during a motion. May not matter at all.
          prep.current_spindle_pwm = spindle_compute_pwm_value(rpm);
    3fdc:	0e 94 d4 10 	call	0x21a8	; 0x21a8 <spindle_compute_pwm_value>
    3fe0:	80 93 89 01 	sts	0x0189, r24	; 0x800189 <prep+0x2f>
    3fe4:	0a c0       	rjmp	.+20     	; 0x3ffa <st_prep_buffer+0xd08>
        } else { 
          sys.spindle_speed = 0.0;
    3fe6:	10 92 89 05 	sts	0x0589, r1	; 0x800589 <sys+0xd>
    3fea:	10 92 8a 05 	sts	0x058A, r1	; 0x80058a <sys+0xe>
    3fee:	10 92 8b 05 	sts	0x058B, r1	; 0x80058b <sys+0xf>
    3ff2:	10 92 8c 05 	sts	0x058C, r1	; 0x80058c <sys+0x10>
          prep.current_spindle_pwm = SPINDLE_PWM_OFF_VALUE;
    3ff6:	10 92 89 01 	sts	0x0189, r1	; 0x800189 <prep+0x2f>
        }
        bit_false(sys.step_control,STEP_CONTROL_UPDATE_SPINDLE_PWM);
    3ffa:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <sys+0x4>
    3ffe:	87 7f       	andi	r24, 0xF7	; 247
    4000:	80 93 80 05 	sts	0x0580, r24	; 0x800580 <sys+0x4>
      }
      prep_segment->spindle_pwm = prep.current_spindle_pwm; // Reload segment PWM value
    4004:	09 a5       	ldd	r16, Y+41	; 0x29
    4006:	1a a5       	ldd	r17, Y+42	; 0x2a
    4008:	00 0f       	add	r16, r16
    400a:	11 1f       	adc	r17, r17
    400c:	00 0f       	add	r16, r16
    400e:	11 1f       	adc	r17, r17
    4010:	00 0f       	add	r16, r16
    4012:	11 1f       	adc	r17, r17
    4014:	49 a5       	ldd	r20, Y+41	; 0x29
    4016:	5a a5       	ldd	r21, Y+42	; 0x2a
    4018:	04 1b       	sub	r16, r20
    401a:	15 0b       	sbc	r17, r21
    401c:	09 54       	subi	r16, 0x49	; 73
    401e:	1e 4f       	sbci	r17, 0xFE	; 254
    4020:	80 91 89 01 	lds	r24, 0x0189	; 0x800189 <prep+0x2f>
    4024:	d8 01       	movw	r26, r16
    4026:	16 96       	adiw	r26, 0x06	; 6
    4028:	8c 93       	st	X, r24
       However, since floats have only 7.2 significant digits, long moves with extremely
       high step counts can exceed the precision of floats, which can lead to lost steps.
       Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
       supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
    */
    float step_dist_remaining = prep.step_per_mm*mm_remaining; // Convert mm_remaining to steps
    402a:	20 91 64 01 	lds	r18, 0x0164	; 0x800164 <prep+0xa>
    402e:	30 91 65 01 	lds	r19, 0x0165	; 0x800165 <prep+0xb>
    4032:	40 91 66 01 	lds	r20, 0x0166	; 0x800166 <prep+0xc>
    4036:	50 91 67 01 	lds	r21, 0x0167	; 0x800167 <prep+0xd>
    403a:	63 2d       	mov	r22, r3
    403c:	72 2d       	mov	r23, r2
    403e:	85 2d       	mov	r24, r5
    4040:	94 2d       	mov	r25, r4
    4042:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    4046:	69 83       	std	Y+1, r22	; 0x01
    4048:	7a 83       	std	Y+2, r23	; 0x02
    404a:	8b 83       	std	Y+3, r24	; 0x03
    404c:	9c 83       	std	Y+4, r25	; 0x04
    float n_steps_remaining = ceil(step_dist_remaining); // Round-up current steps remaining
    404e:	0e 94 3d 2f 	call	0x5e7a	; 0x5e7a <ceil>
    4052:	6d 83       	std	Y+5, r22	; 0x05
    4054:	7e 83       	std	Y+6, r23	; 0x06
    4056:	8f 83       	std	Y+7, r24	; 0x07
    4058:	98 87       	std	Y+8, r25	; 0x08
    float last_n_steps_remaining = ceil(prep.steps_remaining); // Round-up last steps remaining
    405a:	60 91 60 01 	lds	r22, 0x0160	; 0x800160 <prep+0x6>
    405e:	70 91 61 01 	lds	r23, 0x0161	; 0x800161 <prep+0x7>
    4062:	80 91 62 01 	lds	r24, 0x0162	; 0x800162 <prep+0x8>
    4066:	90 91 63 01 	lds	r25, 0x0163	; 0x800163 <prep+0x9>
    406a:	0e 94 3d 2f 	call	0x5e7a	; 0x5e7a <ceil>
    406e:	69 87       	std	Y+9, r22	; 0x09
    4070:	7a 87       	std	Y+10, r23	; 0x0a
    4072:	8b 87       	std	Y+11, r24	; 0x0b
    4074:	9c 87       	std	Y+12, r25	; 0x0c
    prep_segment->n_step = last_n_steps_remaining-n_steps_remaining; // Compute number of steps to execute.
    4076:	2d 81       	ldd	r18, Y+5	; 0x05
    4078:	3e 81       	ldd	r19, Y+6	; 0x06
    407a:	4f 81       	ldd	r20, Y+7	; 0x07
    407c:	58 85       	ldd	r21, Y+8	; 0x08
    407e:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    4082:	0e 94 d7 2f 	call	0x5fae	; 0x5fae <__fixunssfsi>
    4086:	6b 01       	movw	r12, r22
    4088:	7c 01       	movw	r14, r24
    408a:	f8 01       	movw	r30, r16
    408c:	71 83       	std	Z+1, r23	; 0x01
    408e:	60 83       	st	Z, r22

    // Bail if we are at the end of a feed hold and don't have a step to execute.
    if (prep_segment->n_step == 0) {
    4090:	67 2b       	or	r22, r23
    4092:	41 f4       	brne	.+16     	; 0x40a4 <st_prep_buffer+0xdb2>
      if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) {
    4094:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <sys+0x4>
    4098:	81 ff       	sbrs	r24, 1
    409a:	04 c0       	rjmp	.+8      	; 0x40a4 <st_prep_buffer+0xdb2>
        // Less than one step to decelerate to zero speed, but already very close. AMASS
        // requires full steps to execute. So, just bail.
        bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    409c:	81 60       	ori	r24, 0x01	; 1
    409e:	80 93 80 05 	sts	0x0580, r24	; 0x800580 <sys+0x4>
        #ifdef PARKING_ENABLE
          if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
        #endif
        return; // Segment not generated, but current step data still retained.
    40a2:	6e c1       	rjmp	.+732    	; 0x4380 <st_prep_buffer+0x108e>
    // apply it with the partial step distance to the current segment, so that it minutely
    // adjusts the whole segment rate to keep step output exact. These rate adjustments are
    // typically very small and do not adversely effect performance, but ensures that Grbl
    // outputs the exact acceleration and velocity profiles as computed by the planner.
    dt += prep.dt_remainder; // Apply previous segment partial step execute time
    float inv_rate = dt/(last_n_steps_remaining - step_dist_remaining); // Compute adjusted step rate inverse
    40a4:	20 91 5c 01 	lds	r18, 0x015C	; 0x80015c <prep+0x2>
    40a8:	30 91 5d 01 	lds	r19, 0x015D	; 0x80015d <prep+0x3>
    40ac:	40 91 5e 01 	lds	r20, 0x015E	; 0x80015e <prep+0x4>
    40b0:	50 91 5f 01 	lds	r21, 0x015F	; 0x80015f <prep+0x5>
    40b4:	c5 01       	movw	r24, r10
    40b6:	b4 01       	movw	r22, r8
    40b8:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    40bc:	4b 01       	movw	r8, r22
    40be:	5c 01       	movw	r10, r24
    40c0:	29 81       	ldd	r18, Y+1	; 0x01
    40c2:	3a 81       	ldd	r19, Y+2	; 0x02
    40c4:	4b 81       	ldd	r20, Y+3	; 0x03
    40c6:	5c 81       	ldd	r21, Y+4	; 0x04
    40c8:	69 85       	ldd	r22, Y+9	; 0x09
    40ca:	7a 85       	ldd	r23, Y+10	; 0x0a
    40cc:	8b 85       	ldd	r24, Y+11	; 0x0b
    40ce:	9c 85       	ldd	r25, Y+12	; 0x0c
    40d0:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    40d4:	9b 01       	movw	r18, r22
    40d6:	ac 01       	movw	r20, r24
    40d8:	c5 01       	movw	r24, r10
    40da:	b4 01       	movw	r22, r8
    40dc:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <__divsf3>
    40e0:	4b 01       	movw	r8, r22
    40e2:	5c 01       	movw	r10, r24

    // Compute CPU cycles per step for the prepped segment.
    uint32_t cycles = ceil( (TICKS_PER_MICROSECOND*1000000*60)*inv_rate ); // (cycles/step)
    40e4:	20 ec       	ldi	r18, 0xC0	; 192
    40e6:	31 ee       	ldi	r19, 0xE1	; 225
    40e8:	44 e6       	ldi	r20, 0x64	; 100
    40ea:	5e e4       	ldi	r21, 0x4E	; 78
    40ec:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    40f0:	0e 94 3d 2f 	call	0x5e7a	; 0x5e7a <ceil>
    40f4:	0e 94 d7 2f 	call	0x5fae	; 0x5fae <__fixunssfsi>

    #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
      // Compute step timing and multi-axis smoothing level.
      // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.
      if (cycles < AMASS_LEVEL1) { prep_segment->amass_level = 0; }
    40f8:	60 3d       	cpi	r22, 0xD0	; 208
    40fa:	f7 e0       	ldi	r31, 0x07	; 7
    40fc:	7f 07       	cpc	r23, r31
    40fe:	81 05       	cpc	r24, r1
    4100:	91 05       	cpc	r25, r1
    4102:	80 f4       	brcc	.+32     	; 0x4124 <st_prep_buffer+0xe32>
    4104:	e9 a5       	ldd	r30, Y+41	; 0x29
    4106:	fa a5       	ldd	r31, Y+42	; 0x2a
    4108:	ee 0f       	add	r30, r30
    410a:	ff 1f       	adc	r31, r31
    410c:	ee 0f       	add	r30, r30
    410e:	ff 1f       	adc	r31, r31
    4110:	ee 0f       	add	r30, r30
    4112:	ff 1f       	adc	r31, r31
    4114:	29 a5       	ldd	r18, Y+41	; 0x29
    4116:	3a a5       	ldd	r19, Y+42	; 0x2a
    4118:	e2 1b       	sub	r30, r18
    411a:	f3 0b       	sbc	r31, r19
    411c:	e9 54       	subi	r30, 0x49	; 73
    411e:	fe 4f       	sbci	r31, 0xFE	; 254
    4120:	15 82       	std	Z+5, r1	; 0x05
    4122:	5d c0       	rjmp	.+186    	; 0x41de <st_prep_buffer+0xeec>
      else {
        if (cycles < AMASS_LEVEL2) { prep_segment->amass_level = 1; }
    4124:	60 3a       	cpi	r22, 0xA0	; 160
    4126:	3f e0       	ldi	r19, 0x0F	; 15
    4128:	73 07       	cpc	r23, r19
    412a:	81 05       	cpc	r24, r1
    412c:	91 05       	cpc	r25, r1
    412e:	88 f4       	brcc	.+34     	; 0x4152 <st_prep_buffer+0xe60>
    4130:	e9 a5       	ldd	r30, Y+41	; 0x29
    4132:	fa a5       	ldd	r31, Y+42	; 0x2a
    4134:	ee 0f       	add	r30, r30
    4136:	ff 1f       	adc	r31, r31
    4138:	ee 0f       	add	r30, r30
    413a:	ff 1f       	adc	r31, r31
    413c:	ee 0f       	add	r30, r30
    413e:	ff 1f       	adc	r31, r31
    4140:	49 a5       	ldd	r20, Y+41	; 0x29
    4142:	5a a5       	ldd	r21, Y+42	; 0x2a
    4144:	e4 1b       	sub	r30, r20
    4146:	f5 0b       	sbc	r31, r21
    4148:	e9 54       	subi	r30, 0x49	; 73
    414a:	fe 4f       	sbci	r31, 0xFE	; 254
    414c:	51 e0       	ldi	r21, 0x01	; 1
    414e:	55 83       	std	Z+5, r21	; 0x05
    4150:	27 c0       	rjmp	.+78     	; 0x41a0 <st_prep_buffer+0xeae>
        else if (cycles < AMASS_LEVEL3) { prep_segment->amass_level = 2; }
    4152:	60 34       	cpi	r22, 0x40	; 64
    4154:	af e1       	ldi	r26, 0x1F	; 31
    4156:	7a 07       	cpc	r23, r26
    4158:	81 05       	cpc	r24, r1
    415a:	91 05       	cpc	r25, r1
    415c:	88 f4       	brcc	.+34     	; 0x4180 <st_prep_buffer+0xe8e>
    415e:	e9 a5       	ldd	r30, Y+41	; 0x29
    4160:	fa a5       	ldd	r31, Y+42	; 0x2a
    4162:	ee 0f       	add	r30, r30
    4164:	ff 1f       	adc	r31, r31
    4166:	ee 0f       	add	r30, r30
    4168:	ff 1f       	adc	r31, r31
    416a:	ee 0f       	add	r30, r30
    416c:	ff 1f       	adc	r31, r31
    416e:	29 a5       	ldd	r18, Y+41	; 0x29
    4170:	3a a5       	ldd	r19, Y+42	; 0x2a
    4172:	e2 1b       	sub	r30, r18
    4174:	f3 0b       	sbc	r31, r19
    4176:	e9 54       	subi	r30, 0x49	; 73
    4178:	fe 4f       	sbci	r31, 0xFE	; 254
    417a:	32 e0       	ldi	r19, 0x02	; 2
    417c:	35 83       	std	Z+5, r19	; 0x05
    417e:	10 c0       	rjmp	.+32     	; 0x41a0 <st_prep_buffer+0xeae>
        else { prep_segment->amass_level = 3; }
    4180:	e9 a5       	ldd	r30, Y+41	; 0x29
    4182:	fa a5       	ldd	r31, Y+42	; 0x2a
    4184:	ee 0f       	add	r30, r30
    4186:	ff 1f       	adc	r31, r31
    4188:	ee 0f       	add	r30, r30
    418a:	ff 1f       	adc	r31, r31
    418c:	ee 0f       	add	r30, r30
    418e:	ff 1f       	adc	r31, r31
    4190:	49 a5       	ldd	r20, Y+41	; 0x29
    4192:	5a a5       	ldd	r21, Y+42	; 0x2a
    4194:	e4 1b       	sub	r30, r20
    4196:	f5 0b       	sbc	r31, r21
    4198:	e9 54       	subi	r30, 0x49	; 73
    419a:	fe 4f       	sbci	r31, 0xFE	; 254
    419c:	53 e0       	ldi	r21, 0x03	; 3
    419e:	55 83       	std	Z+5, r21	; 0x05
        cycles >>= prep_segment->amass_level;
    41a0:	e9 a5       	ldd	r30, Y+41	; 0x29
    41a2:	fa a5       	ldd	r31, Y+42	; 0x2a
    41a4:	ee 0f       	add	r30, r30
    41a6:	ff 1f       	adc	r31, r31
    41a8:	ee 0f       	add	r30, r30
    41aa:	ff 1f       	adc	r31, r31
    41ac:	ee 0f       	add	r30, r30
    41ae:	ff 1f       	adc	r31, r31
    41b0:	a9 a5       	ldd	r26, Y+41	; 0x29
    41b2:	ba a5       	ldd	r27, Y+42	; 0x2a
    41b4:	ea 1b       	sub	r30, r26
    41b6:	fb 0b       	sbc	r31, r27
    41b8:	e9 54       	subi	r30, 0x49	; 73
    41ba:	fe 4f       	sbci	r31, 0xFE	; 254
    41bc:	25 81       	ldd	r18, Z+5	; 0x05
    41be:	02 2e       	mov	r0, r18
    41c0:	04 c0       	rjmp	.+8      	; 0x41ca <st_prep_buffer+0xed8>
    41c2:	96 95       	lsr	r25
    41c4:	87 95       	ror	r24
    41c6:	77 95       	ror	r23
    41c8:	67 95       	ror	r22
    41ca:	0a 94       	dec	r0
    41cc:	d2 f7       	brpl	.-12     	; 0x41c2 <st_prep_buffer+0xed0>
        prep_segment->n_step <<= prep_segment->amass_level;
    41ce:	a6 01       	movw	r20, r12
    41d0:	02 c0       	rjmp	.+4      	; 0x41d6 <st_prep_buffer+0xee4>
    41d2:	44 0f       	add	r20, r20
    41d4:	55 1f       	adc	r21, r21
    41d6:	2a 95       	dec	r18
    41d8:	e2 f7       	brpl	.-8      	; 0x41d2 <st_prep_buffer+0xee0>
    41da:	51 83       	std	Z+1, r21	; 0x01
    41dc:	40 83       	st	Z, r20
      }
      if (cycles < (1UL << 16)) { prep_segment->cycles_per_tick = cycles; } // < 65536 (4.1ms @ 16MHz)
    41de:	61 15       	cp	r22, r1
    41e0:	71 05       	cpc	r23, r1
    41e2:	51 e0       	ldi	r21, 0x01	; 1
    41e4:	85 07       	cpc	r24, r21
    41e6:	91 05       	cpc	r25, r1
    41e8:	88 f4       	brcc	.+34     	; 0x420c <st_prep_buffer+0xf1a>
    41ea:	e9 a5       	ldd	r30, Y+41	; 0x29
    41ec:	fa a5       	ldd	r31, Y+42	; 0x2a
    41ee:	ee 0f       	add	r30, r30
    41f0:	ff 1f       	adc	r31, r31
    41f2:	ee 0f       	add	r30, r30
    41f4:	ff 1f       	adc	r31, r31
    41f6:	ee 0f       	add	r30, r30
    41f8:	ff 1f       	adc	r31, r31
    41fa:	a9 a5       	ldd	r26, Y+41	; 0x29
    41fc:	ba a5       	ldd	r27, Y+42	; 0x2a
    41fe:	ea 1b       	sub	r30, r26
    4200:	fb 0b       	sbc	r31, r27
    4202:	e9 54       	subi	r30, 0x49	; 73
    4204:	fe 4f       	sbci	r31, 0xFE	; 254
    4206:	73 83       	std	Z+3, r23	; 0x03
    4208:	62 83       	std	Z+2, r22	; 0x02
    420a:	13 c0       	rjmp	.+38     	; 0x4232 <st_prep_buffer+0xf40>
      else { prep_segment->cycles_per_tick = 0xffff; } // Just set the slowest speed possible.
    420c:	89 a5       	ldd	r24, Y+41	; 0x29
    420e:	9a a5       	ldd	r25, Y+42	; 0x2a
    4210:	88 0f       	add	r24, r24
    4212:	99 1f       	adc	r25, r25
    4214:	88 0f       	add	r24, r24
    4216:	99 1f       	adc	r25, r25
    4218:	88 0f       	add	r24, r24
    421a:	99 1f       	adc	r25, r25
    421c:	e9 a5       	ldd	r30, Y+41	; 0x29
    421e:	fa a5       	ldd	r31, Y+42	; 0x2a
    4220:	8e 1b       	sub	r24, r30
    4222:	9f 0b       	sbc	r25, r31
    4224:	fc 01       	movw	r30, r24
    4226:	e9 54       	subi	r30, 0x49	; 73
    4228:	fe 4f       	sbci	r31, 0xFE	; 254
    422a:	2f ef       	ldi	r18, 0xFF	; 255
    422c:	3f ef       	ldi	r19, 0xFF	; 255
    422e:	33 83       	std	Z+3, r19	; 0x03
    4230:	22 83       	std	Z+2, r18	; 0x02
        }
      }
    #endif

    // Segment complete! Increment segment buffer indices, so stepper ISR can immediately execute it.
    segment_buffer_head = segment_next_head;
    4232:	80 91 91 01 	lds	r24, 0x0191	; 0x800191 <segment_next_head>
    4236:	80 93 92 01 	sts	0x0192, r24	; 0x800192 <segment_buffer_head>
    if ( ++segment_next_head == SEGMENT_BUFFER_SIZE ) { segment_next_head = 0; }
    423a:	8f 5f       	subi	r24, 0xFF	; 255
    423c:	86 30       	cpi	r24, 0x06	; 6
    423e:	19 f0       	breq	.+6      	; 0x4246 <st_prep_buffer+0xf54>
    4240:	80 93 91 01 	sts	0x0191, r24	; 0x800191 <segment_next_head>
    4244:	02 c0       	rjmp	.+4      	; 0x424a <st_prep_buffer+0xf58>
    4246:	10 92 91 01 	sts	0x0191, r1	; 0x800191 <segment_next_head>

    // Update the appropriate planner and segment data.
    pl_block->millimeters = mm_remaining;
    424a:	e0 91 8c 01 	lds	r30, 0x018C	; 0x80018c <pl_block>
    424e:	f0 91 8d 01 	lds	r31, 0x018D	; 0x80018d <pl_block+0x1>
    4252:	83 2d       	mov	r24, r3
    4254:	92 2d       	mov	r25, r2
    4256:	a5 2d       	mov	r26, r5
    4258:	b4 2d       	mov	r27, r4
    425a:	86 8f       	std	Z+30, r24	; 0x1e
    425c:	97 8f       	std	Z+31, r25	; 0x1f
    425e:	a0 a3       	std	Z+32, r26	; 0x20
    4260:	b1 a3       	std	Z+33, r27	; 0x21
    prep.steps_remaining = n_steps_remaining;
    4262:	8d 81       	ldd	r24, Y+5	; 0x05
    4264:	9e 81       	ldd	r25, Y+6	; 0x06
    4266:	af 81       	ldd	r26, Y+7	; 0x07
    4268:	b8 85       	ldd	r27, Y+8	; 0x08
    426a:	80 93 60 01 	sts	0x0160, r24	; 0x800160 <prep+0x6>
    426e:	90 93 61 01 	sts	0x0161, r25	; 0x800161 <prep+0x7>
    4272:	a0 93 62 01 	sts	0x0162, r26	; 0x800162 <prep+0x8>
    4276:	b0 93 63 01 	sts	0x0163, r27	; 0x800163 <prep+0x9>
    prep.dt_remainder = (n_steps_remaining - step_dist_remaining)*inv_rate;
    427a:	29 81       	ldd	r18, Y+1	; 0x01
    427c:	3a 81       	ldd	r19, Y+2	; 0x02
    427e:	4b 81       	ldd	r20, Y+3	; 0x03
    4280:	5c 81       	ldd	r21, Y+4	; 0x04
    4282:	bc 01       	movw	r22, r24
    4284:	cd 01       	movw	r24, r26
    4286:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    428a:	a5 01       	movw	r20, r10
    428c:	94 01       	movw	r18, r8
    428e:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    4292:	60 93 5c 01 	sts	0x015C, r22	; 0x80015c <prep+0x2>
    4296:	70 93 5d 01 	sts	0x015D, r23	; 0x80015d <prep+0x3>
    429a:	80 93 5e 01 	sts	0x015E, r24	; 0x80015e <prep+0x4>
    429e:	90 93 5f 01 	sts	0x015F, r25	; 0x80015f <prep+0x5>

    // Check for exit conditions and flag to load next planner block.
    if (mm_remaining == prep.mm_complete) {
    42a2:	20 91 6d 01 	lds	r18, 0x016D	; 0x80016d <prep+0x13>
    42a6:	30 91 6e 01 	lds	r19, 0x016E	; 0x80016e <prep+0x14>
    42aa:	40 91 6f 01 	lds	r20, 0x016F	; 0x80016f <prep+0x15>
    42ae:	50 91 70 01 	lds	r21, 0x0170	; 0x800170 <prep+0x16>
    42b2:	63 2d       	mov	r22, r3
    42b4:	72 2d       	mov	r23, r2
    42b6:	85 2d       	mov	r24, r5
    42b8:	94 2d       	mov	r25, r4
    42ba:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    42be:	81 11       	cpse	r24, r1
    42c0:	23 c0       	rjmp	.+70     	; 0x4308 <st_prep_buffer+0x1016>
    42c2:	75 2c       	mov	r7, r5
    42c4:	53 2c       	mov	r5, r3
      // End of planner block or forced-termination. No more distance to be executed.
      if (mm_remaining > 0.0) { // At end of forced-termination.
    42c6:	20 e0       	ldi	r18, 0x00	; 0
    42c8:	30 e0       	ldi	r19, 0x00	; 0
    42ca:	a9 01       	movw	r20, r18
    42cc:	65 2d       	mov	r22, r5
    42ce:	72 2d       	mov	r23, r2
    42d0:	87 2d       	mov	r24, r7
    42d2:	94 2d       	mov	r25, r4
    42d4:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    42d8:	18 16       	cp	r1, r24
    42da:	34 f4       	brge	.+12     	; 0x42e8 <st_prep_buffer+0xff6>
        // Reset prep parameters for resuming and then bail. Allow the stepper ISR to complete
        // the segment queue, where realtime protocol will set new state upon receiving the
        // cycle stop flag from the ISR. Prep_segment is blocked until then.
        bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    42dc:	ec e7       	ldi	r30, 0x7C	; 124
    42de:	f5 e0       	ldi	r31, 0x05	; 5
    42e0:	84 81       	ldd	r24, Z+4	; 0x04
    42e2:	81 60       	ori	r24, 0x01	; 1
    42e4:	84 83       	std	Z+4, r24	; 0x04
        #ifdef PARKING_ENABLE
          if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
        #endif
        return; // Bail!
    42e6:	4c c0       	rjmp	.+152    	; 0x4380 <st_prep_buffer+0x108e>
      } else { // End of planner block
        // The planner block is complete. All steps are set to be executed in the segment buffer.
        if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
    42e8:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <sys+0x4>
    42ec:	82 ff       	sbrs	r24, 2
    42ee:	04 c0       	rjmp	.+8      	; 0x42f8 <st_prep_buffer+0x1006>
          bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    42f0:	81 60       	ori	r24, 0x01	; 1
    42f2:	80 93 80 05 	sts	0x0580, r24	; 0x800580 <sys+0x4>
          return;
    42f6:	44 c0       	rjmp	.+136    	; 0x4380 <st_prep_buffer+0x108e>
        }
        pl_block = NULL; // Set pointer to indicate check and load next planner block.
    42f8:	10 92 8d 01 	sts	0x018D, r1	; 0x80018d <pl_block+0x1>
    42fc:	10 92 8c 01 	sts	0x018C, r1	; 0x80018c <pl_block>
        plan_discard_current_block();
    4300:	0e 94 1b 25 	call	0x4a36	; 0x4a36 <plan_discard_current_block>
          speed_var = pl_block->acceleration*time_var;
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            prep.ramp_type = RAMP_CRUISE;
    4304:	91 e0       	ldi	r25, 0x01	; 1
    4306:	98 af       	std	Y+56, r25	; 0x38
void st_prep_buffer()
{
  // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }

  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
    4308:	90 91 93 01 	lds	r25, 0x0193	; 0x800193 <segment_buffer_tail>
    430c:	80 91 91 01 	lds	r24, 0x0191	; 0x800191 <segment_next_head>
    4310:	98 13       	cpse	r25, r24
    4312:	13 c8       	rjmp	.-4058   	; 0x333a <st_prep_buffer+0x48>
    4314:	35 c0       	rjmp	.+106    	; 0x4380 <st_prep_buffer+0x108e>
        Compute spindle speed PWM output for step segment
      */
      
      if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
        if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
          float rpm = pl_block->spindle_speed;
    4316:	ab 8d       	ldd	r26, Y+27	; 0x1b
    4318:	bc 8d       	ldd	r27, Y+28	; 0x1c
    431a:	9e 96       	adiw	r26, 0x2e	; 46
    431c:	cd 90       	ld	r12, X+
    431e:	dd 90       	ld	r13, X+
    4320:	ed 90       	ld	r14, X+
    4322:	fc 90       	ld	r15, X
    4324:	d1 97       	sbiw	r26, 0x31	; 49
          // NOTE: Feed and rapid overrides are independent of PWM value and do not alter laser power/rate.        
          if (st_prep_block->is_pwm_rate_adjusted) { rpm *= (prep.current_speed * prep.inv_rate); }
    4326:	20 91 85 01 	lds	r18, 0x0185	; 0x800185 <prep+0x2b>
    432a:	30 91 86 01 	lds	r19, 0x0186	; 0x800186 <prep+0x2c>
    432e:	40 91 87 01 	lds	r20, 0x0187	; 0x800187 <prep+0x2d>
    4332:	50 91 88 01 	lds	r21, 0x0188	; 0x800188 <prep+0x2e>
    4336:	60 91 71 01 	lds	r22, 0x0171	; 0x800171 <prep+0x17>
    433a:	70 91 72 01 	lds	r23, 0x0172	; 0x800172 <prep+0x18>
    433e:	80 91 73 01 	lds	r24, 0x0173	; 0x800173 <prep+0x19>
    4342:	90 91 74 01 	lds	r25, 0x0174	; 0x800174 <prep+0x1a>
    4346:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    434a:	a7 01       	movw	r20, r14
    434c:	96 01       	movw	r18, r12
    434e:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    4352:	44 ce       	rjmp	.-888    	; 0x3fdc <st_prep_buffer+0xcea>
      /* -----------------------------------------------------------------------------------
        Compute spindle speed PWM output for step segment
      */
      
      if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
        if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
    4354:	eb 8d       	ldd	r30, Y+27	; 0x1b
    4356:	fc 8d       	ldd	r31, Y+28	; 0x1c
    4358:	81 89       	ldd	r24, Z+17	; 0x11
    435a:	80 73       	andi	r24, 0x30	; 48
    435c:	09 f4       	brne	.+2      	; 0x4360 <st_prep_buffer+0x106e>
    435e:	43 ce       	rjmp	.-890    	; 0x3fe6 <st_prep_buffer+0xcf4>
    4360:	da cf       	rjmp	.-76     	; 0x4316 <st_prep_buffer+0x1024>
          float rpm = pl_block->spindle_speed;
    4362:	ab 8d       	ldd	r26, Y+27	; 0x1b
    4364:	bc 8d       	ldd	r27, Y+28	; 0x1c
    4366:	9e 96       	adiw	r26, 0x2e	; 46
    4368:	6d 91       	ld	r22, X+
    436a:	7d 91       	ld	r23, X+
    436c:	8d 91       	ld	r24, X+
    436e:	9c 91       	ld	r25, X
    4370:	d1 97       	sbiw	r26, 0x31	; 49
    4372:	34 ce       	rjmp	.-920    	; 0x3fdc <st_prep_buffer+0xcea>
      /* -----------------------------------------------------------------------------------
        Compute spindle speed PWM output for step segment
      */
      
      if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
        if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
    4374:	eb 8d       	ldd	r30, Y+27	; 0x1b
    4376:	fc 8d       	ldd	r31, Y+28	; 0x1c
    4378:	81 89       	ldd	r24, Z+17	; 0x11
    437a:	80 73       	andi	r24, 0x30	; 48
    437c:	91 f7       	brne	.-28     	; 0x4362 <st_prep_buffer+0x1070>
    437e:	33 ce       	rjmp	.-922    	; 0x3fe6 <st_prep_buffer+0xcf4>
        plan_discard_current_block();
      }
    }

  }
}
    4380:	ea 96       	adiw	r28, 0x3a	; 58
    4382:	0f b6       	in	r0, 0x3f	; 63
    4384:	f8 94       	cli
    4386:	de bf       	out	0x3e, r29	; 62
    4388:	0f be       	out	0x3f, r0	; 63
    438a:	cd bf       	out	0x3d, r28	; 61
    438c:	df 91       	pop	r29
    438e:	cf 91       	pop	r28
    4390:	1f 91       	pop	r17
    4392:	0f 91       	pop	r16
    4394:	ff 90       	pop	r15
    4396:	ef 90       	pop	r14
    4398:	df 90       	pop	r13
    439a:	cf 90       	pop	r12
    439c:	bf 90       	pop	r11
    439e:	af 90       	pop	r10
    43a0:	9f 90       	pop	r9
    43a2:	8f 90       	pop	r8
    43a4:	7f 90       	pop	r7
    43a6:	6f 90       	pop	r6
    43a8:	5f 90       	pop	r5
    43aa:	4f 90       	pop	r4
    43ac:	3f 90       	pop	r3
    43ae:	2f 90       	pop	r2
    43b0:	08 95       	ret

000043b2 <eeprom_get_char>:
 *  \param  addr  EEPROM address to read from.
 *  \return  The byte read from the EEPROM address.
 */
unsigned char eeprom_get_char( unsigned int addr )
{
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
    43b2:	f9 99       	sbic	0x1f, 1	; 31
    43b4:	fe cf       	rjmp	.-4      	; 0x43b2 <eeprom_get_char>
	EEAR = addr; // Set EEPROM address register.
    43b6:	92 bd       	out	0x22, r25	; 34
    43b8:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
    43ba:	81 e0       	ldi	r24, 0x01	; 1
    43bc:	8f bb       	out	0x1f, r24	; 31
	return EEDR; // Return the byte read from EEPROM.
    43be:	80 b5       	in	r24, 0x20	; 32
}
    43c0:	08 95       	ret

000043c2 <eeprom_put_char>:
void eeprom_put_char( unsigned int addr, unsigned char new_value )
{
	char old_value; // Old EEPROM value.
	char diff_mask; // Difference mask, i.e. old value XOR new value.

	cli(); // Ensure atomic operation for the write operation.
    43c2:	f8 94       	cli
	
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
    43c4:	f9 99       	sbic	0x1f, 1	; 31
    43c6:	fe cf       	rjmp	.-4      	; 0x43c4 <eeprom_put_char+0x2>
	#ifndef EEPROM_IGNORE_SELFPROG
	do {} while( SPMCSR & (1<<SELFPRGEN) ); // Wait for completion of SPM.
	#endif
	
	EEAR = addr; // Set EEPROM address register.
    43c8:	92 bd       	out	0x22, r25	; 34
    43ca:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
    43cc:	81 e0       	ldi	r24, 0x01	; 1
    43ce:	8f bb       	out	0x1f, r24	; 31
	old_value = EEDR; // Get old EEPROM value.
    43d0:	80 b5       	in	r24, 0x20	; 32
	diff_mask = old_value ^ new_value; // Get bit differences.
    43d2:	86 27       	eor	r24, r22
	
	// Check if any bits are changed to '1' in the new value.
	if( diff_mask & new_value ) {
    43d4:	96 2f       	mov	r25, r22
    43d6:	98 23       	and	r25, r24
    43d8:	59 f0       	breq	.+22     	; 0x43f0 <eeprom_put_char+0x2e>
		// Now we know that _some_ bits need to be erased to '1'.
		
		// Check if any bits in the new value are '0'.
		if( new_value != 0xff ) {
    43da:	6f 3f       	cpi	r22, 0xFF	; 255
    43dc:	29 f0       	breq	.+10     	; 0x43e8 <eeprom_put_char+0x26>
			// Now we know that some bits need to be programmed to '0' also.
			
			EEDR = new_value; // Set EEPROM data register.
    43de:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    43e0:	84 e0       	ldi	r24, 0x04	; 4
    43e2:	8f bb       	out	0x1f, r24	; 31
			       (0<<EEPM1) | (0<<EEPM0); // ...and Erase+Write mode.
			EECR |= (1<<EEPE);  // Start Erase+Write operation.
    43e4:	f9 9a       	sbi	0x1f, 1	; 31
    43e6:	0a c0       	rjmp	.+20     	; 0x43fc <eeprom_put_char+0x3a>
		} else {
			// Now we know that all bits should be erased.

			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    43e8:	84 e1       	ldi	r24, 0x14	; 20
    43ea:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM0);  // ...and Erase-only mode.
			EECR |= (1<<EEPE);  // Start Erase-only operation.
    43ec:	f9 9a       	sbi	0x1f, 1	; 31
    43ee:	06 c0       	rjmp	.+12     	; 0x43fc <eeprom_put_char+0x3a>
		}
	} else {
		// Now we know that _no_ bits need to be erased to '1'.
		
		// Check if any bits are changed from '1' in the old value.
		if( diff_mask ) {
    43f0:	88 23       	and	r24, r24
    43f2:	21 f0       	breq	.+8      	; 0x43fc <eeprom_put_char+0x3a>
			// Now we know that _some_ bits need to the programmed to '0'.
			
			EEDR = new_value;   // Set EEPROM data register.
    43f4:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    43f6:	84 e2       	ldi	r24, 0x24	; 36
    43f8:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM1);  // ...and Write-only mode.
			EECR |= (1<<EEPE);  // Start Write-only operation.
    43fa:	f9 9a       	sbi	0x1f, 1	; 31
		}
	}
	
	sei(); // Restore interrupt flag state.
    43fc:	78 94       	sei
    43fe:	08 95       	ret

00004400 <memcpy_to_eeprom_with_checksum>:
}

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
    4400:	8f 92       	push	r8
    4402:	9f 92       	push	r9
    4404:	af 92       	push	r10
    4406:	bf 92       	push	r11
    4408:	cf 92       	push	r12
    440a:	df 92       	push	r13
    440c:	ef 92       	push	r14
    440e:	ff 92       	push	r15
    4410:	0f 93       	push	r16
    4412:	1f 93       	push	r17
    4414:	cf 93       	push	r28
    4416:	df 93       	push	r29
    4418:	7c 01       	movw	r14, r24
    441a:	8b 01       	movw	r16, r22
    441c:	6a 01       	movw	r12, r20
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    441e:	41 15       	cp	r20, r1
    4420:	51 05       	cpc	r21, r1
    4422:	09 f1       	breq	.+66     	; 0x4466 <memcpy_to_eeprom_with_checksum+0x66>
    4424:	5a 01       	movw	r10, r20
    4426:	c0 e0       	ldi	r28, 0x00	; 0
    checksum = (checksum << 1) || (checksum >> 7);
    4428:	d1 e0       	ldi	r29, 0x01	; 1
    442a:	01 c0       	rjmp	.+2      	; 0x442e <memcpy_to_eeprom_with_checksum+0x2e>
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
    442c:	c4 01       	movw	r24, r8


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
    442e:	c1 11       	cpse	r28, r1
    4430:	08 c0       	rjmp	.+16     	; 0x4442 <memcpy_to_eeprom_with_checksum+0x42>
    4432:	6c 2f       	mov	r22, r28
    4434:	cc 0f       	add	r28, r28
    4436:	77 0b       	sbc	r23, r23
    4438:	c7 2f       	mov	r28, r23
    443a:	cc 1f       	adc	r28, r28
    443c:	cc 27       	eor	r28, r28
    443e:	cc 1f       	adc	r28, r28
    4440:	01 c0       	rjmp	.+2      	; 0x4444 <memcpy_to_eeprom_with_checksum+0x44>
    4442:	cd 2f       	mov	r28, r29
    checksum += *source;
    4444:	f8 01       	movw	r30, r16
    4446:	61 91       	ld	r22, Z+
    4448:	8f 01       	movw	r16, r30
    444a:	c6 0f       	add	r28, r22
    eeprom_put_char(destination++, *(source++)); 
    444c:	4c 01       	movw	r8, r24
    444e:	ff ef       	ldi	r31, 0xFF	; 255
    4450:	8f 1a       	sub	r8, r31
    4452:	9f 0a       	sbc	r9, r31
    4454:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <eeprom_put_char>
// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    4458:	21 e0       	ldi	r18, 0x01	; 1
    445a:	a2 1a       	sub	r10, r18
    445c:	b1 08       	sbc	r11, r1
    445e:	31 f7       	brne	.-52     	; 0x442c <memcpy_to_eeprom_with_checksum+0x2c>
    4460:	ec 0c       	add	r14, r12
    4462:	fd 1c       	adc	r15, r13
    4464:	01 c0       	rjmp	.+2      	; 0x4468 <memcpy_to_eeprom_with_checksum+0x68>

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
    4466:	c0 e0       	ldi	r28, 0x00	; 0
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
  }
  eeprom_put_char(destination, checksum);
    4468:	6c 2f       	mov	r22, r28
    446a:	c7 01       	movw	r24, r14
    446c:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <eeprom_put_char>
}
    4470:	df 91       	pop	r29
    4472:	cf 91       	pop	r28
    4474:	1f 91       	pop	r17
    4476:	0f 91       	pop	r16
    4478:	ff 90       	pop	r15
    447a:	ef 90       	pop	r14
    447c:	df 90       	pop	r13
    447e:	cf 90       	pop	r12
    4480:	bf 90       	pop	r11
    4482:	af 90       	pop	r10
    4484:	9f 90       	pop	r9
    4486:	8f 90       	pop	r8
    4488:	08 95       	ret

0000448a <memcpy_from_eeprom_with_checksum>:

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
    448a:	8f 92       	push	r8
    448c:	9f 92       	push	r9
    448e:	af 92       	push	r10
    4490:	bf 92       	push	r11
    4492:	cf 92       	push	r12
    4494:	df 92       	push	r13
    4496:	ef 92       	push	r14
    4498:	ff 92       	push	r15
    449a:	0f 93       	push	r16
    449c:	1f 93       	push	r17
    449e:	cf 93       	push	r28
    44a0:	df 93       	push	r29
    44a2:	7b 01       	movw	r14, r22
    44a4:	6a 01       	movw	r12, r20
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    44a6:	41 15       	cp	r20, r1
    44a8:	51 05       	cpc	r21, r1
    44aa:	11 f1       	breq	.+68     	; 0x44f0 <memcpy_from_eeprom_with_checksum+0x66>
    44ac:	c8 2f       	mov	r28, r24
    44ae:	d9 2f       	mov	r29, r25
    44b0:	5a 01       	movw	r10, r20
    44b2:	cb 01       	movw	r24, r22
    44b4:	91 2c       	mov	r9, r1
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    44b6:	88 24       	eor	r8, r8
    44b8:	83 94       	inc	r8
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    data = eeprom_get_char(source++);
    44ba:	8c 01       	movw	r16, r24
    44bc:	0f 5f       	subi	r16, 0xFF	; 255
    44be:	1f 4f       	sbci	r17, 0xFF	; 255
    44c0:	0e 94 d9 21 	call	0x43b2	; 0x43b2 <eeprom_get_char>
    checksum = (checksum << 1) || (checksum >> 7);
    44c4:	91 10       	cpse	r9, r1
    44c6:	08 c0       	rjmp	.+16     	; 0x44d8 <memcpy_from_eeprom_with_checksum+0x4e>
    44c8:	29 2d       	mov	r18, r9
    44ca:	99 0c       	add	r9, r9
    44cc:	33 0b       	sbc	r19, r19
    44ce:	23 2f       	mov	r18, r19
    44d0:	22 1f       	adc	r18, r18
    44d2:	22 27       	eor	r18, r18
    44d4:	22 1f       	adc	r18, r18
    44d6:	01 c0       	rjmp	.+2      	; 0x44da <memcpy_from_eeprom_with_checksum+0x50>
    44d8:	28 2d       	mov	r18, r8
    checksum += data;    
    44da:	98 2e       	mov	r9, r24
    44dc:	92 0e       	add	r9, r18
    *(destination++) = data; 
    44de:	89 93       	st	Y+, r24
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    44e0:	81 e0       	ldi	r24, 0x01	; 1
    44e2:	a8 1a       	sub	r10, r24
    44e4:	b1 08       	sbc	r11, r1
    data = eeprom_get_char(source++);
    44e6:	c8 01       	movw	r24, r16
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    44e8:	41 f7       	brne	.-48     	; 0x44ba <memcpy_from_eeprom_with_checksum+0x30>
    44ea:	ec 0c       	add	r14, r12
    44ec:	fd 1c       	adc	r15, r13
    44ee:	01 c0       	rjmp	.+2      	; 0x44f2 <memcpy_from_eeprom_with_checksum+0x68>
  }
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
    44f0:	91 2c       	mov	r9, r1
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += data;    
    *(destination++) = data; 
  }
  return(checksum == eeprom_get_char(source));
    44f2:	c7 01       	movw	r24, r14
    44f4:	0e 94 d9 21 	call	0x43b2	; 0x43b2 <eeprom_get_char>
    44f8:	21 e0       	ldi	r18, 0x01	; 1
    44fa:	30 e0       	ldi	r19, 0x00	; 0
    44fc:	89 15       	cp	r24, r9
    44fe:	11 f0       	breq	.+4      	; 0x4504 <memcpy_from_eeprom_with_checksum+0x7a>
    4500:	20 e0       	ldi	r18, 0x00	; 0
    4502:	30 e0       	ldi	r19, 0x00	; 0
}
    4504:	c9 01       	movw	r24, r18
    4506:	df 91       	pop	r29
    4508:	cf 91       	pop	r28
    450a:	1f 91       	pop	r17
    450c:	0f 91       	pop	r16
    450e:	ff 90       	pop	r15
    4510:	ef 90       	pop	r14
    4512:	df 90       	pop	r13
    4514:	cf 90       	pop	r12
    4516:	bf 90       	pop	r11
    4518:	af 90       	pop	r10
    451a:	9f 90       	pop	r9
    451c:	8f 90       	pop	r8
    451e:	08 95       	ret

00004520 <settings_store_startup_line>:
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
  return(STATUS_OK);
}
    4520:	0f 93       	push	r16
    4522:	1f 93       	push	r17
    4524:	cf 93       	push	r28
    4526:	c8 2f       	mov	r28, r24
    4528:	8b 01       	movw	r16, r22
    452a:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <protocol_buffer_synchronize>
    452e:	21 e5       	ldi	r18, 0x51	; 81
    4530:	c2 9f       	mul	r28, r18
    4532:	c0 01       	movw	r24, r0
    4534:	11 24       	eor	r1, r1
    4536:	40 e5       	ldi	r20, 0x50	; 80
    4538:	50 e0       	ldi	r21, 0x00	; 0
    453a:	b8 01       	movw	r22, r16
    453c:	9d 5f       	subi	r25, 0xFD	; 253
    453e:	0e 94 00 22 	call	0x4400	; 0x4400 <memcpy_to_eeprom_with_checksum>
    4542:	cf 91       	pop	r28
    4544:	1f 91       	pop	r17
    4546:	0f 91       	pop	r16
    4548:	08 95       	ret

0000454a <settings_write_coord_data>:
    454a:	0f 93       	push	r16
    454c:	1f 93       	push	r17
    454e:	cf 93       	push	r28
    4550:	c8 2f       	mov	r28, r24
    4552:	8b 01       	movw	r16, r22
    4554:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <protocol_buffer_synchronize>
    4558:	2d e0       	ldi	r18, 0x0D	; 13
    455a:	c2 9f       	mul	r28, r18
    455c:	c0 01       	movw	r24, r0
    455e:	11 24       	eor	r1, r1
    4560:	4c e0       	ldi	r20, 0x0C	; 12
    4562:	50 e0       	ldi	r21, 0x00	; 0
    4564:	b8 01       	movw	r22, r16
    4566:	9e 5f       	subi	r25, 0xFE	; 254
    4568:	0e 94 00 22 	call	0x4400	; 0x4400 <memcpy_to_eeprom_with_checksum>
    456c:	cf 91       	pop	r28
    456e:	1f 91       	pop	r17
    4570:	0f 91       	pop	r16
    4572:	08 95       	ret

00004574 <write_global_settings>:
    4574:	6a e0       	ldi	r22, 0x0A	; 10
    4576:	80 e0       	ldi	r24, 0x00	; 0
    4578:	90 e0       	ldi	r25, 0x00	; 0
    457a:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <eeprom_put_char>
    457e:	45 e5       	ldi	r20, 0x55	; 85
    4580:	50 e0       	ldi	r21, 0x00	; 0
    4582:	6e e0       	ldi	r22, 0x0E	; 14
    4584:	77 e0       	ldi	r23, 0x07	; 7
    4586:	81 e0       	ldi	r24, 0x01	; 1
    4588:	90 e0       	ldi	r25, 0x00	; 0
    458a:	0e 94 00 22 	call	0x4400	; 0x4400 <memcpy_to_eeprom_with_checksum>
    458e:	08 95       	ret

00004590 <settings_restore>:
    4590:	0f 93       	push	r16
    4592:	1f 93       	push	r17
    4594:	cf 93       	push	r28
    4596:	df 93       	push	r29
    4598:	cd b7       	in	r28, 0x3d	; 61
    459a:	de b7       	in	r29, 0x3e	; 62
    459c:	2c 97       	sbiw	r28, 0x0c	; 12
    459e:	0f b6       	in	r0, 0x3f	; 63
    45a0:	f8 94       	cli
    45a2:	de bf       	out	0x3e, r29	; 62
    45a4:	0f be       	out	0x3f, r0	; 63
    45a6:	cd bf       	out	0x3d, r28	; 61
    45a8:	08 2f       	mov	r16, r24
    45aa:	80 ff       	sbrs	r24, 0
    45ac:	0b c0       	rjmp	.+22     	; 0x45c4 <settings_restore+0x34>
    45ae:	85 e5       	ldi	r24, 0x55	; 85
    45b0:	e4 e1       	ldi	r30, 0x14	; 20
    45b2:	f2 e0       	ldi	r31, 0x02	; 2
    45b4:	ae e0       	ldi	r26, 0x0E	; 14
    45b6:	b7 e0       	ldi	r27, 0x07	; 7
    45b8:	05 90       	lpm	r0, Z+
    45ba:	0d 92       	st	X+, r0
    45bc:	8a 95       	dec	r24
    45be:	e1 f7       	brne	.-8      	; 0x45b8 <settings_restore+0x28>
    45c0:	0e 94 ba 22 	call	0x4574	; 0x4574 <write_global_settings>
    45c4:	01 ff       	sbrs	r16, 1
    45c6:	11 c0       	rjmp	.+34     	; 0x45ea <settings_restore+0x5a>
    45c8:	fe 01       	movw	r30, r28
    45ca:	31 96       	adiw	r30, 0x01	; 1
    45cc:	8c e0       	ldi	r24, 0x0C	; 12
    45ce:	df 01       	movw	r26, r30
    45d0:	1d 92       	st	X+, r1
    45d2:	8a 95       	dec	r24
    45d4:	e9 f7       	brne	.-6      	; 0x45d0 <settings_restore+0x40>
    45d6:	10 e0       	ldi	r17, 0x00	; 0
    45d8:	be 01       	movw	r22, r28
    45da:	6f 5f       	subi	r22, 0xFF	; 255
    45dc:	7f 4f       	sbci	r23, 0xFF	; 255
    45de:	81 2f       	mov	r24, r17
    45e0:	0e 94 a5 22 	call	0x454a	; 0x454a <settings_write_coord_data>
    45e4:	1f 5f       	subi	r17, 0xFF	; 255
    45e6:	18 30       	cpi	r17, 0x08	; 8
    45e8:	b9 f7       	brne	.-18     	; 0x45d8 <settings_restore+0x48>
    45ea:	02 ff       	sbrs	r16, 2
    45ec:	14 c0       	rjmp	.+40     	; 0x4616 <settings_restore+0x86>
    45ee:	60 e0       	ldi	r22, 0x00	; 0
    45f0:	80 e0       	ldi	r24, 0x00	; 0
    45f2:	93 e0       	ldi	r25, 0x03	; 3
    45f4:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <eeprom_put_char>
    45f8:	60 e0       	ldi	r22, 0x00	; 0
    45fa:	81 e0       	ldi	r24, 0x01	; 1
    45fc:	93 e0       	ldi	r25, 0x03	; 3
    45fe:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <eeprom_put_char>
    4602:	60 e0       	ldi	r22, 0x00	; 0
    4604:	81 e5       	ldi	r24, 0x51	; 81
    4606:	93 e0       	ldi	r25, 0x03	; 3
    4608:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <eeprom_put_char>
    460c:	60 e0       	ldi	r22, 0x00	; 0
    460e:	82 e5       	ldi	r24, 0x52	; 82
    4610:	93 e0       	ldi	r25, 0x03	; 3
    4612:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <eeprom_put_char>
    4616:	03 ff       	sbrs	r16, 3
    4618:	0a c0       	rjmp	.+20     	; 0x462e <settings_restore+0x9e>
    461a:	60 e0       	ldi	r22, 0x00	; 0
    461c:	8e ea       	ldi	r24, 0xAE	; 174
    461e:	93 e0       	ldi	r25, 0x03	; 3
    4620:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <eeprom_put_char>
    4624:	60 e0       	ldi	r22, 0x00	; 0
    4626:	8f ea       	ldi	r24, 0xAF	; 175
    4628:	93 e0       	ldi	r25, 0x03	; 3
    462a:	0e 94 e1 21 	call	0x43c2	; 0x43c2 <eeprom_put_char>
    462e:	2c 96       	adiw	r28, 0x0c	; 12
    4630:	0f b6       	in	r0, 0x3f	; 63
    4632:	f8 94       	cli
    4634:	de bf       	out	0x3e, r29	; 62
    4636:	0f be       	out	0x3f, r0	; 63
    4638:	cd bf       	out	0x3d, r28	; 61
    463a:	df 91       	pop	r29
    463c:	cf 91       	pop	r28
    463e:	1f 91       	pop	r17
    4640:	0f 91       	pop	r16
    4642:	08 95       	ret

00004644 <settings_read_startup_line>:
    4644:	1f 93       	push	r17
    4646:	cf 93       	push	r28
    4648:	df 93       	push	r29
    464a:	18 2f       	mov	r17, r24
    464c:	eb 01       	movw	r28, r22
    464e:	81 e5       	ldi	r24, 0x51	; 81
    4650:	18 9f       	mul	r17, r24
    4652:	b0 01       	movw	r22, r0
    4654:	11 24       	eor	r1, r1
    4656:	7d 5f       	subi	r23, 0xFD	; 253
    4658:	40 e5       	ldi	r20, 0x50	; 80
    465a:	50 e0       	ldi	r21, 0x00	; 0
    465c:	ce 01       	movw	r24, r28
    465e:	0e 94 45 22 	call	0x448a	; 0x448a <memcpy_from_eeprom_with_checksum>
    4662:	89 2b       	or	r24, r25
    4664:	39 f4       	brne	.+14     	; 0x4674 <settings_read_startup_line+0x30>
    4666:	18 82       	st	Y, r1
    4668:	be 01       	movw	r22, r28
    466a:	81 2f       	mov	r24, r17
    466c:	0e 94 90 22 	call	0x4520	; 0x4520 <settings_store_startup_line>
    4670:	80 e0       	ldi	r24, 0x00	; 0
    4672:	01 c0       	rjmp	.+2      	; 0x4676 <settings_read_startup_line+0x32>
    4674:	81 e0       	ldi	r24, 0x01	; 1
    4676:	df 91       	pop	r29
    4678:	cf 91       	pop	r28
    467a:	1f 91       	pop	r17
    467c:	08 95       	ret

0000467e <settings_read_coord_data>:
    467e:	1f 93       	push	r17
    4680:	cf 93       	push	r28
    4682:	df 93       	push	r29
    4684:	18 2f       	mov	r17, r24
    4686:	eb 01       	movw	r28, r22
    4688:	8d e0       	ldi	r24, 0x0D	; 13
    468a:	18 9f       	mul	r17, r24
    468c:	b0 01       	movw	r22, r0
    468e:	11 24       	eor	r1, r1
    4690:	7e 5f       	subi	r23, 0xFE	; 254
    4692:	4c e0       	ldi	r20, 0x0C	; 12
    4694:	50 e0       	ldi	r21, 0x00	; 0
    4696:	ce 01       	movw	r24, r28
    4698:	0e 94 45 22 	call	0x448a	; 0x448a <memcpy_from_eeprom_with_checksum>
    469c:	89 2b       	or	r24, r25
    469e:	59 f4       	brne	.+22     	; 0x46b6 <settings_read_coord_data+0x38>
    46a0:	8c e0       	ldi	r24, 0x0C	; 12
    46a2:	fe 01       	movw	r30, r28
    46a4:	11 92       	st	Z+, r1
    46a6:	8a 95       	dec	r24
    46a8:	e9 f7       	brne	.-6      	; 0x46a4 <settings_read_coord_data+0x26>
    46aa:	be 01       	movw	r22, r28
    46ac:	81 2f       	mov	r24, r17
    46ae:	0e 94 a5 22 	call	0x454a	; 0x454a <settings_write_coord_data>
    46b2:	80 e0       	ldi	r24, 0x00	; 0
    46b4:	01 c0       	rjmp	.+2      	; 0x46b8 <settings_read_coord_data+0x3a>
    46b6:	81 e0       	ldi	r24, 0x01	; 1
    46b8:	df 91       	pop	r29
    46ba:	cf 91       	pop	r28
    46bc:	1f 91       	pop	r17
    46be:	08 95       	ret

000046c0 <read_global_settings>:
    46c0:	80 e0       	ldi	r24, 0x00	; 0
    46c2:	90 e0       	ldi	r25, 0x00	; 0
    46c4:	0e 94 d9 21 	call	0x43b2	; 0x43b2 <eeprom_get_char>
    46c8:	8a 30       	cpi	r24, 0x0A	; 10
    46ca:	69 f4       	brne	.+26     	; 0x46e6 <read_global_settings+0x26>
    46cc:	45 e5       	ldi	r20, 0x55	; 85
    46ce:	50 e0       	ldi	r21, 0x00	; 0
    46d0:	61 e0       	ldi	r22, 0x01	; 1
    46d2:	70 e0       	ldi	r23, 0x00	; 0
    46d4:	8e e0       	ldi	r24, 0x0E	; 14
    46d6:	97 e0       	ldi	r25, 0x07	; 7
    46d8:	0e 94 45 22 	call	0x448a	; 0x448a <memcpy_from_eeprom_with_checksum>
    46dc:	21 e0       	ldi	r18, 0x01	; 1
    46de:	89 2b       	or	r24, r25
    46e0:	19 f4       	brne	.+6      	; 0x46e8 <read_global_settings+0x28>
    46e2:	20 e0       	ldi	r18, 0x00	; 0
    46e4:	01 c0       	rjmp	.+2      	; 0x46e8 <read_global_settings+0x28>
    46e6:	20 e0       	ldi	r18, 0x00	; 0
    46e8:	82 2f       	mov	r24, r18
    46ea:	08 95       	ret

000046ec <settings_init>:


// Initialize the config subsystem
void settings_init() {
  if(!read_global_settings()) {
    46ec:	0e 94 60 23 	call	0x46c0	; 0x46c0 <read_global_settings>
    46f0:	81 11       	cpse	r24, r1
    46f2:	08 c0       	rjmp	.+16     	; 0x4704 <settings_init+0x18>
    report_status_message(STATUS_SETTING_READ_FAIL);
    46f4:	87 e0       	ldi	r24, 0x07	; 7
    46f6:	0e 94 ee 2c 	call	0x59dc	; 0x59dc <report_status_message>
    settings_restore(SETTINGS_RESTORE_ALL); // Force restore all EEPROM data.
    46fa:	8f ef       	ldi	r24, 0xFF	; 255
    46fc:	0e 94 c8 22 	call	0x4590	; 0x4590 <settings_restore>
    report_grbl_settings();
    4700:	0e 94 f2 2c 	call	0x59e4	; 0x59e4 <report_grbl_settings>
    4704:	08 95       	ret

00004706 <get_step_pin_mask>:


// Returns step pin mask according to Grbl internal axis indexing.
uint8_t get_step_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    4706:	88 23       	and	r24, r24
    4708:	21 f0       	breq	.+8      	; 0x4712 <get_step_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
    470a:	81 30       	cpi	r24, 0x01	; 1
    470c:	21 f0       	breq	.+8      	; 0x4716 <get_step_pin_mask+0x10>
  return((1<<Z_STEP_BIT));
    470e:	80 e1       	ldi	r24, 0x10	; 16
    4710:	08 95       	ret


// Returns step pin mask according to Grbl internal axis indexing.
uint8_t get_step_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    4712:	84 e0       	ldi	r24, 0x04	; 4
    4714:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
    4716:	88 e0       	ldi	r24, 0x08	; 8
  return((1<<Z_STEP_BIT));
}
    4718:	08 95       	ret

0000471a <get_direction_pin_mask>:


// Returns direction pin mask according to Grbl internal axis indexing.
uint8_t get_direction_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    471a:	88 23       	and	r24, r24
    471c:	21 f0       	breq	.+8      	; 0x4726 <get_direction_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
    471e:	81 30       	cpi	r24, 0x01	; 1
    4720:	21 f0       	breq	.+8      	; 0x472a <get_direction_pin_mask+0x10>
  return((1<<Z_DIRECTION_BIT));
    4722:	80 e8       	ldi	r24, 0x80	; 128
    4724:	08 95       	ret


// Returns direction pin mask according to Grbl internal axis indexing.
uint8_t get_direction_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    4726:	80 e2       	ldi	r24, 0x20	; 32
    4728:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
    472a:	80 e4       	ldi	r24, 0x40	; 64
  return((1<<Z_DIRECTION_BIT));
}
    472c:	08 95       	ret

0000472e <get_limit_pin_mask>:


// Returns limit pin mask according to Grbl internal axis indexing.
uint8_t get_limit_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    472e:	88 23       	and	r24, r24
    4730:	21 f0       	breq	.+8      	; 0x473a <get_limit_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
    4732:	81 30       	cpi	r24, 0x01	; 1
    4734:	21 f0       	breq	.+8      	; 0x473e <get_limit_pin_mask+0x10>
  return((1<<Z_LIMIT_BIT));
    4736:	80 e1       	ldi	r24, 0x10	; 16
    4738:	08 95       	ret


// Returns limit pin mask according to Grbl internal axis indexing.
uint8_t get_limit_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    473a:	82 e0       	ldi	r24, 0x02	; 2
    473c:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
    473e:	84 e0       	ldi	r24, 0x04	; 4
  return((1<<Z_LIMIT_BIT));
}
    4740:	08 95       	ret

00004742 <planner_recalculate>:
// NOTE: Deprecated. Not used unless classic status reports are enabled in config.h
uint8_t plan_get_block_buffer_count()
{
  if (block_buffer_head >= block_buffer_tail) { return(block_buffer_head-block_buffer_tail); }
  return(BLOCK_BUFFER_SIZE - (block_buffer_tail-block_buffer_head));
}
    4742:	2f 92       	push	r2
    4744:	3f 92       	push	r3
    4746:	4f 92       	push	r4
    4748:	5f 92       	push	r5
    474a:	6f 92       	push	r6
    474c:	7f 92       	push	r7
    474e:	8f 92       	push	r8
    4750:	9f 92       	push	r9
    4752:	af 92       	push	r10
    4754:	bf 92       	push	r11
    4756:	cf 92       	push	r12
    4758:	df 92       	push	r13
    475a:	ef 92       	push	r14
    475c:	ff 92       	push	r15
    475e:	0f 93       	push	r16
    4760:	1f 93       	push	r17
    4762:	cf 93       	push	r28
    4764:	df 93       	push	r29
    4766:	c0 91 59 02 	lds	r28, 0x0259	; 0x800259 <block_buffer_head>
    476a:	c1 11       	cpse	r28, r1
    476c:	01 c0       	rjmp	.+2      	; 0x4770 <planner_recalculate+0x2e>
    476e:	c0 e1       	ldi	r28, 0x10	; 16
    4770:	c1 50       	subi	r28, 0x01	; 1
    4772:	d0 91 57 02 	lds	r29, 0x0257	; 0x800257 <block_buffer_planned>
    4776:	dc 17       	cp	r29, r28
    4778:	09 f4       	brne	.+2      	; 0x477c <planner_recalculate+0x3a>
    477a:	36 c1       	rjmp	.+620    	; 0x49e8 <planner_recalculate+0x2a6>
    477c:	0c 2f       	mov	r16, r28
    477e:	10 e0       	ldi	r17, 0x00	; 0
    4780:	22 e3       	ldi	r18, 0x32	; 50
    4782:	c2 9f       	mul	r28, r18
    4784:	c0 01       	movw	r24, r0
    4786:	11 24       	eor	r1, r1
    4788:	fc 01       	movw	r30, r24
    478a:	e5 5a       	subi	r30, 0xA5	; 165
    478c:	fd 4f       	sbci	r31, 0xFD	; 253
    478e:	6f 01       	movw	r12, r30
    4790:	e6 88       	ldd	r14, Z+22	; 0x16
    4792:	f7 88       	ldd	r15, Z+23	; 0x17
    4794:	90 8c       	ldd	r9, Z+24	; 0x18
    4796:	81 8c       	ldd	r8, Z+25	; 0x19
    4798:	62 8d       	ldd	r22, Z+26	; 0x1a
    479a:	73 8d       	ldd	r23, Z+27	; 0x1b
    479c:	84 8d       	ldd	r24, Z+28	; 0x1c
    479e:	95 8d       	ldd	r25, Z+29	; 0x1d
    47a0:	9b 01       	movw	r18, r22
    47a2:	ac 01       	movw	r20, r24
    47a4:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    47a8:	f6 01       	movw	r30, r12
    47aa:	26 8d       	ldd	r18, Z+30	; 0x1e
    47ac:	37 8d       	ldd	r19, Z+31	; 0x1f
    47ae:	40 a1       	ldd	r20, Z+32	; 0x20
    47b0:	51 a1       	ldd	r21, Z+33	; 0x21
    47b2:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    47b6:	a6 2e       	mov	r10, r22
    47b8:	b7 2e       	mov	r11, r23
    47ba:	c8 2e       	mov	r12, r24
    47bc:	d9 2e       	mov	r13, r25
    47be:	26 2f       	mov	r18, r22
    47c0:	37 2f       	mov	r19, r23
    47c2:	48 2f       	mov	r20, r24
    47c4:	59 2f       	mov	r21, r25
    47c6:	6e 2d       	mov	r22, r14
    47c8:	7f 2d       	mov	r23, r15
    47ca:	89 2d       	mov	r24, r9
    47cc:	98 2d       	mov	r25, r8
    47ce:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    47d2:	88 23       	and	r24, r24
    47d4:	24 f0       	brlt	.+8      	; 0x47de <planner_recalculate+0x9c>
    47d6:	ea 2c       	mov	r14, r10
    47d8:	fb 2c       	mov	r15, r11
    47da:	9c 2c       	mov	r9, r12
    47dc:	8d 2c       	mov	r8, r13
    47de:	82 e3       	ldi	r24, 0x32	; 50
    47e0:	80 9f       	mul	r24, r16
    47e2:	f0 01       	movw	r30, r0
    47e4:	81 9f       	mul	r24, r17
    47e6:	f0 0d       	add	r31, r0
    47e8:	11 24       	eor	r1, r1
    47ea:	e5 5a       	subi	r30, 0xA5	; 165
    47ec:	fd 4f       	sbci	r31, 0xFD	; 253
    47ee:	8e 2d       	mov	r24, r14
    47f0:	9f 2d       	mov	r25, r15
    47f2:	a9 2d       	mov	r26, r9
    47f4:	b8 2d       	mov	r27, r8
    47f6:	82 8b       	std	Z+18, r24	; 0x12
    47f8:	93 8b       	std	Z+19, r25	; 0x13
    47fa:	a4 8b       	std	Z+20, r26	; 0x14
    47fc:	b5 8b       	std	Z+21, r27	; 0x15
    47fe:	c1 11       	cpse	r28, r1
    4800:	01 c0       	rjmp	.+2      	; 0x4804 <planner_recalculate+0xc2>
    4802:	c0 e1       	ldi	r28, 0x10	; 16
    4804:	c1 50       	subi	r28, 0x01	; 1
    4806:	dc 13       	cpse	r29, r28
    4808:	07 c0       	rjmp	.+14     	; 0x4818 <planner_recalculate+0xd6>
    480a:	80 91 5a 02 	lds	r24, 0x025A	; 0x80025a <block_buffer_tail>
    480e:	d8 13       	cpse	r29, r24
    4810:	7c c0       	rjmp	.+248    	; 0x490a <planner_recalculate+0x1c8>
    4812:	0e 94 59 19 	call	0x32b2	; 0x32b2 <st_update_plan_block_parameters>
    4816:	79 c0       	rjmp	.+242    	; 0x490a <planner_recalculate+0x1c8>
    4818:	22 e3       	ldi	r18, 0x32	; 50
    481a:	20 9f       	mul	r18, r16
    481c:	c0 01       	movw	r24, r0
    481e:	21 9f       	mul	r18, r17
    4820:	90 0d       	add	r25, r0
    4822:	11 24       	eor	r1, r1
    4824:	9c 01       	movw	r18, r24
    4826:	25 5a       	subi	r18, 0xA5	; 165
    4828:	3d 4f       	sbci	r19, 0xFD	; 253
    482a:	69 01       	movw	r12, r18
    482c:	d2 e3       	ldi	r29, 0x32	; 50
    482e:	ec 2e       	mov	r14, r28
    4830:	f1 2c       	mov	r15, r1
    4832:	de 9d       	mul	r29, r14
    4834:	80 01       	movw	r16, r0
    4836:	df 9d       	mul	r29, r15
    4838:	10 0d       	add	r17, r0
    483a:	11 24       	eor	r1, r1
    483c:	05 5a       	subi	r16, 0xA5	; 165
    483e:	1d 4f       	sbci	r17, 0xFD	; 253
    4840:	c1 11       	cpse	r28, r1
    4842:	01 c0       	rjmp	.+2      	; 0x4846 <planner_recalculate+0x104>
    4844:	c0 e1       	ldi	r28, 0x10	; 16
    4846:	c1 50       	subi	r28, 0x01	; 1
    4848:	80 91 5a 02 	lds	r24, 0x025A	; 0x80025a <block_buffer_tail>
    484c:	8c 13       	cpse	r24, r28
    484e:	02 c0       	rjmp	.+4      	; 0x4854 <planner_recalculate+0x112>
    4850:	0e 94 59 19 	call	0x32b2	; 0x32b2 <st_update_plan_block_parameters>
    4854:	de 9d       	mul	r29, r14
    4856:	f0 01       	movw	r30, r0
    4858:	df 9d       	mul	r29, r15
    485a:	f0 0d       	add	r31, r0
    485c:	11 24       	eor	r1, r1
    485e:	e5 5a       	subi	r30, 0xA5	; 165
    4860:	fd 4f       	sbci	r31, 0xFD	; 253
    4862:	46 88       	ldd	r4, Z+22	; 0x16
    4864:	57 88       	ldd	r5, Z+23	; 0x17
    4866:	60 8c       	ldd	r6, Z+24	; 0x18
    4868:	71 8c       	ldd	r7, Z+25	; 0x19
    486a:	a3 01       	movw	r20, r6
    486c:	92 01       	movw	r18, r4
    486e:	62 89       	ldd	r22, Z+18	; 0x12
    4870:	73 89       	ldd	r23, Z+19	; 0x13
    4872:	84 89       	ldd	r24, Z+20	; 0x14
    4874:	95 89       	ldd	r25, Z+21	; 0x15
    4876:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    487a:	88 23       	and	r24, r24
    487c:	09 f4       	brne	.+2      	; 0x4880 <planner_recalculate+0x13e>
    487e:	40 c0       	rjmp	.+128    	; 0x4900 <planner_recalculate+0x1be>
    4880:	de 9d       	mul	r29, r14
    4882:	c0 01       	movw	r24, r0
    4884:	df 9d       	mul	r29, r15
    4886:	90 0d       	add	r25, r0
    4888:	11 24       	eor	r1, r1
    488a:	fc 01       	movw	r30, r24
    488c:	e5 5a       	subi	r30, 0xA5	; 165
    488e:	fd 4f       	sbci	r31, 0xFD	; 253
    4890:	5f 01       	movw	r10, r30
    4892:	62 8d       	ldd	r22, Z+26	; 0x1a
    4894:	73 8d       	ldd	r23, Z+27	; 0x1b
    4896:	84 8d       	ldd	r24, Z+28	; 0x1c
    4898:	95 8d       	ldd	r25, Z+29	; 0x1d
    489a:	9b 01       	movw	r18, r22
    489c:	ac 01       	movw	r20, r24
    489e:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    48a2:	f5 01       	movw	r30, r10
    48a4:	26 8d       	ldd	r18, Z+30	; 0x1e
    48a6:	37 8d       	ldd	r19, Z+31	; 0x1f
    48a8:	40 a1       	ldd	r20, Z+32	; 0x20
    48aa:	51 a1       	ldd	r21, Z+33	; 0x21
    48ac:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    48b0:	f6 01       	movw	r30, r12
    48b2:	22 89       	ldd	r18, Z+18	; 0x12
    48b4:	33 89       	ldd	r19, Z+19	; 0x13
    48b6:	44 89       	ldd	r20, Z+20	; 0x14
    48b8:	55 89       	ldd	r21, Z+21	; 0x15
    48ba:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    48be:	4b 01       	movw	r8, r22
    48c0:	5c 01       	movw	r10, r24
    48c2:	9b 01       	movw	r18, r22
    48c4:	ac 01       	movw	r20, r24
    48c6:	c3 01       	movw	r24, r6
    48c8:	b2 01       	movw	r22, r4
    48ca:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    48ce:	18 16       	cp	r1, r24
    48d0:	64 f4       	brge	.+24     	; 0x48ea <planner_recalculate+0x1a8>
    48d2:	de 9d       	mul	r29, r14
    48d4:	f0 01       	movw	r30, r0
    48d6:	df 9d       	mul	r29, r15
    48d8:	f0 0d       	add	r31, r0
    48da:	11 24       	eor	r1, r1
    48dc:	e5 5a       	subi	r30, 0xA5	; 165
    48de:	fd 4f       	sbci	r31, 0xFD	; 253
    48e0:	82 8a       	std	Z+18, r8	; 0x12
    48e2:	93 8a       	std	Z+19, r9	; 0x13
    48e4:	a4 8a       	std	Z+20, r10	; 0x14
    48e6:	b5 8a       	std	Z+21, r11	; 0x15
    48e8:	0b c0       	rjmp	.+22     	; 0x4900 <planner_recalculate+0x1be>
    48ea:	de 9d       	mul	r29, r14
    48ec:	f0 01       	movw	r30, r0
    48ee:	df 9d       	mul	r29, r15
    48f0:	f0 0d       	add	r31, r0
    48f2:	11 24       	eor	r1, r1
    48f4:	e5 5a       	subi	r30, 0xA5	; 165
    48f6:	fd 4f       	sbci	r31, 0xFD	; 253
    48f8:	42 8a       	std	Z+18, r4	; 0x12
    48fa:	53 8a       	std	Z+19, r5	; 0x13
    48fc:	64 8a       	std	Z+20, r6	; 0x14
    48fe:	75 8a       	std	Z+21, r7	; 0x15
    4900:	68 01       	movw	r12, r16
    4902:	80 91 57 02 	lds	r24, 0x0257	; 0x800257 <block_buffer_planned>
    4906:	8c 13       	cpse	r24, r28
    4908:	92 cf       	rjmp	.-220    	; 0x482e <planner_recalculate+0xec>
    490a:	20 90 57 02 	lds	r2, 0x0257	; 0x800257 <block_buffer_planned>
    490e:	f2 e3       	ldi	r31, 0x32	; 50
    4910:	2f 9e       	mul	r2, r31
    4912:	c0 01       	movw	r24, r0
    4914:	11 24       	eor	r1, r1
    4916:	9c 01       	movw	r18, r24
    4918:	25 5a       	subi	r18, 0xA5	; 165
    491a:	3d 4f       	sbci	r19, 0xFD	; 253
    491c:	79 01       	movw	r14, r18
    491e:	c1 e0       	ldi	r28, 0x01	; 1
    4920:	c2 0d       	add	r28, r2
    4922:	c0 31       	cpi	r28, 0x10	; 16
    4924:	09 f4       	brne	.+2      	; 0x4928 <planner_recalculate+0x1e6>
    4926:	c0 e0       	ldi	r28, 0x00	; 0
    4928:	30 90 59 02 	lds	r3, 0x0259	; 0x800259 <block_buffer_head>
    492c:	d2 e3       	ldi	r29, 0x32	; 50
    492e:	58 c0       	rjmp	.+176    	; 0x49e0 <planner_recalculate+0x29e>
    4930:	cc 2e       	mov	r12, r28
    4932:	d1 2c       	mov	r13, r1
    4934:	dc 9d       	mul	r29, r12
    4936:	80 01       	movw	r16, r0
    4938:	dd 9d       	mul	r29, r13
    493a:	10 0d       	add	r17, r0
    493c:	11 24       	eor	r1, r1
    493e:	05 5a       	subi	r16, 0xA5	; 165
    4940:	1d 4f       	sbci	r17, 0xFD	; 253
    4942:	f7 01       	movw	r30, r14
    4944:	42 88       	ldd	r4, Z+18	; 0x12
    4946:	53 88       	ldd	r5, Z+19	; 0x13
    4948:	64 88       	ldd	r6, Z+20	; 0x14
    494a:	75 88       	ldd	r7, Z+21	; 0x15
    494c:	f8 01       	movw	r30, r16
    494e:	82 88       	ldd	r8, Z+18	; 0x12
    4950:	93 88       	ldd	r9, Z+19	; 0x13
    4952:	a4 88       	ldd	r10, Z+20	; 0x14
    4954:	b5 88       	ldd	r11, Z+21	; 0x15
    4956:	a5 01       	movw	r20, r10
    4958:	94 01       	movw	r18, r8
    495a:	c3 01       	movw	r24, r6
    495c:	b2 01       	movw	r22, r4
    495e:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    4962:	88 23       	and	r24, r24
    4964:	24 f5       	brge	.+72     	; 0x49ae <planner_recalculate+0x26c>
    4966:	f7 01       	movw	r30, r14
    4968:	62 8d       	ldd	r22, Z+26	; 0x1a
    496a:	73 8d       	ldd	r23, Z+27	; 0x1b
    496c:	84 8d       	ldd	r24, Z+28	; 0x1c
    496e:	95 8d       	ldd	r25, Z+29	; 0x1d
    4970:	9b 01       	movw	r18, r22
    4972:	ac 01       	movw	r20, r24
    4974:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    4978:	f7 01       	movw	r30, r14
    497a:	26 8d       	ldd	r18, Z+30	; 0x1e
    497c:	37 8d       	ldd	r19, Z+31	; 0x1f
    497e:	40 a1       	ldd	r20, Z+32	; 0x20
    4980:	51 a1       	ldd	r21, Z+33	; 0x21
    4982:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    4986:	a3 01       	movw	r20, r6
    4988:	92 01       	movw	r18, r4
    498a:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    498e:	2b 01       	movw	r4, r22
    4990:	3c 01       	movw	r6, r24
    4992:	9b 01       	movw	r18, r22
    4994:	ac 01       	movw	r20, r24
    4996:	c5 01       	movw	r24, r10
    4998:	b4 01       	movw	r22, r8
    499a:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    499e:	18 16       	cp	r1, r24
    49a0:	34 f4       	brge	.+12     	; 0x49ae <planner_recalculate+0x26c>
    49a2:	f8 01       	movw	r30, r16
    49a4:	42 8a       	std	Z+18, r4	; 0x12
    49a6:	53 8a       	std	Z+19, r5	; 0x13
    49a8:	64 8a       	std	Z+20, r6	; 0x14
    49aa:	75 8a       	std	Z+21, r7	; 0x15
    49ac:	2c 2e       	mov	r2, r28
    49ae:	dc 9d       	mul	r29, r12
    49b0:	f0 01       	movw	r30, r0
    49b2:	dd 9d       	mul	r29, r13
    49b4:	f0 0d       	add	r31, r0
    49b6:	11 24       	eor	r1, r1
    49b8:	e5 5a       	subi	r30, 0xA5	; 165
    49ba:	fd 4f       	sbci	r31, 0xFD	; 253
    49bc:	26 89       	ldd	r18, Z+22	; 0x16
    49be:	37 89       	ldd	r19, Z+23	; 0x17
    49c0:	40 8d       	ldd	r20, Z+24	; 0x18
    49c2:	51 8d       	ldd	r21, Z+25	; 0x19
    49c4:	62 89       	ldd	r22, Z+18	; 0x12
    49c6:	73 89       	ldd	r23, Z+19	; 0x13
    49c8:	84 89       	ldd	r24, Z+20	; 0x14
    49ca:	95 89       	ldd	r25, Z+21	; 0x15
    49cc:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    49d0:	81 11       	cpse	r24, r1
    49d2:	01 c0       	rjmp	.+2      	; 0x49d6 <planner_recalculate+0x294>
    49d4:	2c 2e       	mov	r2, r28
    49d6:	cf 5f       	subi	r28, 0xFF	; 255
    49d8:	c0 31       	cpi	r28, 0x10	; 16
    49da:	09 f4       	brne	.+2      	; 0x49de <planner_recalculate+0x29c>
    49dc:	c0 e0       	ldi	r28, 0x00	; 0
    49de:	78 01       	movw	r14, r16
    49e0:	c3 11       	cpse	r28, r3
    49e2:	a6 cf       	rjmp	.-180    	; 0x4930 <planner_recalculate+0x1ee>
    49e4:	20 92 57 02 	sts	0x0257, r2	; 0x800257 <block_buffer_planned>
    49e8:	df 91       	pop	r29
    49ea:	cf 91       	pop	r28
    49ec:	1f 91       	pop	r17
    49ee:	0f 91       	pop	r16
    49f0:	ff 90       	pop	r15
    49f2:	ef 90       	pop	r14
    49f4:	df 90       	pop	r13
    49f6:	cf 90       	pop	r12
    49f8:	bf 90       	pop	r11
    49fa:	af 90       	pop	r10
    49fc:	9f 90       	pop	r9
    49fe:	8f 90       	pop	r8
    4a00:	7f 90       	pop	r7
    4a02:	6f 90       	pop	r6
    4a04:	5f 90       	pop	r5
    4a06:	4f 90       	pop	r4
    4a08:	3f 90       	pop	r3
    4a0a:	2f 90       	pop	r2
    4a0c:	08 95       	ret

00004a0e <plan_reset_buffer>:
    4a0e:	10 92 5a 02 	sts	0x025A, r1	; 0x80025a <block_buffer_tail>
    4a12:	10 92 59 02 	sts	0x0259, r1	; 0x800259 <block_buffer_head>
    4a16:	81 e0       	ldi	r24, 0x01	; 1
    4a18:	80 93 58 02 	sts	0x0258, r24	; 0x800258 <next_buffer_head>
    4a1c:	10 92 57 02 	sts	0x0257, r1	; 0x800257 <block_buffer_planned>
    4a20:	08 95       	ret

00004a22 <plan_reset>:
    4a22:	8c e1       	ldi	r24, 0x1C	; 28
    4a24:	eb e3       	ldi	r30, 0x3B	; 59
    4a26:	f2 e0       	ldi	r31, 0x02	; 2
    4a28:	df 01       	movw	r26, r30
    4a2a:	1d 92       	st	X+, r1
    4a2c:	8a 95       	dec	r24
    4a2e:	e9 f7       	brne	.-6      	; 0x4a2a <plan_reset+0x8>
    4a30:	0e 94 07 25 	call	0x4a0e	; 0x4a0e <plan_reset_buffer>
    4a34:	08 95       	ret

00004a36 <plan_discard_current_block>:
    4a36:	80 91 5a 02 	lds	r24, 0x025A	; 0x80025a <block_buffer_tail>
    4a3a:	90 91 59 02 	lds	r25, 0x0259	; 0x800259 <block_buffer_head>
    4a3e:	98 17       	cp	r25, r24
    4a40:	69 f0       	breq	.+26     	; 0x4a5c <plan_discard_current_block+0x26>
    4a42:	91 e0       	ldi	r25, 0x01	; 1
    4a44:	98 0f       	add	r25, r24
    4a46:	90 31       	cpi	r25, 0x10	; 16
    4a48:	09 f4       	brne	.+2      	; 0x4a4c <plan_discard_current_block+0x16>
    4a4a:	90 e0       	ldi	r25, 0x00	; 0
    4a4c:	20 91 57 02 	lds	r18, 0x0257	; 0x800257 <block_buffer_planned>
    4a50:	82 13       	cpse	r24, r18
    4a52:	02 c0       	rjmp	.+4      	; 0x4a58 <plan_discard_current_block+0x22>
    4a54:	90 93 57 02 	sts	0x0257, r25	; 0x800257 <block_buffer_planned>
    4a58:	90 93 5a 02 	sts	0x025A, r25	; 0x80025a <block_buffer_tail>
    4a5c:	08 95       	ret

00004a5e <plan_get_system_motion_block>:
    4a5e:	80 91 59 02 	lds	r24, 0x0259	; 0x800259 <block_buffer_head>
    4a62:	22 e3       	ldi	r18, 0x32	; 50
    4a64:	82 9f       	mul	r24, r18
    4a66:	c0 01       	movw	r24, r0
    4a68:	11 24       	eor	r1, r1
    4a6a:	85 5a       	subi	r24, 0xA5	; 165
    4a6c:	9d 4f       	sbci	r25, 0xFD	; 253
    4a6e:	08 95       	ret

00004a70 <plan_get_current_block>:
    4a70:	80 91 5a 02 	lds	r24, 0x025A	; 0x80025a <block_buffer_tail>
    4a74:	90 91 59 02 	lds	r25, 0x0259	; 0x800259 <block_buffer_head>
    4a78:	98 17       	cp	r25, r24
    4a7a:	39 f0       	breq	.+14     	; 0x4a8a <plan_get_current_block+0x1a>
    4a7c:	22 e3       	ldi	r18, 0x32	; 50
    4a7e:	82 9f       	mul	r24, r18
    4a80:	c0 01       	movw	r24, r0
    4a82:	11 24       	eor	r1, r1
    4a84:	85 5a       	subi	r24, 0xA5	; 165
    4a86:	9d 4f       	sbci	r25, 0xFD	; 253
    4a88:	08 95       	ret
    4a8a:	80 e0       	ldi	r24, 0x00	; 0
    4a8c:	90 e0       	ldi	r25, 0x00	; 0
    4a8e:	08 95       	ret

00004a90 <plan_get_exec_block_exit_speed_sqr>:
    4a90:	e0 91 5a 02 	lds	r30, 0x025A	; 0x80025a <block_buffer_tail>
    4a94:	ef 5f       	subi	r30, 0xFF	; 255
    4a96:	e0 31       	cpi	r30, 0x10	; 16
    4a98:	09 f4       	brne	.+2      	; 0x4a9c <plan_get_exec_block_exit_speed_sqr+0xc>
    4a9a:	e0 e0       	ldi	r30, 0x00	; 0
    4a9c:	80 91 59 02 	lds	r24, 0x0259	; 0x800259 <block_buffer_head>
    4aa0:	8e 17       	cp	r24, r30
    4aa2:	59 f0       	breq	.+22     	; 0x4aba <plan_get_exec_block_exit_speed_sqr+0x2a>
    4aa4:	82 e3       	ldi	r24, 0x32	; 50
    4aa6:	e8 9f       	mul	r30, r24
    4aa8:	f0 01       	movw	r30, r0
    4aaa:	11 24       	eor	r1, r1
    4aac:	e5 5a       	subi	r30, 0xA5	; 165
    4aae:	fd 4f       	sbci	r31, 0xFD	; 253
    4ab0:	62 89       	ldd	r22, Z+18	; 0x12
    4ab2:	73 89       	ldd	r23, Z+19	; 0x13
    4ab4:	84 89       	ldd	r24, Z+20	; 0x14
    4ab6:	95 89       	ldd	r25, Z+21	; 0x15
    4ab8:	08 95       	ret
    4aba:	60 e0       	ldi	r22, 0x00	; 0
    4abc:	70 e0       	ldi	r23, 0x00	; 0
    4abe:	cb 01       	movw	r24, r22
    4ac0:	08 95       	ret

00004ac2 <plan_check_full_buffer>:
    4ac2:	81 e0       	ldi	r24, 0x01	; 1
    4ac4:	20 91 5a 02 	lds	r18, 0x025A	; 0x80025a <block_buffer_tail>
    4ac8:	90 91 58 02 	lds	r25, 0x0258	; 0x800258 <next_buffer_head>
    4acc:	29 13       	cpse	r18, r25
    4ace:	80 e0       	ldi	r24, 0x00	; 0
    4ad0:	08 95       	ret

00004ad2 <plan_compute_profile_nominal_speed>:
    4ad2:	af 92       	push	r10
    4ad4:	bf 92       	push	r11
    4ad6:	cf 92       	push	r12
    4ad8:	df 92       	push	r13
    4ada:	ef 92       	push	r14
    4adc:	ff 92       	push	r15
    4ade:	0f 93       	push	r16
    4ae0:	1f 93       	push	r17
    4ae2:	cf 93       	push	r28
    4ae4:	df 93       	push	r29
    4ae6:	ec 01       	movw	r28, r24
    4ae8:	1a a5       	ldd	r17, Y+42	; 0x2a
    4aea:	ab a4       	ldd	r10, Y+43	; 0x2b
    4aec:	ec a4       	ldd	r14, Y+44	; 0x2c
    4aee:	0d a5       	ldd	r16, Y+45	; 0x2d
    4af0:	89 89       	ldd	r24, Y+17	; 0x11
    4af2:	80 ff       	sbrs	r24, 0
    4af4:	1a c0       	rjmp	.+52     	; 0x4b2a <plan_compute_profile_nominal_speed+0x58>
    4af6:	60 91 84 05 	lds	r22, 0x0584	; 0x800584 <sys+0x8>
    4afa:	70 e0       	ldi	r23, 0x00	; 0
    4afc:	80 e0       	ldi	r24, 0x00	; 0
    4afe:	90 e0       	ldi	r25, 0x00	; 0
    4b00:	0e 94 08 30 	call	0x6010	; 0x6010 <__floatsisf>
    4b04:	2a e0       	ldi	r18, 0x0A	; 10
    4b06:	37 ed       	ldi	r19, 0xD7	; 215
    4b08:	43 e2       	ldi	r20, 0x23	; 35
    4b0a:	5c e3       	ldi	r21, 0x3C	; 60
    4b0c:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    4b10:	9b 01       	movw	r18, r22
    4b12:	ac 01       	movw	r20, r24
    4b14:	61 2f       	mov	r22, r17
    4b16:	7a 2d       	mov	r23, r10
    4b18:	8e 2d       	mov	r24, r14
    4b1a:	90 2f       	mov	r25, r16
    4b1c:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    4b20:	16 2f       	mov	r17, r22
    4b22:	a7 2e       	mov	r10, r23
    4b24:	e8 2e       	mov	r14, r24
    4b26:	09 2f       	mov	r16, r25
    4b28:	2f c0       	rjmp	.+94     	; 0x4b88 <plan_compute_profile_nominal_speed+0xb6>
    4b2a:	82 fd       	sbrc	r24, 2
    4b2c:	19 c0       	rjmp	.+50     	; 0x4b60 <plan_compute_profile_nominal_speed+0x8e>
    4b2e:	60 91 83 05 	lds	r22, 0x0583	; 0x800583 <sys+0x7>
    4b32:	70 e0       	ldi	r23, 0x00	; 0
    4b34:	80 e0       	ldi	r24, 0x00	; 0
    4b36:	90 e0       	ldi	r25, 0x00	; 0
    4b38:	0e 94 08 30 	call	0x6010	; 0x6010 <__floatsisf>
    4b3c:	2a e0       	ldi	r18, 0x0A	; 10
    4b3e:	37 ed       	ldi	r19, 0xD7	; 215
    4b40:	43 e2       	ldi	r20, 0x23	; 35
    4b42:	5c e3       	ldi	r21, 0x3C	; 60
    4b44:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    4b48:	9b 01       	movw	r18, r22
    4b4a:	ac 01       	movw	r20, r24
    4b4c:	61 2f       	mov	r22, r17
    4b4e:	7a 2d       	mov	r23, r10
    4b50:	8e 2d       	mov	r24, r14
    4b52:	90 2f       	mov	r25, r16
    4b54:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    4b58:	16 2f       	mov	r17, r22
    4b5a:	a7 2e       	mov	r10, r23
    4b5c:	e8 2e       	mov	r14, r24
    4b5e:	09 2f       	mov	r16, r25
    4b60:	be a0       	ldd	r11, Y+38	; 0x26
    4b62:	cf a0       	ldd	r12, Y+39	; 0x27
    4b64:	d8 a4       	ldd	r13, Y+40	; 0x28
    4b66:	f9 a4       	ldd	r15, Y+41	; 0x29
    4b68:	2b 2d       	mov	r18, r11
    4b6a:	3c 2d       	mov	r19, r12
    4b6c:	4d 2d       	mov	r20, r13
    4b6e:	5f 2d       	mov	r21, r15
    4b70:	61 2f       	mov	r22, r17
    4b72:	7a 2d       	mov	r23, r10
    4b74:	8e 2d       	mov	r24, r14
    4b76:	90 2f       	mov	r25, r16
    4b78:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    4b7c:	18 16       	cp	r1, r24
    4b7e:	24 f4       	brge	.+8      	; 0x4b88 <plan_compute_profile_nominal_speed+0xb6>
    4b80:	1b 2d       	mov	r17, r11
    4b82:	ac 2c       	mov	r10, r12
    4b84:	ed 2c       	mov	r14, r13
    4b86:	0f 2d       	mov	r16, r15
    4b88:	20 e0       	ldi	r18, 0x00	; 0
    4b8a:	30 e0       	ldi	r19, 0x00	; 0
    4b8c:	40 e8       	ldi	r20, 0x80	; 128
    4b8e:	5f e3       	ldi	r21, 0x3F	; 63
    4b90:	61 2f       	mov	r22, r17
    4b92:	7a 2d       	mov	r23, r10
    4b94:	8e 2d       	mov	r24, r14
    4b96:	90 2f       	mov	r25, r16
    4b98:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    4b9c:	18 16       	cp	r1, r24
    4b9e:	1c f4       	brge	.+6      	; 0x4ba6 <plan_compute_profile_nominal_speed+0xd4>
    4ba0:	da 2d       	mov	r29, r10
    4ba2:	ce 2d       	mov	r28, r14
    4ba4:	04 c0       	rjmp	.+8      	; 0x4bae <plan_compute_profile_nominal_speed+0xdc>
    4ba6:	10 e0       	ldi	r17, 0x00	; 0
    4ba8:	d0 e0       	ldi	r29, 0x00	; 0
    4baa:	c0 e8       	ldi	r28, 0x80	; 128
    4bac:	0f e3       	ldi	r16, 0x3F	; 63
    4bae:	61 2f       	mov	r22, r17
    4bb0:	7d 2f       	mov	r23, r29
    4bb2:	8c 2f       	mov	r24, r28
    4bb4:	90 2f       	mov	r25, r16
    4bb6:	df 91       	pop	r29
    4bb8:	cf 91       	pop	r28
    4bba:	1f 91       	pop	r17
    4bbc:	0f 91       	pop	r16
    4bbe:	ff 90       	pop	r15
    4bc0:	ef 90       	pop	r14
    4bc2:	df 90       	pop	r13
    4bc4:	cf 90       	pop	r12
    4bc6:	bf 90       	pop	r11
    4bc8:	af 90       	pop	r10
    4bca:	08 95       	ret

00004bcc <plan_update_velocity_profile_parameters>:
    4bcc:	5f 92       	push	r5
    4bce:	6f 92       	push	r6
    4bd0:	7f 92       	push	r7
    4bd2:	8f 92       	push	r8
    4bd4:	9f 92       	push	r9
    4bd6:	af 92       	push	r10
    4bd8:	bf 92       	push	r11
    4bda:	cf 92       	push	r12
    4bdc:	df 92       	push	r13
    4bde:	ef 92       	push	r14
    4be0:	ff 92       	push	r15
    4be2:	0f 93       	push	r16
    4be4:	1f 93       	push	r17
    4be6:	cf 93       	push	r28
    4be8:	df 93       	push	r29
    4bea:	10 91 5a 02 	lds	r17, 0x025A	; 0x80025a <block_buffer_tail>
    4bee:	50 90 59 02 	lds	r5, 0x0259	; 0x800259 <block_buffer_head>
    4bf2:	0f 2e       	mov	r0, r31
    4bf4:	f9 e9       	ldi	r31, 0x99	; 153
    4bf6:	9f 2e       	mov	r9, r31
    4bf8:	f0 2d       	mov	r31, r0
    4bfa:	0f 2e       	mov	r0, r31
    4bfc:	f6 e7       	ldi	r31, 0x76	; 118
    4bfe:	8f 2e       	mov	r8, r31
    4c00:	f0 2d       	mov	r31, r0
    4c02:	0f 2e       	mov	r0, r31
    4c04:	f6 e9       	ldi	r31, 0x96	; 150
    4c06:	7f 2e       	mov	r7, r31
    4c08:	f0 2d       	mov	r31, r0
    4c0a:	0f 2e       	mov	r0, r31
    4c0c:	fe e7       	ldi	r31, 0x7E	; 126
    4c0e:	6f 2e       	mov	r6, r31
    4c10:	f0 2d       	mov	r31, r0
    4c12:	0f 2e       	mov	r0, r31
    4c14:	f2 e3       	ldi	r31, 0x32	; 50
    4c16:	cf 2e       	mov	r12, r31
    4c18:	f0 2d       	mov	r31, r0
    4c1a:	74 c0       	rjmp	.+232    	; 0x4d04 <plan_update_velocity_profile_parameters+0x138>
    4c1c:	c1 2f       	mov	r28, r17
    4c1e:	d0 e0       	ldi	r29, 0x00	; 0
    4c20:	cc 9e       	mul	r12, r28
    4c22:	c0 01       	movw	r24, r0
    4c24:	cd 9e       	mul	r12, r29
    4c26:	90 0d       	add	r25, r0
    4c28:	11 24       	eor	r1, r1
    4c2a:	85 5a       	subi	r24, 0xA5	; 165
    4c2c:	9d 4f       	sbci	r25, 0xFD	; 253
    4c2e:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <plan_compute_profile_nominal_speed>
    4c32:	06 2f       	mov	r16, r22
    4c34:	f7 2e       	mov	r15, r23
    4c36:	e8 2e       	mov	r14, r24
    4c38:	d9 2e       	mov	r13, r25
    4c3a:	26 2f       	mov	r18, r22
    4c3c:	37 2f       	mov	r19, r23
    4c3e:	48 2f       	mov	r20, r24
    4c40:	59 2f       	mov	r21, r25
    4c42:	69 2d       	mov	r22, r9
    4c44:	78 2d       	mov	r23, r8
    4c46:	87 2d       	mov	r24, r7
    4c48:	96 2d       	mov	r25, r6
    4c4a:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    4c4e:	88 23       	and	r24, r24
    4c50:	cc f4       	brge	.+50     	; 0x4c84 <plan_update_velocity_profile_parameters+0xb8>
    4c52:	cc 9e       	mul	r12, r28
    4c54:	c0 01       	movw	r24, r0
    4c56:	cd 9e       	mul	r12, r29
    4c58:	90 0d       	add	r25, r0
    4c5a:	11 24       	eor	r1, r1
    4c5c:	9c 01       	movw	r18, r24
    4c5e:	25 5a       	subi	r18, 0xA5	; 165
    4c60:	3d 4f       	sbci	r19, 0xFD	; 253
    4c62:	59 01       	movw	r10, r18
    4c64:	29 2d       	mov	r18, r9
    4c66:	38 2d       	mov	r19, r8
    4c68:	47 2d       	mov	r20, r7
    4c6a:	56 2d       	mov	r21, r6
    4c6c:	69 2d       	mov	r22, r9
    4c6e:	78 2d       	mov	r23, r8
    4c70:	87 2d       	mov	r24, r7
    4c72:	96 2d       	mov	r25, r6
    4c74:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    4c78:	f5 01       	movw	r30, r10
    4c7a:	66 8b       	std	Z+22, r22	; 0x16
    4c7c:	77 8b       	std	Z+23, r23	; 0x17
    4c7e:	80 8f       	std	Z+24, r24	; 0x18
    4c80:	91 8f       	std	Z+25, r25	; 0x19
    4c82:	18 c0       	rjmp	.+48     	; 0x4cb4 <plan_update_velocity_profile_parameters+0xe8>
    4c84:	cc 9e       	mul	r12, r28
    4c86:	c0 01       	movw	r24, r0
    4c88:	cd 9e       	mul	r12, r29
    4c8a:	90 0d       	add	r25, r0
    4c8c:	11 24       	eor	r1, r1
    4c8e:	9c 01       	movw	r18, r24
    4c90:	25 5a       	subi	r18, 0xA5	; 165
    4c92:	3d 4f       	sbci	r19, 0xFD	; 253
    4c94:	59 01       	movw	r10, r18
    4c96:	20 2f       	mov	r18, r16
    4c98:	3f 2d       	mov	r19, r15
    4c9a:	4e 2d       	mov	r20, r14
    4c9c:	5d 2d       	mov	r21, r13
    4c9e:	60 2f       	mov	r22, r16
    4ca0:	7f 2d       	mov	r23, r15
    4ca2:	8e 2d       	mov	r24, r14
    4ca4:	9d 2d       	mov	r25, r13
    4ca6:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    4caa:	f5 01       	movw	r30, r10
    4cac:	66 8b       	std	Z+22, r22	; 0x16
    4cae:	77 8b       	std	Z+23, r23	; 0x17
    4cb0:	80 8f       	std	Z+24, r24	; 0x18
    4cb2:	91 8f       	std	Z+25, r25	; 0x19
    4cb4:	cc 9e       	mul	r12, r28
    4cb6:	f0 01       	movw	r30, r0
    4cb8:	cd 9e       	mul	r12, r29
    4cba:	f0 0d       	add	r31, r0
    4cbc:	11 24       	eor	r1, r1
    4cbe:	e5 5a       	subi	r30, 0xA5	; 165
    4cc0:	fd 4f       	sbci	r31, 0xFD	; 253
    4cc2:	82 a0       	ldd	r8, Z+34	; 0x22
    4cc4:	93 a0       	ldd	r9, Z+35	; 0x23
    4cc6:	a4 a0       	ldd	r10, Z+36	; 0x24
    4cc8:	b5 a0       	ldd	r11, Z+37	; 0x25
    4cca:	a5 01       	movw	r20, r10
    4ccc:	94 01       	movw	r18, r8
    4cce:	66 89       	ldd	r22, Z+22	; 0x16
    4cd0:	77 89       	ldd	r23, Z+23	; 0x17
    4cd2:	80 8d       	ldd	r24, Z+24	; 0x18
    4cd4:	91 8d       	ldd	r25, Z+25	; 0x19
    4cd6:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    4cda:	18 16       	cp	r1, r24
    4cdc:	5c f4       	brge	.+22     	; 0x4cf4 <plan_update_velocity_profile_parameters+0x128>
    4cde:	cc 9e       	mul	r12, r28
    4ce0:	f0 01       	movw	r30, r0
    4ce2:	cd 9e       	mul	r12, r29
    4ce4:	f0 0d       	add	r31, r0
    4ce6:	11 24       	eor	r1, r1
    4ce8:	e5 5a       	subi	r30, 0xA5	; 165
    4cea:	fd 4f       	sbci	r31, 0xFD	; 253
    4cec:	86 8a       	std	Z+22, r8	; 0x16
    4cee:	97 8a       	std	Z+23, r9	; 0x17
    4cf0:	a0 8e       	std	Z+24, r10	; 0x18
    4cf2:	b1 8e       	std	Z+25, r11	; 0x19
    4cf4:	1f 5f       	subi	r17, 0xFF	; 255
    4cf6:	10 31       	cpi	r17, 0x10	; 16
    4cf8:	09 f4       	brne	.+2      	; 0x4cfc <plan_update_velocity_profile_parameters+0x130>
    4cfa:	10 e0       	ldi	r17, 0x00	; 0
    4cfc:	90 2e       	mov	r9, r16
    4cfe:	8f 2c       	mov	r8, r15
    4d00:	7e 2c       	mov	r7, r14
    4d02:	6d 2c       	mov	r6, r13
    4d04:	15 11       	cpse	r17, r5
    4d06:	8a cf       	rjmp	.-236    	; 0x4c1c <plan_update_velocity_profile_parameters+0x50>
    4d08:	89 2d       	mov	r24, r9
    4d0a:	98 2d       	mov	r25, r8
    4d0c:	a7 2d       	mov	r26, r7
    4d0e:	b6 2d       	mov	r27, r6
    4d10:	80 93 53 02 	sts	0x0253, r24	; 0x800253 <pl+0x18>
    4d14:	90 93 54 02 	sts	0x0254, r25	; 0x800254 <pl+0x19>
    4d18:	a0 93 55 02 	sts	0x0255, r26	; 0x800255 <pl+0x1a>
    4d1c:	b0 93 56 02 	sts	0x0256, r27	; 0x800256 <pl+0x1b>
    4d20:	df 91       	pop	r29
    4d22:	cf 91       	pop	r28
    4d24:	1f 91       	pop	r17
    4d26:	0f 91       	pop	r16
    4d28:	ff 90       	pop	r15
    4d2a:	ef 90       	pop	r14
    4d2c:	df 90       	pop	r13
    4d2e:	cf 90       	pop	r12
    4d30:	bf 90       	pop	r11
    4d32:	af 90       	pop	r10
    4d34:	9f 90       	pop	r9
    4d36:	8f 90       	pop	r8
    4d38:	7f 90       	pop	r7
    4d3a:	6f 90       	pop	r6
    4d3c:	5f 90       	pop	r5
    4d3e:	08 95       	ret

00004d40 <plan_buffer_line>:
    4d40:	2f 92       	push	r2
    4d42:	3f 92       	push	r3
    4d44:	4f 92       	push	r4
    4d46:	5f 92       	push	r5
    4d48:	6f 92       	push	r6
    4d4a:	7f 92       	push	r7
    4d4c:	8f 92       	push	r8
    4d4e:	9f 92       	push	r9
    4d50:	af 92       	push	r10
    4d52:	bf 92       	push	r11
    4d54:	cf 92       	push	r12
    4d56:	df 92       	push	r13
    4d58:	ef 92       	push	r14
    4d5a:	ff 92       	push	r15
    4d5c:	0f 93       	push	r16
    4d5e:	1f 93       	push	r17
    4d60:	cf 93       	push	r28
    4d62:	df 93       	push	r29
    4d64:	cd b7       	in	r28, 0x3d	; 61
    4d66:	de b7       	in	r29, 0x3e	; 62
    4d68:	c6 54       	subi	r28, 0x46	; 70
    4d6a:	d1 09       	sbc	r29, r1
    4d6c:	0f b6       	in	r0, 0x3f	; 63
    4d6e:	f8 94       	cli
    4d70:	de bf       	out	0x3e, r29	; 62
    4d72:	0f be       	out	0x3f, r0	; 63
    4d74:	cd bf       	out	0x3d, r28	; 61
    4d76:	25 96       	adiw	r28, 0x05	; 5
    4d78:	7f af       	std	Y+63, r23	; 0x3f
    4d7a:	6e af       	std	Y+62, r22	; 0x3e
    4d7c:	25 97       	sbiw	r28, 0x05	; 5
    4d7e:	20 90 59 02 	lds	r2, 0x0259	; 0x800259 <block_buffer_head>
    4d82:	a2 2c       	mov	r10, r2
    4d84:	b1 2c       	mov	r11, r1
    4d86:	22 e3       	ldi	r18, 0x32	; 50
    4d88:	2a 9d       	mul	r18, r10
    4d8a:	a0 01       	movw	r20, r0
    4d8c:	2b 9d       	mul	r18, r11
    4d8e:	50 0d       	add	r21, r0
    4d90:	11 24       	eor	r1, r1
    4d92:	ba 01       	movw	r22, r20
    4d94:	65 5a       	subi	r22, 0xA5	; 165
    4d96:	7d 4f       	sbci	r23, 0xFD	; 253
    4d98:	21 96       	adiw	r28, 0x01	; 1
    4d9a:	7f af       	std	Y+63, r23	; 0x3f
    4d9c:	6e af       	std	Y+62, r22	; 0x3e
    4d9e:	21 97       	sbiw	r28, 0x01	; 1
    4da0:	fb 01       	movw	r30, r22
    4da2:	11 92       	st	Z+, r1
    4da4:	2a 95       	dec	r18
    4da6:	e9 f7       	brne	.-6      	; 0x4da2 <plan_buffer_line+0x62>
    4da8:	25 96       	adiw	r28, 0x05	; 5
    4daa:	ee ad       	ldd	r30, Y+62	; 0x3e
    4dac:	ff ad       	ldd	r31, Y+63	; 0x3f
    4dae:	25 97       	sbiw	r28, 0x05	; 5
    4db0:	20 85       	ldd	r18, Z+8	; 0x08
    4db2:	fb 01       	movw	r30, r22
    4db4:	21 8b       	std	Z+17, r18	; 0x11
    4db6:	25 96       	adiw	r28, 0x05	; 5
    4db8:	ee ad       	ldd	r30, Y+62	; 0x3e
    4dba:	ff ad       	ldd	r31, Y+63	; 0x3f
    4dbc:	25 97       	sbiw	r28, 0x05	; 5
    4dbe:	44 81       	ldd	r20, Z+4	; 0x04
    4dc0:	55 81       	ldd	r21, Z+5	; 0x05
    4dc2:	66 81       	ldd	r22, Z+6	; 0x06
    4dc4:	77 81       	ldd	r23, Z+7	; 0x07
    4dc6:	21 96       	adiw	r28, 0x01	; 1
    4dc8:	ee ad       	ldd	r30, Y+62	; 0x3e
    4dca:	ff ad       	ldd	r31, Y+63	; 0x3f
    4dcc:	21 97       	sbiw	r28, 0x01	; 1
    4dce:	46 a7       	std	Z+46, r20	; 0x2e
    4dd0:	57 a7       	std	Z+47, r21	; 0x2f
    4dd2:	60 ab       	std	Z+48, r22	; 0x30
    4dd4:	71 ab       	std	Z+49, r23	; 0x31
    4dd6:	21 ff       	sbrs	r18, 1
    4dd8:	0a c0       	rjmp	.+20     	; 0x4dee <plan_buffer_line+0xae>
    4dda:	2c e0       	ldi	r18, 0x0C	; 12
    4ddc:	ec e9       	ldi	r30, 0x9C	; 156
    4dde:	f5 e0       	ldi	r31, 0x05	; 5
    4de0:	de 01       	movw	r26, r28
    4de2:	1d 96       	adiw	r26, 0x0d	; 13
    4de4:	01 90       	ld	r0, Z+
    4de6:	0d 92       	st	X+, r0
    4de8:	2a 95       	dec	r18
    4dea:	e1 f7       	brne	.-8      	; 0x4de4 <plan_buffer_line+0xa4>
    4dec:	6d c2       	rjmp	.+1242   	; 0x52c8 <plan_buffer_line+0x588>
    4dee:	2c e0       	ldi	r18, 0x0C	; 12
    4df0:	eb e3       	ldi	r30, 0x3B	; 59
    4df2:	f2 e0       	ldi	r31, 0x02	; 2
    4df4:	de 01       	movw	r26, r28
    4df6:	1d 96       	adiw	r26, 0x0d	; 13
    4df8:	01 90       	ld	r0, Z+
    4dfa:	0d 92       	st	X+, r0
    4dfc:	2a 95       	dec	r18
    4dfe:	e1 f7       	brne	.-8      	; 0x4df8 <plan_buffer_line+0xb8>
    4e00:	63 c2       	rjmp	.+1222   	; 0x52c8 <plan_buffer_line+0x588>
    4e02:	e9 ad       	ldd	r30, Y+57	; 0x39
    4e04:	fa ad       	ldd	r31, Y+58	; 0x3a
    4e06:	61 91       	ld	r22, Z+
    4e08:	71 91       	ld	r23, Z+
    4e0a:	81 91       	ld	r24, Z+
    4e0c:	91 91       	ld	r25, Z+
    4e0e:	fa af       	std	Y+58, r31	; 0x3a
    4e10:	e9 af       	std	Y+57, r30	; 0x39
    4e12:	eb ad       	ldd	r30, Y+59	; 0x3b
    4e14:	fc ad       	ldd	r31, Y+60	; 0x3c
    4e16:	21 91       	ld	r18, Z+
    4e18:	31 91       	ld	r19, Z+
    4e1a:	41 91       	ld	r20, Z+
    4e1c:	51 91       	ld	r21, Z+
    4e1e:	fc af       	std	Y+60, r31	; 0x3c
    4e20:	eb af       	std	Y+59, r30	; 0x3b
    4e22:	2d ab       	std	Y+53, r18	; 0x35
    4e24:	3e ab       	std	Y+54, r19	; 0x36
    4e26:	4f ab       	std	Y+55, r20	; 0x37
    4e28:	58 af       	std	Y+56, r21	; 0x38
    4e2a:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    4e2e:	0e 94 83 31 	call	0x6306	; 0x6306 <lround>
    4e32:	f4 01       	movw	r30, r8
    4e34:	61 93       	st	Z+, r22
    4e36:	71 93       	st	Z+, r23
    4e38:	81 93       	st	Z+, r24
    4e3a:	91 93       	st	Z+, r25
    4e3c:	4f 01       	movw	r8, r30
    4e3e:	f6 01       	movw	r30, r12
    4e40:	01 91       	ld	r16, Z+
    4e42:	11 91       	ld	r17, Z+
    4e44:	21 91       	ld	r18, Z+
    4e46:	31 91       	ld	r19, Z+
    4e48:	6f 01       	movw	r12, r30
    4e4a:	60 1b       	sub	r22, r16
    4e4c:	71 0b       	sbc	r23, r17
    4e4e:	82 0b       	sbc	r24, r18
    4e50:	93 0b       	sbc	r25, r19
    4e52:	8b 01       	movw	r16, r22
    4e54:	9c 01       	movw	r18, r24
    4e56:	3a f4       	brpl	.+14     	; 0x4e66 <plan_buffer_line+0x126>
    4e58:	00 27       	eor	r16, r16
    4e5a:	11 27       	eor	r17, r17
    4e5c:	98 01       	movw	r18, r16
    4e5e:	06 1b       	sub	r16, r22
    4e60:	17 0b       	sbc	r17, r23
    4e62:	28 0b       	sbc	r18, r24
    4e64:	39 0b       	sbc	r19, r25
    4e66:	f1 01       	movw	r30, r2
    4e68:	01 93       	st	Z+, r16
    4e6a:	11 93       	st	Z+, r17
    4e6c:	21 93       	st	Z+, r18
    4e6e:	31 93       	st	Z+, r19
    4e70:	1f 01       	movw	r2, r30
    4e72:	f7 01       	movw	r30, r14
    4e74:	40 80       	ld	r4, Z
    4e76:	51 80       	ldd	r5, Z+1	; 0x01
    4e78:	62 80       	ldd	r6, Z+2	; 0x02
    4e7a:	73 80       	ldd	r7, Z+3	; 0x03
    4e7c:	40 16       	cp	r4, r16
    4e7e:	51 06       	cpc	r5, r17
    4e80:	62 06       	cpc	r6, r18
    4e82:	73 06       	cpc	r7, r19
    4e84:	10 f4       	brcc	.+4      	; 0x4e8a <plan_buffer_line+0x14a>
    4e86:	28 01       	movw	r4, r16
    4e88:	39 01       	movw	r6, r18
    4e8a:	f7 01       	movw	r30, r14
    4e8c:	40 82       	st	Z, r4
    4e8e:	51 82       	std	Z+1, r5	; 0x01
    4e90:	62 82       	std	Z+2, r6	; 0x02
    4e92:	73 82       	std	Z+3, r7	; 0x03
    4e94:	0e 94 08 30 	call	0x6010	; 0x6010 <__floatsisf>
    4e98:	2d a9       	ldd	r18, Y+53	; 0x35
    4e9a:	3e a9       	ldd	r19, Y+54	; 0x36
    4e9c:	4f a9       	ldd	r20, Y+55	; 0x37
    4e9e:	58 ad       	ldd	r21, Y+56	; 0x38
    4ea0:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <__divsf3>
    4ea4:	ed ad       	ldd	r30, Y+61	; 0x3d
    4ea6:	fe ad       	ldd	r31, Y+62	; 0x3e
    4ea8:	61 93       	st	Z+, r22
    4eaa:	71 93       	st	Z+, r23
    4eac:	81 93       	st	Z+, r24
    4eae:	91 93       	st	Z+, r25
    4eb0:	fe af       	std	Y+62, r31	; 0x3e
    4eb2:	ed af       	std	Y+61, r30	; 0x3d
    4eb4:	20 e0       	ldi	r18, 0x00	; 0
    4eb6:	30 e0       	ldi	r19, 0x00	; 0
    4eb8:	a9 01       	movw	r20, r18
    4eba:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    4ebe:	88 23       	and	r24, r24
    4ec0:	54 f4       	brge	.+20     	; 0x4ed6 <plan_buffer_line+0x196>
    4ec2:	89 a9       	ldd	r24, Y+49	; 0x31
    4ec4:	0e 94 8d 23 	call	0x471a	; 0x471a <get_direction_pin_mask>
    4ec8:	27 96       	adiw	r28, 0x07	; 7
    4eca:	ee ad       	ldd	r30, Y+62	; 0x3e
    4ecc:	ff ad       	ldd	r31, Y+63	; 0x3f
    4ece:	27 97       	sbiw	r28, 0x07	; 7
    4ed0:	90 81       	ld	r25, Z
    4ed2:	89 2b       	or	r24, r25
    4ed4:	80 83       	st	Z, r24
    4ed6:	f9 a9       	ldd	r31, Y+49	; 0x31
    4ed8:	ff 5f       	subi	r31, 0xFF	; 255
    4eda:	f9 ab       	std	Y+49, r31	; 0x31
    4edc:	f3 30       	cpi	r31, 0x03	; 3
    4ede:	09 f0       	breq	.+2      	; 0x4ee2 <plan_buffer_line+0x1a2>
    4ee0:	90 cf       	rjmp	.-224    	; 0x4e02 <plan_buffer_line+0xc2>
    4ee2:	82 e3       	ldi	r24, 0x32	; 50
    4ee4:	8a 9d       	mul	r24, r10
    4ee6:	f0 01       	movw	r30, r0
    4ee8:	8b 9d       	mul	r24, r11
    4eea:	f0 0d       	add	r31, r0
    4eec:	11 24       	eor	r1, r1
    4eee:	e5 5a       	subi	r30, 0xA5	; 165
    4ef0:	fd 4f       	sbci	r31, 0xFD	; 253
    4ef2:	84 85       	ldd	r24, Z+12	; 0x0c
    4ef4:	95 85       	ldd	r25, Z+13	; 0x0d
    4ef6:	a6 85       	ldd	r26, Z+14	; 0x0e
    4ef8:	b7 85       	ldd	r27, Z+15	; 0x0f
    4efa:	89 2b       	or	r24, r25
    4efc:	8a 2b       	or	r24, r26
    4efe:	8b 2b       	or	r24, r27
    4f00:	09 f4       	brne	.+2      	; 0x4f04 <plan_buffer_line+0x1c4>
    4f02:	de c1       	rjmp	.+956    	; 0x52c0 <plan_buffer_line+0x580>
    4f04:	ce 01       	movw	r24, r28
    4f06:	49 96       	adiw	r24, 0x19	; 25
    4f08:	0e 94 0f 2b 	call	0x561e	; 0x561e <convert_delta_vector_to_unit_vector>
    4f0c:	22 e3       	ldi	r18, 0x32	; 50
    4f0e:	2a 9d       	mul	r18, r10
    4f10:	80 01       	movw	r16, r0
    4f12:	2b 9d       	mul	r18, r11
    4f14:	10 0d       	add	r17, r0
    4f16:	11 24       	eor	r1, r1
    4f18:	05 5a       	subi	r16, 0xA5	; 165
    4f1a:	1d 4f       	sbci	r17, 0xFD	; 253
    4f1c:	f8 01       	movw	r30, r16
    4f1e:	66 8f       	std	Z+30, r22	; 0x1e
    4f20:	77 8f       	std	Z+31, r23	; 0x1f
    4f22:	80 a3       	std	Z+32, r24	; 0x20
    4f24:	91 a3       	std	Z+33, r25	; 0x21
    4f26:	be 01       	movw	r22, r28
    4f28:	67 5e       	subi	r22, 0xE7	; 231
    4f2a:	7f 4f       	sbci	r23, 0xFF	; 255
    4f2c:	86 e2       	ldi	r24, 0x26	; 38
    4f2e:	97 e0       	ldi	r25, 0x07	; 7
    4f30:	0e 94 76 2b 	call	0x56ec	; 0x56ec <limit_value_by_axis_maximum>
    4f34:	f8 01       	movw	r30, r16
    4f36:	62 8f       	std	Z+26, r22	; 0x1a
    4f38:	73 8f       	std	Z+27, r23	; 0x1b
    4f3a:	84 8f       	std	Z+28, r24	; 0x1c
    4f3c:	95 8f       	std	Z+29, r25	; 0x1d
    4f3e:	be 01       	movw	r22, r28
    4f40:	67 5e       	subi	r22, 0xE7	; 231
    4f42:	7f 4f       	sbci	r23, 0xFF	; 255
    4f44:	8a e1       	ldi	r24, 0x1A	; 26
    4f46:	97 e0       	ldi	r25, 0x07	; 7
    4f48:	0e 94 76 2b 	call	0x56ec	; 0x56ec <limit_value_by_axis_maximum>
    4f4c:	f8 01       	movw	r30, r16
    4f4e:	66 a3       	std	Z+38, r22	; 0x26
    4f50:	77 a3       	std	Z+39, r23	; 0x27
    4f52:	80 a7       	std	Z+40, r24	; 0x28
    4f54:	91 a7       	std	Z+41, r25	; 0x29
    4f56:	11 89       	ldd	r17, Z+17	; 0x11
    4f58:	10 ff       	sbrs	r17, 0
    4f5a:	0d c0       	rjmp	.+26     	; 0x4f76 <plan_buffer_line+0x236>
    4f5c:	22 e3       	ldi	r18, 0x32	; 50
    4f5e:	2a 9d       	mul	r18, r10
    4f60:	f0 01       	movw	r30, r0
    4f62:	2b 9d       	mul	r18, r11
    4f64:	f0 0d       	add	r31, r0
    4f66:	11 24       	eor	r1, r1
    4f68:	e5 5a       	subi	r30, 0xA5	; 165
    4f6a:	fd 4f       	sbci	r31, 0xFD	; 253
    4f6c:	62 a7       	std	Z+42, r22	; 0x2a
    4f6e:	73 a7       	std	Z+43, r23	; 0x2b
    4f70:	84 a7       	std	Z+44, r24	; 0x2c
    4f72:	95 a7       	std	Z+45, r25	; 0x2d
    4f74:	22 c0       	rjmp	.+68     	; 0x4fba <plan_buffer_line+0x27a>
    4f76:	25 96       	adiw	r28, 0x05	; 5
    4f78:	ee ad       	ldd	r30, Y+62	; 0x3e
    4f7a:	ff ad       	ldd	r31, Y+63	; 0x3f
    4f7c:	25 97       	sbiw	r28, 0x05	; 5
    4f7e:	20 81       	ld	r18, Z
    4f80:	31 81       	ldd	r19, Z+1	; 0x01
    4f82:	42 81       	ldd	r20, Z+2	; 0x02
    4f84:	53 81       	ldd	r21, Z+3	; 0x03
    4f86:	82 e3       	ldi	r24, 0x32	; 50
    4f88:	8a 9d       	mul	r24, r10
    4f8a:	f0 01       	movw	r30, r0
    4f8c:	8b 9d       	mul	r24, r11
    4f8e:	f0 0d       	add	r31, r0
    4f90:	11 24       	eor	r1, r1
    4f92:	e5 5a       	subi	r30, 0xA5	; 165
    4f94:	fd 4f       	sbci	r31, 0xFD	; 253
    4f96:	22 a7       	std	Z+42, r18	; 0x2a
    4f98:	33 a7       	std	Z+43, r19	; 0x2b
    4f9a:	44 a7       	std	Z+44, r20	; 0x2c
    4f9c:	55 a7       	std	Z+45, r21	; 0x2d
    4f9e:	13 ff       	sbrs	r17, 3
    4fa0:	0c c0       	rjmp	.+24     	; 0x4fba <plan_buffer_line+0x27a>
    4fa2:	7f 01       	movw	r14, r30
    4fa4:	66 8d       	ldd	r22, Z+30	; 0x1e
    4fa6:	77 8d       	ldd	r23, Z+31	; 0x1f
    4fa8:	80 a1       	ldd	r24, Z+32	; 0x20
    4faa:	91 a1       	ldd	r25, Z+33	; 0x21
    4fac:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    4fb0:	f7 01       	movw	r30, r14
    4fb2:	62 a7       	std	Z+42, r22	; 0x2a
    4fb4:	73 a7       	std	Z+43, r23	; 0x2b
    4fb6:	84 a7       	std	Z+44, r24	; 0x2c
    4fb8:	95 a7       	std	Z+45, r25	; 0x2d
    4fba:	90 91 59 02 	lds	r25, 0x0259	; 0x800259 <block_buffer_head>
    4fbe:	80 91 5a 02 	lds	r24, 0x025A	; 0x80025a <block_buffer_tail>
    4fc2:	98 17       	cp	r25, r24
    4fc4:	11 f0       	breq	.+4      	; 0x4fca <plan_buffer_line+0x28a>
    4fc6:	11 ff       	sbrs	r17, 1
    4fc8:	11 c0       	rjmp	.+34     	; 0x4fec <plan_buffer_line+0x2ac>
    4fca:	82 e3       	ldi	r24, 0x32	; 50
    4fcc:	8a 9d       	mul	r24, r10
    4fce:	f0 01       	movw	r30, r0
    4fd0:	8b 9d       	mul	r24, r11
    4fd2:	f0 0d       	add	r31, r0
    4fd4:	11 24       	eor	r1, r1
    4fd6:	e5 5a       	subi	r30, 0xA5	; 165
    4fd8:	fd 4f       	sbci	r31, 0xFD	; 253
    4fda:	12 8a       	std	Z+18, r1	; 0x12
    4fdc:	13 8a       	std	Z+19, r1	; 0x13
    4fde:	14 8a       	std	Z+20, r1	; 0x14
    4fe0:	15 8a       	std	Z+21, r1	; 0x15
    4fe2:	12 a2       	std	Z+34, r1	; 0x22
    4fe4:	13 a2       	std	Z+35, r1	; 0x23
    4fe6:	14 a2       	std	Z+36, r1	; 0x24
    4fe8:	15 a2       	std	Z+37, r1	; 0x25
    4fea:	d8 c0       	rjmp	.+432    	; 0x519c <plan_buffer_line+0x45c>
    4fec:	07 e4       	ldi	r16, 0x47	; 71
    4fee:	12 e0       	ldi	r17, 0x02	; 2
    4ff0:	1e 01       	movw	r2, r28
    4ff2:	f5 e2       	ldi	r31, 0x25	; 37
    4ff4:	2f 0e       	add	r2, r31
    4ff6:	31 1c       	adc	r3, r1
    4ff8:	41 01       	movw	r8, r2
    4ffa:	19 aa       	std	Y+49, r1	; 0x31
    4ffc:	1a aa       	std	Y+50, r1	; 0x32
    4ffe:	1b aa       	std	Y+51, r1	; 0x33
    5000:	1c aa       	std	Y+52, r1	; 0x34
    5002:	f8 01       	movw	r30, r16
    5004:	c1 90       	ld	r12, Z+
    5006:	d1 90       	ld	r13, Z+
    5008:	e1 90       	ld	r14, Z+
    500a:	f1 90       	ld	r15, Z+
    500c:	8f 01       	movw	r16, r30
    500e:	23 96       	adiw	r28, 0x03	; 3
    5010:	ee ad       	ldd	r30, Y+62	; 0x3e
    5012:	ff ad       	ldd	r31, Y+63	; 0x3f
    5014:	23 97       	sbiw	r28, 0x03	; 3
    5016:	41 90       	ld	r4, Z+
    5018:	51 90       	ld	r5, Z+
    501a:	61 90       	ld	r6, Z+
    501c:	71 90       	ld	r7, Z+
    501e:	23 96       	adiw	r28, 0x03	; 3
    5020:	ff af       	std	Y+63, r31	; 0x3f
    5022:	ee af       	std	Y+62, r30	; 0x3e
    5024:	23 97       	sbiw	r28, 0x03	; 3
    5026:	a3 01       	movw	r20, r6
    5028:	92 01       	movw	r18, r4
    502a:	c7 01       	movw	r24, r14
    502c:	b6 01       	movw	r22, r12
    502e:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    5032:	9b 01       	movw	r18, r22
    5034:	ac 01       	movw	r20, r24
    5036:	69 a9       	ldd	r22, Y+49	; 0x31
    5038:	7a a9       	ldd	r23, Y+50	; 0x32
    503a:	8b a9       	ldd	r24, Y+51	; 0x33
    503c:	9c a9       	ldd	r25, Y+52	; 0x34
    503e:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    5042:	69 ab       	std	Y+49, r22	; 0x31
    5044:	7a ab       	std	Y+50, r23	; 0x32
    5046:	8b ab       	std	Y+51, r24	; 0x33
    5048:	9c ab       	std	Y+52, r25	; 0x34
    504a:	a7 01       	movw	r20, r14
    504c:	96 01       	movw	r18, r12
    504e:	c3 01       	movw	r24, r6
    5050:	b2 01       	movw	r22, r4
    5052:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    5056:	f1 01       	movw	r30, r2
    5058:	61 93       	st	Z+, r22
    505a:	71 93       	st	Z+, r23
    505c:	81 93       	st	Z+, r24
    505e:	91 93       	st	Z+, r25
    5060:	1f 01       	movw	r2, r30
    5062:	23 96       	adiw	r28, 0x03	; 3
    5064:	2e ad       	ldd	r18, Y+62	; 0x3e
    5066:	3f ad       	ldd	r19, Y+63	; 0x3f
    5068:	23 97       	sbiw	r28, 0x03	; 3
    506a:	28 15       	cp	r18, r8
    506c:	39 05       	cpc	r19, r9
    506e:	49 f6       	brne	.-110    	; 0x5002 <plan_buffer_line+0x2c2>
    5070:	2f ee       	ldi	r18, 0xEF	; 239
    5072:	3f ef       	ldi	r19, 0xFF	; 255
    5074:	4f e7       	ldi	r20, 0x7F	; 127
    5076:	5f e3       	ldi	r21, 0x3F	; 63
    5078:	69 a9       	ldd	r22, Y+49	; 0x31
    507a:	7a a9       	ldd	r23, Y+50	; 0x32
    507c:	8b a9       	ldd	r24, Y+51	; 0x33
    507e:	9c a9       	ldd	r25, Y+52	; 0x34
    5080:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    5084:	18 16       	cp	r1, r24
    5086:	6c f4       	brge	.+26     	; 0x50a2 <plan_buffer_line+0x362>
    5088:	82 e3       	ldi	r24, 0x32	; 50
    508a:	8a 9d       	mul	r24, r10
    508c:	f0 01       	movw	r30, r0
    508e:	8b 9d       	mul	r24, r11
    5090:	f0 0d       	add	r31, r0
    5092:	11 24       	eor	r1, r1
    5094:	e5 5a       	subi	r30, 0xA5	; 165
    5096:	fd 4f       	sbci	r31, 0xFD	; 253
    5098:	12 a2       	std	Z+34, r1	; 0x22
    509a:	13 a2       	std	Z+35, r1	; 0x23
    509c:	14 a2       	std	Z+36, r1	; 0x24
    509e:	15 a2       	std	Z+37, r1	; 0x25
    50a0:	7d c0       	rjmp	.+250    	; 0x519c <plan_buffer_line+0x45c>
    50a2:	2f ee       	ldi	r18, 0xEF	; 239
    50a4:	3f ef       	ldi	r19, 0xFF	; 255
    50a6:	4f e7       	ldi	r20, 0x7F	; 127
    50a8:	5f eb       	ldi	r21, 0xBF	; 191
    50aa:	69 a9       	ldd	r22, Y+49	; 0x31
    50ac:	7a a9       	ldd	r23, Y+50	; 0x32
    50ae:	8b a9       	ldd	r24, Y+51	; 0x33
    50b0:	9c a9       	ldd	r25, Y+52	; 0x34
    50b2:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    50b6:	88 23       	and	r24, r24
    50b8:	8c f4       	brge	.+34     	; 0x50dc <plan_buffer_line+0x39c>
    50ba:	82 e3       	ldi	r24, 0x32	; 50
    50bc:	8a 9d       	mul	r24, r10
    50be:	f0 01       	movw	r30, r0
    50c0:	8b 9d       	mul	r24, r11
    50c2:	f0 0d       	add	r31, r0
    50c4:	11 24       	eor	r1, r1
    50c6:	e5 5a       	subi	r30, 0xA5	; 165
    50c8:	fd 4f       	sbci	r31, 0xFD	; 253
    50ca:	89 e9       	ldi	r24, 0x99	; 153
    50cc:	96 e7       	ldi	r25, 0x76	; 118
    50ce:	a6 e9       	ldi	r26, 0x96	; 150
    50d0:	be e7       	ldi	r27, 0x7E	; 126
    50d2:	82 a3       	std	Z+34, r24	; 0x22
    50d4:	93 a3       	std	Z+35, r25	; 0x23
    50d6:	a4 a3       	std	Z+36, r26	; 0x24
    50d8:	b5 a3       	std	Z+37, r27	; 0x25
    50da:	60 c0       	rjmp	.+192    	; 0x519c <plan_buffer_line+0x45c>
    50dc:	ce 01       	movw	r24, r28
    50de:	85 96       	adiw	r24, 0x25	; 37
    50e0:	0e 94 0f 2b 	call	0x561e	; 0x561e <convert_delta_vector_to_unit_vector>
    50e4:	be 01       	movw	r22, r28
    50e6:	6b 5d       	subi	r22, 0xDB	; 219
    50e8:	7f 4f       	sbci	r23, 0xFF	; 255
    50ea:	86 e2       	ldi	r24, 0x26	; 38
    50ec:	97 e0       	ldi	r25, 0x07	; 7
    50ee:	0e 94 76 2b 	call	0x56ec	; 0x56ec <limit_value_by_axis_maximum>
    50f2:	6b 01       	movw	r12, r22
    50f4:	7c 01       	movw	r14, r24
    50f6:	29 a9       	ldd	r18, Y+49	; 0x31
    50f8:	3a a9       	ldd	r19, Y+50	; 0x32
    50fa:	4b a9       	ldd	r20, Y+51	; 0x33
    50fc:	5c a9       	ldd	r21, Y+52	; 0x34
    50fe:	60 e0       	ldi	r22, 0x00	; 0
    5100:	70 e0       	ldi	r23, 0x00	; 0
    5102:	80 e8       	ldi	r24, 0x80	; 128
    5104:	9f e3       	ldi	r25, 0x3F	; 63
    5106:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    510a:	20 e0       	ldi	r18, 0x00	; 0
    510c:	30 e0       	ldi	r19, 0x00	; 0
    510e:	40 e0       	ldi	r20, 0x00	; 0
    5110:	5f e3       	ldi	r21, 0x3F	; 63
    5112:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    5116:	0e 94 55 32 	call	0x64aa	; 0x64aa <sqrt>
    511a:	2b 01       	movw	r4, r22
    511c:	3c 01       	movw	r6, r24
    511e:	20 91 43 07 	lds	r18, 0x0743	; 0x800743 <settings+0x35>
    5122:	30 91 44 07 	lds	r19, 0x0744	; 0x800744 <settings+0x36>
    5126:	40 91 45 07 	lds	r20, 0x0745	; 0x800745 <settings+0x37>
    512a:	50 91 46 07 	lds	r21, 0x0746	; 0x800746 <settings+0x38>
    512e:	c7 01       	movw	r24, r14
    5130:	b6 01       	movw	r22, r12
    5132:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    5136:	a3 01       	movw	r20, r6
    5138:	92 01       	movw	r18, r4
    513a:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    513e:	6b 01       	movw	r12, r22
    5140:	7c 01       	movw	r14, r24
    5142:	a3 01       	movw	r20, r6
    5144:	92 01       	movw	r18, r4
    5146:	60 e0       	ldi	r22, 0x00	; 0
    5148:	70 e0       	ldi	r23, 0x00	; 0
    514a:	80 e8       	ldi	r24, 0x80	; 128
    514c:	9f e3       	ldi	r25, 0x3F	; 63
    514e:	0e 94 5e 2e 	call	0x5cbc	; 0x5cbc <__subsf3>
    5152:	9b 01       	movw	r18, r22
    5154:	ac 01       	movw	r20, r24
    5156:	c7 01       	movw	r24, r14
    5158:	b6 01       	movw	r22, r12
    515a:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <__divsf3>
    515e:	e6 2e       	mov	r14, r22
    5160:	f7 2e       	mov	r15, r23
    5162:	08 2f       	mov	r16, r24
    5164:	19 2f       	mov	r17, r25
    5166:	20 e0       	ldi	r18, 0x00	; 0
    5168:	30 e0       	ldi	r19, 0x00	; 0
    516a:	a9 01       	movw	r20, r18
    516c:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    5170:	88 23       	and	r24, r24
    5172:	24 f4       	brge	.+8      	; 0x517c <plan_buffer_line+0x43c>
    5174:	e1 2c       	mov	r14, r1
    5176:	f1 2c       	mov	r15, r1
    5178:	00 e0       	ldi	r16, 0x00	; 0
    517a:	10 e0       	ldi	r17, 0x00	; 0
    517c:	82 e3       	ldi	r24, 0x32	; 50
    517e:	8a 9d       	mul	r24, r10
    5180:	f0 01       	movw	r30, r0
    5182:	8b 9d       	mul	r24, r11
    5184:	f0 0d       	add	r31, r0
    5186:	11 24       	eor	r1, r1
    5188:	e5 5a       	subi	r30, 0xA5	; 165
    518a:	fd 4f       	sbci	r31, 0xFD	; 253
    518c:	4e 2d       	mov	r20, r14
    518e:	5f 2d       	mov	r21, r15
    5190:	60 2f       	mov	r22, r16
    5192:	71 2f       	mov	r23, r17
    5194:	42 a3       	std	Z+34, r20	; 0x22
    5196:	53 a3       	std	Z+35, r21	; 0x23
    5198:	64 a3       	std	Z+36, r22	; 0x24
    519a:	75 a3       	std	Z+37, r23	; 0x25
    519c:	82 e3       	ldi	r24, 0x32	; 50
    519e:	8a 9d       	mul	r24, r10
    51a0:	f0 01       	movw	r30, r0
    51a2:	8b 9d       	mul	r24, r11
    51a4:	f0 0d       	add	r31, r0
    51a6:	11 24       	eor	r1, r1
    51a8:	e5 5a       	subi	r30, 0xA5	; 165
    51aa:	fd 4f       	sbci	r31, 0xFD	; 253
    51ac:	81 89       	ldd	r24, Z+17	; 0x11
    51ae:	81 fd       	sbrc	r24, 1
    51b0:	89 c0       	rjmp	.+274    	; 0x52c4 <plan_buffer_line+0x584>
    51b2:	21 96       	adiw	r28, 0x01	; 1
    51b4:	8e ad       	ldd	r24, Y+62	; 0x3e
    51b6:	9f ad       	ldd	r25, Y+63	; 0x3f
    51b8:	21 97       	sbiw	r28, 0x01	; 1
    51ba:	0e 94 69 25 	call	0x4ad2	; 0x4ad2 <plan_compute_profile_nominal_speed>
    51be:	6b 01       	movw	r12, r22
    51c0:	7c 01       	movw	r14, r24
    51c2:	40 90 53 02 	lds	r4, 0x0253	; 0x800253 <pl+0x18>
    51c6:	50 90 54 02 	lds	r5, 0x0254	; 0x800254 <pl+0x19>
    51ca:	60 90 55 02 	lds	r6, 0x0255	; 0x800255 <pl+0x1a>
    51ce:	70 90 56 02 	lds	r7, 0x0256	; 0x800256 <pl+0x1b>
    51d2:	a3 01       	movw	r20, r6
    51d4:	92 01       	movw	r18, r4
    51d6:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    51da:	18 16       	cp	r1, r24
    51dc:	a4 f4       	brge	.+40     	; 0x5206 <plan_buffer_line+0x4c6>
    51de:	82 e3       	ldi	r24, 0x32	; 50
    51e0:	8a 9d       	mul	r24, r10
    51e2:	80 01       	movw	r16, r0
    51e4:	8b 9d       	mul	r24, r11
    51e6:	10 0d       	add	r17, r0
    51e8:	11 24       	eor	r1, r1
    51ea:	05 5a       	subi	r16, 0xA5	; 165
    51ec:	1d 4f       	sbci	r17, 0xFD	; 253
    51ee:	a3 01       	movw	r20, r6
    51f0:	92 01       	movw	r18, r4
    51f2:	c3 01       	movw	r24, r6
    51f4:	b2 01       	movw	r22, r4
    51f6:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    51fa:	f8 01       	movw	r30, r16
    51fc:	66 8b       	std	Z+22, r22	; 0x16
    51fe:	77 8b       	std	Z+23, r23	; 0x17
    5200:	80 8f       	std	Z+24, r24	; 0x18
    5202:	91 8f       	std	Z+25, r25	; 0x19
    5204:	13 c0       	rjmp	.+38     	; 0x522c <plan_buffer_line+0x4ec>
    5206:	82 e3       	ldi	r24, 0x32	; 50
    5208:	8a 9d       	mul	r24, r10
    520a:	80 01       	movw	r16, r0
    520c:	8b 9d       	mul	r24, r11
    520e:	10 0d       	add	r17, r0
    5210:	11 24       	eor	r1, r1
    5212:	05 5a       	subi	r16, 0xA5	; 165
    5214:	1d 4f       	sbci	r17, 0xFD	; 253
    5216:	a7 01       	movw	r20, r14
    5218:	96 01       	movw	r18, r12
    521a:	c7 01       	movw	r24, r14
    521c:	b6 01       	movw	r22, r12
    521e:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    5222:	f8 01       	movw	r30, r16
    5224:	66 8b       	std	Z+22, r22	; 0x16
    5226:	77 8b       	std	Z+23, r23	; 0x17
    5228:	80 8f       	std	Z+24, r24	; 0x18
    522a:	91 8f       	std	Z+25, r25	; 0x19
    522c:	82 e3       	ldi	r24, 0x32	; 50
    522e:	8a 9d       	mul	r24, r10
    5230:	f0 01       	movw	r30, r0
    5232:	8b 9d       	mul	r24, r11
    5234:	f0 0d       	add	r31, r0
    5236:	11 24       	eor	r1, r1
    5238:	e5 5a       	subi	r30, 0xA5	; 165
    523a:	fd 4f       	sbci	r31, 0xFD	; 253
    523c:	42 a0       	ldd	r4, Z+34	; 0x22
    523e:	53 a0       	ldd	r5, Z+35	; 0x23
    5240:	64 a0       	ldd	r6, Z+36	; 0x24
    5242:	75 a0       	ldd	r7, Z+37	; 0x25
    5244:	a3 01       	movw	r20, r6
    5246:	92 01       	movw	r18, r4
    5248:	66 89       	ldd	r22, Z+22	; 0x16
    524a:	77 89       	ldd	r23, Z+23	; 0x17
    524c:	80 8d       	ldd	r24, Z+24	; 0x18
    524e:	91 8d       	ldd	r25, Z+25	; 0x19
    5250:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    5254:	18 16       	cp	r1, r24
    5256:	64 f4       	brge	.+24     	; 0x5270 <plan_buffer_line+0x530>
    5258:	82 e3       	ldi	r24, 0x32	; 50
    525a:	8a 9d       	mul	r24, r10
    525c:	f0 01       	movw	r30, r0
    525e:	8b 9d       	mul	r24, r11
    5260:	f0 0d       	add	r31, r0
    5262:	11 24       	eor	r1, r1
    5264:	e5 5a       	subi	r30, 0xA5	; 165
    5266:	fd 4f       	sbci	r31, 0xFD	; 253
    5268:	46 8a       	std	Z+22, r4	; 0x16
    526a:	57 8a       	std	Z+23, r5	; 0x17
    526c:	60 8e       	std	Z+24, r6	; 0x18
    526e:	71 8e       	std	Z+25, r7	; 0x19
    5270:	c0 92 53 02 	sts	0x0253, r12	; 0x800253 <pl+0x18>
    5274:	d0 92 54 02 	sts	0x0254, r13	; 0x800254 <pl+0x19>
    5278:	e0 92 55 02 	sts	0x0255, r14	; 0x800255 <pl+0x1a>
    527c:	f0 92 56 02 	sts	0x0256, r15	; 0x800256 <pl+0x1b>
    5280:	8c e0       	ldi	r24, 0x0C	; 12
    5282:	fe 01       	movw	r30, r28
    5284:	79 96       	adiw	r30, 0x19	; 25
    5286:	a7 e4       	ldi	r26, 0x47	; 71
    5288:	b2 e0       	ldi	r27, 0x02	; 2
    528a:	01 90       	ld	r0, Z+
    528c:	0d 92       	st	X+, r0
    528e:	8a 95       	dec	r24
    5290:	e1 f7       	brne	.-8      	; 0x528a <plan_buffer_line+0x54a>
    5292:	8c e0       	ldi	r24, 0x0C	; 12
    5294:	fe 01       	movw	r30, r28
    5296:	31 96       	adiw	r30, 0x01	; 1
    5298:	ab e3       	ldi	r26, 0x3B	; 59
    529a:	b2 e0       	ldi	r27, 0x02	; 2
    529c:	01 90       	ld	r0, Z+
    529e:	0d 92       	st	X+, r0
    52a0:	8a 95       	dec	r24
    52a2:	e1 f7       	brne	.-8      	; 0x529c <plan_buffer_line+0x55c>
    52a4:	80 91 58 02 	lds	r24, 0x0258	; 0x800258 <next_buffer_head>
    52a8:	80 93 59 02 	sts	0x0259, r24	; 0x800259 <block_buffer_head>
    52ac:	8f 5f       	subi	r24, 0xFF	; 255
    52ae:	80 31       	cpi	r24, 0x10	; 16
    52b0:	09 f4       	brne	.+2      	; 0x52b4 <plan_buffer_line+0x574>
    52b2:	80 e0       	ldi	r24, 0x00	; 0
    52b4:	80 93 58 02 	sts	0x0258, r24	; 0x800258 <next_buffer_head>
    52b8:	0e 94 a1 23 	call	0x4742	; 0x4742 <planner_recalculate>
    52bc:	81 e0       	ldi	r24, 0x01	; 1
    52be:	39 c0       	rjmp	.+114    	; 0x5332 <plan_buffer_line+0x5f2>
    52c0:	80 e0       	ldi	r24, 0x00	; 0
    52c2:	37 c0       	rjmp	.+110    	; 0x5332 <plan_buffer_line+0x5f2>
    52c4:	81 e0       	ldi	r24, 0x01	; 1
    52c6:	35 c0       	rjmp	.+106    	; 0x5332 <plan_buffer_line+0x5f2>
    52c8:	89 af       	std	Y+57, r24	; 0x39
    52ca:	9a af       	std	Y+58, r25	; 0x3a
    52cc:	2e e0       	ldi	r18, 0x0E	; 14
    52ce:	37 e0       	ldi	r19, 0x07	; 7
    52d0:	3c af       	std	Y+60, r19	; 0x3c
    52d2:	2b af       	std	Y+59, r18	; 0x3b
    52d4:	ae 01       	movw	r20, r28
    52d6:	4f 5f       	subi	r20, 0xFF	; 255
    52d8:	5f 4f       	sbci	r21, 0xFF	; 255
    52da:	4a 01       	movw	r8, r20
    52dc:	6e 01       	movw	r12, r28
    52de:	5d e0       	ldi	r21, 0x0D	; 13
    52e0:	c5 0e       	add	r12, r21
    52e2:	d1 1c       	adc	r13, r1
    52e4:	62 e3       	ldi	r22, 0x32	; 50
    52e6:	26 9e       	mul	r2, r22
    52e8:	c0 01       	movw	r24, r0
    52ea:	11 24       	eor	r1, r1
    52ec:	fc 01       	movw	r30, r24
    52ee:	e5 5a       	subi	r30, 0xA5	; 165
    52f0:	fd 4f       	sbci	r31, 0xFD	; 253
    52f2:	1f 01       	movw	r2, r30
    52f4:	9e 01       	movw	r18, r28
    52f6:	27 5e       	subi	r18, 0xE7	; 231
    52f8:	3f 4f       	sbci	r19, 0xFF	; 255
    52fa:	23 96       	adiw	r28, 0x03	; 3
    52fc:	3f af       	std	Y+63, r19	; 0x3f
    52fe:	2e af       	std	Y+62, r18	; 0x3e
    5300:	23 97       	sbiw	r28, 0x03	; 3
    5302:	3e af       	std	Y+62, r19	; 0x3e
    5304:	2d af       	std	Y+61, r18	; 0x3d
    5306:	10 e0       	ldi	r17, 0x00	; 0
    5308:	22 e3       	ldi	r18, 0x32	; 50
    530a:	2a 9d       	mul	r18, r10
    530c:	c0 01       	movw	r24, r0
    530e:	2b 9d       	mul	r18, r11
    5310:	90 0d       	add	r25, r0
    5312:	11 24       	eor	r1, r1
    5314:	85 5a       	subi	r24, 0xA5	; 165
    5316:	9d 4f       	sbci	r25, 0xFD	; 253
    5318:	7c 01       	movw	r14, r24
    531a:	3c e0       	ldi	r19, 0x0C	; 12
    531c:	e3 0e       	add	r14, r19
    531e:	f1 1c       	adc	r15, r1
    5320:	ac 01       	movw	r20, r24
    5322:	40 5f       	subi	r20, 0xF0	; 240
    5324:	5f 4f       	sbci	r21, 0xFF	; 255
    5326:	27 96       	adiw	r28, 0x07	; 7
    5328:	5f af       	std	Y+63, r21	; 0x3f
    532a:	4e af       	std	Y+62, r20	; 0x3e
    532c:	27 97       	sbiw	r28, 0x07	; 7
    532e:	19 ab       	std	Y+49, r17	; 0x31
    5330:	68 cd       	rjmp	.-1328   	; 0x4e02 <plan_buffer_line+0xc2>
    5332:	ca 5b       	subi	r28, 0xBA	; 186
    5334:	df 4f       	sbci	r29, 0xFF	; 255
    5336:	0f b6       	in	r0, 0x3f	; 63
    5338:	f8 94       	cli
    533a:	de bf       	out	0x3e, r29	; 62
    533c:	0f be       	out	0x3f, r0	; 63
    533e:	cd bf       	out	0x3d, r28	; 61
    5340:	df 91       	pop	r29
    5342:	cf 91       	pop	r28
    5344:	1f 91       	pop	r17
    5346:	0f 91       	pop	r16
    5348:	ff 90       	pop	r15
    534a:	ef 90       	pop	r14
    534c:	df 90       	pop	r13
    534e:	cf 90       	pop	r12
    5350:	bf 90       	pop	r11
    5352:	af 90       	pop	r10
    5354:	9f 90       	pop	r9
    5356:	8f 90       	pop	r8
    5358:	7f 90       	pop	r7
    535a:	6f 90       	pop	r6
    535c:	5f 90       	pop	r5
    535e:	4f 90       	pop	r4
    5360:	3f 90       	pop	r3
    5362:	2f 90       	pop	r2
    5364:	08 95       	ret

00005366 <plan_sync_position>:
    5366:	ec e9       	ldi	r30, 0x9C	; 156
    5368:	f5 e0       	ldi	r31, 0x05	; 5
    536a:	ab e3       	ldi	r26, 0x3B	; 59
    536c:	b2 e0       	ldi	r27, 0x02	; 2
    536e:	88 ea       	ldi	r24, 0xA8	; 168
    5370:	95 e0       	ldi	r25, 0x05	; 5
    5372:	41 91       	ld	r20, Z+
    5374:	51 91       	ld	r21, Z+
    5376:	61 91       	ld	r22, Z+
    5378:	71 91       	ld	r23, Z+
    537a:	4d 93       	st	X+, r20
    537c:	5d 93       	st	X+, r21
    537e:	6d 93       	st	X+, r22
    5380:	7d 93       	st	X+, r23
    5382:	e8 17       	cp	r30, r24
    5384:	f9 07       	cpc	r31, r25
    5386:	a9 f7       	brne	.-22     	; 0x5372 <plan_sync_position+0xc>
    5388:	08 95       	ret

0000538a <plan_cycle_reinitialize>:
// Re-initialize buffer plan with a partially completed block, assumed to exist at the buffer tail.
// Called after a steppers have come to a complete stop for a feed hold and the cycle is stopped.
void plan_cycle_reinitialize()
{
  // Re-plan from a complete stop. Reset planner entry speeds and buffer planned pointer.
  st_update_plan_block_parameters();
    538a:	0e 94 59 19 	call	0x32b2	; 0x32b2 <st_update_plan_block_parameters>
  block_buffer_planned = block_buffer_tail;
    538e:	80 91 5a 02 	lds	r24, 0x025A	; 0x80025a <block_buffer_tail>
    5392:	80 93 57 02 	sts	0x0257, r24	; 0x800257 <block_buffer_planned>
  planner_recalculate();
    5396:	0e 94 a1 23 	call	0x4742	; 0x4742 <planner_recalculate>
    539a:	08 95       	ret

0000539c <read_float>:
// Delays variable defined microseconds. Compiler compatibility fix for _delay_us(),
// which only accepts constants in future compiler releases. Written to perform more
// efficiently with larger delays, as the counter adds parasitic time in each iteration.
void delay_us(uint32_t us)
{
  while (us) {
    539c:	4f 92       	push	r4
    539e:	5f 92       	push	r5
    53a0:	6f 92       	push	r6
    53a2:	7f 92       	push	r7
    53a4:	8f 92       	push	r8
    53a6:	9f 92       	push	r9
    53a8:	af 92       	push	r10
    53aa:	bf 92       	push	r11
    53ac:	cf 92       	push	r12
    53ae:	df 92       	push	r13
    53b0:	ef 92       	push	r14
    53b2:	ff 92       	push	r15
    53b4:	0f 93       	push	r16
    53b6:	1f 93       	push	r17
    53b8:	cf 93       	push	r28
    53ba:	df 93       	push	r29
    53bc:	dc 01       	movw	r26, r24
    53be:	fb 01       	movw	r30, r22
    53c0:	c0 81       	ld	r28, Z
    53c2:	d0 e0       	ldi	r29, 0x00	; 0
    53c4:	fc 01       	movw	r30, r24
    53c6:	ec 0f       	add	r30, r28
    53c8:	fd 1f       	adc	r31, r29
    53ca:	90 81       	ld	r25, Z
    53cc:	9d 32       	cpi	r25, 0x2D	; 45
    53ce:	29 f4       	brne	.+10     	; 0x53da <read_float+0x3e>
    53d0:	ef 01       	movw	r28, r30
    53d2:	22 96       	adiw	r28, 0x02	; 2
    53d4:	91 81       	ldd	r25, Z+1	; 0x01
    53d6:	01 e0       	ldi	r16, 0x01	; 1
    53d8:	0b c0       	rjmp	.+22     	; 0x53f0 <read_float+0x54>
    53da:	9b 32       	cpi	r25, 0x2B	; 43
    53dc:	29 f0       	breq	.+10     	; 0x53e8 <read_float+0x4c>
    53de:	21 96       	adiw	r28, 0x01	; 1
    53e0:	ca 0f       	add	r28, r26
    53e2:	db 1f       	adc	r29, r27
    53e4:	00 e0       	ldi	r16, 0x00	; 0
    53e6:	04 c0       	rjmp	.+8      	; 0x53f0 <read_float+0x54>
    53e8:	ef 01       	movw	r28, r30
    53ea:	22 96       	adiw	r28, 0x02	; 2
    53ec:	91 81       	ldd	r25, Z+1	; 0x01
    53ee:	00 e0       	ldi	r16, 0x00	; 0
    53f0:	80 e0       	ldi	r24, 0x00	; 0
    53f2:	20 e0       	ldi	r18, 0x00	; 0
    53f4:	10 e0       	ldi	r17, 0x00	; 0
    53f6:	41 2c       	mov	r4, r1
    53f8:	51 2c       	mov	r5, r1
    53fa:	32 01       	movw	r6, r4
    53fc:	31 e0       	ldi	r19, 0x01	; 1
    53fe:	fe 01       	movw	r30, r28
    5400:	90 53       	subi	r25, 0x30	; 48
    5402:	9a 30       	cpi	r25, 0x0A	; 10
    5404:	10 f5       	brcc	.+68     	; 0x544a <read_float+0xae>
    5406:	2f 5f       	subi	r18, 0xFF	; 255
    5408:	29 30       	cpi	r18, 0x09	; 9
    540a:	d8 f4       	brcc	.+54     	; 0x5442 <read_float+0xa6>
    540c:	81 11       	cpse	r24, r1
    540e:	11 50       	subi	r17, 0x01	; 1
    5410:	53 01       	movw	r10, r6
    5412:	42 01       	movw	r8, r4
    5414:	88 0c       	add	r8, r8
    5416:	99 1c       	adc	r9, r9
    5418:	aa 1c       	adc	r10, r10
    541a:	bb 1c       	adc	r11, r11
    541c:	88 0c       	add	r8, r8
    541e:	99 1c       	adc	r9, r9
    5420:	aa 1c       	adc	r10, r10
    5422:	bb 1c       	adc	r11, r11
    5424:	84 0c       	add	r8, r4
    5426:	95 1c       	adc	r9, r5
    5428:	a6 1c       	adc	r10, r6
    542a:	b7 1c       	adc	r11, r7
    542c:	88 0c       	add	r8, r8
    542e:	99 1c       	adc	r9, r9
    5430:	aa 1c       	adc	r10, r10
    5432:	bb 1c       	adc	r11, r11
    5434:	24 01       	movw	r4, r8
    5436:	35 01       	movw	r6, r10
    5438:	49 0e       	add	r4, r25
    543a:	51 1c       	adc	r5, r1
    543c:	61 1c       	adc	r6, r1
    543e:	71 1c       	adc	r7, r1
    5440:	09 c0       	rjmp	.+18     	; 0x5454 <read_float+0xb8>
    5442:	81 11       	cpse	r24, r1
    5444:	07 c0       	rjmp	.+14     	; 0x5454 <read_float+0xb8>
    5446:	1f 5f       	subi	r17, 0xFF	; 255
    5448:	05 c0       	rjmp	.+10     	; 0x5454 <read_float+0xb8>
    544a:	9e 3f       	cpi	r25, 0xFE	; 254
    544c:	31 f4       	brne	.+12     	; 0x545a <read_float+0xbe>
    544e:	81 11       	cpse	r24, r1
    5450:	04 c0       	rjmp	.+8      	; 0x545a <read_float+0xbe>
    5452:	83 2f       	mov	r24, r19
    5454:	90 81       	ld	r25, Z
    5456:	21 96       	adiw	r28, 0x01	; 1
    5458:	d2 cf       	rjmp	.-92     	; 0x53fe <read_float+0x62>
    545a:	22 23       	and	r18, r18
    545c:	09 f4       	brne	.+2      	; 0x5460 <read_float+0xc4>
    545e:	52 c0       	rjmp	.+164    	; 0x5504 <read_float+0x168>
    5460:	6a 01       	movw	r12, r20
    5462:	7b 01       	movw	r14, r22
    5464:	5d 01       	movw	r10, r26
    5466:	c3 01       	movw	r24, r6
    5468:	b2 01       	movw	r22, r4
    546a:	0e 94 06 30 	call	0x600c	; 0x600c <__floatunsisf>
    546e:	2b 01       	movw	r4, r22
    5470:	3c 01       	movw	r6, r24
    5472:	20 e0       	ldi	r18, 0x00	; 0
    5474:	30 e0       	ldi	r19, 0x00	; 0
    5476:	a9 01       	movw	r20, r18
    5478:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    547c:	88 23       	and	r24, r24
    547e:	51 f1       	breq	.+84     	; 0x54d4 <read_float+0x138>
    5480:	1f 3f       	cpi	r17, 0xFF	; 255
    5482:	6c f4       	brge	.+26     	; 0x549e <read_float+0x102>
    5484:	2a e0       	ldi	r18, 0x0A	; 10
    5486:	37 ed       	ldi	r19, 0xD7	; 215
    5488:	43 e2       	ldi	r20, 0x23	; 35
    548a:	5c e3       	ldi	r21, 0x3C	; 60
    548c:	c3 01       	movw	r24, r6
    548e:	b2 01       	movw	r22, r4
    5490:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    5494:	2b 01       	movw	r4, r22
    5496:	3c 01       	movw	r6, r24
    5498:	1e 5f       	subi	r17, 0xFE	; 254
    549a:	1f 3f       	cpi	r17, 0xFF	; 255
    549c:	9c f3       	brlt	.-26     	; 0x5484 <read_float+0xe8>
    549e:	11 23       	and	r17, r17
    54a0:	5c f4       	brge	.+22     	; 0x54b8 <read_float+0x11c>
    54a2:	2d ec       	ldi	r18, 0xCD	; 205
    54a4:	3c ec       	ldi	r19, 0xCC	; 204
    54a6:	4c ec       	ldi	r20, 0xCC	; 204
    54a8:	5d e3       	ldi	r21, 0x3D	; 61
    54aa:	c3 01       	movw	r24, r6
    54ac:	b2 01       	movw	r22, r4
    54ae:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    54b2:	2b 01       	movw	r4, r22
    54b4:	3c 01       	movw	r6, r24
    54b6:	0e c0       	rjmp	.+28     	; 0x54d4 <read_float+0x138>
    54b8:	11 16       	cp	r1, r17
    54ba:	64 f4       	brge	.+24     	; 0x54d4 <read_float+0x138>
    54bc:	20 e0       	ldi	r18, 0x00	; 0
    54be:	30 e0       	ldi	r19, 0x00	; 0
    54c0:	40 e2       	ldi	r20, 0x20	; 32
    54c2:	51 e4       	ldi	r21, 0x41	; 65
    54c4:	c3 01       	movw	r24, r6
    54c6:	b2 01       	movw	r22, r4
    54c8:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    54cc:	2b 01       	movw	r4, r22
    54ce:	3c 01       	movw	r6, r24
    54d0:	11 50       	subi	r17, 0x01	; 1
    54d2:	a1 f7       	brne	.-24     	; 0x54bc <read_float+0x120>
    54d4:	00 23       	and	r16, r16
    54d6:	51 f0       	breq	.+20     	; 0x54ec <read_float+0x150>
    54d8:	77 fa       	bst	r7, 7
    54da:	70 94       	com	r7
    54dc:	77 f8       	bld	r7, 7
    54de:	70 94       	com	r7
    54e0:	f6 01       	movw	r30, r12
    54e2:	40 82       	st	Z, r4
    54e4:	51 82       	std	Z+1, r5	; 0x01
    54e6:	62 82       	std	Z+2, r6	; 0x02
    54e8:	73 82       	std	Z+3, r7	; 0x03
    54ea:	05 c0       	rjmp	.+10     	; 0x54f6 <read_float+0x15a>
    54ec:	f6 01       	movw	r30, r12
    54ee:	40 82       	st	Z, r4
    54f0:	51 82       	std	Z+1, r5	; 0x01
    54f2:	62 82       	std	Z+2, r6	; 0x02
    54f4:	73 82       	std	Z+3, r7	; 0x03
    54f6:	ca 19       	sub	r28, r10
    54f8:	db 09       	sbc	r29, r11
    54fa:	c1 50       	subi	r28, 0x01	; 1
    54fc:	f7 01       	movw	r30, r14
    54fe:	c0 83       	st	Z, r28
    5500:	81 e0       	ldi	r24, 0x01	; 1
    5502:	01 c0       	rjmp	.+2      	; 0x5506 <read_float+0x16a>
    5504:	80 e0       	ldi	r24, 0x00	; 0
    5506:	df 91       	pop	r29
    5508:	cf 91       	pop	r28
    550a:	1f 91       	pop	r17
    550c:	0f 91       	pop	r16
    550e:	ff 90       	pop	r15
    5510:	ef 90       	pop	r14
    5512:	df 90       	pop	r13
    5514:	cf 90       	pop	r12
    5516:	bf 90       	pop	r11
    5518:	af 90       	pop	r10
    551a:	9f 90       	pop	r9
    551c:	8f 90       	pop	r8
    551e:	7f 90       	pop	r7
    5520:	6f 90       	pop	r6
    5522:	5f 90       	pop	r5
    5524:	4f 90       	pop	r4
    5526:	08 95       	ret

00005528 <delay_sec>:
    5528:	ff 92       	push	r15
    552a:	0f 93       	push	r16
    552c:	1f 93       	push	r17
    552e:	cf 93       	push	r28
    5530:	df 93       	push	r29
    5532:	f4 2e       	mov	r15, r20
    5534:	20 e0       	ldi	r18, 0x00	; 0
    5536:	30 e0       	ldi	r19, 0x00	; 0
    5538:	40 ea       	ldi	r20, 0xA0	; 160
    553a:	51 e4       	ldi	r21, 0x41	; 65
    553c:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    5540:	0e 94 3d 2f 	call	0x5e7a	; 0x5e7a <ceil>
    5544:	0e 94 d7 2f 	call	0x5fae	; 0x5fae <__fixunssfsi>
    5548:	61 15       	cp	r22, r1
    554a:	71 05       	cpc	r23, r1
    554c:	21 f1       	breq	.+72     	; 0x5596 <delay_sec+0x6e>
    554e:	20 91 7d 05 	lds	r18, 0x057D	; 0x80057d <sys+0x1>
    5552:	21 11       	cpse	r18, r1
    5554:	20 c0       	rjmp	.+64     	; 0x5596 <delay_sec+0x6e>
    5556:	eb 01       	movw	r28, r22
    5558:	0c e7       	ldi	r16, 0x7C	; 124
    555a:	15 e0       	ldi	r17, 0x05	; 5
    555c:	05 c0       	rjmp	.+10     	; 0x5568 <delay_sec+0x40>
    555e:	21 97       	sbiw	r28, 0x01	; 1
    5560:	f8 01       	movw	r30, r16
    5562:	81 81       	ldd	r24, Z+1	; 0x01
    5564:	81 11       	cpse	r24, r1
    5566:	17 c0       	rjmp	.+46     	; 0x5596 <delay_sec+0x6e>
    5568:	f1 10       	cpse	r15, r1
    556a:	03 c0       	rjmp	.+6      	; 0x5572 <delay_sec+0x4a>
    556c:	0e 94 9e 14 	call	0x293c	; 0x293c <protocol_execute_realtime>
    5570:	06 c0       	rjmp	.+12     	; 0x557e <delay_sec+0x56>
    5572:	0e 94 da 12 	call	0x25b4	; 0x25b4 <protocol_exec_rt_system>
    5576:	f8 01       	movw	r30, r16
    5578:	82 81       	ldd	r24, Z+2	; 0x02
    557a:	81 fd       	sbrc	r24, 1
    557c:	0c c0       	rjmp	.+24     	; 0x5596 <delay_sec+0x6e>
    557e:	ff ef       	ldi	r31, 0xFF	; 255
    5580:	20 e7       	ldi	r18, 0x70	; 112
    5582:	82 e0       	ldi	r24, 0x02	; 2
    5584:	f1 50       	subi	r31, 0x01	; 1
    5586:	20 40       	sbci	r18, 0x00	; 0
    5588:	80 40       	sbci	r24, 0x00	; 0
    558a:	e1 f7       	brne	.-8      	; 0x5584 <delay_sec+0x5c>
    558c:	00 c0       	rjmp	.+0      	; 0x558e <delay_sec+0x66>
    558e:	00 00       	nop
    5590:	c1 30       	cpi	r28, 0x01	; 1
    5592:	d1 05       	cpc	r29, r1
    5594:	21 f7       	brne	.-56     	; 0x555e <delay_sec+0x36>
    5596:	df 91       	pop	r29
    5598:	cf 91       	pop	r28
    559a:	1f 91       	pop	r17
    559c:	0f 91       	pop	r16
    559e:	ff 90       	pop	r15
    55a0:	08 95       	ret

000055a2 <delay_ms>:
    55a2:	00 97       	sbiw	r24, 0x00	; 0
    55a4:	41 f0       	breq	.+16     	; 0x55b6 <delay_ms+0x14>
    55a6:	ef e9       	ldi	r30, 0x9F	; 159
    55a8:	ff e0       	ldi	r31, 0x0F	; 15
    55aa:	31 97       	sbiw	r30, 0x01	; 1
    55ac:	f1 f7       	brne	.-4      	; 0x55aa <delay_ms+0x8>
    55ae:	00 c0       	rjmp	.+0      	; 0x55b0 <delay_ms+0xe>
    55b0:	00 00       	nop
    55b2:	01 97       	sbiw	r24, 0x01	; 1
    55b4:	c1 f7       	brne	.-16     	; 0x55a6 <delay_ms+0x4>
    55b6:	08 95       	ret

000055b8 <hypot_f>:
  }
}


// Simple hypotenuse computation function.
float hypot_f(float x, float y) { return(sqrt(x*x + y*y)); }
    55b8:	4f 92       	push	r4
    55ba:	5f 92       	push	r5
    55bc:	6f 92       	push	r6
    55be:	7f 92       	push	r7
    55c0:	8f 92       	push	r8
    55c2:	9f 92       	push	r9
    55c4:	af 92       	push	r10
    55c6:	bf 92       	push	r11
    55c8:	cf 92       	push	r12
    55ca:	df 92       	push	r13
    55cc:	ef 92       	push	r14
    55ce:	ff 92       	push	r15
    55d0:	4b 01       	movw	r8, r22
    55d2:	5c 01       	movw	r10, r24
    55d4:	69 01       	movw	r12, r18
    55d6:	7a 01       	movw	r14, r20
    55d8:	a5 01       	movw	r20, r10
    55da:	94 01       	movw	r18, r8
    55dc:	c5 01       	movw	r24, r10
    55de:	b4 01       	movw	r22, r8
    55e0:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    55e4:	4b 01       	movw	r8, r22
    55e6:	5c 01       	movw	r10, r24
    55e8:	a7 01       	movw	r20, r14
    55ea:	96 01       	movw	r18, r12
    55ec:	c7 01       	movw	r24, r14
    55ee:	b6 01       	movw	r22, r12
    55f0:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    55f4:	9b 01       	movw	r18, r22
    55f6:	ac 01       	movw	r20, r24
    55f8:	c5 01       	movw	r24, r10
    55fa:	b4 01       	movw	r22, r8
    55fc:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    5600:	0e 94 55 32 	call	0x64aa	; 0x64aa <sqrt>
    5604:	ff 90       	pop	r15
    5606:	ef 90       	pop	r14
    5608:	df 90       	pop	r13
    560a:	cf 90       	pop	r12
    560c:	bf 90       	pop	r11
    560e:	af 90       	pop	r10
    5610:	9f 90       	pop	r9
    5612:	8f 90       	pop	r8
    5614:	7f 90       	pop	r7
    5616:	6f 90       	pop	r6
    5618:	5f 90       	pop	r5
    561a:	4f 90       	pop	r4
    561c:	08 95       	ret

0000561e <convert_delta_vector_to_unit_vector>:


float convert_delta_vector_to_unit_vector(float *vector)
{
    561e:	4f 92       	push	r4
    5620:	5f 92       	push	r5
    5622:	6f 92       	push	r6
    5624:	7f 92       	push	r7
    5626:	af 92       	push	r10
    5628:	bf 92       	push	r11
    562a:	cf 92       	push	r12
    562c:	df 92       	push	r13
    562e:	ef 92       	push	r14
    5630:	ff 92       	push	r15
    5632:	0f 93       	push	r16
    5634:	1f 93       	push	r17
    5636:	cf 93       	push	r28
    5638:	df 93       	push	r29
    563a:	ec 01       	movw	r28, r24
    563c:	5c 01       	movw	r10, r24
    563e:	8c e0       	ldi	r24, 0x0C	; 12
    5640:	a8 0e       	add	r10, r24
    5642:	b1 1c       	adc	r11, r1
    5644:	8e 01       	movw	r16, r28
  uint8_t idx;
  float magnitude = 0.0;
    5646:	41 2c       	mov	r4, r1
    5648:	51 2c       	mov	r5, r1
    564a:	32 01       	movw	r6, r4
  for (idx=0; idx<N_AXIS; idx++) {
    if (vector[idx] != 0.0) {
    564c:	f8 01       	movw	r30, r16
    564e:	c1 90       	ld	r12, Z+
    5650:	d1 90       	ld	r13, Z+
    5652:	e1 90       	ld	r14, Z+
    5654:	f1 90       	ld	r15, Z+
    5656:	8f 01       	movw	r16, r30
    5658:	20 e0       	ldi	r18, 0x00	; 0
    565a:	30 e0       	ldi	r19, 0x00	; 0
    565c:	a9 01       	movw	r20, r18
    565e:	c7 01       	movw	r24, r14
    5660:	b6 01       	movw	r22, r12
    5662:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    5666:	88 23       	and	r24, r24
    5668:	71 f0       	breq	.+28     	; 0x5686 <convert_delta_vector_to_unit_vector+0x68>
      magnitude += vector[idx]*vector[idx];
    566a:	a7 01       	movw	r20, r14
    566c:	96 01       	movw	r18, r12
    566e:	c7 01       	movw	r24, r14
    5670:	b6 01       	movw	r22, r12
    5672:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    5676:	9b 01       	movw	r18, r22
    5678:	ac 01       	movw	r20, r24
    567a:	c3 01       	movw	r24, r6
    567c:	b2 01       	movw	r22, r4
    567e:	0e 94 5f 2e 	call	0x5cbe	; 0x5cbe <__addsf3>
    5682:	2b 01       	movw	r4, r22
    5684:	3c 01       	movw	r6, r24

float convert_delta_vector_to_unit_vector(float *vector)
{
  uint8_t idx;
  float magnitude = 0.0;
  for (idx=0; idx<N_AXIS; idx++) {
    5686:	0a 15       	cp	r16, r10
    5688:	1b 05       	cpc	r17, r11
    568a:	01 f7       	brne	.-64     	; 0x564c <convert_delta_vector_to_unit_vector+0x2e>
    if (vector[idx] != 0.0) {
      magnitude += vector[idx]*vector[idx];
    }
  }
  magnitude = sqrt(magnitude);
    568c:	c3 01       	movw	r24, r6
    568e:	b2 01       	movw	r22, r4
    5690:	0e 94 55 32 	call	0x64aa	; 0x64aa <sqrt>
    5694:	2b 01       	movw	r4, r22
    5696:	3c 01       	movw	r6, r24
  float inv_magnitude = 1.0/magnitude;
    5698:	9b 01       	movw	r18, r22
    569a:	ac 01       	movw	r20, r24
    569c:	60 e0       	ldi	r22, 0x00	; 0
    569e:	70 e0       	ldi	r23, 0x00	; 0
    56a0:	80 e8       	ldi	r24, 0x80	; 128
    56a2:	9f e3       	ldi	r25, 0x3F	; 63
    56a4:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <__divsf3>
    56a8:	6b 01       	movw	r12, r22
    56aa:	7c 01       	movw	r14, r24
  for (idx=0; idx<N_AXIS; idx++) { vector[idx] *= inv_magnitude; }
    56ac:	a7 01       	movw	r20, r14
    56ae:	96 01       	movw	r18, r12
    56b0:	68 81       	ld	r22, Y
    56b2:	79 81       	ldd	r23, Y+1	; 0x01
    56b4:	8a 81       	ldd	r24, Y+2	; 0x02
    56b6:	9b 81       	ldd	r25, Y+3	; 0x03
    56b8:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    56bc:	69 93       	st	Y+, r22
    56be:	79 93       	st	Y+, r23
    56c0:	89 93       	st	Y+, r24
    56c2:	99 93       	st	Y+, r25
    56c4:	ca 15       	cp	r28, r10
    56c6:	db 05       	cpc	r29, r11
    56c8:	89 f7       	brne	.-30     	; 0x56ac <convert_delta_vector_to_unit_vector+0x8e>
  return(magnitude);
}
    56ca:	c3 01       	movw	r24, r6
    56cc:	b2 01       	movw	r22, r4
    56ce:	df 91       	pop	r29
    56d0:	cf 91       	pop	r28
    56d2:	1f 91       	pop	r17
    56d4:	0f 91       	pop	r16
    56d6:	ff 90       	pop	r15
    56d8:	ef 90       	pop	r14
    56da:	df 90       	pop	r13
    56dc:	cf 90       	pop	r12
    56de:	bf 90       	pop	r11
    56e0:	af 90       	pop	r10
    56e2:	7f 90       	pop	r7
    56e4:	6f 90       	pop	r6
    56e6:	5f 90       	pop	r5
    56e8:	4f 90       	pop	r4
    56ea:	08 95       	ret

000056ec <limit_value_by_axis_maximum>:


float limit_value_by_axis_maximum(float *max_value, float *unit_vec)
{
    56ec:	6f 92       	push	r6
    56ee:	7f 92       	push	r7
    56f0:	8f 92       	push	r8
    56f2:	9f 92       	push	r9
    56f4:	af 92       	push	r10
    56f6:	bf 92       	push	r11
    56f8:	cf 92       	push	r12
    56fa:	df 92       	push	r13
    56fc:	ef 92       	push	r14
    56fe:	ff 92       	push	r15
    5700:	0f 93       	push	r16
    5702:	1f 93       	push	r17
    5704:	cf 93       	push	r28
    5706:	df 93       	push	r29
    5708:	eb 01       	movw	r28, r22
    570a:	8c 01       	movw	r16, r24
    570c:	7b 01       	movw	r14, r22
    570e:	8c e0       	ldi	r24, 0x0C	; 12
    5710:	e8 0e       	add	r14, r24
    5712:	f1 1c       	adc	r15, r1
  uint8_t idx;
  float limit_value = SOME_LARGE_VALUE;
    5714:	0f 2e       	mov	r0, r31
    5716:	f9 e9       	ldi	r31, 0x99	; 153
    5718:	7f 2e       	mov	r7, r31
    571a:	f0 2d       	mov	r31, r0
    571c:	0f 2e       	mov	r0, r31
    571e:	f6 e7       	ldi	r31, 0x76	; 118
    5720:	cf 2e       	mov	r12, r31
    5722:	f0 2d       	mov	r31, r0
    5724:	0f 2e       	mov	r0, r31
    5726:	f6 e9       	ldi	r31, 0x96	; 150
    5728:	df 2e       	mov	r13, r31
    572a:	f0 2d       	mov	r31, r0
    572c:	0f 2e       	mov	r0, r31
    572e:	fe e7       	ldi	r31, 0x7E	; 126
    5730:	6f 2e       	mov	r6, r31
    5732:	f0 2d       	mov	r31, r0
  for (idx=0; idx<N_AXIS; idx++) {
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
    5734:	89 90       	ld	r8, Y+
    5736:	99 90       	ld	r9, Y+
    5738:	a9 90       	ld	r10, Y+
    573a:	b9 90       	ld	r11, Y+
    573c:	20 e0       	ldi	r18, 0x00	; 0
    573e:	30 e0       	ldi	r19, 0x00	; 0
    5740:	a9 01       	movw	r20, r18
    5742:	c5 01       	movw	r24, r10
    5744:	b4 01       	movw	r22, r8
    5746:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    574a:	88 23       	and	r24, r24
    574c:	d9 f0       	breq	.+54     	; 0x5784 <limit_value_by_axis_maximum+0x98>
      limit_value = min(limit_value,fabs(max_value[idx]/unit_vec[idx]));
    574e:	a5 01       	movw	r20, r10
    5750:	94 01       	movw	r18, r8
    5752:	f8 01       	movw	r30, r16
    5754:	60 81       	ld	r22, Z
    5756:	71 81       	ldd	r23, Z+1	; 0x01
    5758:	82 81       	ldd	r24, Z+2	; 0x02
    575a:	93 81       	ldd	r25, Z+3	; 0x03
    575c:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <__divsf3>
    5760:	4b 01       	movw	r8, r22
    5762:	5c 01       	movw	r10, r24
    5764:	e8 94       	clt
    5766:	b7 f8       	bld	r11, 7
    5768:	27 2d       	mov	r18, r7
    576a:	3c 2d       	mov	r19, r12
    576c:	4d 2d       	mov	r20, r13
    576e:	56 2d       	mov	r21, r6
    5770:	c5 01       	movw	r24, r10
    5772:	b4 01       	movw	r22, r8
    5774:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    5778:	18 16       	cp	r1, r24
    577a:	24 f0       	brlt	.+8      	; 0x5784 <limit_value_by_axis_maximum+0x98>
    577c:	78 2c       	mov	r7, r8
    577e:	c9 2c       	mov	r12, r9
    5780:	da 2c       	mov	r13, r10
    5782:	6b 2c       	mov	r6, r11
    5784:	0c 5f       	subi	r16, 0xFC	; 252
    5786:	1f 4f       	sbci	r17, 0xFF	; 255

float limit_value_by_axis_maximum(float *max_value, float *unit_vec)
{
  uint8_t idx;
  float limit_value = SOME_LARGE_VALUE;
  for (idx=0; idx<N_AXIS; idx++) {
    5788:	ce 15       	cp	r28, r14
    578a:	df 05       	cpc	r29, r15
    578c:	99 f6       	brne	.-90     	; 0x5734 <limit_value_by_axis_maximum+0x48>
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
      limit_value = min(limit_value,fabs(max_value[idx]/unit_vec[idx]));
    }
  }
  return(limit_value);
}
    578e:	67 2d       	mov	r22, r7
    5790:	7c 2d       	mov	r23, r12
    5792:	8d 2d       	mov	r24, r13
    5794:	96 2d       	mov	r25, r6
    5796:	df 91       	pop	r29
    5798:	cf 91       	pop	r28
    579a:	1f 91       	pop	r17
    579c:	0f 91       	pop	r16
    579e:	ff 90       	pop	r15
    57a0:	ef 90       	pop	r14
    57a2:	df 90       	pop	r13
    57a4:	cf 90       	pop	r12
    57a6:	bf 90       	pop	r11
    57a8:	af 90       	pop	r10
    57aa:	9f 90       	pop	r9
    57ac:	8f 90       	pop	r8
    57ae:	7f 90       	pop	r7
    57b0:	6f 90       	pop	r6
    57b2:	08 95       	ret

000057b4 <limits_disable>:
      #endif

    }
  }
  sys.step_control = STEP_CONTROL_NORMAL_OP; // Return step control to normal operation.
}
    57b4:	eb e6       	ldi	r30, 0x6B	; 107
    57b6:	f0 e0       	ldi	r31, 0x00	; 0
    57b8:	80 81       	ld	r24, Z
    57ba:	89 7e       	andi	r24, 0xE9	; 233
    57bc:	80 83       	st	Z, r24
    57be:	e8 e6       	ldi	r30, 0x68	; 104
    57c0:	f0 e0       	ldi	r31, 0x00	; 0
    57c2:	80 81       	ld	r24, Z
    57c4:	8e 7f       	andi	r24, 0xFE	; 254
    57c6:	80 83       	st	Z, r24
    57c8:	08 95       	ret

000057ca <limits_init>:
    57ca:	84 b1       	in	r24, 0x04	; 4
    57cc:	89 7e       	andi	r24, 0xE9	; 233
    57ce:	84 b9       	out	0x04, r24	; 4
    57d0:	85 b1       	in	r24, 0x05	; 5
    57d2:	86 61       	ori	r24, 0x16	; 22
    57d4:	85 b9       	out	0x05, r24	; 5
    57d6:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <settings+0x45>
    57da:	83 ff       	sbrs	r24, 3
    57dc:	0b c0       	rjmp	.+22     	; 0x57f4 <limits_init+0x2a>
    57de:	eb e6       	ldi	r30, 0x6B	; 107
    57e0:	f0 e0       	ldi	r31, 0x00	; 0
    57e2:	80 81       	ld	r24, Z
    57e4:	86 61       	ori	r24, 0x16	; 22
    57e6:	80 83       	st	Z, r24
    57e8:	e8 e6       	ldi	r30, 0x68	; 104
    57ea:	f0 e0       	ldi	r31, 0x00	; 0
    57ec:	80 81       	ld	r24, Z
    57ee:	81 60       	ori	r24, 0x01	; 1
    57f0:	80 83       	st	Z, r24
    57f2:	08 95       	ret
    57f4:	0e 94 da 2b 	call	0x57b4	; 0x57b4 <limits_disable>
    57f8:	08 95       	ret

000057fa <limits_get_state>:
    57fa:	ef 92       	push	r14
    57fc:	ff 92       	push	r15
    57fe:	0f 93       	push	r16
    5800:	1f 93       	push	r17
    5802:	cf 93       	push	r28
    5804:	df 93       	push	r29
    5806:	13 b1       	in	r17, 0x03	; 3
    5808:	16 71       	andi	r17, 0x16	; 22
    580a:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <settings+0x45>
    580e:	86 fd       	sbrc	r24, 6
    5810:	1b c0       	rjmp	.+54     	; 0x5848 <limits_get_state+0x4e>
    5812:	86 e1       	ldi	r24, 0x16	; 22
    5814:	18 27       	eor	r17, r24
    5816:	18 c0       	rjmp	.+48     	; 0x5848 <limits_get_state+0x4e>
    5818:	c0 e0       	ldi	r28, 0x00	; 0
    581a:	d0 e0       	ldi	r29, 0x00	; 0
    581c:	00 e0       	ldi	r16, 0x00	; 0
    581e:	ee 24       	eor	r14, r14
    5820:	e3 94       	inc	r14
    5822:	f1 2c       	mov	r15, r1
    5824:	8c 2f       	mov	r24, r28
    5826:	0e 94 97 23 	call	0x472e	; 0x472e <get_limit_pin_mask>
    582a:	81 23       	and	r24, r17
    582c:	41 f0       	breq	.+16     	; 0x583e <limits_get_state+0x44>
    582e:	c7 01       	movw	r24, r14
    5830:	0c 2e       	mov	r0, r28
    5832:	02 c0       	rjmp	.+4      	; 0x5838 <limits_get_state+0x3e>
    5834:	88 0f       	add	r24, r24
    5836:	99 1f       	adc	r25, r25
    5838:	0a 94       	dec	r0
    583a:	e2 f7       	brpl	.-8      	; 0x5834 <limits_get_state+0x3a>
    583c:	08 2b       	or	r16, r24
    583e:	21 96       	adiw	r28, 0x01	; 1
    5840:	c3 30       	cpi	r28, 0x03	; 3
    5842:	d1 05       	cpc	r29, r1
    5844:	79 f7       	brne	.-34     	; 0x5824 <limits_get_state+0x2a>
    5846:	03 c0       	rjmp	.+6      	; 0x584e <limits_get_state+0x54>
    5848:	11 11       	cpse	r17, r1
    584a:	e6 cf       	rjmp	.-52     	; 0x5818 <limits_get_state+0x1e>
    584c:	00 e0       	ldi	r16, 0x00	; 0
    584e:	80 2f       	mov	r24, r16
    5850:	df 91       	pop	r29
    5852:	cf 91       	pop	r28
    5854:	1f 91       	pop	r17
    5856:	0f 91       	pop	r16
    5858:	ff 90       	pop	r15
    585a:	ef 90       	pop	r14
    585c:	08 95       	ret

0000585e <__vector_3>:
    585e:	1f 92       	push	r1
    5860:	0f 92       	push	r0
    5862:	0f b6       	in	r0, 0x3f	; 63
    5864:	0f 92       	push	r0
    5866:	11 24       	eor	r1, r1
    5868:	2f 93       	push	r18
    586a:	3f 93       	push	r19
    586c:	4f 93       	push	r20
    586e:	5f 93       	push	r21
    5870:	6f 93       	push	r22
    5872:	7f 93       	push	r23
    5874:	8f 93       	push	r24
    5876:	9f 93       	push	r25
    5878:	af 93       	push	r26
    587a:	bf 93       	push	r27
    587c:	ef 93       	push	r30
    587e:	ff 93       	push	r31
    5880:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    5884:	81 30       	cpi	r24, 0x01	; 1
    5886:	49 f0       	breq	.+18     	; 0x589a <__vector_3+0x3c>
    5888:	80 91 a8 05 	lds	r24, 0x05A8	; 0x8005a8 <sys_rt_exec_alarm>
    588c:	81 11       	cpse	r24, r1
    588e:	05 c0       	rjmp	.+10     	; 0x589a <__vector_3+0x3c>
    5890:	0e 94 5d 05 	call	0xaba	; 0xaba <mc_reset>
    5894:	81 e0       	ldi	r24, 0x01	; 1
    5896:	0e 94 34 2e 	call	0x5c68	; 0x5c68 <system_set_exec_alarm>
    589a:	ff 91       	pop	r31
    589c:	ef 91       	pop	r30
    589e:	bf 91       	pop	r27
    58a0:	af 91       	pop	r26
    58a2:	9f 91       	pop	r25
    58a4:	8f 91       	pop	r24
    58a6:	7f 91       	pop	r23
    58a8:	6f 91       	pop	r22
    58aa:	5f 91       	pop	r21
    58ac:	4f 91       	pop	r20
    58ae:	3f 91       	pop	r19
    58b0:	2f 91       	pop	r18
    58b2:	0f 90       	pop	r0
    58b4:	0f be       	out	0x3f, r0	; 63
    58b6:	0f 90       	pop	r0
    58b8:	1f 90       	pop	r1
    58ba:	18 95       	reti

000058bc <limits_soft_check>:

// Performs a soft limit check. Called from mc_line() only. Assumes the machine has been homed,
// the workspace volume is in all negative space, and the system is in normal operation.
// NOTE: Used by jogging to limit travel within soft-limit volume.
void limits_soft_check(float *target)
{
    58bc:	cf 93       	push	r28
    58be:	df 93       	push	r29
  if (system_check_travel_limits(target)) {
    58c0:	0e 94 b6 2d 	call	0x5b6c	; 0x5b6c <system_check_travel_limits>
    58c4:	88 23       	and	r24, r24
    58c6:	d1 f0       	breq	.+52     	; 0x58fc <limits_soft_check+0x40>
    sys.soft_limit = true;
    58c8:	ec e7       	ldi	r30, 0x7C	; 124
    58ca:	f5 e0       	ldi	r31, 0x05	; 5
    58cc:	81 e0       	ldi	r24, 0x01	; 1
    58ce:	83 83       	std	Z+3, r24	; 0x03
    // Force feed hold if cycle is active. All buffered blocks are guaranteed to be within
    // workspace volume so just come to a controlled stop so position is not lost. When complete
    // enter alarm mode.
    if (sys.state == STATE_CYCLE) {
    58d0:	80 81       	ld	r24, Z
    58d2:	88 30       	cpi	r24, 0x08	; 8
    58d4:	61 f4       	brne	.+24     	; 0x58ee <limits_soft_check+0x32>
      system_set_exec_state_flag(EXEC_FEED_HOLD);
    58d6:	0e 94 21 2e 	call	0x5c42	; 0x5c42 <system_set_exec_state_flag>
      do {
        protocol_execute_realtime();
        if (sys.abort) { return; }
    58da:	cc e7       	ldi	r28, 0x7C	; 124
    58dc:	d5 e0       	ldi	r29, 0x05	; 5
    // workspace volume so just come to a controlled stop so position is not lost. When complete
    // enter alarm mode.
    if (sys.state == STATE_CYCLE) {
      system_set_exec_state_flag(EXEC_FEED_HOLD);
      do {
        protocol_execute_realtime();
    58de:	0e 94 9e 14 	call	0x293c	; 0x293c <protocol_execute_realtime>
        if (sys.abort) { return; }
    58e2:	89 81       	ldd	r24, Y+1	; 0x01
    58e4:	81 11       	cpse	r24, r1
    58e6:	0a c0       	rjmp	.+20     	; 0x58fc <limits_soft_check+0x40>
      } while ( sys.state != STATE_IDLE );
    58e8:	88 81       	ld	r24, Y
    58ea:	81 11       	cpse	r24, r1
    58ec:	f8 cf       	rjmp	.-16     	; 0x58de <limits_soft_check+0x22>
    }
    mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
    58ee:	0e 94 5d 05 	call	0xaba	; 0xaba <mc_reset>
    system_set_exec_alarm(EXEC_ALARM_SOFT_LIMIT); // Indicate soft limit critical event
    58f2:	82 e0       	ldi	r24, 0x02	; 2
    58f4:	0e 94 34 2e 	call	0x5c68	; 0x5c68 <system_set_exec_alarm>
    protocol_execute_realtime(); // Execute to enter critical event loop and system abort
    58f8:	0e 94 9e 14 	call	0x293c	; 0x293c <protocol_execute_realtime>
    return;
  }
}
    58fc:	df 91       	pop	r29
    58fe:	cf 91       	pop	r28
    5900:	08 95       	ret

00005902 <jog_execute>:
#include "grbl.h"


// Sets up valid jog motion received from g-code parser, checks for soft-limits, and executes the jog.
uint8_t jog_execute(plan_line_data_t *pl_data, parser_block_t *gc_block)
{
    5902:	0f 93       	push	r16
    5904:	1f 93       	push	r17
    5906:	cf 93       	push	r28
    5908:	df 93       	push	r29
    590a:	ec 01       	movw	r28, r24
    590c:	8b 01       	movw	r16, r22
  // Initialize planner data struct for jogging motions.
  // NOTE: Spindle and coolant are allowed to fully function with overrides during a jog.
  pl_data->feed_rate = gc_block->values.f;
    590e:	fb 01       	movw	r30, r22
    5910:	84 85       	ldd	r24, Z+12	; 0x0c
    5912:	95 85       	ldd	r25, Z+13	; 0x0d
    5914:	a6 85       	ldd	r26, Z+14	; 0x0e
    5916:	b7 85       	ldd	r27, Z+15	; 0x0f
    5918:	88 83       	st	Y, r24
    591a:	99 83       	std	Y+1, r25	; 0x01
    591c:	aa 83       	std	Y+2, r26	; 0x02
    591e:	bb 83       	std	Y+3, r27	; 0x03
  pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
    5920:	88 85       	ldd	r24, Y+8	; 0x08
    5922:	84 60       	ori	r24, 0x04	; 4
    5924:	88 87       	std	Y+8, r24	; 0x08
  #ifdef USE_LINE_NUMBERS
    pl_data->line_number = gc_block->values.n;
  #endif

  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) {
    5926:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <settings+0x45>
    592a:	85 ff       	sbrs	r24, 5
    592c:	06 c0       	rjmp	.+12     	; 0x593a <jog_execute+0x38>
    if (system_check_travel_limits(gc_block->values.xyz)) { return(STATUS_TRAVEL_EXCEEDED); }
    592e:	cb 01       	movw	r24, r22
    5930:	8e 96       	adiw	r24, 0x2e	; 46
    5932:	0e 94 b6 2d 	call	0x5b6c	; 0x5b6c <system_check_travel_limits>
    5936:	81 11       	cpse	r24, r1
    5938:	15 c0       	rjmp	.+42     	; 0x5964 <jog_execute+0x62>
  }

  // Valid jog command. Plan, set state, and execute.
  mc_line(gc_block->values.xyz,pl_data);
    593a:	be 01       	movw	r22, r28
    593c:	c8 01       	movw	r24, r16
    593e:	8e 96       	adiw	r24, 0x2e	; 46
    5940:	0e 94 ad 01 	call	0x35a	; 0x35a <mc_line>
  if (sys.state == STATE_IDLE) {
    5944:	c0 91 7c 05 	lds	r28, 0x057C	; 0x80057c <sys>
    5948:	c1 11       	cpse	r28, r1
    594a:	0e c0       	rjmp	.+28     	; 0x5968 <jog_execute+0x66>
    if (plan_get_current_block() != NULL) { // Check if there is a block to execute.
    594c:	0e 94 38 25 	call	0x4a70	; 0x4a70 <plan_get_current_block>
    5950:	89 2b       	or	r24, r25
    5952:	59 f0       	breq	.+22     	; 0x596a <jog_execute+0x68>
      sys.state = STATE_JOG;
    5954:	80 e2       	ldi	r24, 0x20	; 32
    5956:	80 93 7c 05 	sts	0x057C, r24	; 0x80057c <sys>
      st_prep_buffer();
    595a:	0e 94 79 19 	call	0x32f2	; 0x32f2 <st_prep_buffer>
      st_wake_up();  // NOTE: Manual start. No state machine required.
    595e:	0e 94 70 16 	call	0x2ce0	; 0x2ce0 <st_wake_up>
    5962:	03 c0       	rjmp	.+6      	; 0x596a <jog_execute+0x68>
  #ifdef USE_LINE_NUMBERS
    pl_data->line_number = gc_block->values.n;
  #endif

  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) {
    if (system_check_travel_limits(gc_block->values.xyz)) { return(STATUS_TRAVEL_EXCEEDED); }
    5964:	cf e0       	ldi	r28, 0x0F	; 15
    5966:	01 c0       	rjmp	.+2      	; 0x596a <jog_execute+0x68>
      st_prep_buffer();
      st_wake_up();  // NOTE: Manual start. No state machine required.
    }
  }

  return(STATUS_OK);
    5968:	c0 e0       	ldi	r28, 0x00	; 0
}
    596a:	8c 2f       	mov	r24, r28
    596c:	df 91       	pop	r29
    596e:	cf 91       	pop	r28
    5970:	1f 91       	pop	r17
    5972:	0f 91       	pop	r16
    5974:	08 95       	ret

00005976 <probe_configure_invert_mask>:
// Called by probe_init() and the mc_probe() routines. Sets up the probe pin invert mask to
// appropriately set the pin logic according to setting for normal-high/normal-low operation
// and the probing cycle modes for toward-workpiece/away-from-workpiece.
void probe_configure_invert_mask(uint8_t is_probe_away)
{
  probe_invert_mask = 0; // Initialize as zero.
    5976:	10 92 63 07 	sts	0x0763, r1	; 0x800763 <probe_invert_mask>
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_PROBE_PIN)) { probe_invert_mask ^= PROBE_MASK; }
    597a:	90 91 53 07 	lds	r25, 0x0753	; 0x800753 <settings+0x45>
    597e:	99 23       	and	r25, r25
    5980:	1c f0       	brlt	.+6      	; 0x5988 <probe_configure_invert_mask+0x12>
    5982:	90 e2       	ldi	r25, 0x20	; 32
    5984:	90 93 63 07 	sts	0x0763, r25	; 0x800763 <probe_invert_mask>
  if (is_probe_away) { probe_invert_mask ^= PROBE_MASK; }
    5988:	88 23       	and	r24, r24
    598a:	31 f0       	breq	.+12     	; 0x5998 <probe_configure_invert_mask+0x22>
    598c:	90 91 63 07 	lds	r25, 0x0763	; 0x800763 <probe_invert_mask>
    5990:	80 e2       	ldi	r24, 0x20	; 32
    5992:	89 27       	eor	r24, r25
    5994:	80 93 63 07 	sts	0x0763, r24	; 0x800763 <probe_invert_mask>
    5998:	08 95       	ret

0000599a <probe_init>:


// Probe pin initialization routine.
void probe_init()
{
  PROBE_DDR &= ~(PROBE_MASK); // Configure as input pins
    599a:	3d 98       	cbi	0x07, 5	; 7
  #ifdef DISABLE_PROBE_PIN_PULL_UP
    PROBE_PORT &= ~(PROBE_MASK); // Normal low operation. Requires external pull-down.
  #else
    PROBE_PORT |= PROBE_MASK;    // Enable internal pull-up resistors. Normal high operation.
    599c:	45 9a       	sbi	0x08, 5	; 8
  #endif
  probe_configure_invert_mask(false); // Initialize invert mask.
    599e:	80 e0       	ldi	r24, 0x00	; 0
    59a0:	0e 94 bb 2c 	call	0x5976	; 0x5976 <probe_configure_invert_mask>
    59a4:	08 95       	ret

000059a6 <probe_get_state>:
  if (is_probe_away) { probe_invert_mask ^= PROBE_MASK; }
}


// Returns the probe pin state. Triggered = true. Called by gcode parser and probe state monitor.
uint8_t probe_get_state() { return((PROBE_PIN & PROBE_MASK) ^ probe_invert_mask); }
    59a6:	86 b1       	in	r24, 0x06	; 6
    59a8:	80 72       	andi	r24, 0x20	; 32
    59aa:	90 91 63 07 	lds	r25, 0x0763	; 0x800763 <probe_invert_mask>
    59ae:	89 27       	eor	r24, r25
    59b0:	08 95       	ret

000059b2 <probe_state_monitor>:
// Monitors probe pin state and records the system position when detected. Called by the
// stepper ISR per ISR tick.
// NOTE: This function must be extremely efficient as to not bog down the stepper ISR.
void probe_state_monitor()
{
  if (probe_get_state()) {
    59b2:	0e 94 d3 2c 	call	0x59a6	; 0x59a6 <probe_get_state>
    59b6:	88 23       	and	r24, r24
    59b8:	81 f0       	breq	.+32     	; 0x59da <probe_state_monitor+0x28>
    sys_probe_state = PROBE_OFF;
    59ba:	10 92 8f 05 	sts	0x058F, r1	; 0x80058f <sys_probe_state>
    memcpy(sys_probe_position, sys_position, sizeof(sys_position));
    59be:	8c e0       	ldi	r24, 0x0C	; 12
    59c0:	ec e9       	ldi	r30, 0x9C	; 156
    59c2:	f5 e0       	ldi	r31, 0x05	; 5
    59c4:	a0 e9       	ldi	r26, 0x90	; 144
    59c6:	b5 e0       	ldi	r27, 0x05	; 5
    59c8:	01 90       	ld	r0, Z+
    59ca:	0d 92       	st	X+, r0
    59cc:	8a 95       	dec	r24
    59ce:	e1 f7       	brne	.-8      	; 0x59c8 <probe_state_monitor+0x16>
    bit_true(sys_rt_exec_state, EXEC_MOTION_CANCEL);
    59d0:	80 91 8e 05 	lds	r24, 0x058E	; 0x80058e <sys_rt_exec_state>
    59d4:	80 64       	ori	r24, 0x40	; 64
    59d6:	80 93 8e 05 	sts	0x058E, r24	; 0x80058e <sys_rt_exec_state>
    59da:	08 95       	ret

000059dc <report_status_message>:


// Prints the character string line Grbl has received from the user, which has been pre-parsed,
// and has been sent into protocol_execute_line() routine to be executed by Grbl.
void report_echo_line_received(char *line)
{
    59dc:	08 95       	ret

000059de <report_alarm_message>:
    59de:	08 95       	ret

000059e0 <report_feedback_message>:
    59e0:	08 95       	ret

000059e2 <report_init_message>:
    59e2:	08 95       	ret

000059e4 <report_grbl_settings>:
    59e4:	08 95       	ret

000059e6 <report_probe_parameters>:
    59e6:	08 95       	ret

000059e8 <report_execute_startup_message>:
    59e8:	08 95       	ret

000059ea <report_realtime_status>:
 // and the actual location of the CNC machine. Users may change the following function to their
 // specific needs, but the desired real-time data report must be as short as possible. This is
 // requires as it minimizes the computational overhead and allows grbl to keep running smoothly,
 // especially during g-code programs with fast, short line segments and high frequency reports (5-20Hz).
void report_realtime_status()
{
    59ea:	08 95       	ret

000059ec <report_realtime_debug>:
}


#ifdef DEBUG
  void report_realtime_debug()
  {
    59ec:	08 95       	ret

000059ee <system_init>:
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
}
    59ee:	87 b1       	in	r24, 0x07	; 7
    59f0:	88 7f       	andi	r24, 0xF8	; 248
    59f2:	87 b9       	out	0x07, r24	; 7
    59f4:	88 b1       	in	r24, 0x08	; 8
    59f6:	87 60       	ori	r24, 0x07	; 7
    59f8:	88 b9       	out	0x08, r24	; 8
    59fa:	ec e6       	ldi	r30, 0x6C	; 108
    59fc:	f0 e0       	ldi	r31, 0x00	; 0
    59fe:	80 81       	ld	r24, Z
    5a00:	87 60       	ori	r24, 0x07	; 7
    5a02:	80 83       	st	Z, r24
    5a04:	e8 e6       	ldi	r30, 0x68	; 104
    5a06:	f0 e0       	ldi	r31, 0x00	; 0
    5a08:	80 81       	ld	r24, Z
    5a0a:	82 60       	ori	r24, 0x02	; 2
    5a0c:	80 83       	st	Z, r24
    5a0e:	08 95       	ret

00005a10 <system_control_get_state>:
    5a10:	96 b1       	in	r25, 0x06	; 6
    5a12:	90 95       	com	r25
    5a14:	89 2f       	mov	r24, r25
    5a16:	87 70       	andi	r24, 0x07	; 7
    5a18:	59 f0       	breq	.+22     	; 0x5a30 <system_control_get_state+0x20>
    5a1a:	91 ff       	sbrs	r25, 1
    5a1c:	02 c0       	rjmp	.+4      	; 0x5a22 <system_control_get_state+0x12>
    5a1e:	82 e0       	ldi	r24, 0x02	; 2
    5a20:	01 c0       	rjmp	.+2      	; 0x5a24 <system_control_get_state+0x14>
    5a22:	80 e0       	ldi	r24, 0x00	; 0
    5a24:	90 fd       	sbrc	r25, 0
    5a26:	81 60       	ori	r24, 0x01	; 1
    5a28:	92 ff       	sbrs	r25, 2
    5a2a:	03 c0       	rjmp	.+6      	; 0x5a32 <system_control_get_state+0x22>
    5a2c:	84 60       	ori	r24, 0x04	; 4
    5a2e:	08 95       	ret
    5a30:	80 e0       	ldi	r24, 0x00	; 0
    5a32:	08 95       	ret

00005a34 <__vector_4>:
    5a34:	1f 92       	push	r1
    5a36:	0f 92       	push	r0
    5a38:	0f b6       	in	r0, 0x3f	; 63
    5a3a:	0f 92       	push	r0
    5a3c:	11 24       	eor	r1, r1
    5a3e:	2f 93       	push	r18
    5a40:	3f 93       	push	r19
    5a42:	4f 93       	push	r20
    5a44:	5f 93       	push	r21
    5a46:	6f 93       	push	r22
    5a48:	7f 93       	push	r23
    5a4a:	8f 93       	push	r24
    5a4c:	9f 93       	push	r25
    5a4e:	af 93       	push	r26
    5a50:	bf 93       	push	r27
    5a52:	cf 93       	push	r28
    5a54:	ef 93       	push	r30
    5a56:	ff 93       	push	r31
    5a58:	0e 94 08 2d 	call	0x5a10	; 0x5a10 <system_control_get_state>
    5a5c:	c8 2f       	mov	r28, r24
    5a5e:	88 23       	and	r24, r24
    5a60:	89 f0       	breq	.+34     	; 0x5a84 <__vector_4+0x50>
    5a62:	80 fd       	sbrc	r24, 0
    5a64:	0e 94 5d 05 	call	0xaba	; 0xaba <mc_reset>
    5a68:	c2 ff       	sbrs	r28, 2
    5a6a:	05 c0       	rjmp	.+10     	; 0x5a76 <__vector_4+0x42>
    5a6c:	80 91 8e 05 	lds	r24, 0x058E	; 0x80058e <sys_rt_exec_state>
    5a70:	82 60       	ori	r24, 0x02	; 2
    5a72:	80 93 8e 05 	sts	0x058E, r24	; 0x80058e <sys_rt_exec_state>
    5a76:	c1 ff       	sbrs	r28, 1
    5a78:	05 c0       	rjmp	.+10     	; 0x5a84 <__vector_4+0x50>
    5a7a:	80 91 8e 05 	lds	r24, 0x058E	; 0x80058e <sys_rt_exec_state>
    5a7e:	88 60       	ori	r24, 0x08	; 8
    5a80:	80 93 8e 05 	sts	0x058E, r24	; 0x80058e <sys_rt_exec_state>
    5a84:	ff 91       	pop	r31
    5a86:	ef 91       	pop	r30
    5a88:	cf 91       	pop	r28
    5a8a:	bf 91       	pop	r27
    5a8c:	af 91       	pop	r26
    5a8e:	9f 91       	pop	r25
    5a90:	8f 91       	pop	r24
    5a92:	7f 91       	pop	r23
    5a94:	6f 91       	pop	r22
    5a96:	5f 91       	pop	r21
    5a98:	4f 91       	pop	r20
    5a9a:	3f 91       	pop	r19
    5a9c:	2f 91       	pop	r18
    5a9e:	0f 90       	pop	r0
    5aa0:	0f be       	out	0x3f, r0	; 63
    5aa2:	0f 90       	pop	r0
    5aa4:	1f 90       	pop	r1
    5aa6:	18 95       	reti

00005aa8 <system_check_safety_door_ajar>:
    5aa8:	80 e0       	ldi	r24, 0x00	; 0
    5aaa:	08 95       	ret

00005aac <system_execute_startup>:
    5aac:	0f 93       	push	r16
    5aae:	1f 93       	push	r17
    5ab0:	cf 93       	push	r28
    5ab2:	8c 01       	movw	r16, r24
    5ab4:	c0 e0       	ldi	r28, 0x00	; 0
    5ab6:	b8 01       	movw	r22, r16
    5ab8:	8c 2f       	mov	r24, r28
    5aba:	0e 94 22 23 	call	0x4644	; 0x4644 <settings_read_startup_line>
    5abe:	81 11       	cpse	r24, r1
    5ac0:	07 c0       	rjmp	.+14     	; 0x5ad0 <system_execute_startup+0x24>
    5ac2:	f8 01       	movw	r30, r16
    5ac4:	10 82       	st	Z, r1
    5ac6:	67 e0       	ldi	r22, 0x07	; 7
    5ac8:	c8 01       	movw	r24, r16
    5aca:	0e 94 f4 2c 	call	0x59e8	; 0x59e8 <report_execute_startup_message>
    5ace:	0b c0       	rjmp	.+22     	; 0x5ae6 <system_execute_startup+0x3a>
    5ad0:	f8 01       	movw	r30, r16
    5ad2:	80 81       	ld	r24, Z
    5ad4:	88 23       	and	r24, r24
    5ad6:	39 f0       	breq	.+14     	; 0x5ae6 <system_execute_startup+0x3a>
    5ad8:	c8 01       	movw	r24, r16
    5ada:	0e 94 9a 05 	call	0xb34	; 0xb34 <gc_execute_line>
    5ade:	68 2f       	mov	r22, r24
    5ae0:	c8 01       	movw	r24, r16
    5ae2:	0e 94 f4 2c 	call	0x59e8	; 0x59e8 <report_execute_startup_message>
    5ae6:	cf 5f       	subi	r28, 0xFF	; 255
    5ae8:	c2 30       	cpi	r28, 0x02	; 2
    5aea:	29 f7       	brne	.-54     	; 0x5ab6 <system_execute_startup+0xa>
    5aec:	cf 91       	pop	r28
    5aee:	1f 91       	pop	r17
    5af0:	0f 91       	pop	r16
    5af2:	08 95       	ret

00005af4 <system_flag_wco_change>:
    5af4:	0e 94 5b 16 	call	0x2cb6	; 0x2cb6 <protocol_buffer_synchronize>
    5af8:	10 92 88 05 	sts	0x0588, r1	; 0x800588 <sys+0xc>
    5afc:	08 95       	ret

00005afe <system_convert_axis_steps_to_mpos>:
    5afe:	cf 93       	push	r28
    5b00:	df 93       	push	r29
    5b02:	c6 2f       	mov	r28, r22
    5b04:	d0 e0       	ldi	r29, 0x00	; 0
    5b06:	cc 0f       	add	r28, r28
    5b08:	dd 1f       	adc	r29, r29
    5b0a:	cc 0f       	add	r28, r28
    5b0c:	dd 1f       	adc	r29, r29
    5b0e:	8c 0f       	add	r24, r28
    5b10:	9d 1f       	adc	r25, r29
    5b12:	fc 01       	movw	r30, r24
    5b14:	60 81       	ld	r22, Z
    5b16:	71 81       	ldd	r23, Z+1	; 0x01
    5b18:	82 81       	ldd	r24, Z+2	; 0x02
    5b1a:	93 81       	ldd	r25, Z+3	; 0x03
    5b1c:	0e 94 08 30 	call	0x6010	; 0x6010 <__floatsisf>
    5b20:	c2 5f       	subi	r28, 0xF2	; 242
    5b22:	d8 4f       	sbci	r29, 0xF8	; 248
    5b24:	28 81       	ld	r18, Y
    5b26:	39 81       	ldd	r19, Y+1	; 0x01
    5b28:	4a 81       	ldd	r20, Y+2	; 0x02
    5b2a:	5b 81       	ldd	r21, Y+3	; 0x03
    5b2c:	0e 94 5e 2f 	call	0x5ebc	; 0x5ebc <__divsf3>
    5b30:	df 91       	pop	r29
    5b32:	cf 91       	pop	r28
    5b34:	08 95       	ret

00005b36 <system_convert_array_steps_to_mpos>:
    5b36:	ef 92       	push	r14
    5b38:	ff 92       	push	r15
    5b3a:	0f 93       	push	r16
    5b3c:	1f 93       	push	r17
    5b3e:	cf 93       	push	r28
    5b40:	7b 01       	movw	r14, r22
    5b42:	8c 01       	movw	r16, r24
    5b44:	c0 e0       	ldi	r28, 0x00	; 0
    5b46:	6c 2f       	mov	r22, r28
    5b48:	c7 01       	movw	r24, r14
    5b4a:	0e 94 7f 2d 	call	0x5afe	; 0x5afe <system_convert_axis_steps_to_mpos>
    5b4e:	f8 01       	movw	r30, r16
    5b50:	61 93       	st	Z+, r22
    5b52:	71 93       	st	Z+, r23
    5b54:	81 93       	st	Z+, r24
    5b56:	91 93       	st	Z+, r25
    5b58:	8f 01       	movw	r16, r30
    5b5a:	cf 5f       	subi	r28, 0xFF	; 255
    5b5c:	c3 30       	cpi	r28, 0x03	; 3
    5b5e:	99 f7       	brne	.-26     	; 0x5b46 <system_convert_array_steps_to_mpos+0x10>
    5b60:	cf 91       	pop	r28
    5b62:	1f 91       	pop	r17
    5b64:	0f 91       	pop	r16
    5b66:	ff 90       	pop	r15
    5b68:	ef 90       	pop	r14
    5b6a:	08 95       	ret

00005b6c <system_check_travel_limits>:
    5b6c:	cf 92       	push	r12
    5b6e:	df 92       	push	r13
    5b70:	ef 92       	push	r14
    5b72:	ff 92       	push	r15
    5b74:	cf 93       	push	r28
    5b76:	df 93       	push	r29
    5b78:	ec 01       	movw	r28, r24
    5b7a:	c8 80       	ld	r12, Y
    5b7c:	d9 80       	ldd	r13, Y+1	; 0x01
    5b7e:	ea 80       	ldd	r14, Y+2	; 0x02
    5b80:	fb 80       	ldd	r15, Y+3	; 0x03
    5b82:	20 e0       	ldi	r18, 0x00	; 0
    5b84:	30 e0       	ldi	r19, 0x00	; 0
    5b86:	a9 01       	movw	r20, r18
    5b88:	c7 01       	movw	r24, r14
    5b8a:	b6 01       	movw	r22, r12
    5b8c:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    5b90:	18 16       	cp	r1, r24
    5b92:	0c f4       	brge	.+2      	; 0x5b96 <system_check_travel_limits+0x2a>
    5b94:	46 c0       	rjmp	.+140    	; 0x5c22 <system_check_travel_limits+0xb6>
    5b96:	20 91 32 07 	lds	r18, 0x0732	; 0x800732 <settings+0x24>
    5b9a:	30 91 33 07 	lds	r19, 0x0733	; 0x800733 <settings+0x25>
    5b9e:	40 91 34 07 	lds	r20, 0x0734	; 0x800734 <settings+0x26>
    5ba2:	50 91 35 07 	lds	r21, 0x0735	; 0x800735 <settings+0x27>
    5ba6:	c7 01       	movw	r24, r14
    5ba8:	b6 01       	movw	r22, r12
    5baa:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    5bae:	88 23       	and	r24, r24
    5bb0:	d4 f1       	brlt	.+116    	; 0x5c26 <system_check_travel_limits+0xba>
    5bb2:	cc 80       	ldd	r12, Y+4	; 0x04
    5bb4:	dd 80       	ldd	r13, Y+5	; 0x05
    5bb6:	ee 80       	ldd	r14, Y+6	; 0x06
    5bb8:	ff 80       	ldd	r15, Y+7	; 0x07
    5bba:	20 e0       	ldi	r18, 0x00	; 0
    5bbc:	30 e0       	ldi	r19, 0x00	; 0
    5bbe:	a9 01       	movw	r20, r18
    5bc0:	c7 01       	movw	r24, r14
    5bc2:	b6 01       	movw	r22, r12
    5bc4:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    5bc8:	18 16       	cp	r1, r24
    5bca:	7c f1       	brlt	.+94     	; 0x5c2a <system_check_travel_limits+0xbe>
    5bcc:	20 91 36 07 	lds	r18, 0x0736	; 0x800736 <settings+0x28>
    5bd0:	30 91 37 07 	lds	r19, 0x0737	; 0x800737 <settings+0x29>
    5bd4:	40 91 38 07 	lds	r20, 0x0738	; 0x800738 <settings+0x2a>
    5bd8:	50 91 39 07 	lds	r21, 0x0739	; 0x800739 <settings+0x2b>
    5bdc:	c7 01       	movw	r24, r14
    5bde:	b6 01       	movw	r22, r12
    5be0:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    5be4:	88 23       	and	r24, r24
    5be6:	1c f1       	brlt	.+70     	; 0x5c2e <system_check_travel_limits+0xc2>
    5be8:	c8 84       	ldd	r12, Y+8	; 0x08
    5bea:	d9 84       	ldd	r13, Y+9	; 0x09
    5bec:	ea 84       	ldd	r14, Y+10	; 0x0a
    5bee:	fb 84       	ldd	r15, Y+11	; 0x0b
    5bf0:	20 e0       	ldi	r18, 0x00	; 0
    5bf2:	30 e0       	ldi	r19, 0x00	; 0
    5bf4:	a9 01       	movw	r20, r18
    5bf6:	c7 01       	movw	r24, r14
    5bf8:	b6 01       	movw	r22, r12
    5bfa:	0e 94 76 31 	call	0x62ec	; 0x62ec <__gesf2>
    5bfe:	18 16       	cp	r1, r24
    5c00:	c4 f0       	brlt	.+48     	; 0x5c32 <system_check_travel_limits+0xc6>
    5c02:	20 91 3a 07 	lds	r18, 0x073A	; 0x80073a <settings+0x2c>
    5c06:	30 91 3b 07 	lds	r19, 0x073B	; 0x80073b <settings+0x2d>
    5c0a:	40 91 3c 07 	lds	r20, 0x073C	; 0x80073c <settings+0x2e>
    5c0e:	50 91 3d 07 	lds	r21, 0x073D	; 0x80073d <settings+0x2f>
    5c12:	c7 01       	movw	r24, r14
    5c14:	b6 01       	movw	r22, r12
    5c16:	0e 94 54 2f 	call	0x5ea8	; 0x5ea8 <__cmpsf2>
    5c1a:	88 1f       	adc	r24, r24
    5c1c:	88 27       	eor	r24, r24
    5c1e:	88 1f       	adc	r24, r24
    5c20:	09 c0       	rjmp	.+18     	; 0x5c34 <system_check_travel_limits+0xc8>
    5c22:	81 e0       	ldi	r24, 0x01	; 1
    5c24:	07 c0       	rjmp	.+14     	; 0x5c34 <system_check_travel_limits+0xc8>
    5c26:	81 e0       	ldi	r24, 0x01	; 1
    5c28:	05 c0       	rjmp	.+10     	; 0x5c34 <system_check_travel_limits+0xc8>
    5c2a:	81 e0       	ldi	r24, 0x01	; 1
    5c2c:	03 c0       	rjmp	.+6      	; 0x5c34 <system_check_travel_limits+0xc8>
    5c2e:	81 e0       	ldi	r24, 0x01	; 1
    5c30:	01 c0       	rjmp	.+2      	; 0x5c34 <system_check_travel_limits+0xc8>
    5c32:	81 e0       	ldi	r24, 0x01	; 1
    5c34:	df 91       	pop	r29
    5c36:	cf 91       	pop	r28
    5c38:	ff 90       	pop	r15
    5c3a:	ef 90       	pop	r14
    5c3c:	df 90       	pop	r13
    5c3e:	cf 90       	pop	r12
    5c40:	08 95       	ret

00005c42 <system_set_exec_state_flag>:
    5c42:	9f b7       	in	r25, 0x3f	; 63
    5c44:	f8 94       	cli
    5c46:	20 91 8e 05 	lds	r18, 0x058E	; 0x80058e <sys_rt_exec_state>
    5c4a:	82 2b       	or	r24, r18
    5c4c:	80 93 8e 05 	sts	0x058E, r24	; 0x80058e <sys_rt_exec_state>
    5c50:	9f bf       	out	0x3f, r25	; 63
    5c52:	08 95       	ret

00005c54 <system_clear_exec_state_flag>:
  sys_rt_exec_state |= (mask);
  SREG = sreg;
}

void system_clear_exec_state_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    5c54:	2f b7       	in	r18, 0x3f	; 63
  cli();
    5c56:	f8 94       	cli
  sys_rt_exec_state &= ~(mask);
    5c58:	90 91 8e 05 	lds	r25, 0x058E	; 0x80058e <sys_rt_exec_state>
    5c5c:	80 95       	com	r24
    5c5e:	89 23       	and	r24, r25
    5c60:	80 93 8e 05 	sts	0x058E, r24	; 0x80058e <sys_rt_exec_state>
  SREG = sreg;
    5c64:	2f bf       	out	0x3f, r18	; 63
    5c66:	08 95       	ret

00005c68 <system_set_exec_alarm>:
}

void system_set_exec_alarm(uint8_t code) {
  uint8_t sreg = SREG;
    5c68:	9f b7       	in	r25, 0x3f	; 63
  cli();
    5c6a:	f8 94       	cli
  sys_rt_exec_alarm = code;
    5c6c:	80 93 a8 05 	sts	0x05A8, r24	; 0x8005a8 <sys_rt_exec_alarm>
  SREG = sreg;
    5c70:	9f bf       	out	0x3f, r25	; 63
    5c72:	08 95       	ret

00005c74 <system_clear_exec_alarm>:
}

void system_clear_exec_alarm() {
  uint8_t sreg = SREG;
    5c74:	8f b7       	in	r24, 0x3f	; 63
  cli();
    5c76:	f8 94       	cli
  sys_rt_exec_alarm = 0;
    5c78:	10 92 a8 05 	sts	0x05A8, r1	; 0x8005a8 <sys_rt_exec_alarm>
  SREG = sreg;
    5c7c:	8f bf       	out	0x3f, r24	; 63
    5c7e:	08 95       	ret

00005c80 <system_set_exec_motion_override_flag>:
}

void system_set_exec_motion_override_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    5c80:	9f b7       	in	r25, 0x3f	; 63
  cli();
    5c82:	f8 94       	cli
  sys_rt_exec_motion_override |= (mask);
    5c84:	20 91 7b 05 	lds	r18, 0x057B	; 0x80057b <sys_rt_exec_motion_override>
    5c88:	82 2b       	or	r24, r18
    5c8a:	80 93 7b 05 	sts	0x057B, r24	; 0x80057b <sys_rt_exec_motion_override>
  SREG = sreg;
    5c8e:	9f bf       	out	0x3f, r25	; 63
    5c90:	08 95       	ret

00005c92 <system_set_exec_accessory_override_flag>:
}

void system_set_exec_accessory_override_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    5c92:	9f b7       	in	r25, 0x3f	; 63
  cli();
    5c94:	f8 94       	cli
  sys_rt_exec_accessory_override |= (mask);
    5c96:	20 91 8d 05 	lds	r18, 0x058D	; 0x80058d <sys_rt_exec_accessory_override>
    5c9a:	82 2b       	or	r24, r18
    5c9c:	80 93 8d 05 	sts	0x058D, r24	; 0x80058d <sys_rt_exec_accessory_override>
  SREG = sreg;
    5ca0:	9f bf       	out	0x3f, r25	; 63
    5ca2:	08 95       	ret

00005ca4 <system_clear_exec_motion_overrides>:
}

void system_clear_exec_motion_overrides() {
  uint8_t sreg = SREG;
    5ca4:	8f b7       	in	r24, 0x3f	; 63
  cli();
    5ca6:	f8 94       	cli
  sys_rt_exec_motion_override = 0;
    5ca8:	10 92 7b 05 	sts	0x057B, r1	; 0x80057b <sys_rt_exec_motion_override>
  SREG = sreg;
    5cac:	8f bf       	out	0x3f, r24	; 63
    5cae:	08 95       	ret

00005cb0 <system_clear_exec_accessory_overrides>:
}

void system_clear_exec_accessory_overrides() {
  uint8_t sreg = SREG;
    5cb0:	8f b7       	in	r24, 0x3f	; 63
  cli();
    5cb2:	f8 94       	cli
  sys_rt_exec_accessory_override = 0;
    5cb4:	10 92 8d 05 	sts	0x058D, r1	; 0x80058d <sys_rt_exec_accessory_override>
  SREG = sreg;
    5cb8:	8f bf       	out	0x3f, r24	; 63
    5cba:	08 95       	ret

00005cbc <__subsf3>:
    5cbc:	50 58       	subi	r21, 0x80	; 128

00005cbe <__addsf3>:
    5cbe:	bb 27       	eor	r27, r27
    5cc0:	aa 27       	eor	r26, r26
    5cc2:	0e 94 76 2e 	call	0x5cec	; 0x5cec <__addsf3x>
    5cc6:	0c 94 10 31 	jmp	0x6220	; 0x6220 <__fp_round>
    5cca:	0e 94 d7 30 	call	0x61ae	; 0x61ae <__fp_pscA>
    5cce:	38 f0       	brcs	.+14     	; 0x5cde <__addsf3+0x20>
    5cd0:	0e 94 de 30 	call	0x61bc	; 0x61bc <__fp_pscB>
    5cd4:	20 f0       	brcs	.+8      	; 0x5cde <__addsf3+0x20>
    5cd6:	39 f4       	brne	.+14     	; 0x5ce6 <__addsf3+0x28>
    5cd8:	9f 3f       	cpi	r25, 0xFF	; 255
    5cda:	19 f4       	brne	.+6      	; 0x5ce2 <__addsf3+0x24>
    5cdc:	26 f4       	brtc	.+8      	; 0x5ce6 <__addsf3+0x28>
    5cde:	0c 94 ad 30 	jmp	0x615a	; 0x615a <__fp_nan>
    5ce2:	0e f4       	brtc	.+2      	; 0x5ce6 <__addsf3+0x28>
    5ce4:	e0 95       	com	r30
    5ce6:	e7 fb       	bst	r30, 7
    5ce8:	0c 94 7e 30 	jmp	0x60fc	; 0x60fc <__fp_inf>

00005cec <__addsf3x>:
    5cec:	e9 2f       	mov	r30, r25
    5cee:	0e 94 35 31 	call	0x626a	; 0x626a <__fp_split3>
    5cf2:	58 f3       	brcs	.-42     	; 0x5cca <__addsf3+0xc>
    5cf4:	ba 17       	cp	r27, r26
    5cf6:	62 07       	cpc	r22, r18
    5cf8:	73 07       	cpc	r23, r19
    5cfa:	84 07       	cpc	r24, r20
    5cfc:	95 07       	cpc	r25, r21
    5cfe:	20 f0       	brcs	.+8      	; 0x5d08 <__addsf3x+0x1c>
    5d00:	79 f4       	brne	.+30     	; 0x5d20 <__addsf3x+0x34>
    5d02:	a6 f5       	brtc	.+104    	; 0x5d6c <__addsf3x+0x80>
    5d04:	0c 94 6f 31 	jmp	0x62de	; 0x62de <__fp_zero>
    5d08:	0e f4       	brtc	.+2      	; 0x5d0c <__addsf3x+0x20>
    5d0a:	e0 95       	com	r30
    5d0c:	0b 2e       	mov	r0, r27
    5d0e:	ba 2f       	mov	r27, r26
    5d10:	a0 2d       	mov	r26, r0
    5d12:	0b 01       	movw	r0, r22
    5d14:	b9 01       	movw	r22, r18
    5d16:	90 01       	movw	r18, r0
    5d18:	0c 01       	movw	r0, r24
    5d1a:	ca 01       	movw	r24, r20
    5d1c:	a0 01       	movw	r20, r0
    5d1e:	11 24       	eor	r1, r1
    5d20:	ff 27       	eor	r31, r31
    5d22:	59 1b       	sub	r21, r25
    5d24:	99 f0       	breq	.+38     	; 0x5d4c <__addsf3x+0x60>
    5d26:	59 3f       	cpi	r21, 0xF9	; 249
    5d28:	50 f4       	brcc	.+20     	; 0x5d3e <__addsf3x+0x52>
    5d2a:	50 3e       	cpi	r21, 0xE0	; 224
    5d2c:	68 f1       	brcs	.+90     	; 0x5d88 <__addsf3x+0x9c>
    5d2e:	1a 16       	cp	r1, r26
    5d30:	f0 40       	sbci	r31, 0x00	; 0
    5d32:	a2 2f       	mov	r26, r18
    5d34:	23 2f       	mov	r18, r19
    5d36:	34 2f       	mov	r19, r20
    5d38:	44 27       	eor	r20, r20
    5d3a:	58 5f       	subi	r21, 0xF8	; 248
    5d3c:	f3 cf       	rjmp	.-26     	; 0x5d24 <__addsf3x+0x38>
    5d3e:	46 95       	lsr	r20
    5d40:	37 95       	ror	r19
    5d42:	27 95       	ror	r18
    5d44:	a7 95       	ror	r26
    5d46:	f0 40       	sbci	r31, 0x00	; 0
    5d48:	53 95       	inc	r21
    5d4a:	c9 f7       	brne	.-14     	; 0x5d3e <__addsf3x+0x52>
    5d4c:	7e f4       	brtc	.+30     	; 0x5d6c <__addsf3x+0x80>
    5d4e:	1f 16       	cp	r1, r31
    5d50:	ba 0b       	sbc	r27, r26
    5d52:	62 0b       	sbc	r22, r18
    5d54:	73 0b       	sbc	r23, r19
    5d56:	84 0b       	sbc	r24, r20
    5d58:	ba f0       	brmi	.+46     	; 0x5d88 <__addsf3x+0x9c>
    5d5a:	91 50       	subi	r25, 0x01	; 1
    5d5c:	a1 f0       	breq	.+40     	; 0x5d86 <__addsf3x+0x9a>
    5d5e:	ff 0f       	add	r31, r31
    5d60:	bb 1f       	adc	r27, r27
    5d62:	66 1f       	adc	r22, r22
    5d64:	77 1f       	adc	r23, r23
    5d66:	88 1f       	adc	r24, r24
    5d68:	c2 f7       	brpl	.-16     	; 0x5d5a <__addsf3x+0x6e>
    5d6a:	0e c0       	rjmp	.+28     	; 0x5d88 <__addsf3x+0x9c>
    5d6c:	ba 0f       	add	r27, r26
    5d6e:	62 1f       	adc	r22, r18
    5d70:	73 1f       	adc	r23, r19
    5d72:	84 1f       	adc	r24, r20
    5d74:	48 f4       	brcc	.+18     	; 0x5d88 <__addsf3x+0x9c>
    5d76:	87 95       	ror	r24
    5d78:	77 95       	ror	r23
    5d7a:	67 95       	ror	r22
    5d7c:	b7 95       	ror	r27
    5d7e:	f7 95       	ror	r31
    5d80:	9e 3f       	cpi	r25, 0xFE	; 254
    5d82:	08 f0       	brcs	.+2      	; 0x5d86 <__addsf3x+0x9a>
    5d84:	b0 cf       	rjmp	.-160    	; 0x5ce6 <__addsf3+0x28>
    5d86:	93 95       	inc	r25
    5d88:	88 0f       	add	r24, r24
    5d8a:	08 f0       	brcs	.+2      	; 0x5d8e <__addsf3x+0xa2>
    5d8c:	99 27       	eor	r25, r25
    5d8e:	ee 0f       	add	r30, r30
    5d90:	97 95       	ror	r25
    5d92:	87 95       	ror	r24
    5d94:	08 95       	ret
    5d96:	0e 94 d7 30 	call	0x61ae	; 0x61ae <__fp_pscA>
    5d9a:	60 f0       	brcs	.+24     	; 0x5db4 <__addsf3x+0xc8>
    5d9c:	80 e8       	ldi	r24, 0x80	; 128
    5d9e:	91 e0       	ldi	r25, 0x01	; 1
    5da0:	09 f4       	brne	.+2      	; 0x5da4 <__addsf3x+0xb8>
    5da2:	9e ef       	ldi	r25, 0xFE	; 254
    5da4:	0e 94 de 30 	call	0x61bc	; 0x61bc <__fp_pscB>
    5da8:	28 f0       	brcs	.+10     	; 0x5db4 <__addsf3x+0xc8>
    5daa:	40 e8       	ldi	r20, 0x80	; 128
    5dac:	51 e0       	ldi	r21, 0x01	; 1
    5dae:	71 f4       	brne	.+28     	; 0x5dcc <atan2+0x10>
    5db0:	5e ef       	ldi	r21, 0xFE	; 254
    5db2:	0c c0       	rjmp	.+24     	; 0x5dcc <atan2+0x10>
    5db4:	0c 94 ad 30 	jmp	0x615a	; 0x615a <__fp_nan>
    5db8:	0c 94 6f 31 	jmp	0x62de	; 0x62de <__fp_zero>

00005dbc <atan2>:
    5dbc:	e9 2f       	mov	r30, r25
    5dbe:	e0 78       	andi	r30, 0x80	; 128
    5dc0:	0e 94 35 31 	call	0x626a	; 0x626a <__fp_split3>
    5dc4:	40 f3       	brcs	.-48     	; 0x5d96 <__addsf3x+0xaa>
    5dc6:	09 2e       	mov	r0, r25
    5dc8:	05 2a       	or	r0, r21
    5dca:	b1 f3       	breq	.-20     	; 0x5db8 <__addsf3x+0xcc>
    5dcc:	26 17       	cp	r18, r22
    5dce:	37 07       	cpc	r19, r23
    5dd0:	48 07       	cpc	r20, r24
    5dd2:	59 07       	cpc	r21, r25
    5dd4:	38 f0       	brcs	.+14     	; 0x5de4 <atan2+0x28>
    5dd6:	0e 2e       	mov	r0, r30
    5dd8:	07 f8       	bld	r0, 7
    5dda:	e0 25       	eor	r30, r0
    5ddc:	69 f0       	breq	.+26     	; 0x5df8 <atan2+0x3c>
    5dde:	e0 25       	eor	r30, r0
    5de0:	e0 64       	ori	r30, 0x40	; 64
    5de2:	0a c0       	rjmp	.+20     	; 0x5df8 <atan2+0x3c>
    5de4:	ef 63       	ori	r30, 0x3F	; 63
    5de6:	07 f8       	bld	r0, 7
    5de8:	00 94       	com	r0
    5dea:	07 fa       	bst	r0, 7
    5dec:	db 01       	movw	r26, r22
    5dee:	b9 01       	movw	r22, r18
    5df0:	9d 01       	movw	r18, r26
    5df2:	dc 01       	movw	r26, r24
    5df4:	ca 01       	movw	r24, r20
    5df6:	ad 01       	movw	r20, r26
    5df8:	ef 93       	push	r30
    5dfa:	0e 94 75 2f 	call	0x5eea	; 0x5eea <__divsf3_pse>
    5dfe:	0e 94 10 31 	call	0x6220	; 0x6220 <__fp_round>
    5e02:	0e 94 0e 2f 	call	0x5e1c	; 0x5e1c <atan>
    5e06:	5f 91       	pop	r21
    5e08:	55 23       	and	r21, r21
    5e0a:	39 f0       	breq	.+14     	; 0x5e1a <atan2+0x5e>
    5e0c:	2b ed       	ldi	r18, 0xDB	; 219
    5e0e:	3f e0       	ldi	r19, 0x0F	; 15
    5e10:	49 e4       	ldi	r20, 0x49	; 73
    5e12:	50 fd       	sbrc	r21, 0
    5e14:	49 ec       	ldi	r20, 0xC9	; 201
    5e16:	0c 94 5f 2e 	jmp	0x5cbe	; 0x5cbe <__addsf3>
    5e1a:	08 95       	ret

00005e1c <atan>:
    5e1c:	df 93       	push	r29
    5e1e:	dd 27       	eor	r29, r29
    5e20:	b9 2f       	mov	r27, r25
    5e22:	bf 77       	andi	r27, 0x7F	; 127
    5e24:	40 e8       	ldi	r20, 0x80	; 128
    5e26:	5f e3       	ldi	r21, 0x3F	; 63
    5e28:	16 16       	cp	r1, r22
    5e2a:	17 06       	cpc	r1, r23
    5e2c:	48 07       	cpc	r20, r24
    5e2e:	5b 07       	cpc	r21, r27
    5e30:	18 f4       	brcc	.+6      	; 0x5e38 <atan+0x1c>
    5e32:	d9 2f       	mov	r29, r25
    5e34:	0e 94 7b 31 	call	0x62f6	; 0x62f6 <inverse>
    5e38:	9f 93       	push	r25
    5e3a:	8f 93       	push	r24
    5e3c:	7f 93       	push	r23
    5e3e:	6f 93       	push	r22
    5e40:	0e 94 95 32 	call	0x652a	; 0x652a <square>
    5e44:	e8 ec       	ldi	r30, 0xC8	; 200
    5e46:	f1 e0       	ldi	r31, 0x01	; 1
    5e48:	0e 94 b0 30 	call	0x6160	; 0x6160 <__fp_powser>
    5e4c:	0e 94 10 31 	call	0x6220	; 0x6220 <__fp_round>
    5e50:	2f 91       	pop	r18
    5e52:	3f 91       	pop	r19
    5e54:	4f 91       	pop	r20
    5e56:	5f 91       	pop	r21
    5e58:	0e 94 c9 31 	call	0x6392	; 0x6392 <__mulsf3x>
    5e5c:	dd 23       	and	r29, r29
    5e5e:	51 f0       	breq	.+20     	; 0x5e74 <atan+0x58>
    5e60:	90 58       	subi	r25, 0x80	; 128
    5e62:	a2 ea       	ldi	r26, 0xA2	; 162
    5e64:	2a ed       	ldi	r18, 0xDA	; 218
    5e66:	3f e0       	ldi	r19, 0x0F	; 15
    5e68:	49 ec       	ldi	r20, 0xC9	; 201
    5e6a:	5f e3       	ldi	r21, 0x3F	; 63
    5e6c:	d0 78       	andi	r29, 0x80	; 128
    5e6e:	5d 27       	eor	r21, r29
    5e70:	0e 94 76 2e 	call	0x5cec	; 0x5cec <__addsf3x>
    5e74:	df 91       	pop	r29
    5e76:	0c 94 10 31 	jmp	0x6220	; 0x6220 <__fp_round>

00005e7a <ceil>:
    5e7a:	0e 94 57 31 	call	0x62ae	; 0x62ae <__fp_trunc>
    5e7e:	90 f0       	brcs	.+36     	; 0x5ea4 <ceil+0x2a>
    5e80:	9f 37       	cpi	r25, 0x7F	; 127
    5e82:	48 f4       	brcc	.+18     	; 0x5e96 <ceil+0x1c>
    5e84:	91 11       	cpse	r25, r1
    5e86:	16 f4       	brtc	.+4      	; 0x5e8c <ceil+0x12>
    5e88:	0c 94 70 31 	jmp	0x62e0	; 0x62e0 <__fp_szero>
    5e8c:	60 e0       	ldi	r22, 0x00	; 0
    5e8e:	70 e0       	ldi	r23, 0x00	; 0
    5e90:	80 e8       	ldi	r24, 0x80	; 128
    5e92:	9f e3       	ldi	r25, 0x3F	; 63
    5e94:	08 95       	ret
    5e96:	26 f0       	brts	.+8      	; 0x5ea0 <ceil+0x26>
    5e98:	1b 16       	cp	r1, r27
    5e9a:	61 1d       	adc	r22, r1
    5e9c:	71 1d       	adc	r23, r1
    5e9e:	81 1d       	adc	r24, r1
    5ea0:	0c 94 84 30 	jmp	0x6108	; 0x6108 <__fp_mintl>
    5ea4:	0c 94 9f 30 	jmp	0x613e	; 0x613e <__fp_mpack>

00005ea8 <__cmpsf2>:
    5ea8:	0e 94 5a 30 	call	0x60b4	; 0x60b4 <__fp_cmp>
    5eac:	08 f4       	brcc	.+2      	; 0x5eb0 <__cmpsf2+0x8>
    5eae:	81 e0       	ldi	r24, 0x01	; 1
    5eb0:	08 95       	ret

00005eb2 <cos>:
    5eb2:	0e 94 e7 30 	call	0x61ce	; 0x61ce <__fp_rempio2>
    5eb6:	e3 95       	inc	r30
    5eb8:	0c 94 21 31 	jmp	0x6242	; 0x6242 <__fp_sinus>

00005ebc <__divsf3>:
    5ebc:	0e 94 72 2f 	call	0x5ee4	; 0x5ee4 <__divsf3x>
    5ec0:	0c 94 10 31 	jmp	0x6220	; 0x6220 <__fp_round>
    5ec4:	0e 94 de 30 	call	0x61bc	; 0x61bc <__fp_pscB>
    5ec8:	58 f0       	brcs	.+22     	; 0x5ee0 <__divsf3+0x24>
    5eca:	0e 94 d7 30 	call	0x61ae	; 0x61ae <__fp_pscA>
    5ece:	40 f0       	brcs	.+16     	; 0x5ee0 <__divsf3+0x24>
    5ed0:	29 f4       	brne	.+10     	; 0x5edc <__divsf3+0x20>
    5ed2:	5f 3f       	cpi	r21, 0xFF	; 255
    5ed4:	29 f0       	breq	.+10     	; 0x5ee0 <__divsf3+0x24>
    5ed6:	0c 94 7e 30 	jmp	0x60fc	; 0x60fc <__fp_inf>
    5eda:	51 11       	cpse	r21, r1
    5edc:	0c 94 70 31 	jmp	0x62e0	; 0x62e0 <__fp_szero>
    5ee0:	0c 94 ad 30 	jmp	0x615a	; 0x615a <__fp_nan>

00005ee4 <__divsf3x>:
    5ee4:	0e 94 35 31 	call	0x626a	; 0x626a <__fp_split3>
    5ee8:	68 f3       	brcs	.-38     	; 0x5ec4 <__divsf3+0x8>

00005eea <__divsf3_pse>:
    5eea:	99 23       	and	r25, r25
    5eec:	b1 f3       	breq	.-20     	; 0x5eda <__divsf3+0x1e>
    5eee:	55 23       	and	r21, r21
    5ef0:	91 f3       	breq	.-28     	; 0x5ed6 <__divsf3+0x1a>
    5ef2:	95 1b       	sub	r25, r21
    5ef4:	55 0b       	sbc	r21, r21
    5ef6:	bb 27       	eor	r27, r27
    5ef8:	aa 27       	eor	r26, r26
    5efa:	62 17       	cp	r22, r18
    5efc:	73 07       	cpc	r23, r19
    5efe:	84 07       	cpc	r24, r20
    5f00:	38 f0       	brcs	.+14     	; 0x5f10 <__divsf3_pse+0x26>
    5f02:	9f 5f       	subi	r25, 0xFF	; 255
    5f04:	5f 4f       	sbci	r21, 0xFF	; 255
    5f06:	22 0f       	add	r18, r18
    5f08:	33 1f       	adc	r19, r19
    5f0a:	44 1f       	adc	r20, r20
    5f0c:	aa 1f       	adc	r26, r26
    5f0e:	a9 f3       	breq	.-22     	; 0x5efa <__divsf3_pse+0x10>
    5f10:	35 d0       	rcall	.+106    	; 0x5f7c <__divsf3_pse+0x92>
    5f12:	0e 2e       	mov	r0, r30
    5f14:	3a f0       	brmi	.+14     	; 0x5f24 <__divsf3_pse+0x3a>
    5f16:	e0 e8       	ldi	r30, 0x80	; 128
    5f18:	32 d0       	rcall	.+100    	; 0x5f7e <__divsf3_pse+0x94>
    5f1a:	91 50       	subi	r25, 0x01	; 1
    5f1c:	50 40       	sbci	r21, 0x00	; 0
    5f1e:	e6 95       	lsr	r30
    5f20:	00 1c       	adc	r0, r0
    5f22:	ca f7       	brpl	.-14     	; 0x5f16 <__divsf3_pse+0x2c>
    5f24:	2b d0       	rcall	.+86     	; 0x5f7c <__divsf3_pse+0x92>
    5f26:	fe 2f       	mov	r31, r30
    5f28:	29 d0       	rcall	.+82     	; 0x5f7c <__divsf3_pse+0x92>
    5f2a:	66 0f       	add	r22, r22
    5f2c:	77 1f       	adc	r23, r23
    5f2e:	88 1f       	adc	r24, r24
    5f30:	bb 1f       	adc	r27, r27
    5f32:	26 17       	cp	r18, r22
    5f34:	37 07       	cpc	r19, r23
    5f36:	48 07       	cpc	r20, r24
    5f38:	ab 07       	cpc	r26, r27
    5f3a:	b0 e8       	ldi	r27, 0x80	; 128
    5f3c:	09 f0       	breq	.+2      	; 0x5f40 <__divsf3_pse+0x56>
    5f3e:	bb 0b       	sbc	r27, r27
    5f40:	80 2d       	mov	r24, r0
    5f42:	bf 01       	movw	r22, r30
    5f44:	ff 27       	eor	r31, r31
    5f46:	93 58       	subi	r25, 0x83	; 131
    5f48:	5f 4f       	sbci	r21, 0xFF	; 255
    5f4a:	3a f0       	brmi	.+14     	; 0x5f5a <__divsf3_pse+0x70>
    5f4c:	9e 3f       	cpi	r25, 0xFE	; 254
    5f4e:	51 05       	cpc	r21, r1
    5f50:	78 f0       	brcs	.+30     	; 0x5f70 <__divsf3_pse+0x86>
    5f52:	0c 94 7e 30 	jmp	0x60fc	; 0x60fc <__fp_inf>
    5f56:	0c 94 70 31 	jmp	0x62e0	; 0x62e0 <__fp_szero>
    5f5a:	5f 3f       	cpi	r21, 0xFF	; 255
    5f5c:	e4 f3       	brlt	.-8      	; 0x5f56 <__divsf3_pse+0x6c>
    5f5e:	98 3e       	cpi	r25, 0xE8	; 232
    5f60:	d4 f3       	brlt	.-12     	; 0x5f56 <__divsf3_pse+0x6c>
    5f62:	86 95       	lsr	r24
    5f64:	77 95       	ror	r23
    5f66:	67 95       	ror	r22
    5f68:	b7 95       	ror	r27
    5f6a:	f7 95       	ror	r31
    5f6c:	9f 5f       	subi	r25, 0xFF	; 255
    5f6e:	c9 f7       	brne	.-14     	; 0x5f62 <__divsf3_pse+0x78>
    5f70:	88 0f       	add	r24, r24
    5f72:	91 1d       	adc	r25, r1
    5f74:	96 95       	lsr	r25
    5f76:	87 95       	ror	r24
    5f78:	97 f9       	bld	r25, 7
    5f7a:	08 95       	ret
    5f7c:	e1 e0       	ldi	r30, 0x01	; 1
    5f7e:	66 0f       	add	r22, r22
    5f80:	77 1f       	adc	r23, r23
    5f82:	88 1f       	adc	r24, r24
    5f84:	bb 1f       	adc	r27, r27
    5f86:	62 17       	cp	r22, r18
    5f88:	73 07       	cpc	r23, r19
    5f8a:	84 07       	cpc	r24, r20
    5f8c:	ba 07       	cpc	r27, r26
    5f8e:	20 f0       	brcs	.+8      	; 0x5f98 <__divsf3_pse+0xae>
    5f90:	62 1b       	sub	r22, r18
    5f92:	73 0b       	sbc	r23, r19
    5f94:	84 0b       	sbc	r24, r20
    5f96:	ba 0b       	sbc	r27, r26
    5f98:	ee 1f       	adc	r30, r30
    5f9a:	88 f7       	brcc	.-30     	; 0x5f7e <__divsf3_pse+0x94>
    5f9c:	e0 95       	com	r30
    5f9e:	08 95       	ret

00005fa0 <__fixsfsi>:
    5fa0:	0e 94 d7 2f 	call	0x5fae	; 0x5fae <__fixunssfsi>
    5fa4:	68 94       	set
    5fa6:	b1 11       	cpse	r27, r1
    5fa8:	0c 94 70 31 	jmp	0x62e0	; 0x62e0 <__fp_szero>
    5fac:	08 95       	ret

00005fae <__fixunssfsi>:
    5fae:	0e 94 3d 31 	call	0x627a	; 0x627a <__fp_splitA>
    5fb2:	88 f0       	brcs	.+34     	; 0x5fd6 <__fixunssfsi+0x28>
    5fb4:	9f 57       	subi	r25, 0x7F	; 127
    5fb6:	98 f0       	brcs	.+38     	; 0x5fde <__fixunssfsi+0x30>
    5fb8:	b9 2f       	mov	r27, r25
    5fba:	99 27       	eor	r25, r25
    5fbc:	b7 51       	subi	r27, 0x17	; 23
    5fbe:	b0 f0       	brcs	.+44     	; 0x5fec <__fixunssfsi+0x3e>
    5fc0:	e1 f0       	breq	.+56     	; 0x5ffa <__fixunssfsi+0x4c>
    5fc2:	66 0f       	add	r22, r22
    5fc4:	77 1f       	adc	r23, r23
    5fc6:	88 1f       	adc	r24, r24
    5fc8:	99 1f       	adc	r25, r25
    5fca:	1a f0       	brmi	.+6      	; 0x5fd2 <__fixunssfsi+0x24>
    5fcc:	ba 95       	dec	r27
    5fce:	c9 f7       	brne	.-14     	; 0x5fc2 <__fixunssfsi+0x14>
    5fd0:	14 c0       	rjmp	.+40     	; 0x5ffa <__fixunssfsi+0x4c>
    5fd2:	b1 30       	cpi	r27, 0x01	; 1
    5fd4:	91 f0       	breq	.+36     	; 0x5ffa <__fixunssfsi+0x4c>
    5fd6:	0e 94 6f 31 	call	0x62de	; 0x62de <__fp_zero>
    5fda:	b1 e0       	ldi	r27, 0x01	; 1
    5fdc:	08 95       	ret
    5fde:	0c 94 6f 31 	jmp	0x62de	; 0x62de <__fp_zero>
    5fe2:	67 2f       	mov	r22, r23
    5fe4:	78 2f       	mov	r23, r24
    5fe6:	88 27       	eor	r24, r24
    5fe8:	b8 5f       	subi	r27, 0xF8	; 248
    5fea:	39 f0       	breq	.+14     	; 0x5ffa <__fixunssfsi+0x4c>
    5fec:	b9 3f       	cpi	r27, 0xF9	; 249
    5fee:	cc f3       	brlt	.-14     	; 0x5fe2 <__fixunssfsi+0x34>
    5ff0:	86 95       	lsr	r24
    5ff2:	77 95       	ror	r23
    5ff4:	67 95       	ror	r22
    5ff6:	b3 95       	inc	r27
    5ff8:	d9 f7       	brne	.-10     	; 0x5ff0 <__fixunssfsi+0x42>
    5ffa:	3e f4       	brtc	.+14     	; 0x600a <__fixunssfsi+0x5c>
    5ffc:	90 95       	com	r25
    5ffe:	80 95       	com	r24
    6000:	70 95       	com	r23
    6002:	61 95       	neg	r22
    6004:	7f 4f       	sbci	r23, 0xFF	; 255
    6006:	8f 4f       	sbci	r24, 0xFF	; 255
    6008:	9f 4f       	sbci	r25, 0xFF	; 255
    600a:	08 95       	ret

0000600c <__floatunsisf>:
    600c:	e8 94       	clt
    600e:	09 c0       	rjmp	.+18     	; 0x6022 <__floatsisf+0x12>

00006010 <__floatsisf>:
    6010:	97 fb       	bst	r25, 7
    6012:	3e f4       	brtc	.+14     	; 0x6022 <__floatsisf+0x12>
    6014:	90 95       	com	r25
    6016:	80 95       	com	r24
    6018:	70 95       	com	r23
    601a:	61 95       	neg	r22
    601c:	7f 4f       	sbci	r23, 0xFF	; 255
    601e:	8f 4f       	sbci	r24, 0xFF	; 255
    6020:	9f 4f       	sbci	r25, 0xFF	; 255
    6022:	99 23       	and	r25, r25
    6024:	a9 f0       	breq	.+42     	; 0x6050 <__floatsisf+0x40>
    6026:	f9 2f       	mov	r31, r25
    6028:	96 e9       	ldi	r25, 0x96	; 150
    602a:	bb 27       	eor	r27, r27
    602c:	93 95       	inc	r25
    602e:	f6 95       	lsr	r31
    6030:	87 95       	ror	r24
    6032:	77 95       	ror	r23
    6034:	67 95       	ror	r22
    6036:	b7 95       	ror	r27
    6038:	f1 11       	cpse	r31, r1
    603a:	f8 cf       	rjmp	.-16     	; 0x602c <__floatsisf+0x1c>
    603c:	fa f4       	brpl	.+62     	; 0x607c <__floatsisf+0x6c>
    603e:	bb 0f       	add	r27, r27
    6040:	11 f4       	brne	.+4      	; 0x6046 <__floatsisf+0x36>
    6042:	60 ff       	sbrs	r22, 0
    6044:	1b c0       	rjmp	.+54     	; 0x607c <__floatsisf+0x6c>
    6046:	6f 5f       	subi	r22, 0xFF	; 255
    6048:	7f 4f       	sbci	r23, 0xFF	; 255
    604a:	8f 4f       	sbci	r24, 0xFF	; 255
    604c:	9f 4f       	sbci	r25, 0xFF	; 255
    604e:	16 c0       	rjmp	.+44     	; 0x607c <__floatsisf+0x6c>
    6050:	88 23       	and	r24, r24
    6052:	11 f0       	breq	.+4      	; 0x6058 <__floatsisf+0x48>
    6054:	96 e9       	ldi	r25, 0x96	; 150
    6056:	11 c0       	rjmp	.+34     	; 0x607a <__floatsisf+0x6a>
    6058:	77 23       	and	r23, r23
    605a:	21 f0       	breq	.+8      	; 0x6064 <__floatsisf+0x54>
    605c:	9e e8       	ldi	r25, 0x8E	; 142
    605e:	87 2f       	mov	r24, r23
    6060:	76 2f       	mov	r23, r22
    6062:	05 c0       	rjmp	.+10     	; 0x606e <__floatsisf+0x5e>
    6064:	66 23       	and	r22, r22
    6066:	71 f0       	breq	.+28     	; 0x6084 <__floatsisf+0x74>
    6068:	96 e8       	ldi	r25, 0x86	; 134
    606a:	86 2f       	mov	r24, r22
    606c:	70 e0       	ldi	r23, 0x00	; 0
    606e:	60 e0       	ldi	r22, 0x00	; 0
    6070:	2a f0       	brmi	.+10     	; 0x607c <__floatsisf+0x6c>
    6072:	9a 95       	dec	r25
    6074:	66 0f       	add	r22, r22
    6076:	77 1f       	adc	r23, r23
    6078:	88 1f       	adc	r24, r24
    607a:	da f7       	brpl	.-10     	; 0x6072 <__floatsisf+0x62>
    607c:	88 0f       	add	r24, r24
    607e:	96 95       	lsr	r25
    6080:	87 95       	ror	r24
    6082:	97 f9       	bld	r25, 7
    6084:	08 95       	ret

00006086 <floor>:
    6086:	0e 94 57 31 	call	0x62ae	; 0x62ae <__fp_trunc>
    608a:	90 f0       	brcs	.+36     	; 0x60b0 <floor+0x2a>
    608c:	9f 37       	cpi	r25, 0x7F	; 127
    608e:	48 f4       	brcc	.+18     	; 0x60a2 <floor+0x1c>
    6090:	91 11       	cpse	r25, r1
    6092:	16 f0       	brts	.+4      	; 0x6098 <floor+0x12>
    6094:	0c 94 70 31 	jmp	0x62e0	; 0x62e0 <__fp_szero>
    6098:	60 e0       	ldi	r22, 0x00	; 0
    609a:	70 e0       	ldi	r23, 0x00	; 0
    609c:	80 e8       	ldi	r24, 0x80	; 128
    609e:	9f eb       	ldi	r25, 0xBF	; 191
    60a0:	08 95       	ret
    60a2:	26 f4       	brtc	.+8      	; 0x60ac <floor+0x26>
    60a4:	1b 16       	cp	r1, r27
    60a6:	61 1d       	adc	r22, r1
    60a8:	71 1d       	adc	r23, r1
    60aa:	81 1d       	adc	r24, r1
    60ac:	0c 94 84 30 	jmp	0x6108	; 0x6108 <__fp_mintl>
    60b0:	0c 94 9f 30 	jmp	0x613e	; 0x613e <__fp_mpack>

000060b4 <__fp_cmp>:
    60b4:	99 0f       	add	r25, r25
    60b6:	00 08       	sbc	r0, r0
    60b8:	55 0f       	add	r21, r21
    60ba:	aa 0b       	sbc	r26, r26
    60bc:	e0 e8       	ldi	r30, 0x80	; 128
    60be:	fe ef       	ldi	r31, 0xFE	; 254
    60c0:	16 16       	cp	r1, r22
    60c2:	17 06       	cpc	r1, r23
    60c4:	e8 07       	cpc	r30, r24
    60c6:	f9 07       	cpc	r31, r25
    60c8:	c0 f0       	brcs	.+48     	; 0x60fa <__fp_cmp+0x46>
    60ca:	12 16       	cp	r1, r18
    60cc:	13 06       	cpc	r1, r19
    60ce:	e4 07       	cpc	r30, r20
    60d0:	f5 07       	cpc	r31, r21
    60d2:	98 f0       	brcs	.+38     	; 0x60fa <__fp_cmp+0x46>
    60d4:	62 1b       	sub	r22, r18
    60d6:	73 0b       	sbc	r23, r19
    60d8:	84 0b       	sbc	r24, r20
    60da:	95 0b       	sbc	r25, r21
    60dc:	39 f4       	brne	.+14     	; 0x60ec <__fp_cmp+0x38>
    60de:	0a 26       	eor	r0, r26
    60e0:	61 f0       	breq	.+24     	; 0x60fa <__fp_cmp+0x46>
    60e2:	23 2b       	or	r18, r19
    60e4:	24 2b       	or	r18, r20
    60e6:	25 2b       	or	r18, r21
    60e8:	21 f4       	brne	.+8      	; 0x60f2 <__fp_cmp+0x3e>
    60ea:	08 95       	ret
    60ec:	0a 26       	eor	r0, r26
    60ee:	09 f4       	brne	.+2      	; 0x60f2 <__fp_cmp+0x3e>
    60f0:	a1 40       	sbci	r26, 0x01	; 1
    60f2:	a6 95       	lsr	r26
    60f4:	8f ef       	ldi	r24, 0xFF	; 255
    60f6:	81 1d       	adc	r24, r1
    60f8:	81 1d       	adc	r24, r1
    60fa:	08 95       	ret

000060fc <__fp_inf>:
    60fc:	97 f9       	bld	r25, 7
    60fe:	9f 67       	ori	r25, 0x7F	; 127
    6100:	80 e8       	ldi	r24, 0x80	; 128
    6102:	70 e0       	ldi	r23, 0x00	; 0
    6104:	60 e0       	ldi	r22, 0x00	; 0
    6106:	08 95       	ret

00006108 <__fp_mintl>:
    6108:	88 23       	and	r24, r24
    610a:	71 f4       	brne	.+28     	; 0x6128 <__fp_mintl+0x20>
    610c:	77 23       	and	r23, r23
    610e:	21 f0       	breq	.+8      	; 0x6118 <__fp_mintl+0x10>
    6110:	98 50       	subi	r25, 0x08	; 8
    6112:	87 2b       	or	r24, r23
    6114:	76 2f       	mov	r23, r22
    6116:	07 c0       	rjmp	.+14     	; 0x6126 <__fp_mintl+0x1e>
    6118:	66 23       	and	r22, r22
    611a:	11 f4       	brne	.+4      	; 0x6120 <__fp_mintl+0x18>
    611c:	99 27       	eor	r25, r25
    611e:	0d c0       	rjmp	.+26     	; 0x613a <__fp_mintl+0x32>
    6120:	90 51       	subi	r25, 0x10	; 16
    6122:	86 2b       	or	r24, r22
    6124:	70 e0       	ldi	r23, 0x00	; 0
    6126:	60 e0       	ldi	r22, 0x00	; 0
    6128:	2a f0       	brmi	.+10     	; 0x6134 <__fp_mintl+0x2c>
    612a:	9a 95       	dec	r25
    612c:	66 0f       	add	r22, r22
    612e:	77 1f       	adc	r23, r23
    6130:	88 1f       	adc	r24, r24
    6132:	da f7       	brpl	.-10     	; 0x612a <__fp_mintl+0x22>
    6134:	88 0f       	add	r24, r24
    6136:	96 95       	lsr	r25
    6138:	87 95       	ror	r24
    613a:	97 f9       	bld	r25, 7
    613c:	08 95       	ret

0000613e <__fp_mpack>:
    613e:	9f 3f       	cpi	r25, 0xFF	; 255
    6140:	31 f0       	breq	.+12     	; 0x614e <__fp_mpack_finite+0xc>

00006142 <__fp_mpack_finite>:
    6142:	91 50       	subi	r25, 0x01	; 1
    6144:	20 f4       	brcc	.+8      	; 0x614e <__fp_mpack_finite+0xc>
    6146:	87 95       	ror	r24
    6148:	77 95       	ror	r23
    614a:	67 95       	ror	r22
    614c:	b7 95       	ror	r27
    614e:	88 0f       	add	r24, r24
    6150:	91 1d       	adc	r25, r1
    6152:	96 95       	lsr	r25
    6154:	87 95       	ror	r24
    6156:	97 f9       	bld	r25, 7
    6158:	08 95       	ret

0000615a <__fp_nan>:
    615a:	9f ef       	ldi	r25, 0xFF	; 255
    615c:	80 ec       	ldi	r24, 0xC0	; 192
    615e:	08 95       	ret

00006160 <__fp_powser>:
    6160:	df 93       	push	r29
    6162:	cf 93       	push	r28
    6164:	1f 93       	push	r17
    6166:	0f 93       	push	r16
    6168:	ff 92       	push	r15
    616a:	ef 92       	push	r14
    616c:	df 92       	push	r13
    616e:	7b 01       	movw	r14, r22
    6170:	8c 01       	movw	r16, r24
    6172:	68 94       	set
    6174:	06 c0       	rjmp	.+12     	; 0x6182 <__fp_powser+0x22>
    6176:	da 2e       	mov	r13, r26
    6178:	ef 01       	movw	r28, r30
    617a:	0e 94 c9 31 	call	0x6392	; 0x6392 <__mulsf3x>
    617e:	fe 01       	movw	r30, r28
    6180:	e8 94       	clt
    6182:	a5 91       	lpm	r26, Z+
    6184:	25 91       	lpm	r18, Z+
    6186:	35 91       	lpm	r19, Z+
    6188:	45 91       	lpm	r20, Z+
    618a:	55 91       	lpm	r21, Z+
    618c:	a6 f3       	brts	.-24     	; 0x6176 <__fp_powser+0x16>
    618e:	ef 01       	movw	r28, r30
    6190:	0e 94 76 2e 	call	0x5cec	; 0x5cec <__addsf3x>
    6194:	fe 01       	movw	r30, r28
    6196:	97 01       	movw	r18, r14
    6198:	a8 01       	movw	r20, r16
    619a:	da 94       	dec	r13
    619c:	69 f7       	brne	.-38     	; 0x6178 <__fp_powser+0x18>
    619e:	df 90       	pop	r13
    61a0:	ef 90       	pop	r14
    61a2:	ff 90       	pop	r15
    61a4:	0f 91       	pop	r16
    61a6:	1f 91       	pop	r17
    61a8:	cf 91       	pop	r28
    61aa:	df 91       	pop	r29
    61ac:	08 95       	ret

000061ae <__fp_pscA>:
    61ae:	00 24       	eor	r0, r0
    61b0:	0a 94       	dec	r0
    61b2:	16 16       	cp	r1, r22
    61b4:	17 06       	cpc	r1, r23
    61b6:	18 06       	cpc	r1, r24
    61b8:	09 06       	cpc	r0, r25
    61ba:	08 95       	ret

000061bc <__fp_pscB>:
    61bc:	00 24       	eor	r0, r0
    61be:	0a 94       	dec	r0
    61c0:	12 16       	cp	r1, r18
    61c2:	13 06       	cpc	r1, r19
    61c4:	14 06       	cpc	r1, r20
    61c6:	05 06       	cpc	r0, r21
    61c8:	08 95       	ret
    61ca:	0c 94 ad 30 	jmp	0x615a	; 0x615a <__fp_nan>

000061ce <__fp_rempio2>:
    61ce:	0e 94 3d 31 	call	0x627a	; 0x627a <__fp_splitA>
    61d2:	d8 f3       	brcs	.-10     	; 0x61ca <__fp_pscB+0xe>
    61d4:	e8 94       	clt
    61d6:	e0 e0       	ldi	r30, 0x00	; 0
    61d8:	bb 27       	eor	r27, r27
    61da:	9f 57       	subi	r25, 0x7F	; 127
    61dc:	f0 f0       	brcs	.+60     	; 0x621a <__fp_rempio2+0x4c>
    61de:	2a ed       	ldi	r18, 0xDA	; 218
    61e0:	3f e0       	ldi	r19, 0x0F	; 15
    61e2:	49 ec       	ldi	r20, 0xC9	; 201
    61e4:	06 c0       	rjmp	.+12     	; 0x61f2 <__fp_rempio2+0x24>
    61e6:	ee 0f       	add	r30, r30
    61e8:	bb 0f       	add	r27, r27
    61ea:	66 1f       	adc	r22, r22
    61ec:	77 1f       	adc	r23, r23
    61ee:	88 1f       	adc	r24, r24
    61f0:	28 f0       	brcs	.+10     	; 0x61fc <__fp_rempio2+0x2e>
    61f2:	b2 3a       	cpi	r27, 0xA2	; 162
    61f4:	62 07       	cpc	r22, r18
    61f6:	73 07       	cpc	r23, r19
    61f8:	84 07       	cpc	r24, r20
    61fa:	28 f0       	brcs	.+10     	; 0x6206 <__fp_rempio2+0x38>
    61fc:	b2 5a       	subi	r27, 0xA2	; 162
    61fe:	62 0b       	sbc	r22, r18
    6200:	73 0b       	sbc	r23, r19
    6202:	84 0b       	sbc	r24, r20
    6204:	e3 95       	inc	r30
    6206:	9a 95       	dec	r25
    6208:	72 f7       	brpl	.-36     	; 0x61e6 <__fp_rempio2+0x18>
    620a:	80 38       	cpi	r24, 0x80	; 128
    620c:	30 f4       	brcc	.+12     	; 0x621a <__fp_rempio2+0x4c>
    620e:	9a 95       	dec	r25
    6210:	bb 0f       	add	r27, r27
    6212:	66 1f       	adc	r22, r22
    6214:	77 1f       	adc	r23, r23
    6216:	88 1f       	adc	r24, r24
    6218:	d2 f7       	brpl	.-12     	; 0x620e <__fp_rempio2+0x40>
    621a:	90 48       	sbci	r25, 0x80	; 128
    621c:	0c 94 a1 30 	jmp	0x6142	; 0x6142 <__fp_mpack_finite>

00006220 <__fp_round>:
    6220:	09 2e       	mov	r0, r25
    6222:	03 94       	inc	r0
    6224:	00 0c       	add	r0, r0
    6226:	11 f4       	brne	.+4      	; 0x622c <__fp_round+0xc>
    6228:	88 23       	and	r24, r24
    622a:	52 f0       	brmi	.+20     	; 0x6240 <__fp_round+0x20>
    622c:	bb 0f       	add	r27, r27
    622e:	40 f4       	brcc	.+16     	; 0x6240 <__fp_round+0x20>
    6230:	bf 2b       	or	r27, r31
    6232:	11 f4       	brne	.+4      	; 0x6238 <__fp_round+0x18>
    6234:	60 ff       	sbrs	r22, 0
    6236:	04 c0       	rjmp	.+8      	; 0x6240 <__fp_round+0x20>
    6238:	6f 5f       	subi	r22, 0xFF	; 255
    623a:	7f 4f       	sbci	r23, 0xFF	; 255
    623c:	8f 4f       	sbci	r24, 0xFF	; 255
    623e:	9f 4f       	sbci	r25, 0xFF	; 255
    6240:	08 95       	ret

00006242 <__fp_sinus>:
    6242:	ef 93       	push	r30
    6244:	e0 ff       	sbrs	r30, 0
    6246:	07 c0       	rjmp	.+14     	; 0x6256 <__fp_sinus+0x14>
    6248:	a2 ea       	ldi	r26, 0xA2	; 162
    624a:	2a ed       	ldi	r18, 0xDA	; 218
    624c:	3f e0       	ldi	r19, 0x0F	; 15
    624e:	49 ec       	ldi	r20, 0xC9	; 201
    6250:	5f eb       	ldi	r21, 0xBF	; 191
    6252:	0e 94 76 2e 	call	0x5cec	; 0x5cec <__addsf3x>
    6256:	0e 94 10 31 	call	0x6220	; 0x6220 <__fp_round>
    625a:	0f 90       	pop	r0
    625c:	03 94       	inc	r0
    625e:	01 fc       	sbrc	r0, 1
    6260:	90 58       	subi	r25, 0x80	; 128
    6262:	e5 ef       	ldi	r30, 0xF5	; 245
    6264:	f1 e0       	ldi	r31, 0x01	; 1
    6266:	0c 94 ab 32 	jmp	0x6556	; 0x6556 <__fp_powsodd>

0000626a <__fp_split3>:
    626a:	57 fd       	sbrc	r21, 7
    626c:	90 58       	subi	r25, 0x80	; 128
    626e:	44 0f       	add	r20, r20
    6270:	55 1f       	adc	r21, r21
    6272:	59 f0       	breq	.+22     	; 0x628a <__fp_splitA+0x10>
    6274:	5f 3f       	cpi	r21, 0xFF	; 255
    6276:	71 f0       	breq	.+28     	; 0x6294 <__fp_splitA+0x1a>
    6278:	47 95       	ror	r20

0000627a <__fp_splitA>:
    627a:	88 0f       	add	r24, r24
    627c:	97 fb       	bst	r25, 7
    627e:	99 1f       	adc	r25, r25
    6280:	61 f0       	breq	.+24     	; 0x629a <__fp_splitA+0x20>
    6282:	9f 3f       	cpi	r25, 0xFF	; 255
    6284:	79 f0       	breq	.+30     	; 0x62a4 <__fp_splitA+0x2a>
    6286:	87 95       	ror	r24
    6288:	08 95       	ret
    628a:	12 16       	cp	r1, r18
    628c:	13 06       	cpc	r1, r19
    628e:	14 06       	cpc	r1, r20
    6290:	55 1f       	adc	r21, r21
    6292:	f2 cf       	rjmp	.-28     	; 0x6278 <__fp_split3+0xe>
    6294:	46 95       	lsr	r20
    6296:	f1 df       	rcall	.-30     	; 0x627a <__fp_splitA>
    6298:	08 c0       	rjmp	.+16     	; 0x62aa <__fp_splitA+0x30>
    629a:	16 16       	cp	r1, r22
    629c:	17 06       	cpc	r1, r23
    629e:	18 06       	cpc	r1, r24
    62a0:	99 1f       	adc	r25, r25
    62a2:	f1 cf       	rjmp	.-30     	; 0x6286 <__fp_splitA+0xc>
    62a4:	86 95       	lsr	r24
    62a6:	71 05       	cpc	r23, r1
    62a8:	61 05       	cpc	r22, r1
    62aa:	08 94       	sec
    62ac:	08 95       	ret

000062ae <__fp_trunc>:
    62ae:	0e 94 3d 31 	call	0x627a	; 0x627a <__fp_splitA>
    62b2:	a0 f0       	brcs	.+40     	; 0x62dc <__fp_trunc+0x2e>
    62b4:	be e7       	ldi	r27, 0x7E	; 126
    62b6:	b9 17       	cp	r27, r25
    62b8:	88 f4       	brcc	.+34     	; 0x62dc <__fp_trunc+0x2e>
    62ba:	bb 27       	eor	r27, r27
    62bc:	9f 38       	cpi	r25, 0x8F	; 143
    62be:	60 f4       	brcc	.+24     	; 0x62d8 <__fp_trunc+0x2a>
    62c0:	16 16       	cp	r1, r22
    62c2:	b1 1d       	adc	r27, r1
    62c4:	67 2f       	mov	r22, r23
    62c6:	78 2f       	mov	r23, r24
    62c8:	88 27       	eor	r24, r24
    62ca:	98 5f       	subi	r25, 0xF8	; 248
    62cc:	f7 cf       	rjmp	.-18     	; 0x62bc <__fp_trunc+0xe>
    62ce:	86 95       	lsr	r24
    62d0:	77 95       	ror	r23
    62d2:	67 95       	ror	r22
    62d4:	b1 1d       	adc	r27, r1
    62d6:	93 95       	inc	r25
    62d8:	96 39       	cpi	r25, 0x96	; 150
    62da:	c8 f3       	brcs	.-14     	; 0x62ce <__fp_trunc+0x20>
    62dc:	08 95       	ret

000062de <__fp_zero>:
    62de:	e8 94       	clt

000062e0 <__fp_szero>:
    62e0:	bb 27       	eor	r27, r27
    62e2:	66 27       	eor	r22, r22
    62e4:	77 27       	eor	r23, r23
    62e6:	cb 01       	movw	r24, r22
    62e8:	97 f9       	bld	r25, 7
    62ea:	08 95       	ret

000062ec <__gesf2>:
    62ec:	0e 94 5a 30 	call	0x60b4	; 0x60b4 <__fp_cmp>
    62f0:	08 f4       	brcc	.+2      	; 0x62f4 <__gesf2+0x8>
    62f2:	8f ef       	ldi	r24, 0xFF	; 255
    62f4:	08 95       	ret

000062f6 <inverse>:
    62f6:	9b 01       	movw	r18, r22
    62f8:	ac 01       	movw	r20, r24
    62fa:	60 e0       	ldi	r22, 0x00	; 0
    62fc:	70 e0       	ldi	r23, 0x00	; 0
    62fe:	80 e8       	ldi	r24, 0x80	; 128
    6300:	9f e3       	ldi	r25, 0x3F	; 63
    6302:	0c 94 5e 2f 	jmp	0x5ebc	; 0x5ebc <__divsf3>

00006306 <lround>:
    6306:	0e 94 3d 31 	call	0x627a	; 0x627a <__fp_splitA>
    630a:	58 f1       	brcs	.+86     	; 0x6362 <lround+0x5c>
    630c:	9e 57       	subi	r25, 0x7E	; 126
    630e:	60 f1       	brcs	.+88     	; 0x6368 <lround+0x62>
    6310:	98 51       	subi	r25, 0x18	; 24
    6312:	a0 f0       	brcs	.+40     	; 0x633c <lround+0x36>
    6314:	e9 f0       	breq	.+58     	; 0x6350 <lround+0x4a>
    6316:	98 30       	cpi	r25, 0x08	; 8
    6318:	20 f5       	brcc	.+72     	; 0x6362 <lround+0x5c>
    631a:	09 2e       	mov	r0, r25
    631c:	99 27       	eor	r25, r25
    631e:	66 0f       	add	r22, r22
    6320:	77 1f       	adc	r23, r23
    6322:	88 1f       	adc	r24, r24
    6324:	99 1f       	adc	r25, r25
    6326:	0a 94       	dec	r0
    6328:	d1 f7       	brne	.-12     	; 0x631e <lround+0x18>
    632a:	12 c0       	rjmp	.+36     	; 0x6350 <lround+0x4a>
    632c:	06 2e       	mov	r0, r22
    632e:	67 2f       	mov	r22, r23
    6330:	78 2f       	mov	r23, r24
    6332:	88 27       	eor	r24, r24
    6334:	98 5f       	subi	r25, 0xF8	; 248
    6336:	11 f4       	brne	.+4      	; 0x633c <lround+0x36>
    6338:	00 0c       	add	r0, r0
    633a:	07 c0       	rjmp	.+14     	; 0x634a <lround+0x44>
    633c:	99 3f       	cpi	r25, 0xF9	; 249
    633e:	b4 f3       	brlt	.-20     	; 0x632c <lround+0x26>
    6340:	86 95       	lsr	r24
    6342:	77 95       	ror	r23
    6344:	67 95       	ror	r22
    6346:	93 95       	inc	r25
    6348:	d9 f7       	brne	.-10     	; 0x6340 <lround+0x3a>
    634a:	61 1d       	adc	r22, r1
    634c:	71 1d       	adc	r23, r1
    634e:	81 1d       	adc	r24, r1
    6350:	3e f4       	brtc	.+14     	; 0x6360 <lround+0x5a>
    6352:	90 95       	com	r25
    6354:	80 95       	com	r24
    6356:	70 95       	com	r23
    6358:	61 95       	neg	r22
    635a:	7f 4f       	sbci	r23, 0xFF	; 255
    635c:	8f 4f       	sbci	r24, 0xFF	; 255
    635e:	9f 4f       	sbci	r25, 0xFF	; 255
    6360:	08 95       	ret
    6362:	68 94       	set
    6364:	0c 94 70 31 	jmp	0x62e0	; 0x62e0 <__fp_szero>
    6368:	0c 94 6f 31 	jmp	0x62de	; 0x62de <__fp_zero>

0000636c <__mulsf3>:
    636c:	0e 94 c9 31 	call	0x6392	; 0x6392 <__mulsf3x>
    6370:	0c 94 10 31 	jmp	0x6220	; 0x6220 <__fp_round>
    6374:	0e 94 d7 30 	call	0x61ae	; 0x61ae <__fp_pscA>
    6378:	38 f0       	brcs	.+14     	; 0x6388 <__mulsf3+0x1c>
    637a:	0e 94 de 30 	call	0x61bc	; 0x61bc <__fp_pscB>
    637e:	20 f0       	brcs	.+8      	; 0x6388 <__mulsf3+0x1c>
    6380:	95 23       	and	r25, r21
    6382:	11 f0       	breq	.+4      	; 0x6388 <__mulsf3+0x1c>
    6384:	0c 94 7e 30 	jmp	0x60fc	; 0x60fc <__fp_inf>
    6388:	0c 94 ad 30 	jmp	0x615a	; 0x615a <__fp_nan>
    638c:	11 24       	eor	r1, r1
    638e:	0c 94 70 31 	jmp	0x62e0	; 0x62e0 <__fp_szero>

00006392 <__mulsf3x>:
    6392:	0e 94 35 31 	call	0x626a	; 0x626a <__fp_split3>
    6396:	70 f3       	brcs	.-36     	; 0x6374 <__mulsf3+0x8>

00006398 <__mulsf3_pse>:
    6398:	95 9f       	mul	r25, r21
    639a:	c1 f3       	breq	.-16     	; 0x638c <__mulsf3+0x20>
    639c:	95 0f       	add	r25, r21
    639e:	50 e0       	ldi	r21, 0x00	; 0
    63a0:	55 1f       	adc	r21, r21
    63a2:	62 9f       	mul	r22, r18
    63a4:	f0 01       	movw	r30, r0
    63a6:	72 9f       	mul	r23, r18
    63a8:	bb 27       	eor	r27, r27
    63aa:	f0 0d       	add	r31, r0
    63ac:	b1 1d       	adc	r27, r1
    63ae:	63 9f       	mul	r22, r19
    63b0:	aa 27       	eor	r26, r26
    63b2:	f0 0d       	add	r31, r0
    63b4:	b1 1d       	adc	r27, r1
    63b6:	aa 1f       	adc	r26, r26
    63b8:	64 9f       	mul	r22, r20
    63ba:	66 27       	eor	r22, r22
    63bc:	b0 0d       	add	r27, r0
    63be:	a1 1d       	adc	r26, r1
    63c0:	66 1f       	adc	r22, r22
    63c2:	82 9f       	mul	r24, r18
    63c4:	22 27       	eor	r18, r18
    63c6:	b0 0d       	add	r27, r0
    63c8:	a1 1d       	adc	r26, r1
    63ca:	62 1f       	adc	r22, r18
    63cc:	73 9f       	mul	r23, r19
    63ce:	b0 0d       	add	r27, r0
    63d0:	a1 1d       	adc	r26, r1
    63d2:	62 1f       	adc	r22, r18
    63d4:	83 9f       	mul	r24, r19
    63d6:	a0 0d       	add	r26, r0
    63d8:	61 1d       	adc	r22, r1
    63da:	22 1f       	adc	r18, r18
    63dc:	74 9f       	mul	r23, r20
    63de:	33 27       	eor	r19, r19
    63e0:	a0 0d       	add	r26, r0
    63e2:	61 1d       	adc	r22, r1
    63e4:	23 1f       	adc	r18, r19
    63e6:	84 9f       	mul	r24, r20
    63e8:	60 0d       	add	r22, r0
    63ea:	21 1d       	adc	r18, r1
    63ec:	82 2f       	mov	r24, r18
    63ee:	76 2f       	mov	r23, r22
    63f0:	6a 2f       	mov	r22, r26
    63f2:	11 24       	eor	r1, r1
    63f4:	9f 57       	subi	r25, 0x7F	; 127
    63f6:	50 40       	sbci	r21, 0x00	; 0
    63f8:	9a f0       	brmi	.+38     	; 0x6420 <__mulsf3_pse+0x88>
    63fa:	f1 f0       	breq	.+60     	; 0x6438 <__mulsf3_pse+0xa0>
    63fc:	88 23       	and	r24, r24
    63fe:	4a f0       	brmi	.+18     	; 0x6412 <__mulsf3_pse+0x7a>
    6400:	ee 0f       	add	r30, r30
    6402:	ff 1f       	adc	r31, r31
    6404:	bb 1f       	adc	r27, r27
    6406:	66 1f       	adc	r22, r22
    6408:	77 1f       	adc	r23, r23
    640a:	88 1f       	adc	r24, r24
    640c:	91 50       	subi	r25, 0x01	; 1
    640e:	50 40       	sbci	r21, 0x00	; 0
    6410:	a9 f7       	brne	.-22     	; 0x63fc <__mulsf3_pse+0x64>
    6412:	9e 3f       	cpi	r25, 0xFE	; 254
    6414:	51 05       	cpc	r21, r1
    6416:	80 f0       	brcs	.+32     	; 0x6438 <__mulsf3_pse+0xa0>
    6418:	0c 94 7e 30 	jmp	0x60fc	; 0x60fc <__fp_inf>
    641c:	0c 94 70 31 	jmp	0x62e0	; 0x62e0 <__fp_szero>
    6420:	5f 3f       	cpi	r21, 0xFF	; 255
    6422:	e4 f3       	brlt	.-8      	; 0x641c <__mulsf3_pse+0x84>
    6424:	98 3e       	cpi	r25, 0xE8	; 232
    6426:	d4 f3       	brlt	.-12     	; 0x641c <__mulsf3_pse+0x84>
    6428:	86 95       	lsr	r24
    642a:	77 95       	ror	r23
    642c:	67 95       	ror	r22
    642e:	b7 95       	ror	r27
    6430:	f7 95       	ror	r31
    6432:	e7 95       	ror	r30
    6434:	9f 5f       	subi	r25, 0xFF	; 255
    6436:	c1 f7       	brne	.-16     	; 0x6428 <__mulsf3_pse+0x90>
    6438:	fe 2b       	or	r31, r30
    643a:	88 0f       	add	r24, r24
    643c:	91 1d       	adc	r25, r1
    643e:	96 95       	lsr	r25
    6440:	87 95       	ror	r24
    6442:	97 f9       	bld	r25, 7
    6444:	08 95       	ret

00006446 <round>:
    6446:	0e 94 3d 31 	call	0x627a	; 0x627a <__fp_splitA>
    644a:	e8 f0       	brcs	.+58     	; 0x6486 <round+0x40>
    644c:	9e 37       	cpi	r25, 0x7E	; 126
    644e:	e8 f0       	brcs	.+58     	; 0x648a <round+0x44>
    6450:	96 39       	cpi	r25, 0x96	; 150
    6452:	b8 f4       	brcc	.+46     	; 0x6482 <round+0x3c>
    6454:	9e 38       	cpi	r25, 0x8E	; 142
    6456:	48 f4       	brcc	.+18     	; 0x646a <round+0x24>
    6458:	67 2f       	mov	r22, r23
    645a:	78 2f       	mov	r23, r24
    645c:	88 27       	eor	r24, r24
    645e:	98 5f       	subi	r25, 0xF8	; 248
    6460:	f9 cf       	rjmp	.-14     	; 0x6454 <round+0xe>
    6462:	86 95       	lsr	r24
    6464:	77 95       	ror	r23
    6466:	67 95       	ror	r22
    6468:	93 95       	inc	r25
    646a:	95 39       	cpi	r25, 0x95	; 149
    646c:	d0 f3       	brcs	.-12     	; 0x6462 <round+0x1c>
    646e:	b6 2f       	mov	r27, r22
    6470:	b1 70       	andi	r27, 0x01	; 1
    6472:	6b 0f       	add	r22, r27
    6474:	71 1d       	adc	r23, r1
    6476:	81 1d       	adc	r24, r1
    6478:	20 f4       	brcc	.+8      	; 0x6482 <round+0x3c>
    647a:	87 95       	ror	r24
    647c:	77 95       	ror	r23
    647e:	67 95       	ror	r22
    6480:	93 95       	inc	r25
    6482:	0c 94 84 30 	jmp	0x6108	; 0x6108 <__fp_mintl>
    6486:	0c 94 9f 30 	jmp	0x613e	; 0x613e <__fp_mpack>
    648a:	0c 94 70 31 	jmp	0x62e0	; 0x62e0 <__fp_szero>

0000648e <sin>:
    648e:	9f 93       	push	r25
    6490:	0e 94 e7 30 	call	0x61ce	; 0x61ce <__fp_rempio2>
    6494:	0f 90       	pop	r0
    6496:	07 fc       	sbrc	r0, 7
    6498:	ee 5f       	subi	r30, 0xFE	; 254
    649a:	0c 94 21 31 	jmp	0x6242	; 0x6242 <__fp_sinus>
    649e:	19 f4       	brne	.+6      	; 0x64a6 <sin+0x18>
    64a0:	16 f4       	brtc	.+4      	; 0x64a6 <sin+0x18>
    64a2:	0c 94 ad 30 	jmp	0x615a	; 0x615a <__fp_nan>
    64a6:	0c 94 9f 30 	jmp	0x613e	; 0x613e <__fp_mpack>

000064aa <sqrt>:
    64aa:	0e 94 3d 31 	call	0x627a	; 0x627a <__fp_splitA>
    64ae:	b8 f3       	brcs	.-18     	; 0x649e <sin+0x10>
    64b0:	99 23       	and	r25, r25
    64b2:	c9 f3       	breq	.-14     	; 0x64a6 <sin+0x18>
    64b4:	b6 f3       	brts	.-20     	; 0x64a2 <sin+0x14>
    64b6:	9f 57       	subi	r25, 0x7F	; 127
    64b8:	55 0b       	sbc	r21, r21
    64ba:	87 ff       	sbrs	r24, 7
    64bc:	0e 94 a4 32 	call	0x6548	; 0x6548 <__fp_norm2>
    64c0:	00 24       	eor	r0, r0
    64c2:	a0 e6       	ldi	r26, 0x60	; 96
    64c4:	40 ea       	ldi	r20, 0xA0	; 160
    64c6:	90 01       	movw	r18, r0
    64c8:	80 58       	subi	r24, 0x80	; 128
    64ca:	56 95       	lsr	r21
    64cc:	97 95       	ror	r25
    64ce:	28 f4       	brcc	.+10     	; 0x64da <sqrt+0x30>
    64d0:	80 5c       	subi	r24, 0xC0	; 192
    64d2:	66 0f       	add	r22, r22
    64d4:	77 1f       	adc	r23, r23
    64d6:	88 1f       	adc	r24, r24
    64d8:	20 f0       	brcs	.+8      	; 0x64e2 <sqrt+0x38>
    64da:	26 17       	cp	r18, r22
    64dc:	37 07       	cpc	r19, r23
    64de:	48 07       	cpc	r20, r24
    64e0:	30 f4       	brcc	.+12     	; 0x64ee <sqrt+0x44>
    64e2:	62 1b       	sub	r22, r18
    64e4:	73 0b       	sbc	r23, r19
    64e6:	84 0b       	sbc	r24, r20
    64e8:	20 29       	or	r18, r0
    64ea:	31 29       	or	r19, r1
    64ec:	4a 2b       	or	r20, r26
    64ee:	a6 95       	lsr	r26
    64f0:	17 94       	ror	r1
    64f2:	07 94       	ror	r0
    64f4:	20 25       	eor	r18, r0
    64f6:	31 25       	eor	r19, r1
    64f8:	4a 27       	eor	r20, r26
    64fa:	58 f7       	brcc	.-42     	; 0x64d2 <sqrt+0x28>
    64fc:	66 0f       	add	r22, r22
    64fe:	77 1f       	adc	r23, r23
    6500:	88 1f       	adc	r24, r24
    6502:	20 f0       	brcs	.+8      	; 0x650c <sqrt+0x62>
    6504:	26 17       	cp	r18, r22
    6506:	37 07       	cpc	r19, r23
    6508:	48 07       	cpc	r20, r24
    650a:	30 f4       	brcc	.+12     	; 0x6518 <sqrt+0x6e>
    650c:	62 0b       	sbc	r22, r18
    650e:	73 0b       	sbc	r23, r19
    6510:	84 0b       	sbc	r24, r20
    6512:	20 0d       	add	r18, r0
    6514:	31 1d       	adc	r19, r1
    6516:	41 1d       	adc	r20, r1
    6518:	a0 95       	com	r26
    651a:	81 f7       	brne	.-32     	; 0x64fc <sqrt+0x52>
    651c:	b9 01       	movw	r22, r18
    651e:	84 2f       	mov	r24, r20
    6520:	91 58       	subi	r25, 0x81	; 129
    6522:	88 0f       	add	r24, r24
    6524:	96 95       	lsr	r25
    6526:	87 95       	ror	r24
    6528:	08 95       	ret

0000652a <square>:
    652a:	9b 01       	movw	r18, r22
    652c:	ac 01       	movw	r20, r24
    652e:	0c 94 b6 31 	jmp	0x636c	; 0x636c <__mulsf3>

00006532 <trunc>:
    6532:	0e 94 57 31 	call	0x62ae	; 0x62ae <__fp_trunc>
    6536:	30 f0       	brcs	.+12     	; 0x6544 <trunc+0x12>
    6538:	9f 37       	cpi	r25, 0x7F	; 127
    653a:	10 f4       	brcc	.+4      	; 0x6540 <trunc+0xe>
    653c:	0c 94 70 31 	jmp	0x62e0	; 0x62e0 <__fp_szero>
    6540:	0c 94 84 30 	jmp	0x6108	; 0x6108 <__fp_mintl>
    6544:	0c 94 9f 30 	jmp	0x613e	; 0x613e <__fp_mpack>

00006548 <__fp_norm2>:
    6548:	91 50       	subi	r25, 0x01	; 1
    654a:	50 40       	sbci	r21, 0x00	; 0
    654c:	66 0f       	add	r22, r22
    654e:	77 1f       	adc	r23, r23
    6550:	88 1f       	adc	r24, r24
    6552:	d2 f7       	brpl	.-12     	; 0x6548 <__fp_norm2>
    6554:	08 95       	ret

00006556 <__fp_powsodd>:
    6556:	9f 93       	push	r25
    6558:	8f 93       	push	r24
    655a:	7f 93       	push	r23
    655c:	6f 93       	push	r22
    655e:	ff 93       	push	r31
    6560:	ef 93       	push	r30
    6562:	9b 01       	movw	r18, r22
    6564:	ac 01       	movw	r20, r24
    6566:	0e 94 b6 31 	call	0x636c	; 0x636c <__mulsf3>
    656a:	ef 91       	pop	r30
    656c:	ff 91       	pop	r31
    656e:	0e 94 b0 30 	call	0x6160	; 0x6160 <__fp_powser>
    6572:	2f 91       	pop	r18
    6574:	3f 91       	pop	r19
    6576:	4f 91       	pop	r20
    6578:	5f 91       	pop	r21
    657a:	0c 94 b6 31 	jmp	0x636c	; 0x636c <__mulsf3>

0000657e <__tablejump2__>:
    657e:	ee 0f       	add	r30, r30
    6580:	ff 1f       	adc	r31, r31
    6582:	05 90       	lpm	r0, Z+
    6584:	f4 91       	lpm	r31, Z
    6586:	e0 2d       	mov	r30, r0
    6588:	09 94       	ijmp

0000658a <__umulhisi3>:
    658a:	a2 9f       	mul	r26, r18
    658c:	b0 01       	movw	r22, r0
    658e:	b3 9f       	mul	r27, r19
    6590:	c0 01       	movw	r24, r0
    6592:	a3 9f       	mul	r26, r19
    6594:	70 0d       	add	r23, r0
    6596:	81 1d       	adc	r24, r1
    6598:	11 24       	eor	r1, r1
    659a:	91 1d       	adc	r25, r1
    659c:	b2 9f       	mul	r27, r18
    659e:	70 0d       	add	r23, r0
    65a0:	81 1d       	adc	r24, r1
    65a2:	11 24       	eor	r1, r1
    65a4:	91 1d       	adc	r25, r1
    65a6:	08 95       	ret

000065a8 <memcmp>:
    65a8:	fb 01       	movw	r30, r22
    65aa:	dc 01       	movw	r26, r24
    65ac:	04 c0       	rjmp	.+8      	; 0x65b6 <memcmp+0xe>
    65ae:	8d 91       	ld	r24, X+
    65b0:	01 90       	ld	r0, Z+
    65b2:	80 19       	sub	r24, r0
    65b4:	21 f4       	brne	.+8      	; 0x65be <memcmp+0x16>
    65b6:	41 50       	subi	r20, 0x01	; 1
    65b8:	50 40       	sbci	r21, 0x00	; 0
    65ba:	c8 f7       	brcc	.-14     	; 0x65ae <memcmp+0x6>
    65bc:	88 1b       	sub	r24, r24
    65be:	99 0b       	sbc	r25, r25
    65c0:	08 95       	ret

000065c2 <_exit>:
    65c2:	f8 94       	cli

000065c4 <__stop_program>:
    65c4:	ff cf       	rjmp	.-2      	; 0x65c4 <__stop_program>
