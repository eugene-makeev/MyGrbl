
MyGRBL.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .data         00000002  00800100  000065e6  0000667a  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  1 .text         000065e6  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .bss          00000662  00800102  00800102  0000667c  2**0
                  ALLOC
  3 .comment      00000030  00000000  00000000  0000667c  2**0
                  CONTENTS, READONLY
  4 .note.gnu.avr.deviceinfo 00000040  00000000  00000000  000066ac  2**2
                  CONTENTS, READONLY
  5 .debug_aranges 000005b8  00000000  00000000  000066ec  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_info   000082b7  00000000  00000000  00006ca4  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_abbrev 000021f2  00000000  00000000  0000ef5b  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_line   0000516d  00000000  00000000  0001114d  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_frame  00001230  00000000  00000000  000162bc  2**2
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_str    00001c27  00000000  00000000  000174ec  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_loc    00005ecc  00000000  00000000  00019113  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_ranges 000005a8  00000000  00000000  0001efdf  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 35 01 	jmp	0x26a	; 0x26a <__ctors_end>
       4:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
       8:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
       c:	0c 94 3e 2c 	jmp	0x587c	; 0x587c <__vector_3>
      10:	0c 94 2a 2d 	jmp	0x5a54	; 0x5a54 <__vector_4>
      14:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      18:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      1c:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      20:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      24:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      28:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      2c:	0c 94 c5 16 	jmp	0x2d8a	; 0x2d8a <__vector_11>
      30:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      34:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      38:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      3c:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      40:	0c 94 bd 18 	jmp	0x317a	; 0x317a <__vector_16>
      44:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      48:	0c 94 11 12 	jmp	0x2422	; 0x2422 <__vector_18>
      4c:	0c 94 e7 11 	jmp	0x23ce	; 0x23ce <__vector_19>
      50:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      54:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      58:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      5c:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      60:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      64:	0c 94 52 01 	jmp	0x2a4	; 0x2a4 <__bad_interrupt>
      68:	5a 06       	cpc	r5, r26
      6a:	5a 06       	cpc	r5, r26
      6c:	5a 06       	cpc	r5, r26
      6e:	5a 06       	cpc	r5, r26
      70:	3d 06       	cpc	r3, r29
      72:	c6 0f       	add	r28, r22
      74:	c6 0f       	add	r28, r22
      76:	c6 0f       	add	r28, r22
      78:	c6 0f       	add	r28, r22
      7a:	c6 0f       	add	r28, r22
      7c:	32 06       	cpc	r3, r18
      7e:	c6 0f       	add	r28, r22
      80:	c6 0f       	add	r28, r22
      82:	c6 0f       	add	r28, r22
      84:	c6 0f       	add	r28, r22
      86:	c6 0f       	add	r28, r22
      88:	c6 0f       	add	r28, r22
      8a:	83 06       	cpc	r8, r19
      8c:	83 06       	cpc	r8, r19
      8e:	83 06       	cpc	r8, r19
      90:	a2 06       	cpc	r10, r18
      92:	a2 06       	cpc	r10, r18
      94:	c6 0f       	add	r28, r22
      96:	c6 0f       	add	r28, r22
      98:	c6 0f       	add	r28, r22
      9a:	c6 0f       	add	r28, r22
      9c:	c6 0f       	add	r28, r22
      9e:	c6 0f       	add	r28, r22
      a0:	32 06       	cpc	r3, r18
      a2:	c6 0f       	add	r28, r22
      a4:	32 06       	cpc	r3, r18
      a6:	c6 0f       	add	r28, r22
      a8:	c6 0f       	add	r28, r22
      aa:	c6 0f       	add	r28, r22
      ac:	c6 0f       	add	r28, r22
      ae:	c6 0f       	add	r28, r22
      b0:	c6 0f       	add	r28, r22
      b2:	c6 0f       	add	r28, r22
      b4:	5a 06       	cpc	r5, r26
      b6:	c6 0f       	add	r28, r22
      b8:	cc 06       	cpc	r12, r28
      ba:	c6 0f       	add	r28, r22
      bc:	c6 0f       	add	r28, r22
      be:	a8 06       	cpc	r10, r24
      c0:	c6 0f       	add	r28, r22
      c2:	c6 0f       	add	r28, r22
      c4:	c6 0f       	add	r28, r22
      c6:	c6 0f       	add	r28, r22
      c8:	c6 0f       	add	r28, r22
      ca:	a8 06       	cpc	r10, r24
      cc:	c6 0f       	add	r28, r22
      ce:	c6 0f       	add	r28, r22
      d0:	c6 0f       	add	r28, r22
      d2:	3d 06       	cpc	r3, r29
      d4:	c0 06       	cpc	r12, r16
      d6:	c0 06       	cpc	r12, r16
      d8:	c0 06       	cpc	r12, r16
      da:	c0 06       	cpc	r12, r16
      dc:	c0 06       	cpc	r12, r16
      de:	c0 06       	cpc	r12, r16
      e0:	c6 0f       	add	r28, r22
      e2:	c6 06       	cpc	r12, r22
      e4:	c6 0f       	add	r28, r22
      e6:	c6 0f       	add	r28, r22
      e8:	c6 0f       	add	r28, r22
      ea:	c6 0f       	add	r28, r22
      ec:	c6 0f       	add	r28, r22
      ee:	c6 0f       	add	r28, r22
      f0:	c6 0f       	add	r28, r22
      f2:	c6 0f       	add	r28, r22
      f4:	c6 0f       	add	r28, r22
      f6:	c6 0f       	add	r28, r22
      f8:	c6 0f       	add	r28, r22
      fa:	c6 0f       	add	r28, r22
      fc:	c6 0f       	add	r28, r22
      fe:	c6 0f       	add	r28, r22
     100:	c6 0f       	add	r28, r22
     102:	c6 0f       	add	r28, r22
     104:	c6 0f       	add	r28, r22
     106:	c6 0f       	add	r28, r22
     108:	60 06       	cpc	r6, r16
     10a:	c6 0f       	add	r28, r22
     10c:	c6 0f       	add	r28, r22
     10e:	c6 0f       	add	r28, r22
     110:	c6 0f       	add	r28, r22
     112:	c6 0f       	add	r28, r22
     114:	c6 0f       	add	r28, r22
     116:	c6 0f       	add	r28, r22
     118:	c6 0f       	add	r28, r22
     11a:	c6 0f       	add	r28, r22
     11c:	89 06       	cpc	r8, r25
     11e:	89 06       	cpc	r8, r25
     120:	32 06       	cpc	r3, r18
     122:	9c 06       	cpc	r9, r28
     124:	9c 06       	cpc	r9, r28
     126:	f5 06       	cpc	r15, r21
     128:	f5 06       	cpc	r15, r21
     12a:	f5 06       	cpc	r15, r21
     12c:	04 07       	cpc	r16, r20
     12e:	04 07       	cpc	r16, r20
     130:	04 07       	cpc	r16, r20
     132:	e0 0f       	add	r30, r16
     134:	e0 0f       	add	r30, r16
     136:	1b 07       	cpc	r17, r27
     138:	1b 07       	cpc	r17, r27
     13a:	e0 0f       	add	r30, r16
     13c:	e0 0f       	add	r30, r16
     13e:	e0 0f       	add	r30, r16
     140:	e0 0f       	add	r30, r16
     142:	e0 0f       	add	r30, r16
     144:	e0 0f       	add	r30, r16
     146:	e0 0f       	add	r30, r16
     148:	e0 0f       	add	r30, r16
     14a:	e0 0f       	add	r30, r16
     14c:	e0 0f       	add	r30, r16
     14e:	e0 0f       	add	r30, r16
     150:	e0 0f       	add	r30, r16
     152:	e0 0f       	add	r30, r16
     154:	e0 0f       	add	r30, r16
     156:	e0 0f       	add	r30, r16
     158:	e0 0f       	add	r30, r16
     15a:	e0 0f       	add	r30, r16
     15c:	e0 0f       	add	r30, r16
     15e:	e0 0f       	add	r30, r16
     160:	e0 0f       	add	r30, r16
     162:	f5 06       	cpc	r15, r21
     164:	50 07       	cpc	r21, r16
     166:	e4 0f       	add	r30, r20
     168:	e4 0f       	add	r30, r20
     16a:	5a 07       	cpc	r21, r26
     16c:	67 07       	cpc	r22, r23
     16e:	74 07       	cpc	r23, r20
     170:	81 07       	cpc	r24, r17
     172:	e4 0f       	add	r30, r20
     174:	85 07       	cpc	r24, r21
     176:	e4 0f       	add	r30, r20
     178:	93 07       	cpc	r25, r19
     17a:	e4 0f       	add	r30, r20
     17c:	9d 07       	cpc	r25, r29
     17e:	a7 07       	cpc	r26, r23
     180:	b1 07       	cpc	r27, r17
     182:	e4 0f       	add	r30, r20
     184:	e4 0f       	add	r30, r20
     186:	e4 0f       	add	r30, r20
     188:	c1 07       	cpc	r28, r17
     18a:	ce 07       	cpc	r28, r30
     18c:	db 07       	cpc	r29, r27
     18e:	4e 12       	cpse	r4, r30
     190:	52 12       	cpse	r5, r18
     192:	5a 12       	cpse	r5, r26
     194:	b0 12       	cpse	r11, r16
     196:	b0 12       	cpse	r11, r16
     198:	b0 12       	cpse	r11, r16
     19a:	b0 12       	cpse	r11, r16
     19c:	b0 12       	cpse	r11, r16
     19e:	b0 12       	cpse	r11, r16
     1a0:	b0 12       	cpse	r11, r16
     1a2:	b0 12       	cpse	r11, r16
     1a4:	b0 12       	cpse	r11, r16
     1a6:	63 12       	cpse	r6, r19
     1a8:	67 12       	cpse	r6, r23
     1aa:	6b 12       	cpse	r6, r27
     1ac:	6f 12       	cpse	r6, r31
     1ae:	73 12       	cpse	r7, r19
     1b0:	77 12       	cpse	r7, r23
     1b2:	7b 12       	cpse	r7, r27
     1b4:	7f 12       	cpse	r7, r31
     1b6:	b0 12       	cpse	r11, r16
     1b8:	83 12       	cpse	r8, r19
     1ba:	87 12       	cpse	r8, r23
     1bc:	8b 12       	cpse	r8, r27
     1be:	8f 12       	cpse	r8, r31
     1c0:	93 12       	cpse	r9, r19
     1c2:	97 12       	cpse	r9, r23
     1c4:	b0 12       	cpse	r11, r16
     1c6:	9b 12       	cpse	r9, r27
     1c8:	08 4a       	sbci	r16, 0xA8	; 168
     1ca:	d7 3b       	cpi	r29, 0xB7	; 183
     1cc:	3b ce       	rjmp	.-906    	; 0xfffffe44 <__eeprom_end+0xff7efe44>
     1ce:	01 6e       	ori	r16, 0xE1	; 225
     1d0:	84 bc       	out	0x24, r8	; 36
     1d2:	bf fd       	.word	0xfdbf	; ????
     1d4:	c1 2f       	mov	r28, r17
     1d6:	3d 6c       	ori	r19, 0xCD	; 205
     1d8:	74 31       	cpi	r23, 0x14	; 20
     1da:	9a bd       	out	0x2a, r25	; 42
     1dc:	56 83       	std	Z+6, r21	; 0x06
     1de:	3d da       	rcall	.-2950   	; 0xfffff65a <__eeprom_end+0xff7ef65a>
     1e0:	3d 00       	.word	0x003d	; ????
     1e2:	c7 7f       	andi	r28, 0xF7	; 247
     1e4:	11 be       	out	0x31, r1	; 49
     1e6:	d9 e4       	ldi	r29, 0x49	; 73
     1e8:	bb 4c       	sbci	r27, 0xCB	; 203
     1ea:	3e 91       	ld	r19, -X
     1ec:	6b aa       	std	Y+51, r6	; 0x33
     1ee:	aa be       	out	0x3a, r10	; 58
     1f0:	00 00       	nop
     1f2:	00 80       	ld	r0, Z
     1f4:	3f 05       	cpc	r19, r15
     1f6:	a8 4c       	sbci	r26, 0xC8	; 200
     1f8:	cd b2       	in	r12, 0x1d	; 29
     1fa:	d4 4e       	sbci	r29, 0xE4	; 228
     1fc:	b9 38       	cpi	r27, 0x89	; 137
     1fe:	36 a9       	ldd	r19, Z+54	; 0x36
     200:	02 0c       	add	r0, r2
     202:	50 b9       	out	0x00, r21	; 0
     204:	91 86       	std	Z+9, r9	; 0x09
     206:	88 08       	sbc	r8, r8
     208:	3c a6       	std	Y+44, r3	; 0x2c
     20a:	aa aa       	std	Y+50, r10	; 0x32
     20c:	2a be       	out	0x3a, r2	; 58
     20e:	00 00       	nop
     210:	00 80       	ld	r0, Z
     212:	3f 00       	.word	0x003f	; ????

00000214 <__trampolines_end>:
     214:	00 00       	nop
     216:	7a 43       	sbci	r23, 0x3A	; 58
     218:	00 00       	nop
     21a:	7a 43       	sbci	r23, 0x3A	; 58
     21c:	00 00       	nop
     21e:	7a 43       	sbci	r23, 0x3A	; 58
     220:	00 00       	nop
     222:	fa 43       	sbci	r31, 0x3A	; 58
     224:	00 00       	nop
     226:	fa 43       	sbci	r31, 0x3A	; 58
     228:	00 00       	nop
     22a:	fa 43       	sbci	r31, 0x3A	; 58
     22c:	00 a0       	ldd	r0, Z+32	; 0x20
     22e:	0c 47       	sbci	r16, 0x7C	; 124
     230:	00 a0       	ldd	r0, Z+32	; 0x20
     232:	0c 47       	sbci	r16, 0x7C	; 124
     234:	00 a0       	ldd	r0, Z+32	; 0x20
     236:	0c 47       	sbci	r16, 0x7C	; 124
     238:	00 00       	nop
     23a:	48 c3       	rjmp	.+1680   	; 0x8cc <__LOCK_REGION_LENGTH__+0x4cc>
     23c:	00 00       	nop
     23e:	48 c3       	rjmp	.+1680   	; 0x8d0 <__LOCK_REGION_LENGTH__+0x4d0>
     240:	00 00       	nop
     242:	48 c3       	rjmp	.+1680   	; 0x8d4 <__LOCK_REGION_LENGTH__+0x4d4>
     244:	0a 00       	.word	0x000a	; ????
     246:	00 19       	sub	r16, r0
     248:	01 0a       	sbc	r0, r17
     24a:	d7 23       	and	r29, r23
     24c:	3c 6f       	ori	r19, 0xFC	; 252
     24e:	12 03       	mulsu	r17, r18
     250:	3b 00       	.word	0x003b	; ????
     252:	00 7a       	andi	r16, 0xA0	; 160
     254:	44 00       	.word	0x0044	; ????
     256:	00 00       	nop
     258:	00 00       	nop
     25a:	00 00       	nop
     25c:	00 c8       	rjmp	.-4096   	; 0xfffff25e <__eeprom_end+0xff7ef25e>
     25e:	41 00       	.word	0x0041	; ????
     260:	00 fa       	bst	r0, 0
     262:	43 fa       	bst	r4, 3
     264:	00 00       	nop
     266:	00 80       	ld	r0, Z
     268:	3f 00       	.word	0x003f	; ????

0000026a <__ctors_end>:
     26a:	11 24       	eor	r1, r1
     26c:	1f be       	out	0x3f, r1	; 63
     26e:	cf ef       	ldi	r28, 0xFF	; 255
     270:	d8 e0       	ldi	r29, 0x08	; 8
     272:	de bf       	out	0x3e, r29	; 62
     274:	cd bf       	out	0x3d, r28	; 61

00000276 <__do_copy_data>:
     276:	11 e0       	ldi	r17, 0x01	; 1
     278:	a0 e0       	ldi	r26, 0x00	; 0
     27a:	b1 e0       	ldi	r27, 0x01	; 1
     27c:	e6 ee       	ldi	r30, 0xE6	; 230
     27e:	f5 e6       	ldi	r31, 0x65	; 101
     280:	02 c0       	rjmp	.+4      	; 0x286 <__do_copy_data+0x10>
     282:	05 90       	lpm	r0, Z+
     284:	0d 92       	st	X+, r0
     286:	a2 30       	cpi	r26, 0x02	; 2
     288:	b1 07       	cpc	r27, r17
     28a:	d9 f7       	brne	.-10     	; 0x282 <__do_copy_data+0xc>

0000028c <__do_clear_bss>:
     28c:	27 e0       	ldi	r18, 0x07	; 7
     28e:	a2 e0       	ldi	r26, 0x02	; 2
     290:	b1 e0       	ldi	r27, 0x01	; 1
     292:	01 c0       	rjmp	.+2      	; 0x296 <.do_clear_bss_start>

00000294 <.do_clear_bss_loop>:
     294:	1d 92       	st	X+, r1

00000296 <.do_clear_bss_start>:
     296:	a4 36       	cpi	r26, 0x64	; 100
     298:	b2 07       	cpc	r27, r18
     29a:	e1 f7       	brne	.-8      	; 0x294 <.do_clear_bss_loop>
     29c:	0e 94 54 01 	call	0x2a8	; 0x2a8 <main>
     2a0:	0c 94 f1 32 	jmp	0x65e2	; 0x65e2 <_exit>

000002a4 <__bad_interrupt>:
     2a4:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

000002a8 <main>:


int main(void)
{
  // Initialize system upon power-up.
  serial_init();   // Setup serial baud rate and interrupts
     2a8:	0e 94 d7 11 	call	0x23ae	; 0x23ae <serial_init>
  settings_init(); // Load Grbl settings from EEPROM
     2ac:	0e 94 85 23 	call	0x470a	; 0x470a <settings_init>
  stepper_init();  // Configure stepper pins and interrupt timers
     2b0:	0e 94 46 19 	call	0x328c	; 0x328c <stepper_init>
  system_init();   // Configure pinout pins and pin-change interrupt
     2b4:	0e 94 07 2d 	call	0x5a0e	; 0x5a0e <system_init>

  memset(sys_position,0,sizeof(sys_position)); // Clear machine position.
     2b8:	8c e0       	ldi	r24, 0x0C	; 12
     2ba:	ec e9       	ldi	r30, 0x9C	; 156
     2bc:	f5 e0       	ldi	r31, 0x05	; 5
     2be:	df 01       	movw	r26, r30
     2c0:	1d 92       	st	X+, r1
     2c2:	8a 95       	dec	r24
     2c4:	e9 f7       	brne	.-6      	; 0x2c0 <main+0x18>
  sei(); // Enable interrupts
     2c6:	78 94       	sei
  // Initialize system state.
  #ifdef FORCE_INITIALIZATION_ALARM
    // Force Grbl into an ALARM state upon a power-cycle or hard reset.
    sys.state = STATE_ALARM;
  #else
    sys.state = STATE_IDLE;
     2c8:	10 92 7c 05 	sts	0x057C, r1	; 0x80057c <sys>
  // cycle '$H' or kill alarm locks '$X' will disable the alarm.
  // NOTE: The startup script will run after successful completion of the homing cycle, but
  // not after disabling the alarm locks. Prevents motion startup blocks from crashing into
  // things uncontrollably. Very bad.
  #ifdef HOMING_INIT_LOCK
    if (bit_istrue(settings.flags,BITFLAG_HOMING_ENABLE)) { sys.state = STATE_ALARM; }
     2cc:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <settings+0x45>
     2d0:	84 ff       	sbrs	r24, 4
     2d2:	03 c0       	rjmp	.+6      	; 0x2da <main+0x32>
     2d4:	81 e0       	ldi	r24, 0x01	; 1
     2d6:	80 93 7c 05 	sts	0x057C, r24	; 0x80057c <sys>
  // Grbl initialization loop upon power-up or a system abort. For the latter, all processes
  // will return to this loop to be cleanly re-initialized.
  for(;;) {

    // Reset system variables.
    uint8_t prior_state = sys.state;
     2da:	cc e7       	ldi	r28, 0x7C	; 124
     2dc:	d5 e0       	ldi	r29, 0x05	; 5
    memset(&sys, 0, sizeof(system_t)); // Clear system struct variable.
     2de:	0f 2e       	mov	r0, r31
     2e0:	f1 e1       	ldi	r31, 0x11	; 17
     2e2:	df 2e       	mov	r13, r31
     2e4:	f0 2d       	mov	r31, r0
    sys.state = prior_state;
    sys.f_override = DEFAULT_FEED_OVERRIDE;  // Set to 100%
     2e6:	14 e6       	ldi	r17, 0x64	; 100
    sys.r_override = DEFAULT_RAPID_OVERRIDE; // Set to 100%
    sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE; // Set to 100%
	memset(sys_probe_position,0,sizeof(sys_probe_position)); // Clear probe position.
     2e8:	0f 2e       	mov	r0, r31
     2ea:	f0 e9       	ldi	r31, 0x90	; 144
     2ec:	ef 2e       	mov	r14, r31
     2ee:	f5 e0       	ldi	r31, 0x05	; 5
     2f0:	ff 2e       	mov	r15, r31
     2f2:	f0 2d       	mov	r31, r0
     2f4:	0c e0       	ldi	r16, 0x0C	; 12
  // Grbl initialization loop upon power-up or a system abort. For the latter, all processes
  // will return to this loop to be cleanly re-initialized.
  for(;;) {

    // Reset system variables.
    uint8_t prior_state = sys.state;
     2f6:	88 81       	ld	r24, Y
    memset(&sys, 0, sizeof(system_t)); // Clear system struct variable.
     2f8:	fe 01       	movw	r30, r28
     2fa:	9d 2d       	mov	r25, r13
     2fc:	11 92       	st	Z+, r1
     2fe:	9a 95       	dec	r25
     300:	e9 f7       	brne	.-6      	; 0x2fc <main+0x54>
    sys.state = prior_state;
     302:	88 83       	st	Y, r24
    sys.f_override = DEFAULT_FEED_OVERRIDE;  // Set to 100%
     304:	1f 83       	std	Y+7, r17	; 0x07
    sys.r_override = DEFAULT_RAPID_OVERRIDE; // Set to 100%
     306:	18 87       	std	Y+8, r17	; 0x08
    sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE; // Set to 100%
     308:	19 87       	std	Y+9, r17	; 0x09
	memset(sys_probe_position,0,sizeof(sys_probe_position)); // Clear probe position.
     30a:	d7 01       	movw	r26, r14
     30c:	e0 2f       	mov	r30, r16
     30e:	1d 92       	st	X+, r1
     310:	ea 95       	dec	r30
     312:	e9 f7       	brne	.-6      	; 0x30e <main+0x66>
    sys_probe_state = 0;
     314:	10 92 8f 05 	sts	0x058F, r1	; 0x80058f <sys_probe_state>
    sys_rt_exec_state = 0;
     318:	10 92 8e 05 	sts	0x058E, r1	; 0x80058e <sys_rt_exec_state>
    sys_rt_exec_alarm = 0;
     31c:	10 92 a8 05 	sts	0x05A8, r1	; 0x8005a8 <sys_rt_exec_alarm>
    sys_rt_exec_motion_override = 0;
     320:	10 92 7b 05 	sts	0x057B, r1	; 0x80057b <sys_rt_exec_motion_override>
    sys_rt_exec_accessory_override = 0;
     324:	10 92 8d 05 	sts	0x058D, r1	; 0x80058d <sys_rt_exec_accessory_override>

    // Reset Grbl primary systems.
    serial_reset_read_buffer(); // Clear serial read buffer
     328:	0e 94 c1 12 	call	0x2582	; 0x2582 <serial_reset_read_buffer>
    gc_init(); // Set g-code parser to default state
     32c:	0e 94 81 05 	call	0xb02	; 0xb02 <gc_init>
    spindle_init();
     330:	0e 94 97 10 	call	0x212e	; 0x212e <spindle_init>
    coolant_init();
     334:	0e 94 ba 11 	call	0x2374	; 0x2374 <coolant_init>
    limits_init();
     338:	0e 94 f4 2b 	call	0x57e8	; 0x57e8 <limits_init>
    probe_init();
     33c:	0e 94 dc 2c 	call	0x59b8	; 0x59b8 <probe_init>
    plan_reset(); // Clear block buffer and planner variables
     340:	0e 94 20 25 	call	0x4a40	; 0x4a40 <plan_reset>
    st_reset(); // Clear stepper subsystem variables.
     344:	0e 94 13 19 	call	0x3226	; 0x3226 <st_reset>

    // Sync cleared gcode and planner positions to current system position.
    plan_sync_position();
     348:	0e 94 c2 29 	call	0x5384	; 0x5384 <plan_sync_position>
    gc_sync_position();
     34c:	0e 94 93 05 	call	0xb26	; 0xb26 <gc_sync_position>

    // Print welcome message. Indicates an initialization has occured at power-up or with a reset.
    report_init_message();
     350:	0e 94 00 2d 	call	0x5a00	; 0x5a00 <report_init_message>

    // Start Grbl main loop. Processes program inputs and executes them.
    protocol_main_loop();
     354:	0e 94 c1 15 	call	0x2b82	; 0x2b82 <protocol_main_loop>
     358:	ce cf       	rjmp	.-100    	; 0x2f6 <main+0x4e>

0000035a <mc_line>:
  // Sync gcode parser and planner positions to homed position.
  gc_sync_position();
  plan_sync_position();

  // If hard limits feature enabled, re-enable hard limits pin change register after homing cycle.
  limits_init();
     35a:	ef 92       	push	r14
     35c:	ff 92       	push	r15
     35e:	0f 93       	push	r16
     360:	1f 93       	push	r17
     362:	cf 93       	push	r28
     364:	df 93       	push	r29
     366:	8c 01       	movw	r16, r24
     368:	7b 01       	movw	r14, r22
     36a:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <settings+0x45>
     36e:	85 ff       	sbrs	r24, 5
     370:	07 c0       	rjmp	.+14     	; 0x380 <mc_line+0x26>
     372:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
     376:	80 32       	cpi	r24, 0x20	; 32
     378:	39 f0       	breq	.+14     	; 0x388 <mc_line+0x2e>
     37a:	c8 01       	movw	r24, r16
     37c:	0e 94 6d 2c 	call	0x58da	; 0x58da <limits_soft_check>
     380:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
     384:	82 30       	cpi	r24, 0x02	; 2
     386:	19 f1       	breq	.+70     	; 0x3ce <mc_line+0x74>
     388:	cc e7       	ldi	r28, 0x7C	; 124
     38a:	d5 e0       	ldi	r29, 0x05	; 5
     38c:	0e 94 9e 14 	call	0x293c	; 0x293c <protocol_execute_realtime>
     390:	89 81       	ldd	r24, Y+1	; 0x01
     392:	81 11       	cpse	r24, r1
     394:	1c c0       	rjmp	.+56     	; 0x3ce <mc_line+0x74>
     396:	0e 94 70 25 	call	0x4ae0	; 0x4ae0 <plan_check_full_buffer>
     39a:	88 23       	and	r24, r24
     39c:	19 f0       	breq	.+6      	; 0x3a4 <mc_line+0x4a>
     39e:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <protocol_auto_cycle_start>
     3a2:	f4 cf       	rjmp	.-24     	; 0x38c <mc_line+0x32>
     3a4:	b7 01       	movw	r22, r14
     3a6:	c8 01       	movw	r24, r16
     3a8:	0e 94 af 26 	call	0x4d5e	; 0x4d5e <plan_buffer_line>
     3ac:	81 11       	cpse	r24, r1
     3ae:	0f c0       	rjmp	.+30     	; 0x3ce <mc_line+0x74>
     3b0:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <settings+0x45>
     3b4:	81 ff       	sbrs	r24, 1
     3b6:	0b c0       	rjmp	.+22     	; 0x3ce <mc_line+0x74>
     3b8:	f7 01       	movw	r30, r14
     3ba:	80 85       	ldd	r24, Z+8	; 0x08
     3bc:	84 ff       	sbrs	r24, 4
     3be:	07 c0       	rjmp	.+14     	; 0x3ce <mc_line+0x74>
     3c0:	44 81       	ldd	r20, Z+4	; 0x04
     3c2:	55 81       	ldd	r21, Z+5	; 0x05
     3c4:	66 81       	ldd	r22, Z+6	; 0x06
     3c6:	77 81       	ldd	r23, Z+7	; 0x07
     3c8:	80 e1       	ldi	r24, 0x10	; 16
     3ca:	0e 94 99 11 	call	0x2332	; 0x2332 <spindle_sync>
     3ce:	df 91       	pop	r29
     3d0:	cf 91       	pop	r28
     3d2:	1f 91       	pop	r17
     3d4:	0f 91       	pop	r16
     3d6:	ff 90       	pop	r15
     3d8:	ef 90       	pop	r14
     3da:	08 95       	ret

000003dc <mc_arc>:
     3dc:	2f 92       	push	r2
     3de:	3f 92       	push	r3
     3e0:	4f 92       	push	r4
     3e2:	5f 92       	push	r5
     3e4:	6f 92       	push	r6
     3e6:	7f 92       	push	r7
     3e8:	8f 92       	push	r8
     3ea:	9f 92       	push	r9
     3ec:	af 92       	push	r10
     3ee:	bf 92       	push	r11
     3f0:	cf 92       	push	r12
     3f2:	df 92       	push	r13
     3f4:	ef 92       	push	r14
     3f6:	ff 92       	push	r15
     3f8:	0f 93       	push	r16
     3fa:	1f 93       	push	r17
     3fc:	cf 93       	push	r28
     3fe:	df 93       	push	r29
     400:	cd b7       	in	r28, 0x3d	; 61
     402:	de b7       	in	r29, 0x3e	; 62
     404:	e2 97       	sbiw	r28, 0x32	; 50
     406:	0f b6       	in	r0, 0x3f	; 63
     408:	f8 94       	cli
     40a:	de bf       	out	0x3e, r29	; 62
     40c:	0f be       	out	0x3f, r0	; 63
     40e:	cd bf       	out	0x3d, r28	; 61
     410:	9a ab       	std	Y+50, r25	; 0x32
     412:	89 ab       	std	Y+49, r24	; 0x31
     414:	78 8b       	std	Y+16, r23	; 0x10
     416:	6f 87       	std	Y+15, r22	; 0x0f
     418:	5e 87       	std	Y+14, r21	; 0x0e
     41a:	4d 87       	std	Y+13, r20	; 0x0d
     41c:	39 01       	movw	r6, r18
     41e:	ed 82       	std	Y+5, r14	; 0x05
     420:	fe 82       	std	Y+6, r15	; 0x06
     422:	0f 83       	std	Y+7, r16	; 0x07
     424:	18 87       	std	Y+8, r17	; 0x08
     426:	89 8a       	std	Y+17, r8	; 0x11
     428:	d1 2c       	mov	r13, r1
     42a:	cc 0c       	add	r12, r12
     42c:	dd 1c       	adc	r13, r13
     42e:	cc 0c       	add	r12, r12
     430:	dd 1c       	adc	r13, r13
     432:	ca 01       	movw	r24, r20
     434:	8c 0d       	add	r24, r12
     436:	9d 1d       	adc	r25, r13
     438:	9e 8b       	std	Y+22, r25	; 0x16
     43a:	8d 8b       	std	Y+21, r24	; 0x15
     43c:	d9 01       	movw	r26, r18
     43e:	ac 0d       	add	r26, r12
     440:	bd 1d       	adc	r27, r13
     442:	be a7       	std	Y+46, r27	; 0x2e
     444:	ad a7       	std	Y+45, r26	; 0x2d
     446:	2d 90       	ld	r2, X+
     448:	3d 90       	ld	r3, X+
     44a:	4d 90       	ld	r4, X+
     44c:	5c 90       	ld	r5, X
     44e:	fc 01       	movw	r30, r24
     450:	20 81       	ld	r18, Z
     452:	31 81       	ldd	r19, Z+1	; 0x01
     454:	42 81       	ldd	r20, Z+2	; 0x02
     456:	53 81       	ldd	r21, Z+3	; 0x03
     458:	c2 01       	movw	r24, r4
     45a:	b1 01       	movw	r22, r2
     45c:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
     460:	6f 8b       	std	Y+23, r22	; 0x17
     462:	78 8f       	std	Y+24, r23	; 0x18
     464:	89 8f       	std	Y+25, r24	; 0x19
     466:	9a 8f       	std	Y+26, r25	; 0x1a
     468:	0a 2d       	mov	r16, r10
     46a:	10 e0       	ldi	r17, 0x00	; 0
     46c:	00 0f       	add	r16, r16
     46e:	11 1f       	adc	r17, r17
     470:	00 0f       	add	r16, r16
     472:	11 1f       	adc	r17, r17
     474:	8d 85       	ldd	r24, Y+13	; 0x0d
     476:	9e 85       	ldd	r25, Y+14	; 0x0e
     478:	80 0f       	add	r24, r16
     47a:	91 1f       	adc	r25, r17
     47c:	9c 8f       	std	Y+28, r25	; 0x1c
     47e:	8b 8f       	std	Y+27, r24	; 0x1b
     480:	d3 01       	movw	r26, r6
     482:	a0 0f       	add	r26, r16
     484:	b1 1f       	adc	r27, r17
     486:	b8 ab       	std	Y+48, r27	; 0x30
     488:	af a7       	std	Y+47, r26	; 0x2f
     48a:	8d 90       	ld	r8, X+
     48c:	9d 90       	ld	r9, X+
     48e:	ad 90       	ld	r10, X+
     490:	bc 90       	ld	r11, X
     492:	fc 01       	movw	r30, r24
     494:	20 81       	ld	r18, Z
     496:	31 81       	ldd	r19, Z+1	; 0x01
     498:	42 81       	ldd	r20, Z+2	; 0x02
     49a:	53 81       	ldd	r21, Z+3	; 0x03
     49c:	c5 01       	movw	r24, r10
     49e:	b4 01       	movw	r22, r8
     4a0:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
     4a4:	6d 8f       	std	Y+29, r22	; 0x1d
     4a6:	7e 8f       	std	Y+30, r23	; 0x1e
     4a8:	8f 8f       	std	Y+31, r24	; 0x1f
     4aa:	98 a3       	std	Y+32, r25	; 0x20
     4ac:	d2 01       	movw	r26, r4
     4ae:	c1 01       	movw	r24, r2
     4b0:	b0 58       	subi	r27, 0x80	; 128
     4b2:	89 83       	std	Y+1, r24	; 0x01
     4b4:	9a 83       	std	Y+2, r25	; 0x02
     4b6:	ab 83       	std	Y+3, r26	; 0x03
     4b8:	bc 83       	std	Y+4, r27	; 0x04
     4ba:	d5 01       	movw	r26, r10
     4bc:	c4 01       	movw	r24, r8
     4be:	b0 58       	subi	r27, 0x80	; 128
     4c0:	89 87       	std	Y+9, r24	; 0x09
     4c2:	9a 87       	std	Y+10, r25	; 0x0a
     4c4:	ab 87       	std	Y+11, r26	; 0x0b
     4c6:	bc 87       	std	Y+12, r27	; 0x0c
     4c8:	e9 a9       	ldd	r30, Y+49	; 0x31
     4ca:	fa a9       	ldd	r31, Y+50	; 0x32
     4cc:	ec 0d       	add	r30, r12
     4ce:	fd 1d       	adc	r31, r13
     4d0:	2f 89       	ldd	r18, Y+23	; 0x17
     4d2:	38 8d       	ldd	r19, Y+24	; 0x18
     4d4:	49 8d       	ldd	r20, Y+25	; 0x19
     4d6:	5a 8d       	ldd	r21, Y+26	; 0x1a
     4d8:	60 81       	ld	r22, Z
     4da:	71 81       	ldd	r23, Z+1	; 0x01
     4dc:	82 81       	ldd	r24, Z+2	; 0x02
     4de:	93 81       	ldd	r25, Z+3	; 0x03
     4e0:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
     4e4:	6b 01       	movw	r12, r22
     4e6:	7c 01       	movw	r14, r24
     4e8:	e9 a9       	ldd	r30, Y+49	; 0x31
     4ea:	fa a9       	ldd	r31, Y+50	; 0x32
     4ec:	e0 0f       	add	r30, r16
     4ee:	f1 1f       	adc	r31, r17
     4f0:	2d 8d       	ldd	r18, Y+29	; 0x1d
     4f2:	3e 8d       	ldd	r19, Y+30	; 0x1e
     4f4:	4f 8d       	ldd	r20, Y+31	; 0x1f
     4f6:	58 a1       	ldd	r21, Y+32	; 0x20
     4f8:	60 81       	ld	r22, Z
     4fa:	71 81       	ldd	r23, Z+1	; 0x01
     4fc:	82 81       	ldd	r24, Z+2	; 0x02
     4fe:	93 81       	ldd	r25, Z+3	; 0x03
     500:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
     504:	4b 01       	movw	r8, r22
     506:	5c 01       	movw	r10, r24
     508:	a7 01       	movw	r20, r14
     50a:	96 01       	movw	r18, r12
     50c:	69 81       	ldd	r22, Y+1	; 0x01
     50e:	7a 81       	ldd	r23, Y+2	; 0x02
     510:	8b 81       	ldd	r24, Y+3	; 0x03
     512:	9c 81       	ldd	r25, Y+4	; 0x04
     514:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
     518:	2b 01       	movw	r4, r22
     51a:	3c 01       	movw	r6, r24
     51c:	a5 01       	movw	r20, r10
     51e:	94 01       	movw	r18, r8
     520:	69 85       	ldd	r22, Y+9	; 0x09
     522:	7a 85       	ldd	r23, Y+10	; 0x0a
     524:	8b 85       	ldd	r24, Y+11	; 0x0b
     526:	9c 85       	ldd	r25, Y+12	; 0x0c
     528:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
     52c:	9b 01       	movw	r18, r22
     52e:	ac 01       	movw	r20, r24
     530:	c3 01       	movw	r24, r6
     532:	b2 01       	movw	r22, r4
     534:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
     538:	2b 01       	movw	r4, r22
     53a:	3c 01       	movw	r6, r24
     53c:	a5 01       	movw	r20, r10
     53e:	94 01       	movw	r18, r8
     540:	69 81       	ldd	r22, Y+1	; 0x01
     542:	7a 81       	ldd	r23, Y+2	; 0x02
     544:	8b 81       	ldd	r24, Y+3	; 0x03
     546:	9c 81       	ldd	r25, Y+4	; 0x04
     548:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
     54c:	4b 01       	movw	r8, r22
     54e:	5c 01       	movw	r10, r24
     550:	a7 01       	movw	r20, r14
     552:	96 01       	movw	r18, r12
     554:	69 85       	ldd	r22, Y+9	; 0x09
     556:	7a 85       	ldd	r23, Y+10	; 0x0a
     558:	8b 85       	ldd	r24, Y+11	; 0x0b
     55a:	9c 85       	ldd	r25, Y+12	; 0x0c
     55c:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
     560:	9b 01       	movw	r18, r22
     562:	ac 01       	movw	r20, r24
     564:	c5 01       	movw	r24, r10
     566:	b4 01       	movw	r22, r8
     568:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
     56c:	a3 01       	movw	r20, r6
     56e:	92 01       	movw	r18, r4
     570:	0e 94 ee 2e 	call	0x5ddc	; 0x5ddc <atan2>
     574:	4b 01       	movw	r8, r22
     576:	5c 01       	movw	r10, r24
     578:	28 96       	adiw	r28, 0x08	; 8
     57a:	8f ad       	ldd	r24, Y+63	; 0x3f
     57c:	28 97       	sbiw	r28, 0x08	; 8
     57e:	88 23       	and	r24, r24
     580:	a9 f0       	breq	.+42     	; 0x5ac <__LOCK_REGION_LENGTH__+0x1ac>
     582:	2d eb       	ldi	r18, 0xBD	; 189
     584:	37 e3       	ldi	r19, 0x37	; 55
     586:	46 e0       	ldi	r20, 0x06	; 6
     588:	55 eb       	ldi	r21, 0xB5	; 181
     58a:	c5 01       	movw	r24, r10
     58c:	b4 01       	movw	r22, r8
     58e:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
     592:	88 23       	and	r24, r24
     594:	fc f0       	brlt	.+62     	; 0x5d4 <__LOCK_REGION_LENGTH__+0x1d4>
     596:	2b ed       	ldi	r18, 0xDB	; 219
     598:	3f e0       	ldi	r19, 0x0F	; 15
     59a:	49 ec       	ldi	r20, 0xC9	; 201
     59c:	50 e4       	ldi	r21, 0x40	; 64
     59e:	c5 01       	movw	r24, r10
     5a0:	b4 01       	movw	r22, r8
     5a2:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
     5a6:	4b 01       	movw	r8, r22
     5a8:	5c 01       	movw	r10, r24
     5aa:	14 c0       	rjmp	.+40     	; 0x5d4 <__LOCK_REGION_LENGTH__+0x1d4>
     5ac:	2d eb       	ldi	r18, 0xBD	; 189
     5ae:	37 e3       	ldi	r19, 0x37	; 55
     5b0:	46 e0       	ldi	r20, 0x06	; 6
     5b2:	55 e3       	ldi	r21, 0x35	; 53
     5b4:	c5 01       	movw	r24, r10
     5b6:	b4 01       	movw	r22, r8
     5b8:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
     5bc:	18 16       	cp	r1, r24
     5be:	54 f0       	brlt	.+20     	; 0x5d4 <__LOCK_REGION_LENGTH__+0x1d4>
     5c0:	2b ed       	ldi	r18, 0xDB	; 219
     5c2:	3f e0       	ldi	r19, 0x0F	; 15
     5c4:	49 ec       	ldi	r20, 0xC9	; 201
     5c6:	50 e4       	ldi	r21, 0x40	; 64
     5c8:	c5 01       	movw	r24, r10
     5ca:	b4 01       	movw	r22, r8
     5cc:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
     5d0:	4b 01       	movw	r8, r22
     5d2:	5c 01       	movw	r10, r24
     5d4:	c0 90 47 07 	lds	r12, 0x0747	; 0x800747 <settings+0x39>
     5d8:	d0 90 48 07 	lds	r13, 0x0748	; 0x800748 <settings+0x3a>
     5dc:	e0 90 49 07 	lds	r14, 0x0749	; 0x800749 <settings+0x3b>
     5e0:	f0 90 4a 07 	lds	r15, 0x074A	; 0x80074a <settings+0x3c>
     5e4:	2d 81       	ldd	r18, Y+5	; 0x05
     5e6:	3e 81       	ldd	r19, Y+6	; 0x06
     5e8:	4f 81       	ldd	r20, Y+7	; 0x07
     5ea:	58 85       	ldd	r21, Y+8	; 0x08
     5ec:	ca 01       	movw	r24, r20
     5ee:	b9 01       	movw	r22, r18
     5f0:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
     5f4:	2b 01       	movw	r4, r22
     5f6:	3c 01       	movw	r6, r24
     5f8:	a7 01       	movw	r20, r14
     5fa:	96 01       	movw	r18, r12
     5fc:	c3 01       	movw	r24, r6
     5fe:	b2 01       	movw	r22, r4
     600:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
     604:	a7 01       	movw	r20, r14
     606:	96 01       	movw	r18, r12
     608:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
     60c:	0e 94 65 32 	call	0x64ca	; 0x64ca <sqrt>
     610:	6b 01       	movw	r12, r22
     612:	7c 01       	movw	r14, r24
     614:	20 e0       	ldi	r18, 0x00	; 0
     616:	30 e0       	ldi	r19, 0x00	; 0
     618:	40 e0       	ldi	r20, 0x00	; 0
     61a:	5f e3       	ldi	r21, 0x3F	; 63
     61c:	c5 01       	movw	r24, r10
     61e:	b4 01       	movw	r22, r8
     620:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
     624:	2d 81       	ldd	r18, Y+5	; 0x05
     626:	3e 81       	ldd	r19, Y+6	; 0x06
     628:	4f 81       	ldd	r20, Y+7	; 0x07
     62a:	58 85       	ldd	r21, Y+8	; 0x08
     62c:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
     630:	9f 77       	andi	r25, 0x7F	; 127
     632:	a7 01       	movw	r20, r14
     634:	96 01       	movw	r18, r12
     636:	0e 94 6e 2f 	call	0x5edc	; 0x5edc <__divsf3>
     63a:	0e 94 53 30 	call	0x60a6	; 0x60a6 <floor>
     63e:	0e 94 e7 2f 	call	0x5fce	; 0x5fce <__fixunssfsi>
     642:	6b 01       	movw	r12, r22
     644:	7c 01       	movw	r14, r24
     646:	3b 01       	movw	r6, r22
     648:	61 15       	cp	r22, r1
     64a:	71 05       	cpc	r23, r1
     64c:	09 f4       	brne	.+2      	; 0x650 <__LOCK_REGION_LENGTH__+0x250>
     64e:	88 c1       	rjmp	.+784    	; 0x960 <__stack+0x61>
     650:	af 85       	ldd	r26, Y+15	; 0x0f
     652:	b8 89       	ldd	r27, Y+16	; 0x10
     654:	18 96       	adiw	r26, 0x08	; 8
     656:	1c 91       	ld	r17, X
     658:	13 ff       	sbrs	r17, 3
     65a:	18 c0       	rjmp	.+48     	; 0x68c <__LOCK_REGION_LENGTH__+0x28c>
     65c:	80 e0       	ldi	r24, 0x00	; 0
     65e:	90 e0       	ldi	r25, 0x00	; 0
     660:	0e 94 16 30 	call	0x602c	; 0x602c <__floatunsisf>
     664:	9b 01       	movw	r18, r22
     666:	ac 01       	movw	r20, r24
     668:	ef 85       	ldd	r30, Y+15	; 0x0f
     66a:	f8 89       	ldd	r31, Y+16	; 0x10
     66c:	60 81       	ld	r22, Z
     66e:	71 81       	ldd	r23, Z+1	; 0x01
     670:	82 81       	ldd	r24, Z+2	; 0x02
     672:	93 81       	ldd	r25, Z+3	; 0x03
     674:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
     678:	af 85       	ldd	r26, Y+15	; 0x0f
     67a:	b8 89       	ldd	r27, Y+16	; 0x10
     67c:	6d 93       	st	X+, r22
     67e:	7d 93       	st	X+, r23
     680:	8d 93       	st	X+, r24
     682:	9c 93       	st	X, r25
     684:	13 97       	sbiw	r26, 0x03	; 3
     686:	17 7f       	andi	r17, 0xF7	; 247
     688:	18 96       	adiw	r26, 0x08	; 8
     68a:	1c 93       	st	X, r17
     68c:	b6 01       	movw	r22, r12
     68e:	80 e0       	ldi	r24, 0x00	; 0
     690:	90 e0       	ldi	r25, 0x00	; 0
     692:	0e 94 16 30 	call	0x602c	; 0x602c <__floatunsisf>
     696:	6b 01       	movw	r12, r22
     698:	7c 01       	movw	r14, r24
     69a:	9b 01       	movw	r18, r22
     69c:	ac 01       	movw	r20, r24
     69e:	c5 01       	movw	r24, r10
     6a0:	b4 01       	movw	r22, r8
     6a2:	0e 94 6e 2f 	call	0x5edc	; 0x5edc <__divsf3>
     6a6:	69 a7       	std	Y+41, r22	; 0x29
     6a8:	7a a7       	std	Y+42, r23	; 0x2a
     6aa:	8b a7       	std	Y+43, r24	; 0x2b
     6ac:	9c a7       	std	Y+44, r25	; 0x2c
     6ae:	b9 89       	ldd	r27, Y+17	; 0x11
     6b0:	8b 2e       	mov	r8, r27
     6b2:	91 2c       	mov	r9, r1
     6b4:	88 0c       	add	r8, r8
     6b6:	99 1c       	adc	r9, r9
     6b8:	88 0c       	add	r8, r8
     6ba:	99 1c       	adc	r9, r9
     6bc:	4d 84       	ldd	r4, Y+13	; 0x0d
     6be:	5e 84       	ldd	r5, Y+14	; 0x0e
     6c0:	48 0c       	add	r4, r8
     6c2:	59 1c       	adc	r5, r9
     6c4:	e9 a9       	ldd	r30, Y+49	; 0x31
     6c6:	fa a9       	ldd	r31, Y+50	; 0x32
     6c8:	e8 0d       	add	r30, r8
     6ca:	f9 1d       	adc	r31, r9
     6cc:	d2 01       	movw	r26, r4
     6ce:	2d 91       	ld	r18, X+
     6d0:	3d 91       	ld	r19, X+
     6d2:	4d 91       	ld	r20, X+
     6d4:	5c 91       	ld	r21, X
     6d6:	60 81       	ld	r22, Z
     6d8:	71 81       	ldd	r23, Z+1	; 0x01
     6da:	82 81       	ldd	r24, Z+2	; 0x02
     6dc:	93 81       	ldd	r25, Z+3	; 0x03
     6de:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
     6e2:	a7 01       	movw	r20, r14
     6e4:	96 01       	movw	r18, r12
     6e6:	0e 94 6e 2f 	call	0x5edc	; 0x5edc <__divsf3>
     6ea:	69 8b       	std	Y+17, r22	; 0x11
     6ec:	7a 8b       	std	Y+18, r23	; 0x12
     6ee:	8b 8b       	std	Y+19, r24	; 0x13
     6f0:	9c 8b       	std	Y+20, r25	; 0x14
     6f2:	29 a5       	ldd	r18, Y+41	; 0x29
     6f4:	3a a5       	ldd	r19, Y+42	; 0x2a
     6f6:	4b a5       	ldd	r20, Y+43	; 0x2b
     6f8:	5c a5       	ldd	r21, Y+44	; 0x2c
     6fa:	ca 01       	movw	r24, r20
     6fc:	b9 01       	movw	r22, r18
     6fe:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
     702:	9b 01       	movw	r18, r22
     704:	ac 01       	movw	r20, r24
     706:	60 e0       	ldi	r22, 0x00	; 0
     708:	70 e0       	ldi	r23, 0x00	; 0
     70a:	80 e0       	ldi	r24, 0x00	; 0
     70c:	90 e4       	ldi	r25, 0x40	; 64
     70e:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
     712:	6b 01       	movw	r12, r22
     714:	7c 01       	movw	r14, r24
     716:	2b ea       	ldi	r18, 0xAB	; 171
     718:	3a ea       	ldi	r19, 0xAA	; 170
     71a:	4a e2       	ldi	r20, 0x2A	; 42
     71c:	5e e3       	ldi	r21, 0x3E	; 62
     71e:	69 a5       	ldd	r22, Y+41	; 0x29
     720:	7a a5       	ldd	r23, Y+42	; 0x2a
     722:	8b a5       	ldd	r24, Y+43	; 0x2b
     724:	9c a5       	ldd	r25, Y+44	; 0x2c
     726:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
     72a:	4b 01       	movw	r8, r22
     72c:	5c 01       	movw	r10, r24
     72e:	20 e0       	ldi	r18, 0x00	; 0
     730:	30 e0       	ldi	r19, 0x00	; 0
     732:	40 e8       	ldi	r20, 0x80	; 128
     734:	50 e4       	ldi	r21, 0x40	; 64
     736:	c7 01       	movw	r24, r14
     738:	b6 01       	movw	r22, r12
     73a:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
     73e:	9b 01       	movw	r18, r22
     740:	ac 01       	movw	r20, r24
     742:	c5 01       	movw	r24, r10
     744:	b4 01       	movw	r22, r8
     746:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
     74a:	69 a3       	std	Y+33, r22	; 0x21
     74c:	7a a3       	std	Y+34, r23	; 0x22
     74e:	8b a3       	std	Y+35, r24	; 0x23
     750:	9c a3       	std	Y+36, r25	; 0x24
     752:	20 e0       	ldi	r18, 0x00	; 0
     754:	30 e0       	ldi	r19, 0x00	; 0
     756:	40 e0       	ldi	r20, 0x00	; 0
     758:	5f e3       	ldi	r21, 0x3F	; 63
     75a:	c7 01       	movw	r24, r14
     75c:	b6 01       	movw	r22, r12
     75e:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
     762:	6d a3       	std	Y+37, r22	; 0x25
     764:	7e a3       	std	Y+38, r23	; 0x26
     766:	8f a3       	std	Y+39, r24	; 0x27
     768:	98 a7       	std	Y+40, r25	; 0x28
     76a:	b2 e0       	ldi	r27, 0x02	; 2
     76c:	6b 16       	cp	r6, r27
     76e:	71 04       	cpc	r7, r1
     770:	08 f4       	brcc	.+2      	; 0x774 <__LOCK_REGION_LENGTH__+0x374>
     772:	f6 c0       	rjmp	.+492    	; 0x960 <__stack+0x61>
     774:	10 e0       	ldi	r17, 0x00	; 0
     776:	22 24       	eor	r2, r2
     778:	23 94       	inc	r2
     77a:	31 2c       	mov	r3, r1
     77c:	c9 84       	ldd	r12, Y+9	; 0x09
     77e:	da 84       	ldd	r13, Y+10	; 0x0a
     780:	eb 84       	ldd	r14, Y+11	; 0x0b
     782:	fc 84       	ldd	r15, Y+12	; 0x0c
     784:	1c 30       	cpi	r17, 0x0C	; 12
     786:	08 f0       	brcs	.+2      	; 0x78a <__LOCK_REGION_LENGTH__+0x38a>
     788:	44 c0       	rjmp	.+136    	; 0x812 <__LOCK_REGION_LENGTH__+0x412>
     78a:	a7 01       	movw	r20, r14
     78c:	96 01       	movw	r18, r12
     78e:	6d a1       	ldd	r22, Y+37	; 0x25
     790:	7e a1       	ldd	r23, Y+38	; 0x26
     792:	8f a1       	ldd	r24, Y+39	; 0x27
     794:	98 a5       	ldd	r25, Y+40	; 0x28
     796:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
     79a:	4b 01       	movw	r8, r22
     79c:	5c 01       	movw	r10, r24
     79e:	29 81       	ldd	r18, Y+1	; 0x01
     7a0:	3a 81       	ldd	r19, Y+2	; 0x02
     7a2:	4b 81       	ldd	r20, Y+3	; 0x03
     7a4:	5c 81       	ldd	r21, Y+4	; 0x04
     7a6:	69 a1       	ldd	r22, Y+33	; 0x21
     7a8:	7a a1       	ldd	r23, Y+34	; 0x22
     7aa:	8b a1       	ldd	r24, Y+35	; 0x23
     7ac:	9c a1       	ldd	r25, Y+36	; 0x24
     7ae:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
     7b2:	a5 01       	movw	r20, r10
     7b4:	94 01       	movw	r18, r8
     7b6:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
     7ba:	96 2e       	mov	r9, r22
     7bc:	a7 2e       	mov	r10, r23
     7be:	b8 2e       	mov	r11, r24
     7c0:	09 2f       	mov	r16, r25
     7c2:	29 81       	ldd	r18, Y+1	; 0x01
     7c4:	3a 81       	ldd	r19, Y+2	; 0x02
     7c6:	4b 81       	ldd	r20, Y+3	; 0x03
     7c8:	5c 81       	ldd	r21, Y+4	; 0x04
     7ca:	6d a1       	ldd	r22, Y+37	; 0x25
     7cc:	7e a1       	ldd	r23, Y+38	; 0x26
     7ce:	8f a1       	ldd	r24, Y+39	; 0x27
     7d0:	98 a5       	ldd	r25, Y+40	; 0x28
     7d2:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
     7d6:	69 83       	std	Y+1, r22	; 0x01
     7d8:	7a 83       	std	Y+2, r23	; 0x02
     7da:	8b 83       	std	Y+3, r24	; 0x03
     7dc:	9c 83       	std	Y+4, r25	; 0x04
     7de:	a7 01       	movw	r20, r14
     7e0:	96 01       	movw	r18, r12
     7e2:	69 a1       	ldd	r22, Y+33	; 0x21
     7e4:	7a a1       	ldd	r23, Y+34	; 0x22
     7e6:	8b a1       	ldd	r24, Y+35	; 0x23
     7e8:	9c a1       	ldd	r25, Y+36	; 0x24
     7ea:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
     7ee:	9b 01       	movw	r18, r22
     7f0:	ac 01       	movw	r20, r24
     7f2:	69 81       	ldd	r22, Y+1	; 0x01
     7f4:	7a 81       	ldd	r23, Y+2	; 0x02
     7f6:	8b 81       	ldd	r24, Y+3	; 0x03
     7f8:	9c 81       	ldd	r25, Y+4	; 0x04
     7fa:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
     7fe:	69 83       	std	Y+1, r22	; 0x01
     800:	7a 83       	std	Y+2, r23	; 0x02
     802:	8b 83       	std	Y+3, r24	; 0x03
     804:	9c 83       	std	Y+4, r25	; 0x04
     806:	1f 5f       	subi	r17, 0xFF	; 255
     808:	c9 2c       	mov	r12, r9
     80a:	da 2c       	mov	r13, r10
     80c:	eb 2c       	mov	r14, r11
     80e:	f0 2e       	mov	r15, r16
     810:	66 c0       	rjmp	.+204    	; 0x8de <__LOCK_REGION_LENGTH__+0x4de>
     812:	b1 01       	movw	r22, r2
     814:	80 e0       	ldi	r24, 0x00	; 0
     816:	90 e0       	ldi	r25, 0x00	; 0
     818:	0e 94 16 30 	call	0x602c	; 0x602c <__floatunsisf>
     81c:	29 a5       	ldd	r18, Y+41	; 0x29
     81e:	3a a5       	ldd	r19, Y+42	; 0x2a
     820:	4b a5       	ldd	r20, Y+43	; 0x2b
     822:	5c a5       	ldd	r21, Y+44	; 0x2c
     824:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
     828:	6b 01       	movw	r12, r22
     82a:	7c 01       	movw	r14, r24
     82c:	0e 94 69 2f 	call	0x5ed2	; 0x5ed2 <cos>
     830:	6d 83       	std	Y+5, r22	; 0x05
     832:	7e 83       	std	Y+6, r23	; 0x06
     834:	8f 83       	std	Y+7, r24	; 0x07
     836:	98 87       	std	Y+8, r25	; 0x08
     838:	c7 01       	movw	r24, r14
     83a:	b6 01       	movw	r22, r12
     83c:	0e 94 57 32 	call	0x64ae	; 0x64ae <sin>
     840:	69 87       	std	Y+9, r22	; 0x09
     842:	7a 87       	std	Y+10, r23	; 0x0a
     844:	8b 87       	std	Y+11, r24	; 0x0b
     846:	9c 87       	std	Y+12, r25	; 0x0c
     848:	ed a5       	ldd	r30, Y+45	; 0x2d
     84a:	fe a5       	ldd	r31, Y+46	; 0x2e
     84c:	c0 80       	ld	r12, Z
     84e:	d1 80       	ldd	r13, Z+1	; 0x01
     850:	e2 80       	ldd	r14, Z+2	; 0x02
     852:	f3 80       	ldd	r15, Z+3	; 0x03
     854:	f7 fa       	bst	r15, 7
     856:	f0 94       	com	r15
     858:	f7 f8       	bld	r15, 7
     85a:	f0 94       	com	r15
     85c:	af a5       	ldd	r26, Y+47	; 0x2f
     85e:	b8 a9       	ldd	r27, Y+48	; 0x30
     860:	8d 90       	ld	r8, X+
     862:	9d 90       	ld	r9, X+
     864:	ad 90       	ld	r10, X+
     866:	bc 90       	ld	r11, X
     868:	a7 01       	movw	r20, r14
     86a:	96 01       	movw	r18, r12
     86c:	6d 81       	ldd	r22, Y+5	; 0x05
     86e:	7e 81       	ldd	r23, Y+6	; 0x06
     870:	8f 81       	ldd	r24, Y+7	; 0x07
     872:	98 85       	ldd	r25, Y+8	; 0x08
     874:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
     878:	69 83       	std	Y+1, r22	; 0x01
     87a:	7a 83       	std	Y+2, r23	; 0x02
     87c:	8b 83       	std	Y+3, r24	; 0x03
     87e:	9c 83       	std	Y+4, r25	; 0x04
     880:	a5 01       	movw	r20, r10
     882:	94 01       	movw	r18, r8
     884:	69 85       	ldd	r22, Y+9	; 0x09
     886:	7a 85       	ldd	r23, Y+10	; 0x0a
     888:	8b 85       	ldd	r24, Y+11	; 0x0b
     88a:	9c 85       	ldd	r25, Y+12	; 0x0c
     88c:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
     890:	9b 01       	movw	r18, r22
     892:	ac 01       	movw	r20, r24
     894:	69 81       	ldd	r22, Y+1	; 0x01
     896:	7a 81       	ldd	r23, Y+2	; 0x02
     898:	8b 81       	ldd	r24, Y+3	; 0x03
     89a:	9c 81       	ldd	r25, Y+4	; 0x04
     89c:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
     8a0:	69 83       	std	Y+1, r22	; 0x01
     8a2:	7a 83       	std	Y+2, r23	; 0x02
     8a4:	8b 83       	std	Y+3, r24	; 0x03
     8a6:	9c 83       	std	Y+4, r25	; 0x04
     8a8:	a7 01       	movw	r20, r14
     8aa:	96 01       	movw	r18, r12
     8ac:	69 85       	ldd	r22, Y+9	; 0x09
     8ae:	7a 85       	ldd	r23, Y+10	; 0x0a
     8b0:	8b 85       	ldd	r24, Y+11	; 0x0b
     8b2:	9c 85       	ldd	r25, Y+12	; 0x0c
     8b4:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
     8b8:	6b 01       	movw	r12, r22
     8ba:	7c 01       	movw	r14, r24
     8bc:	a5 01       	movw	r20, r10
     8be:	94 01       	movw	r18, r8
     8c0:	6d 81       	ldd	r22, Y+5	; 0x05
     8c2:	7e 81       	ldd	r23, Y+6	; 0x06
     8c4:	8f 81       	ldd	r24, Y+7	; 0x07
     8c6:	98 85       	ldd	r25, Y+8	; 0x08
     8c8:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
     8cc:	9b 01       	movw	r18, r22
     8ce:	ac 01       	movw	r20, r24
     8d0:	c7 01       	movw	r24, r14
     8d2:	b6 01       	movw	r22, r12
     8d4:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
     8d8:	6b 01       	movw	r12, r22
     8da:	7c 01       	movw	r14, r24
     8dc:	10 e0       	ldi	r17, 0x00	; 0
     8de:	2f 89       	ldd	r18, Y+23	; 0x17
     8e0:	38 8d       	ldd	r19, Y+24	; 0x18
     8e2:	49 8d       	ldd	r20, Y+25	; 0x19
     8e4:	5a 8d       	ldd	r21, Y+26	; 0x1a
     8e6:	69 81       	ldd	r22, Y+1	; 0x01
     8e8:	7a 81       	ldd	r23, Y+2	; 0x02
     8ea:	8b 81       	ldd	r24, Y+3	; 0x03
     8ec:	9c 81       	ldd	r25, Y+4	; 0x04
     8ee:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
     8f2:	ed 89       	ldd	r30, Y+21	; 0x15
     8f4:	fe 89       	ldd	r31, Y+22	; 0x16
     8f6:	60 83       	st	Z, r22
     8f8:	71 83       	std	Z+1, r23	; 0x01
     8fa:	82 83       	std	Z+2, r24	; 0x02
     8fc:	93 83       	std	Z+3, r25	; 0x03
     8fe:	2d 8d       	ldd	r18, Y+29	; 0x1d
     900:	3e 8d       	ldd	r19, Y+30	; 0x1e
     902:	4f 8d       	ldd	r20, Y+31	; 0x1f
     904:	58 a1       	ldd	r21, Y+32	; 0x20
     906:	c7 01       	movw	r24, r14
     908:	b6 01       	movw	r22, r12
     90a:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
     90e:	ab 8d       	ldd	r26, Y+27	; 0x1b
     910:	bc 8d       	ldd	r27, Y+28	; 0x1c
     912:	6d 93       	st	X+, r22
     914:	7d 93       	st	X+, r23
     916:	8d 93       	st	X+, r24
     918:	9c 93       	st	X, r25
     91a:	13 97       	sbiw	r26, 0x03	; 3
     91c:	29 89       	ldd	r18, Y+17	; 0x11
     91e:	3a 89       	ldd	r19, Y+18	; 0x12
     920:	4b 89       	ldd	r20, Y+19	; 0x13
     922:	5c 89       	ldd	r21, Y+20	; 0x14
     924:	f2 01       	movw	r30, r4
     926:	60 81       	ld	r22, Z
     928:	71 81       	ldd	r23, Z+1	; 0x01
     92a:	82 81       	ldd	r24, Z+2	; 0x02
     92c:	93 81       	ldd	r25, Z+3	; 0x03
     92e:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
     932:	d2 01       	movw	r26, r4
     934:	6d 93       	st	X+, r22
     936:	7d 93       	st	X+, r23
     938:	8d 93       	st	X+, r24
     93a:	9c 93       	st	X, r25
     93c:	13 97       	sbiw	r26, 0x03	; 3
     93e:	6f 85       	ldd	r22, Y+15	; 0x0f
     940:	78 89       	ldd	r23, Y+16	; 0x10
     942:	8d 85       	ldd	r24, Y+13	; 0x0d
     944:	9e 85       	ldd	r25, Y+14	; 0x0e
     946:	0e 94 ad 01 	call	0x35a	; 0x35a <mc_line>
     94a:	80 91 7d 05 	lds	r24, 0x057D	; 0x80057d <sys+0x1>
     94e:	81 11       	cpse	r24, r1
     950:	0d c0       	rjmp	.+26     	; 0x96c <__stack+0x6d>
     952:	bf ef       	ldi	r27, 0xFF	; 255
     954:	2b 1a       	sub	r2, r27
     956:	3b 0a       	sbc	r3, r27
     958:	62 14       	cp	r6, r2
     95a:	73 04       	cpc	r7, r3
     95c:	09 f0       	breq	.+2      	; 0x960 <__stack+0x61>
     95e:	12 cf       	rjmp	.-476    	; 0x784 <__LOCK_REGION_LENGTH__+0x384>
     960:	6f 85       	ldd	r22, Y+15	; 0x0f
     962:	78 89       	ldd	r23, Y+16	; 0x10
     964:	89 a9       	ldd	r24, Y+49	; 0x31
     966:	9a a9       	ldd	r25, Y+50	; 0x32
     968:	0e 94 ad 01 	call	0x35a	; 0x35a <mc_line>
     96c:	e2 96       	adiw	r28, 0x32	; 50
     96e:	0f b6       	in	r0, 0x3f	; 63
     970:	f8 94       	cli
     972:	de bf       	out	0x3e, r29	; 62
     974:	0f be       	out	0x3f, r0	; 63
     976:	cd bf       	out	0x3d, r28	; 61
     978:	df 91       	pop	r29
     97a:	cf 91       	pop	r28
     97c:	1f 91       	pop	r17
     97e:	0f 91       	pop	r16
     980:	ff 90       	pop	r15
     982:	ef 90       	pop	r14
     984:	df 90       	pop	r13
     986:	cf 90       	pop	r12
     988:	bf 90       	pop	r11
     98a:	af 90       	pop	r10
     98c:	9f 90       	pop	r9
     98e:	8f 90       	pop	r8
     990:	7f 90       	pop	r7
     992:	6f 90       	pop	r6
     994:	5f 90       	pop	r5
     996:	4f 90       	pop	r4
     998:	3f 90       	pop	r3
     99a:	2f 90       	pop	r2
     99c:	08 95       	ret

0000099e <mc_dwell>:
     99e:	cf 92       	push	r12
     9a0:	df 92       	push	r13
     9a2:	ef 92       	push	r14
     9a4:	ff 92       	push	r15
     9a6:	20 91 7c 05 	lds	r18, 0x057C	; 0x80057c <sys>
     9aa:	22 30       	cpi	r18, 0x02	; 2
     9ac:	49 f0       	breq	.+18     	; 0x9c0 <mc_dwell+0x22>
     9ae:	6b 01       	movw	r12, r22
     9b0:	7c 01       	movw	r14, r24
     9b2:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <protocol_buffer_synchronize>
     9b6:	40 e0       	ldi	r20, 0x00	; 0
     9b8:	c7 01       	movw	r24, r14
     9ba:	b6 01       	movw	r22, r12
     9bc:	0e 94 a3 2a 	call	0x5546	; 0x5546 <delay_sec>
     9c0:	ff 90       	pop	r15
     9c2:	ef 90       	pop	r14
     9c4:	df 90       	pop	r13
     9c6:	cf 90       	pop	r12
     9c8:	08 95       	ret

000009ca <mc_probe_cycle>:


// Perform tool length probe cycle. Requires probe switch.
// NOTE: Upon probe failure, the program will be stopped and placed into ALARM state.
uint8_t mc_probe_cycle(float *target, plan_line_data_t *pl_data, uint8_t parser_flags)
{
     9ca:	df 92       	push	r13
     9cc:	ef 92       	push	r14
     9ce:	ff 92       	push	r15
     9d0:	0f 93       	push	r16
     9d2:	1f 93       	push	r17
     9d4:	cf 93       	push	r28
     9d6:	df 93       	push	r29
  // TODO: Need to update this cycle so it obeys a non-auto cycle start.
  if (sys.state == STATE_CHECK_MODE) { return(GC_PROBE_CHECK_MODE); }
     9d8:	20 91 7c 05 	lds	r18, 0x057C	; 0x80057c <sys>
     9dc:	22 30       	cpi	r18, 0x02	; 2
     9de:	09 f4       	brne	.+2      	; 0x9e2 <mc_probe_cycle+0x18>
     9e0:	5f c0       	rjmp	.+190    	; 0xaa0 <mc_probe_cycle+0xd6>
     9e2:	d4 2e       	mov	r13, r20
     9e4:	7b 01       	movw	r14, r22
     9e6:	8c 01       	movw	r16, r24

  // Finish all queued commands and empty planner buffer before starting probe cycle.
  protocol_buffer_synchronize();
     9e8:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <protocol_buffer_synchronize>
  if (sys.abort) { return(GC_PROBE_ABORT); } // Return if system reset has been issued.
     9ec:	80 91 7d 05 	lds	r24, 0x057D	; 0x80057d <sys+0x1>
     9f0:	81 11       	cpse	r24, r1
     9f2:	58 c0       	rjmp	.+176    	; 0xaa4 <mc_probe_cycle+0xda>

  // Initialize probing control variables
  uint8_t is_probe_away = bit_istrue(parser_flags,GC_PARSER_PROBE_IS_AWAY);
  uint8_t is_no_error = bit_istrue(parser_flags,GC_PARSER_PROBE_IS_NO_ERROR);
  sys.probe_succeeded = false; // Re-initialize probe history before beginning cycle.
     9f4:	10 92 81 05 	sts	0x0581, r1	; 0x800581 <sys+0x5>
  probe_configure_invert_mask(is_probe_away);
     9f8:	d3 fa       	bst	r13, 3
     9fa:	88 27       	eor	r24, r24
     9fc:	80 f9       	bld	r24, 0
     9fe:	0e 94 ca 2c 	call	0x5994	; 0x5994 <probe_configure_invert_mask>

  // After syncing, check if probe is already triggered. If so, halt and issue alarm.
  // NOTE: This probe initialization error applies to all probing cycles.
  if ( probe_get_state() ) { // Check probe pin state.
     a02:	0e 94 e2 2c 	call	0x59c4	; 0x59c4 <probe_get_state>
     a06:	88 23       	and	r24, r24
     a08:	51 f0       	breq	.+20     	; 0xa1e <mc_probe_cycle+0x54>
    system_set_exec_alarm(EXEC_ALARM_PROBE_FAIL_INITIAL);
     a0a:	84 e0       	ldi	r24, 0x04	; 4
     a0c:	0e 94 44 2e 	call	0x5c88	; 0x5c88 <system_set_exec_alarm>
    protocol_execute_realtime();
     a10:	0e 94 9e 14 	call	0x293c	; 0x293c <protocol_execute_realtime>
    probe_configure_invert_mask(false); // Re-initialize invert mask before returning.
     a14:	80 e0       	ldi	r24, 0x00	; 0
     a16:	0e 94 ca 2c 	call	0x5994	; 0x5994 <probe_configure_invert_mask>
    return(GC_PROBE_FAIL_INIT); // Nothing else to do but bail.
     a1a:	82 e0       	ldi	r24, 0x02	; 2
     a1c:	46 c0       	rjmp	.+140    	; 0xaaa <mc_probe_cycle+0xe0>
  }

  // Setup and queue probing motion. Auto cycle-start should not start the cycle.
  mc_line(target, pl_data);
     a1e:	b7 01       	movw	r22, r14
     a20:	c8 01       	movw	r24, r16
     a22:	0e 94 ad 01 	call	0x35a	; 0x35a <mc_line>

  // Activate the probing state monitor in the stepper module.
  sys_probe_state = PROBE_ACTIVE;
     a26:	81 e0       	ldi	r24, 0x01	; 1
     a28:	80 93 8f 05 	sts	0x058F, r24	; 0x80058f <sys_probe_state>

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  system_set_exec_state_flag(EXEC_CYCLE_START);
     a2c:	82 e0       	ldi	r24, 0x02	; 2
     a2e:	0e 94 31 2e 	call	0x5c62	; 0x5c62 <system_set_exec_state_flag>
  do {
    protocol_execute_realtime();
    if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
     a32:	cc e7       	ldi	r28, 0x7C	; 124
     a34:	d5 e0       	ldi	r29, 0x05	; 5
  sys_probe_state = PROBE_ACTIVE;

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  system_set_exec_state_flag(EXEC_CYCLE_START);
  do {
    protocol_execute_realtime();
     a36:	0e 94 9e 14 	call	0x293c	; 0x293c <protocol_execute_realtime>
    if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
     a3a:	89 81       	ldd	r24, Y+1	; 0x01
     a3c:	81 11       	cpse	r24, r1
     a3e:	34 c0       	rjmp	.+104    	; 0xaa8 <mc_probe_cycle+0xde>
  } while (sys.state != STATE_IDLE);
     a40:	88 81       	ld	r24, Y
     a42:	81 11       	cpse	r24, r1
     a44:	f8 cf       	rjmp	.-16     	; 0xa36 <mc_probe_cycle+0x6c>

  // Probing cycle complete!

  // Set state variables and error out, if the probe failed and cycle with error is enabled.
  if (sys_probe_state == PROBE_ACTIVE) {
     a46:	80 91 8f 05 	lds	r24, 0x058F	; 0x80058f <sys_probe_state>
     a4a:	81 30       	cpi	r24, 0x01	; 1
     a4c:	81 f4       	brne	.+32     	; 0xa6e <mc_probe_cycle+0xa4>
    if (is_no_error) { memcpy(sys_probe_position, sys_position, sizeof(sys_position)); }
     a4e:	d4 fe       	sbrs	r13, 4
     a50:	0a c0       	rjmp	.+20     	; 0xa66 <mc_probe_cycle+0x9c>
     a52:	8c e0       	ldi	r24, 0x0C	; 12
     a54:	ec e9       	ldi	r30, 0x9C	; 156
     a56:	f5 e0       	ldi	r31, 0x05	; 5
     a58:	a0 e9       	ldi	r26, 0x90	; 144
     a5a:	b5 e0       	ldi	r27, 0x05	; 5
     a5c:	01 90       	ld	r0, Z+
     a5e:	0d 92       	st	X+, r0
     a60:	8a 95       	dec	r24
     a62:	e1 f7       	brne	.-8      	; 0xa5c <mc_probe_cycle+0x92>
     a64:	07 c0       	rjmp	.+14     	; 0xa74 <mc_probe_cycle+0xaa>
    else { system_set_exec_alarm(EXEC_ALARM_PROBE_FAIL_CONTACT); }
     a66:	85 e0       	ldi	r24, 0x05	; 5
     a68:	0e 94 44 2e 	call	0x5c88	; 0x5c88 <system_set_exec_alarm>
     a6c:	03 c0       	rjmp	.+6      	; 0xa74 <mc_probe_cycle+0xaa>
  } else {
    sys.probe_succeeded = true; // Indicate to system the probing cycle completed successfully.
     a6e:	81 e0       	ldi	r24, 0x01	; 1
     a70:	80 93 81 05 	sts	0x0581, r24	; 0x800581 <sys+0x5>
  }
  sys_probe_state = PROBE_OFF; // Ensure probe state monitor is disabled.
     a74:	10 92 8f 05 	sts	0x058F, r1	; 0x80058f <sys_probe_state>
  probe_configure_invert_mask(false); // Re-initialize invert mask.
     a78:	80 e0       	ldi	r24, 0x00	; 0
     a7a:	0e 94 ca 2c 	call	0x5994	; 0x5994 <probe_configure_invert_mask>
  protocol_execute_realtime();   // Check and execute run-time commands
     a7e:	0e 94 9e 14 	call	0x293c	; 0x293c <protocol_execute_realtime>

  // Reset the stepper and planner buffers to remove the remainder of the probe motion.
  st_reset(); // Reset step segment buffer.
     a82:	0e 94 13 19 	call	0x3226	; 0x3226 <st_reset>
  plan_reset(); // Reset planner buffer. Zero planner positions. Ensure probing motion is cleared.
     a86:	0e 94 20 25 	call	0x4a40	; 0x4a40 <plan_reset>
  plan_sync_position(); // Sync planner position to current machine position.
     a8a:	0e 94 c2 29 	call	0x5384	; 0x5384 <plan_sync_position>

  #ifdef MESSAGE_PROBE_COORDINATES
    // All done! Output the probe position as message.
    report_probe_parameters();
     a8e:	0e 94 02 2d 	call	0x5a04	; 0x5a04 <report_probe_parameters>
// Perform tool length probe cycle. Requires probe switch.
// NOTE: Upon probe failure, the program will be stopped and placed into ALARM state.
uint8_t mc_probe_cycle(float *target, plan_line_data_t *pl_data, uint8_t parser_flags)
{
  // TODO: Need to update this cycle so it obeys a non-auto cycle start.
  if (sys.state == STATE_CHECK_MODE) { return(GC_PROBE_CHECK_MODE); }
     a92:	81 e0       	ldi	r24, 0x01	; 1
     a94:	90 91 81 05 	lds	r25, 0x0581	; 0x800581 <sys+0x5>
     a98:	91 11       	cpse	r25, r1
     a9a:	07 c0       	rjmp	.+14     	; 0xaaa <mc_probe_cycle+0xe0>
     a9c:	80 e0       	ldi	r24, 0x00	; 0
     a9e:	05 c0       	rjmp	.+10     	; 0xaaa <mc_probe_cycle+0xe0>
     aa0:	80 e0       	ldi	r24, 0x00	; 0
     aa2:	03 c0       	rjmp	.+6      	; 0xaaa <mc_probe_cycle+0xe0>

  // Finish all queued commands and empty planner buffer before starting probe cycle.
  protocol_buffer_synchronize();
  if (sys.abort) { return(GC_PROBE_ABORT); } // Return if system reset has been issued.
     aa4:	82 e0       	ldi	r24, 0x02	; 2
     aa6:	01 c0       	rjmp	.+2      	; 0xaaa <mc_probe_cycle+0xe0>

  // Perform probing cycle. Wait here until probe is triggered or motion completes.
  system_set_exec_state_flag(EXEC_CYCLE_START);
  do {
    protocol_execute_realtime();
    if (sys.abort) { return(GC_PROBE_ABORT); } // Check for system abort
     aa8:	82 e0       	ldi	r24, 0x02	; 2
    report_probe_parameters();
  #endif

  if (sys.probe_succeeded) { return(GC_PROBE_FOUND); } // Successful probe cycle.
  else { return(GC_PROBE_FAIL_END); } // Failed to trigger probe within travel. With or without error.
}
     aaa:	df 91       	pop	r29
     aac:	cf 91       	pop	r28
     aae:	1f 91       	pop	r17
     ab0:	0f 91       	pop	r16
     ab2:	ff 90       	pop	r15
     ab4:	ef 90       	pop	r14
     ab6:	df 90       	pop	r13
     ab8:	08 95       	ret

00000aba <mc_reset>:
// lost, since there was an abrupt uncontrolled deceleration. Called at an interrupt level by
// realtime abort command and hard limits. So, keep to a minimum.
void mc_reset()
{
  // Only this function can set the system reset. Helps prevent multiple kill calls.
  if (bit_isfalse(sys_rt_exec_state, EXEC_RESET)) {
     aba:	80 91 8e 05 	lds	r24, 0x058E	; 0x80058e <sys_rt_exec_state>
     abe:	84 fd       	sbrc	r24, 4
     ac0:	1f c0       	rjmp	.+62     	; 0xb00 <mc_reset+0x46>
    system_set_exec_state_flag(EXEC_RESET);
     ac2:	80 e1       	ldi	r24, 0x10	; 16
     ac4:	0e 94 31 2e 	call	0x5c62	; 0x5c62 <system_set_exec_state_flag>

    // Kill spindle and coolant.
    spindle_stop();
     ac8:	0e 94 91 10 	call	0x2122	; 0x2122 <spindle_stop>
    coolant_stop();
     acc:	0e 94 b8 11 	call	0x2370	; 0x2370 <coolant_stop>

    // Kill steppers only if in any motion state, i.e. cycle, actively holding, or homing.
    // NOTE: If steppers are kept enabled via the step idle delay setting, this also keeps
    // the steppers enabled by avoiding the go_idle call altogether, unless the motion state is
    // violated, by which, all bets are off.
    if ((sys.state & (STATE_CYCLE | STATE_HOMING | STATE_JOG)) ||
     ad0:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
     ad4:	98 2f       	mov	r25, r24
     ad6:	9c 72       	andi	r25, 0x2C	; 44
     ad8:	21 f4       	brne	.+8      	; 0xae2 <mc_reset+0x28>
     ada:	90 91 80 05 	lds	r25, 0x0580	; 0x800580 <sys+0x4>
     ade:	96 70       	andi	r25, 0x06	; 6
     ae0:	79 f0       	breq	.+30     	; 0xb00 <mc_reset+0x46>
    		(sys.step_control & (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION))) {
      if (sys.state == STATE_HOMING) { 
     ae2:	84 30       	cpi	r24, 0x04	; 4
     ae4:	41 f4       	brne	.+16     	; 0xaf6 <mc_reset+0x3c>
        if (!sys_rt_exec_alarm) {system_set_exec_alarm(EXEC_ALARM_HOMING_FAIL_RESET); }
     ae6:	80 91 a8 05 	lds	r24, 0x05A8	; 0x8005a8 <sys_rt_exec_alarm>
     aea:	81 11       	cpse	r24, r1
     aec:	07 c0       	rjmp	.+14     	; 0xafc <mc_reset+0x42>
     aee:	86 e0       	ldi	r24, 0x06	; 6
     af0:	0e 94 44 2e 	call	0x5c88	; 0x5c88 <system_set_exec_alarm>
     af4:	03 c0       	rjmp	.+6      	; 0xafc <mc_reset+0x42>
      } else { system_set_exec_alarm(EXEC_ALARM_ABORT_CYCLE); }
     af6:	83 e0       	ldi	r24, 0x03	; 3
     af8:	0e 94 44 2e 	call	0x5c88	; 0x5c88 <system_set_exec_alarm>
      st_go_idle(); // Force kill steppers. Position has likely been lost.
     afc:	0e 94 97 16 	call	0x2d2e	; 0x2d2e <st_go_idle>
     b00:	08 95       	ret

00000b02 <gc_init>:
#define FAIL(status) return(status);


void gc_init()
{
  memset(&gc_state, 0, sizeof(parser_state_t));
     b02:	80 e4       	ldi	r24, 0x40	; 64
     b04:	ea ea       	ldi	r30, 0xAA	; 170
     b06:	f5 e0       	ldi	r31, 0x05	; 5
     b08:	df 01       	movw	r26, r30
     b0a:	1d 92       	st	X+, r1
     b0c:	8a 95       	dec	r24
     b0e:	e9 f7       	brne	.-6      	; 0xb0a <gc_init+0x8>

  // Load default G54 coordinate system.
  if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) {
     b10:	6e ec       	ldi	r22, 0xCE	; 206
     b12:	75 e0       	ldi	r23, 0x05	; 5
     b14:	80 e0       	ldi	r24, 0x00	; 0
     b16:	0e 94 4e 23 	call	0x469c	; 0x469c <settings_read_coord_data>
     b1a:	81 11       	cpse	r24, r1
     b1c:	03 c0       	rjmp	.+6      	; 0xb24 <gc_init+0x22>
    report_status_message(STATUS_SETTING_READ_FAIL);
     b1e:	87 e0       	ldi	r24, 0x07	; 7
     b20:	0e 94 fd 2c 	call	0x59fa	; 0x59fa <report_status_message>
     b24:	08 95       	ret

00000b26 <gc_sync_position>:

// Sets g-code parser position in mm. Input in steps. Called by the system abort and hard
// limit pull-off routines.
void gc_sync_position()
{
  system_convert_array_steps_to_mpos(gc_state.position,sys_position);
     b26:	6c e9       	ldi	r22, 0x9C	; 156
     b28:	75 e0       	ldi	r23, 0x05	; 5
     b2a:	82 ec       	ldi	r24, 0xC2	; 194
     b2c:	95 e0       	ldi	r25, 0x05	; 5
     b2e:	0e 94 ab 2d 	call	0x5b56	; 0x5b56 <system_convert_array_steps_to_mpos>
     b32:	08 95       	ret

00000b34 <gc_execute_line>:
// characters and signed floating point values (no whitespace). Comments and block delete
// characters have been removed. In this function, all units and positions are converted and
// exported to grbl's internal functions in terms of (mm, mm/min) and absolute machine
// coordinates, respectively.
uint8_t gc_execute_line(char *line)
{
     b34:	2f 92       	push	r2
     b36:	3f 92       	push	r3
     b38:	4f 92       	push	r4
     b3a:	5f 92       	push	r5
     b3c:	6f 92       	push	r6
     b3e:	7f 92       	push	r7
     b40:	8f 92       	push	r8
     b42:	9f 92       	push	r9
     b44:	af 92       	push	r10
     b46:	bf 92       	push	r11
     b48:	cf 92       	push	r12
     b4a:	df 92       	push	r13
     b4c:	ef 92       	push	r14
     b4e:	ff 92       	push	r15
     b50:	0f 93       	push	r16
     b52:	1f 93       	push	r17
     b54:	cf 93       	push	r28
     b56:	df 93       	push	r29
     b58:	cd b7       	in	r28, 0x3d	; 61
     b5a:	de b7       	in	r29, 0x3e	; 62
     b5c:	ad 97       	sbiw	r28, 0x2d	; 45
     b5e:	0f b6       	in	r0, 0x3f	; 63
     b60:	f8 94       	cli
     b62:	de bf       	out	0x3e, r29	; 62
     b64:	0f be       	out	0x3f, r0	; 63
     b66:	cd bf       	out	0x3d, r28	; 61
     b68:	8c 01       	movw	r16, r24
     updates these modes and commands as the block line is parser and will only be used and
     executed after successful error-checking. The parser block struct also contains a block
     values struct, word tracking variables, and a non-modal commands tracker for the new
     block. This struct contains all of the necessary information to execute the block. */

  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
     b6a:	8a e3       	ldi	r24, 0x3A	; 58
     b6c:	ea ee       	ldi	r30, 0xEA	; 234
     b6e:	f5 e0       	ldi	r31, 0x05	; 5
     b70:	df 01       	movw	r26, r30
     b72:	1d 92       	st	X+, r1
     b74:	8a 95       	dec	r24
     b76:	e9 f7       	brne	.-6      	; 0xb72 <gc_execute_line+0x3e>
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes
     b78:	8b e0       	ldi	r24, 0x0B	; 11
     b7a:	ea ea       	ldi	r30, 0xAA	; 170
     b7c:	f5 e0       	ldi	r31, 0x05	; 5
     b7e:	ab ee       	ldi	r26, 0xEB	; 235
     b80:	b5 e0       	ldi	r27, 0x05	; 5
     b82:	01 90       	ld	r0, Z+
     b84:	0d 92       	st	X+, r0
     b86:	8a 95       	dec	r24
     b88:	e1 f7       	brne	.-8      	; 0xb82 <gc_execute_line+0x4e>
  uint16_t command_words = 0; // Tracks G and M command words. Also used for modal group violations.
  uint16_t value_words = 0; // Tracks value words.
  uint8_t gc_parser_flags = GC_PARSER_NONE;

  // Determine if the line is a jogging motion or a normal g-code block.
  if (line[0] == '$') { // NOTE: `$J=` already parsed when passed to this function.
     b8a:	f8 01       	movw	r30, r16
     b8c:	80 81       	ld	r24, Z
     b8e:	84 32       	cpi	r24, 0x24	; 36
     b90:	11 f0       	breq	.+4      	; 0xb96 <gc_execute_line+0x62>
     b92:	0c 94 30 10 	jmp	0x2060	; 0x2060 <gc_execute_line+0x152c>
    // Set G1 and G94 enforced modes to ensure accurate error checks.
    gc_parser_flags |= GC_PARSER_JOG_MOTION;
    gc_block.modal.motion = MOTION_MODE_LINEAR;
     b96:	ea ee       	ldi	r30, 0xEA	; 234
     b98:	f5 e0       	ldi	r31, 0x05	; 5
     b9a:	81 e0       	ldi	r24, 0x01	; 1
     b9c:	81 83       	std	Z+1, r24	; 0x01
    gc_block.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
     b9e:	12 82       	std	Z+2, r1	; 0x02
  uint8_t char_counter;
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
     ba0:	83 e0       	ldi	r24, 0x03	; 3
     ba2:	89 83       	std	Y+1, r24	; 0x01
  uint8_t gc_parser_flags = GC_PARSER_NONE;

  // Determine if the line is a jogging motion or a normal g-code block.
  if (line[0] == '$') { // NOTE: `$J=` already parsed when passed to this function.
    // Set G1 and G94 enforced modes to ensure accurate error checks.
    gc_parser_flags |= GC_PARSER_JOG_MOTION;
     ba4:	f1 e0       	ldi	r31, 0x01	; 1
     ba6:	f8 a3       	std	Y+32, r31	; 0x20
					  if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
            gc_block.values.t = int_value;
						break;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
     ba8:	21 2c       	mov	r2, r1
     baa:	31 2c       	mov	r3, r1
     bac:	e1 2c       	mov	r14, r1
     bae:	f1 2c       	mov	r15, r1
     bb0:	1f 8e       	std	Y+31, r1	; 0x1f
     bb2:	1d 8e       	std	Y+29, r1	; 0x1d
     bb4:	1e 8e       	std	Y+30, r1	; 0x1e
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
     bb6:	cc 24       	eor	r12, r12
     bb8:	c3 94       	inc	r12
     bba:	d1 2c       	mov	r13, r1

        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
     bbc:	0f 2e       	mov	r0, r31
     bbe:	f1 e6       	ldi	r31, 0x61	; 97
     bc0:	8f 2e       	mov	r8, r31
     bc2:	f3 e0       	ldi	r31, 0x03	; 3
     bc4:	9f 2e       	mov	r9, r31
     bc6:	f0 2d       	mov	r31, r0
     bc8:	1c 8f       	std	Y+28, r17	; 0x1c
     bca:	0b 8f       	std	Y+27, r16	; 0x1b
     bcc:	22 c2       	rjmp	.+1092   	; 0x1012 <gc_execute_line+0x4de>

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.

    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
     bce:	9f eb       	ldi	r25, 0xBF	; 191
     bd0:	91 0f       	add	r25, r17
     bd2:	9a 31       	cpi	r25, 0x1A	; 26
     bd4:	10 f0       	brcs	.+4      	; 0xbda <gc_execute_line+0xa6>
     bd6:	0c 94 c2 0f 	jmp	0x1f84	; 0x1f84 <gc_execute_line+0x1450>
    char_counter++;
     bda:	8f 5f       	subi	r24, 0xFF	; 255
     bdc:	89 83       	std	Y+1, r24	; 0x01
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
     bde:	ae 01       	movw	r20, r28
     be0:	4e 5f       	subi	r20, 0xFE	; 254
     be2:	5f 4f       	sbci	r21, 0xFF	; 255
     be4:	be 01       	movw	r22, r28
     be6:	6f 5f       	subi	r22, 0xFF	; 255
     be8:	7f 4f       	sbci	r23, 0xFF	; 255
     bea:	8b 8d       	ldd	r24, Y+27	; 0x1b
     bec:	9c 8d       	ldd	r25, Y+28	; 0x1c
     bee:	0e 94 dd 29 	call	0x53ba	; 0x53ba <read_float>
     bf2:	88 23       	and	r24, r24
     bf4:	11 f4       	brne	.+4      	; 0xbfa <gc_execute_line+0xc6>
     bf6:	0c 94 c4 0f 	jmp	0x1f88	; 0x1f88 <gc_execute_line+0x1454>
    // accurate than the NIST gcode requirement of x10 when used for commands, but not quite
    // accurate enough for value words that require integers to within 0.0001. This should be
    // a good enough comprimise and catch most all non-integer errors. To make it compliant,
    // we would simply need to change the mantissa to int16, but this add compiled flash space.
    // Maybe update this later.
    int_value = trunc(value);
     bfa:	4a 80       	ldd	r4, Y+2	; 0x02
     bfc:	5b 80       	ldd	r5, Y+3	; 0x03
     bfe:	6c 80       	ldd	r6, Y+4	; 0x04
     c00:	7d 80       	ldd	r7, Y+5	; 0x05
     c02:	c3 01       	movw	r24, r6
     c04:	b2 01       	movw	r22, r4
     c06:	0e 94 a9 32 	call	0x6552	; 0x6552 <trunc>
     c0a:	0e 94 e7 2f 	call	0x5fce	; 0x5fce <__fixunssfsi>
     c0e:	a6 2e       	mov	r10, r22
    mantissa =  round(100*(value - int_value)); // Compute mantissa for Gxx.x commands.
     c10:	70 e0       	ldi	r23, 0x00	; 0
     c12:	80 e0       	ldi	r24, 0x00	; 0
     c14:	90 e0       	ldi	r25, 0x00	; 0
     c16:	0e 94 18 30 	call	0x6030	; 0x6030 <__floatsisf>
     c1a:	9b 01       	movw	r18, r22
     c1c:	ac 01       	movw	r20, r24
     c1e:	c3 01       	movw	r24, r6
     c20:	b2 01       	movw	r22, r4
     c22:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
     c26:	20 e0       	ldi	r18, 0x00	; 0
     c28:	30 e0       	ldi	r19, 0x00	; 0
     c2a:	48 ec       	ldi	r20, 0xC8	; 200
     c2c:	52 e4       	ldi	r21, 0x42	; 66
     c2e:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
     c32:	0e 94 33 32 	call	0x6466	; 0x6466 <round>
     c36:	0e 94 e7 2f 	call	0x5fce	; 0x5fce <__fixunssfsi>
     c3a:	86 2f       	mov	r24, r22
     c3c:	97 2f       	mov	r25, r23
    // NOTE: Rounding must be used to catch small floating point errors.

    // Check if the g-code word is supported or errors due to modal group violations or has
    // been repeated in the g-code block. If ok, update the command or record its value.
    switch(letter) {
     c3e:	17 34       	cpi	r17, 0x47	; 71
     c40:	21 f0       	breq	.+8      	; 0xc4a <gc_execute_line+0x116>
     c42:	1d 34       	cpi	r17, 0x4D	; 77
     c44:	09 f4       	brne	.+2      	; 0xc48 <gc_execute_line+0x114>
     c46:	c1 c0       	rjmp	.+386    	; 0xdca <gc_execute_line+0x296>
     c48:	1d c1       	rjmp	.+570    	; 0xe84 <gc_execute_line+0x350>
      /* 'G' and 'M' Command Words: Parse commands and check for modal group violations.
         NOTE: Modal group numbers are defined in Table 4 of NIST RS274-NGC v3, pg.20 */

      case 'G':
        // Determine 'G' command and its modal group
        switch(int_value) {
     c4a:	4a 2c       	mov	r4, r10
     c4c:	51 2c       	mov	r5, r1
     c4e:	2f e5       	ldi	r18, 0x5F	; 95
     c50:	42 16       	cp	r4, r18
     c52:	51 04       	cpc	r5, r1
     c54:	10 f0       	brcs	.+4      	; 0xc5a <gc_execute_line+0x126>
     c56:	0c 94 c6 0f 	jmp	0x1f8c	; 0x1f8c <gc_execute_line+0x1458>
     c5a:	f2 01       	movw	r30, r4
     c5c:	ec 5c       	subi	r30, 0xCC	; 204
     c5e:	ff 4f       	sbci	r31, 0xFF	; 255
     c60:	0c 94 cf 32 	jmp	0x659e	; 0x659e <__tablejump2__>
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
     c64:	00 97       	sbiw	r24, 0x00	; 0
     c66:	11 f0       	breq	.+4      	; 0xc6c <gc_execute_line+0x138>
     c68:	0c 94 34 10 	jmp	0x2068	; 0x2068 <gc_execute_line+0x1534>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
     c6c:	3e 8d       	ldd	r19, Y+30	; 0x1e
     c6e:	33 23       	and	r19, r19
     c70:	11 f4       	brne	.+4      	; 0xc76 <gc_execute_line+0x142>
     c72:	0c 94 3c 10 	jmp	0x2078	; 0x2078 <gc_execute_line+0x1544>
     c76:	0c 94 c8 0f 	jmp	0x1f90	; 0x1f90 <gc_execute_line+0x145c>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
     c7a:	aa ee       	ldi	r26, 0xEA	; 234
     c7c:	b5 e0       	ldi	r27, 0x05	; 5
     c7e:	ac 92       	st	X, r10
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
     c80:	bc e1       	ldi	r27, 0x1C	; 28
     c82:	ab 16       	cp	r10, r27
     c84:	31 f0       	breq	.+12     	; 0xc92 <gc_execute_line+0x15e>
     c86:	ee e1       	ldi	r30, 0x1E	; 30
     c88:	ae 16       	cp	r10, r30
     c8a:	19 f0       	breq	.+6      	; 0xc92 <gc_execute_line+0x15e>
     c8c:	fc e5       	ldi	r31, 0x5C	; 92
     c8e:	af 12       	cpse	r10, r31
     c90:	85 c0       	rjmp	.+266    	; 0xd9c <gc_execute_line+0x268>
              if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); }
     c92:	00 97       	sbiw	r24, 0x00	; 0
     c94:	49 f0       	breq	.+18     	; 0xca8 <gc_execute_line+0x174>
     c96:	0a 97       	sbiw	r24, 0x0a	; 10
     c98:	39 f0       	breq	.+14     	; 0xca8 <gc_execute_line+0x174>
     c9a:	0c 94 ca 0f 	jmp	0x1f94	; 0x1f94 <gc_execute_line+0x1460>
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
     c9e:	21 e0       	ldi	r18, 0x01	; 1
     ca0:	2e 8f       	std	Y+30, r18	; 0x1e
     ca2:	02 c0       	rjmp	.+4      	; 0xca8 <gc_execute_line+0x174>
     ca4:	31 e0       	ldi	r19, 0x01	; 1
     ca6:	3e 8f       	std	Y+30, r19	; 0x1e
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
              if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); }
              gc_block.non_modal_command += mantissa;
     ca8:	6a 0d       	add	r22, r10
     caa:	aa ee       	ldi	r26, 0xEA	; 234
     cac:	b5 e0       	ldi	r27, 0x05	; 5
     cae:	6c 93       	st	X, r22
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
     cb0:	20 e0       	ldi	r18, 0x00	; 0
     cb2:	7b c0       	rjmp	.+246    	; 0xdaa <gc_execute_line+0x276>
            }                
            break;
          case 0: case 1: case 2: case 3: case 38:
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
     cb4:	be 8d       	ldd	r27, Y+30	; 0x1e
     cb6:	b1 11       	cpse	r27, r1
     cb8:	0c 94 cc 0f 	jmp	0x1f98	; 0x1f98 <gc_execute_line+0x1464>
            axis_command = AXIS_COMMAND_MOTION_MODE;
     cbc:	e2 e0       	ldi	r30, 0x02	; 2
     cbe:	ee 8f       	std	Y+30, r30	; 0x1e
            // No break. Continues to next line.
          case 80:
            word_bit = MODAL_GROUP_G1;
            gc_block.modal.motion = int_value;
     cc0:	a0 92 eb 05 	sts	0x05EB, r10	; 0x8005eb <gc_block+0x1>
            if (int_value == 38){
     cc4:	f6 e2       	ldi	r31, 0x26	; 38
     cc6:	af 12       	cpse	r10, r31
     cc8:	6b c0       	rjmp	.+214    	; 0xda0 <gc_execute_line+0x26c>
              if (!((mantissa == 20) || (mantissa == 30) || (mantissa == 40) || (mantissa == 50))) {
     cca:	84 31       	cpi	r24, 0x14	; 20
     ccc:	91 05       	cpc	r25, r1
     cce:	51 f0       	breq	.+20     	; 0xce4 <gc_execute_line+0x1b0>
     cd0:	8e 31       	cpi	r24, 0x1E	; 30
     cd2:	91 05       	cpc	r25, r1
     cd4:	39 f0       	breq	.+14     	; 0xce4 <gc_execute_line+0x1b0>
     cd6:	88 32       	cpi	r24, 0x28	; 40
     cd8:	91 05       	cpc	r25, r1
     cda:	21 f0       	breq	.+8      	; 0xce4 <gc_execute_line+0x1b0>
     cdc:	c2 97       	sbiw	r24, 0x32	; 50
     cde:	11 f0       	breq	.+4      	; 0xce4 <gc_execute_line+0x1b0>
     ce0:	0c 94 ce 0f 	jmp	0x1f9c	; 0x1f9c <gc_execute_line+0x1468>
                FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
              }
              gc_block.modal.motion += (mantissa/10)+100;
     ce4:	26 2f       	mov	r18, r22
     ce6:	37 2f       	mov	r19, r23
     ce8:	ad ec       	ldi	r26, 0xCD	; 205
     cea:	bc ec       	ldi	r27, 0xCC	; 204
     cec:	0e 94 d5 32 	call	0x65aa	; 0x65aa <__umulhisi3>
     cf0:	96 95       	lsr	r25
     cf2:	87 95       	ror	r24
     cf4:	96 95       	lsr	r25
     cf6:	87 95       	ror	r24
     cf8:	96 95       	lsr	r25
     cfa:	87 95       	ror	r24
     cfc:	86 57       	subi	r24, 0x76	; 118
     cfe:	80 93 eb 05 	sts	0x05EB, r24	; 0x8005eb <gc_block+0x1>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE;
            // No break. Continues to next line.
          case 80:
            word_bit = MODAL_GROUP_G1;
     d02:	21 e0       	ldi	r18, 0x01	; 1
     d04:	52 c0       	rjmp	.+164    	; 0xdaa <gc_execute_line+0x276>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
            }  
            break;
          case 17: case 18: case 19:
            word_bit = MODAL_GROUP_G2;
            gc_block.modal.plane_select = int_value - 17;
     d06:	6f ee       	ldi	r22, 0xEF	; 239
     d08:	6a 0d       	add	r22, r10
     d0a:	60 93 ef 05 	sts	0x05EF, r22	; 0x8005ef <gc_block+0x5>
              gc_block.modal.motion += (mantissa/10)+100;
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
            }  
            break;
          case 17: case 18: case 19:
            word_bit = MODAL_GROUP_G2;
     d0e:	22 e0       	ldi	r18, 0x02	; 2
            gc_block.modal.plane_select = int_value - 17;
            break;
     d10:	48 c0       	rjmp	.+144    	; 0xda2 <gc_execute_line+0x26e>
          case 90: case 91:
            if (mantissa == 0) {
     d12:	00 97       	sbiw	r24, 0x00	; 0
     d14:	31 f4       	brne	.+12     	; 0xd22 <gc_execute_line+0x1ee>
              word_bit = MODAL_GROUP_G3;
              gc_block.modal.distance = int_value - 90;
     d16:	66 ea       	ldi	r22, 0xA6	; 166
     d18:	6a 0d       	add	r22, r10
     d1a:	60 93 ee 05 	sts	0x05EE, r22	; 0x8005ee <gc_block+0x4>
            word_bit = MODAL_GROUP_G2;
            gc_block.modal.plane_select = int_value - 17;
            break;
          case 90: case 91:
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3;
     d1e:	23 e0       	ldi	r18, 0x03	; 3
     d20:	44 c0       	rjmp	.+136    	; 0xdaa <gc_execute_line+0x276>
              gc_block.modal.distance = int_value - 90;
            } else {
              word_bit = MODAL_GROUP_G4;
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
     d22:	0a 97       	sbiw	r24, 0x0a	; 10
     d24:	11 f0       	breq	.+4      	; 0xd2a <gc_execute_line+0x1f6>
     d26:	0c 94 d0 0f 	jmp	0x1fa0	; 0x1fa0 <gc_execute_line+0x146c>
     d2a:	2a e5       	ldi	r18, 0x5A	; 90
     d2c:	a2 16       	cp	r10, r18
     d2e:	11 f4       	brne	.+4      	; 0xd34 <gc_execute_line+0x200>
     d30:	0c 94 d2 0f 	jmp	0x1fa4	; 0x1fa4 <gc_execute_line+0x1470>
          case 90: case 91:
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3;
              gc_block.modal.distance = int_value - 90;
            } else {
              word_bit = MODAL_GROUP_G4;
     d34:	24 e0       	ldi	r18, 0x04	; 4
     d36:	39 c0       	rjmp	.+114    	; 0xdaa <gc_execute_line+0x276>
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94:
            word_bit = MODAL_GROUP_G5;
            gc_block.modal.feed_rate = 94 - int_value;
     d38:	2e e5       	ldi	r18, 0x5E	; 94
     d3a:	2a 19       	sub	r18, r10
     d3c:	20 93 ec 05 	sts	0x05EC, r18	; 0x8005ec <gc_block+0x2>
              mantissa = 0; // Set to zero to indicate valid non-integer G command.
              // Otherwise, arc IJK incremental mode is default. G91.1 does nothing.
            }
            break;
          case 93: case 94:
            word_bit = MODAL_GROUP_G5;
     d40:	25 e0       	ldi	r18, 0x05	; 5
            gc_block.modal.feed_rate = 94 - int_value;
            break;
     d42:	2f c0       	rjmp	.+94     	; 0xda2 <gc_execute_line+0x26e>
          case 20: case 21:
            word_bit = MODAL_GROUP_G6;
            gc_block.modal.units = 21 - int_value;
     d44:	25 e1       	ldi	r18, 0x15	; 21
     d46:	2a 19       	sub	r18, r10
     d48:	20 93 ed 05 	sts	0x05ED, r18	; 0x8005ed <gc_block+0x3>
          case 93: case 94:
            word_bit = MODAL_GROUP_G5;
            gc_block.modal.feed_rate = 94 - int_value;
            break;
          case 20: case 21:
            word_bit = MODAL_GROUP_G6;
     d4c:	26 e0       	ldi	r18, 0x06	; 6
            gc_block.modal.units = 21 - int_value;
            break;
     d4e:	29 c0       	rjmp	.+82     	; 0xda2 <gc_execute_line+0x26e>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
     d50:	3e 8d       	ldd	r19, Y+30	; 0x1e
     d52:	31 11       	cpse	r19, r1
     d54:	0c 94 d4 0f 	jmp	0x1fa8	; 0x1fa8 <gc_execute_line+0x1474>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
     d58:	41 e3       	ldi	r20, 0x31	; 49
     d5a:	a4 12       	cpse	r10, r20
     d5c:	06 c0       	rjmp	.+12     	; 0xd6a <gc_execute_line+0x236>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
     d5e:	10 92 f0 05 	sts	0x05F0, r1	; 0x8005f0 <gc_block+0x6>
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
     d62:	28 e0       	ldi	r18, 0x08	; 8
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
     d64:	83 e0       	ldi	r24, 0x03	; 3
     d66:	8e 8f       	std	Y+30, r24	; 0x1e
     d68:	20 c0       	rjmp	.+64     	; 0xdaa <gc_execute_line+0x276>
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
            } else if (mantissa == 10) { // G43.1
     d6a:	0a 97       	sbiw	r24, 0x0a	; 10
     d6c:	11 f0       	breq	.+4      	; 0xd72 <gc_execute_line+0x23e>
     d6e:	0c 94 d6 0f 	jmp	0x1fac	; 0x1fac <gc_execute_line+0x1478>
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
     d72:	91 e0       	ldi	r25, 0x01	; 1
     d74:	90 93 f0 05 	sts	0x05F0, r25	; 0x8005f0 <gc_block+0x6>
            // NOTE: Not required since cutter radius compensation is always disabled. Only here
            // to support G40 commands that often appear in g-code program headers to setup defaults.
            // gc_block.modal.cutter_comp = CUTTER_COMP_DISABLE; // G40
            break;
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
     d78:	28 e0       	ldi	r18, 0x08	; 8
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
     d7a:	a3 e0       	ldi	r26, 0x03	; 3
     d7c:	ae 8f       	std	Y+30, r26	; 0x1e
     d7e:	15 c0       	rjmp	.+42     	; 0xdaa <gc_execute_line+0x276>
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59:
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
     d80:	6a ec       	ldi	r22, 0xCA	; 202
     d82:	6a 0d       	add	r22, r10
     d84:	60 93 f1 05 	sts	0x05F1, r22	; 0x8005f1 <gc_block+0x7>
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
            mantissa = 0; // Set to zero to indicate valid non-integer G command.
            break;
          case 54: case 55: case 56: case 57: case 58: case 59:
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
     d88:	29 e0       	ldi	r18, 0x09	; 9
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
            break;
     d8a:	0b c0       	rjmp	.+22     	; 0xda2 <gc_execute_line+0x26e>
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
     d8c:	89 2b       	or	r24, r25
     d8e:	11 f0       	breq	.+4      	; 0xd94 <gc_execute_line+0x260>
     d90:	0c 94 d8 0f 	jmp	0x1fb0	; 0x1fb0 <gc_execute_line+0x147c>
            // NOTE: G59.x are not supported. (But their int_values would be 60, 61, and 62.)
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
            break;
          case 61:
            word_bit = MODAL_GROUP_G13;
     d94:	2a e0       	ldi	r18, 0x0A	; 10
     d96:	09 c0       	rjmp	.+18     	; 0xdaa <gc_execute_line+0x276>
          case 20: case 21:
            word_bit = MODAL_GROUP_G6;
            gc_block.modal.units = 21 - int_value;
            break;
          case 40:
            word_bit = MODAL_GROUP_G7;
     d98:	27 e0       	ldi	r18, 0x07	; 7
     d9a:	03 c0       	rjmp	.+6      	; 0xda2 <gc_execute_line+0x26e>
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
     d9c:	20 e0       	ldi	r18, 0x00	; 0
     d9e:	01 c0       	rjmp	.+2      	; 0xda2 <gc_execute_line+0x26e>
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
            axis_command = AXIS_COMMAND_MOTION_MODE;
            // No break. Continues to next line.
          case 80:
            word_bit = MODAL_GROUP_G1;
     da0:	21 e0       	ldi	r18, 0x01	; 1
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
     da2:	89 2b       	or	r24, r25
     da4:	11 f0       	breq	.+4      	; 0xdaa <gc_execute_line+0x276>
     da6:	0c 94 da 0f 	jmp	0x1fb4	; 0x1fb4 <gc_execute_line+0x1480>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
     daa:	c6 01       	movw	r24, r12
     dac:	02 c0       	rjmp	.+4      	; 0xdb2 <gc_execute_line+0x27e>
     dae:	88 0f       	add	r24, r24
     db0:	99 1f       	adc	r25, r25
     db2:	2a 95       	dec	r18
     db4:	e2 f7       	brpl	.-8      	; 0xdae <gc_execute_line+0x27a>
     db6:	97 01       	movw	r18, r14
     db8:	28 23       	and	r18, r24
     dba:	39 23       	and	r19, r25
     dbc:	23 2b       	or	r18, r19
     dbe:	11 f0       	breq	.+4      	; 0xdc4 <gc_execute_line+0x290>
     dc0:	0c 94 dc 0f 	jmp	0x1fb8	; 0x1fb8 <gc_execute_line+0x1484>
        command_words |= bit(word_bit);
     dc4:	e8 2a       	or	r14, r24
     dc6:	f9 2a       	or	r15, r25
        break;
     dc8:	24 c1       	rjmp	.+584    	; 0x1012 <gc_execute_line+0x4de>

      case 'M':

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
     dca:	89 2b       	or	r24, r25
     dcc:	11 f0       	breq	.+4      	; 0xdd2 <gc_execute_line+0x29e>
     dce:	0c 94 de 0f 	jmp	0x1fbc	; 0x1fbc <gc_execute_line+0x1488>
        switch(int_value) {
     dd2:	8a 2d       	mov	r24, r10
     dd4:	90 e0       	ldi	r25, 0x00	; 0
     dd6:	8f 31       	cpi	r24, 0x1F	; 31
     dd8:	91 05       	cpc	r25, r1
     dda:	10 f0       	brcs	.+4      	; 0xde0 <gc_execute_line+0x2ac>
     ddc:	0c 94 e0 0f 	jmp	0x1fc0	; 0x1fc0 <gc_execute_line+0x148c>
     de0:	fc 01       	movw	r30, r24
     de2:	ed 56       	subi	r30, 0x6D	; 109
     de4:	ff 4f       	sbci	r31, 0xFF	; 255
     de6:	0c 94 cf 32 	jmp	0x659e	; 0x659e <__tablejump2__>
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
            switch(int_value) {
     dea:	aa 20       	and	r10, r10
     dec:	21 f0       	breq	.+8      	; 0xdf6 <gc_execute_line+0x2c2>
     dee:	b1 e0       	ldi	r27, 0x01	; 1
     df0:	ab 16       	cp	r10, r27
     df2:	99 f1       	breq	.+102    	; 0xe5a <gc_execute_line+0x326>
     df4:	05 c0       	rjmp	.+10     	; 0xe00 <gc_execute_line+0x2cc>
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
     df6:	e3 e0       	ldi	r30, 0x03	; 3
     df8:	e0 93 f2 05 	sts	0x05F2, r30	; 0x8005f2 <gc_block+0x8>

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
     dfc:	8b e0       	ldi	r24, 0x0B	; 11
            switch(int_value) {
              case 0: gc_block.modal.program_flow = PROGRAM_FLOW_PAUSED; break; // Program pause
     dfe:	32 c0       	rjmp	.+100    	; 0xe64 <gc_execute_line+0x330>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
     e00:	a0 92 f2 05 	sts	0x05F2, r10	; 0x8005f2 <gc_block+0x8>

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
     e04:	8b e0       	ldi	r24, 0x0B	; 11
     e06:	2e c0       	rjmp	.+92     	; 0xe64 <gc_execute_line+0x330>
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
            switch(int_value) {
     e08:	f4 e0       	ldi	r31, 0x04	; 4
     e0a:	af 16       	cp	r10, r31
     e0c:	59 f0       	breq	.+22     	; 0xe24 <gc_execute_line+0x2f0>
     e0e:	25 e0       	ldi	r18, 0x05	; 5
     e10:	a2 16       	cp	r10, r18
     e12:	69 f0       	breq	.+26     	; 0xe2e <gc_execute_line+0x2fa>
     e14:	33 e0       	ldi	r19, 0x03	; 3
     e16:	a3 12       	cpse	r10, r19
     e18:	22 c0       	rjmp	.+68     	; 0xe5e <gc_execute_line+0x32a>
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
     e1a:	80 e1       	ldi	r24, 0x10	; 16
     e1c:	80 93 f4 05 	sts	0x05F4, r24	; 0x8005f4 <gc_block+0xa>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
     e20:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
     e22:	20 c0       	rjmp	.+64     	; 0xe64 <gc_execute_line+0x330>
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
     e24:	80 e2       	ldi	r24, 0x20	; 32
     e26:	80 93 f4 05 	sts	0x05F4, r24	; 0x8005f4 <gc_block+0xa>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
     e2a:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
     e2c:	1b c0       	rjmp	.+54     	; 0xe64 <gc_execute_line+0x330>
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
     e2e:	10 92 f4 05 	sts	0x05F4, r1	; 0x8005f4 <gc_block+0xa>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
     e32:	8c e0       	ldi	r24, 0x0C	; 12
            switch(int_value) {
              case 3: gc_block.modal.spindle = SPINDLE_ENABLE_CW; break;
              case 4: gc_block.modal.spindle = SPINDLE_ENABLE_CCW; break;
              case 5: gc_block.modal.spindle = SPINDLE_DISABLE; break;
     e34:	17 c0       	rjmp	.+46     	; 0xe64 <gc_execute_line+0x330>
            case 7: case 8: case 9:
          #else
            case 8: case 9:
          #endif
            word_bit = MODAL_GROUP_M8;
            switch(int_value) {
     e36:	48 e0       	ldi	r20, 0x08	; 8
     e38:	a4 16       	cp	r10, r20
     e3a:	21 f0       	breq	.+8      	; 0xe44 <gc_execute_line+0x310>
     e3c:	89 e0       	ldi	r24, 0x09	; 9
     e3e:	a8 16       	cp	r10, r24
     e40:	41 f0       	breq	.+16     	; 0xe52 <gc_execute_line+0x31e>
     e42:	0f c0       	rjmp	.+30     	; 0xe62 <gc_execute_line+0x32e>
              #ifdef ENABLE_M7
                case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
              #endif
              case 8: gc_block.modal.coolant |= COOLANT_FLOOD_ENABLE; break;
     e44:	80 91 f3 05 	lds	r24, 0x05F3	; 0x8005f3 <gc_block+0x9>
     e48:	80 64       	ori	r24, 0x40	; 64
     e4a:	80 93 f3 05 	sts	0x05F3, r24	; 0x8005f3 <gc_block+0x9>
          #ifdef ENABLE_M7
            case 7: case 8: case 9:
          #else
            case 8: case 9:
          #endif
            word_bit = MODAL_GROUP_M8;
     e4e:	8d e0       	ldi	r24, 0x0D	; 13
            switch(int_value) {
              #ifdef ENABLE_M7
                case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
              #endif
              case 8: gc_block.modal.coolant |= COOLANT_FLOOD_ENABLE; break;
     e50:	09 c0       	rjmp	.+18     	; 0xe64 <gc_execute_line+0x330>
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break; // M9 disables both M7 and M8.
     e52:	10 92 f3 05 	sts	0x05F3, r1	; 0x8005f3 <gc_block+0x9>
          #ifdef ENABLE_M7
            case 7: case 8: case 9:
          #else
            case 8: case 9:
          #endif
            word_bit = MODAL_GROUP_M8;
     e56:	8d e0       	ldi	r24, 0x0D	; 13
            switch(int_value) {
              #ifdef ENABLE_M7
                case 7: gc_block.modal.coolant |= COOLANT_MIST_ENABLE; break;
              #endif
              case 8: gc_block.modal.coolant |= COOLANT_FLOOD_ENABLE; break;
              case 9: gc_block.modal.coolant = COOLANT_DISABLE; break; // M9 disables both M7 and M8.
     e58:	05 c0       	rjmp	.+10     	; 0xe64 <gc_execute_line+0x330>

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
        switch(int_value) {
          case 0: case 1: case 2: case 30:
            word_bit = MODAL_GROUP_M4;
     e5a:	8b e0       	ldi	r24, 0x0B	; 11
     e5c:	03 c0       	rjmp	.+6      	; 0xe64 <gc_execute_line+0x330>
              case 1: break; // Optional stop not supported. Ignore.
              default: gc_block.modal.program_flow = int_value; // Program end and reset
            }
            break;
          case 3: case 4: case 5:
            word_bit = MODAL_GROUP_M7;
     e5e:	8c e0       	ldi	r24, 0x0C	; 12
     e60:	01 c0       	rjmp	.+2      	; 0xe64 <gc_execute_line+0x330>
          #ifdef ENABLE_M7
            case 7: case 8: case 9:
          #else
            case 8: case 9:
          #endif
            word_bit = MODAL_GROUP_M8;
     e62:	8d e0       	ldi	r24, 0x0D	; 13
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
        }

        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
     e64:	d6 01       	movw	r26, r12
     e66:	02 c0       	rjmp	.+4      	; 0xe6c <gc_execute_line+0x338>
     e68:	aa 0f       	add	r26, r26
     e6a:	bb 1f       	adc	r27, r27
     e6c:	8a 95       	dec	r24
     e6e:	e2 f7       	brpl	.-8      	; 0xe68 <gc_execute_line+0x334>
     e70:	97 01       	movw	r18, r14
     e72:	2a 23       	and	r18, r26
     e74:	3b 23       	and	r19, r27
     e76:	23 2b       	or	r18, r19
     e78:	11 f0       	breq	.+4      	; 0xe7e <gc_execute_line+0x34a>
     e7a:	0c 94 e2 0f 	jmp	0x1fc4	; 0x1fc4 <gc_execute_line+0x1490>
        command_words |= bit(word_bit);
     e7e:	ea 2a       	or	r14, r26
     e80:	fb 2a       	or	r15, r27
        break;
     e82:	c7 c0       	rjmp	.+398    	; 0x1012 <gc_execute_line+0x4de>
      default:

        /* Non-Command Words: This initial parsing phase only checks for repeats of the remaining
           legal g-code words and stores their value. Error-checking is performed later since some
           words (I,J,K,L,P,R) have multiple connotations and/or depend on the issued commands. */
        switch(letter){
     e84:	81 2f       	mov	r24, r17
     e86:	90 e0       	ldi	r25, 0x00	; 0
     e88:	fc 01       	movw	r30, r24
     e8a:	e6 54       	subi	r30, 0x46	; 70
     e8c:	f1 09       	sbc	r31, r1
     e8e:	e5 31       	cpi	r30, 0x15	; 21
     e90:	f1 05       	cpc	r31, r1
     e92:	10 f0       	brcs	.+4      	; 0xe98 <gc_execute_line+0x364>
     e94:	0c 94 e4 0f 	jmp	0x1fc8	; 0x1fc8 <gc_execute_line+0x1494>
     e98:	ee 54       	subi	r30, 0x4E	; 78
     e9a:	ff 4f       	sbci	r31, 0xFF	; 255
     e9c:	0c 94 cf 32 	jmp	0x659e	; 0x659e <__tablejump2__>
          // case 'A': // Not supported
          // case 'B': // Not supported
          // case 'C': // Not supported
          // case 'D': // Not supported
          case 'F': word_bit = WORD_F; gc_block.values.f = value; break;
     ea0:	40 92 f6 05 	sts	0x05F6, r4	; 0x8005f6 <gc_block+0xc>
     ea4:	50 92 f7 05 	sts	0x05F7, r5	; 0x8005f7 <gc_block+0xd>
     ea8:	60 92 f8 05 	sts	0x05F8, r6	; 0x8005f8 <gc_block+0xe>
     eac:	70 92 f9 05 	sts	0x05F9, r7	; 0x8005f9 <gc_block+0xf>
     eb0:	80 e0       	ldi	r24, 0x00	; 0
     eb2:	8d c0       	rjmp	.+282    	; 0xfce <gc_execute_line+0x49a>
          // case 'H': // Not supported
          case 'I': word_bit = WORD_I; gc_block.values.ijk[X_AXIS] = value; ijk_words |= (1<<X_AXIS); break;
     eb4:	40 92 fa 05 	sts	0x05FA, r4	; 0x8005fa <gc_block+0x10>
     eb8:	50 92 fb 05 	sts	0x05FB, r5	; 0x8005fb <gc_block+0x11>
     ebc:	60 92 fc 05 	sts	0x05FC, r6	; 0x8005fc <gc_block+0x12>
     ec0:	70 92 fd 05 	sts	0x05FD, r7	; 0x8005fd <gc_block+0x13>
     ec4:	bf 8d       	ldd	r27, Y+31	; 0x1f
     ec6:	b1 60       	ori	r27, 0x01	; 1
     ec8:	bf 8f       	std	Y+31, r27	; 0x1f
     eca:	81 e0       	ldi	r24, 0x01	; 1
     ecc:	80 c0       	rjmp	.+256    	; 0xfce <gc_execute_line+0x49a>
          case 'J': word_bit = WORD_J; gc_block.values.ijk[Y_AXIS] = value; ijk_words |= (1<<Y_AXIS); break;
     ece:	40 92 fe 05 	sts	0x05FE, r4	; 0x8005fe <gc_block+0x14>
     ed2:	50 92 ff 05 	sts	0x05FF, r5	; 0x8005ff <gc_block+0x15>
     ed6:	60 92 00 06 	sts	0x0600, r6	; 0x800600 <gc_block+0x16>
     eda:	70 92 01 06 	sts	0x0601, r7	; 0x800601 <gc_block+0x17>
     ede:	ef 8d       	ldd	r30, Y+31	; 0x1f
     ee0:	e2 60       	ori	r30, 0x02	; 2
     ee2:	ef 8f       	std	Y+31, r30	; 0x1f
     ee4:	82 e0       	ldi	r24, 0x02	; 2
     ee6:	73 c0       	rjmp	.+230    	; 0xfce <gc_execute_line+0x49a>
          case 'K': word_bit = WORD_K; gc_block.values.ijk[Z_AXIS] = value; ijk_words |= (1<<Z_AXIS); break;
     ee8:	40 92 02 06 	sts	0x0602, r4	; 0x800602 <gc_block+0x18>
     eec:	50 92 03 06 	sts	0x0603, r5	; 0x800603 <gc_block+0x19>
     ef0:	60 92 04 06 	sts	0x0604, r6	; 0x800604 <gc_block+0x1a>
     ef4:	70 92 05 06 	sts	0x0605, r7	; 0x800605 <gc_block+0x1b>
     ef8:	ff 8d       	ldd	r31, Y+31	; 0x1f
     efa:	f4 60       	ori	r31, 0x04	; 4
     efc:	ff 8f       	std	Y+31, r31	; 0x1f
     efe:	83 e0       	ldi	r24, 0x03	; 3
     f00:	66 c0       	rjmp	.+204    	; 0xfce <gc_execute_line+0x49a>
          case 'L': word_bit = WORD_L; gc_block.values.l = int_value; break;
     f02:	a0 92 06 06 	sts	0x0606, r10	; 0x800606 <gc_block+0x1c>
     f06:	84 e0       	ldi	r24, 0x04	; 4
     f08:	62 c0       	rjmp	.+196    	; 0xfce <gc_execute_line+0x49a>
          case 'N': word_bit = WORD_N; gc_block.values.n = trunc(value); break;
     f0a:	c3 01       	movw	r24, r6
     f0c:	b2 01       	movw	r22, r4
     f0e:	0e 94 e0 2f 	call	0x5fc0	; 0x5fc0 <__fixsfsi>
     f12:	60 93 07 06 	sts	0x0607, r22	; 0x800607 <gc_block+0x1d>
     f16:	70 93 08 06 	sts	0x0608, r23	; 0x800608 <gc_block+0x1e>
     f1a:	80 93 09 06 	sts	0x0609, r24	; 0x800609 <gc_block+0x1f>
     f1e:	90 93 0a 06 	sts	0x060A, r25	; 0x80060a <gc_block+0x20>
     f22:	85 e0       	ldi	r24, 0x05	; 5
     f24:	54 c0       	rjmp	.+168    	; 0xfce <gc_execute_line+0x49a>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
     f26:	40 92 0b 06 	sts	0x060B, r4	; 0x80060b <gc_block+0x21>
     f2a:	50 92 0c 06 	sts	0x060C, r5	; 0x80060c <gc_block+0x22>
     f2e:	60 92 0d 06 	sts	0x060D, r6	; 0x80060d <gc_block+0x23>
     f32:	70 92 0e 06 	sts	0x060E, r7	; 0x80060e <gc_block+0x24>
     f36:	86 e0       	ldi	r24, 0x06	; 6
     f38:	4a c0       	rjmp	.+148    	; 0xfce <gc_execute_line+0x49a>
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
     f3a:	40 92 0f 06 	sts	0x060F, r4	; 0x80060f <gc_block+0x25>
     f3e:	50 92 10 06 	sts	0x0610, r5	; 0x800610 <gc_block+0x26>
     f42:	60 92 11 06 	sts	0x0611, r6	; 0x800611 <gc_block+0x27>
     f46:	70 92 12 06 	sts	0x0612, r7	; 0x800612 <gc_block+0x28>
     f4a:	87 e0       	ldi	r24, 0x07	; 7
     f4c:	40 c0       	rjmp	.+128    	; 0xfce <gc_execute_line+0x49a>
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
     f4e:	40 92 13 06 	sts	0x0613, r4	; 0x800613 <gc_block+0x29>
     f52:	50 92 14 06 	sts	0x0614, r5	; 0x800614 <gc_block+0x2a>
     f56:	60 92 15 06 	sts	0x0615, r6	; 0x800615 <gc_block+0x2b>
     f5a:	70 92 16 06 	sts	0x0616, r7	; 0x800616 <gc_block+0x2c>
     f5e:	88 e0       	ldi	r24, 0x08	; 8
     f60:	36 c0       	rjmp	.+108    	; 0xfce <gc_execute_line+0x49a>
          case 'T': word_bit = WORD_T; 
					  if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
     f62:	20 e0       	ldi	r18, 0x00	; 0
     f64:	30 e0       	ldi	r19, 0x00	; 0
     f66:	4f e7       	ldi	r20, 0x7F	; 127
     f68:	53 e4       	ldi	r21, 0x43	; 67
     f6a:	c3 01       	movw	r24, r6
     f6c:	b2 01       	movw	r22, r4
     f6e:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
     f72:	18 16       	cp	r1, r24
     f74:	14 f4       	brge	.+4      	; 0xf7a <gc_execute_line+0x446>
     f76:	0c 94 e6 0f 	jmp	0x1fcc	; 0x1fcc <gc_execute_line+0x1498>
            gc_block.values.t = int_value;
     f7a:	a0 92 17 06 	sts	0x0617, r10	; 0x800617 <gc_block+0x2d>
          case 'P': word_bit = WORD_P; gc_block.values.p = value; break;
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; 
     f7e:	89 e0       	ldi	r24, 0x09	; 9
					  if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
            gc_block.values.t = int_value;
						break;
     f80:	26 c0       	rjmp	.+76     	; 0xfce <gc_execute_line+0x49a>
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
     f82:	40 92 18 06 	sts	0x0618, r4	; 0x800618 <gc_block+0x2e>
     f86:	50 92 19 06 	sts	0x0619, r5	; 0x800619 <gc_block+0x2f>
     f8a:	60 92 1a 06 	sts	0x061A, r6	; 0x80061a <gc_block+0x30>
     f8e:	70 92 1b 06 	sts	0x061B, r7	; 0x80061b <gc_block+0x31>
     f92:	2d 8d       	ldd	r18, Y+29	; 0x1d
     f94:	21 60       	ori	r18, 0x01	; 1
     f96:	2d 8f       	std	Y+29, r18	; 0x1d
     f98:	8a e0       	ldi	r24, 0x0A	; 10
     f9a:	19 c0       	rjmp	.+50     	; 0xfce <gc_execute_line+0x49a>
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
     f9c:	40 92 1c 06 	sts	0x061C, r4	; 0x80061c <gc_block+0x32>
     fa0:	50 92 1d 06 	sts	0x061D, r5	; 0x80061d <gc_block+0x33>
     fa4:	60 92 1e 06 	sts	0x061E, r6	; 0x80061e <gc_block+0x34>
     fa8:	70 92 1f 06 	sts	0x061F, r7	; 0x80061f <gc_block+0x35>
     fac:	3d 8d       	ldd	r19, Y+29	; 0x1d
     fae:	32 60       	ori	r19, 0x02	; 2
     fb0:	3d 8f       	std	Y+29, r19	; 0x1d
     fb2:	8b e0       	ldi	r24, 0x0B	; 11
     fb4:	0c c0       	rjmp	.+24     	; 0xfce <gc_execute_line+0x49a>
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
     fb6:	40 92 20 06 	sts	0x0620, r4	; 0x800620 <gc_block+0x36>
     fba:	50 92 21 06 	sts	0x0621, r5	; 0x800621 <gc_block+0x37>
     fbe:	60 92 22 06 	sts	0x0622, r6	; 0x800622 <gc_block+0x38>
     fc2:	70 92 23 06 	sts	0x0623, r7	; 0x800623 <gc_block+0x39>
     fc6:	4d 8d       	ldd	r20, Y+29	; 0x1d
     fc8:	44 60       	ori	r20, 0x04	; 4
     fca:	4d 8f       	std	Y+29, r20	; 0x1d
     fcc:	8c e0       	ldi	r24, 0x0C	; 12
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
        }

        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
     fce:	56 01       	movw	r10, r12
     fd0:	08 2e       	mov	r0, r24
     fd2:	02 c0       	rjmp	.+4      	; 0xfd8 <gc_execute_line+0x4a4>
     fd4:	aa 0c       	add	r10, r10
     fd6:	bb 1c       	adc	r11, r11
     fd8:	0a 94       	dec	r0
     fda:	e2 f7       	brpl	.-8      	; 0xfd4 <gc_execute_line+0x4a0>
     fdc:	91 01       	movw	r18, r2
     fde:	2a 21       	and	r18, r10
     fe0:	3b 21       	and	r19, r11
     fe2:	23 2b       	or	r18, r19
     fe4:	11 f0       	breq	.+4      	; 0xfea <gc_execute_line+0x4b6>
     fe6:	0c 94 e8 0f 	jmp	0x1fd0	; 0x1fd0 <gc_execute_line+0x149c>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
     fea:	d4 01       	movw	r26, r8
     fec:	02 c0       	rjmp	.+4      	; 0xff2 <gc_execute_line+0x4be>
     fee:	b5 95       	asr	r27
     ff0:	a7 95       	ror	r26
     ff2:	8a 95       	dec	r24
     ff4:	e2 f7       	brpl	.-8      	; 0xfee <gc_execute_line+0x4ba>
     ff6:	a0 ff       	sbrs	r26, 0
     ff8:	0a c0       	rjmp	.+20     	; 0x100e <gc_execute_line+0x4da>
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
     ffa:	20 e0       	ldi	r18, 0x00	; 0
     ffc:	30 e0       	ldi	r19, 0x00	; 0
     ffe:	a9 01       	movw	r20, r18
    1000:	c3 01       	movw	r24, r6
    1002:	b2 01       	movw	r22, r4
    1004:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    1008:	88 23       	and	r24, r24
    100a:	0c f4       	brge	.+2      	; 0x100e <gc_execute_line+0x4da>
    100c:	e3 c7       	rjmp	.+4038   	; 0x1fd4 <gc_execute_line+0x14a0>
        }
        value_words |= bit(word_bit); // Flag to indicate parameter assigned.
    100e:	2a 28       	or	r2, r10
    1010:	3b 28       	or	r3, r11
  uint8_t int_value = 0;
  uint16_t mantissa = 0;
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
  else { char_counter = 0; }

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.
    1012:	89 81       	ldd	r24, Y+1	; 0x01
    1014:	eb 8d       	ldd	r30, Y+27	; 0x1b
    1016:	fc 8d       	ldd	r31, Y+28	; 0x1c
    1018:	e8 0f       	add	r30, r24
    101a:	f1 1d       	adc	r31, r1
    101c:	10 81       	ld	r17, Z
    101e:	11 11       	cpse	r17, r1
    1020:	d6 cd       	rjmp	.-1108   	; 0xbce <gc_execute_line+0x9a>

  // [0. Non-specific/common error-checks and miscellaneous setup]:

  // Determine implicit axis command conditions. Axis words have been passed, but no explicit axis
  // command has been sent. If so, set axis command to current motion mode.
  if (axis_words) {
    1022:	bd 8d       	ldd	r27, Y+29	; 0x1d
    1024:	bb 23       	and	r27, r27
    1026:	29 f0       	breq	.+10     	; 0x1032 <gc_execute_line+0x4fe>
    if (!axis_command) { axis_command = AXIS_COMMAND_MOTION_MODE; } // Assign implicit motion-mode
    1028:	ee 8d       	ldd	r30, Y+30	; 0x1e
    102a:	e1 11       	cpse	r30, r1
    102c:	02 c0       	rjmp	.+4      	; 0x1032 <gc_execute_line+0x4fe>
    102e:	f2 e0       	ldi	r31, 0x02	; 2
    1030:	fe 8f       	std	Y+30, r31	; 0x1e
  }

  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    1032:	25 fe       	sbrs	r2, 5
    1034:	0e c0       	rjmp	.+28     	; 0x1052 <gc_execute_line+0x51e>
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    1036:	80 91 07 06 	lds	r24, 0x0607	; 0x800607 <gc_block+0x1d>
    103a:	90 91 08 06 	lds	r25, 0x0608	; 0x800608 <gc_block+0x1e>
    103e:	a0 91 09 06 	lds	r26, 0x0609	; 0x800609 <gc_block+0x1f>
    1042:	b0 91 0a 06 	lds	r27, 0x060A	; 0x80060a <gc_block+0x20>
    1046:	81 38       	cpi	r24, 0x81	; 129
    1048:	96 49       	sbci	r25, 0x96	; 150
    104a:	a8 49       	sbci	r26, 0x98	; 152
    104c:	b1 05       	cpc	r27, r1
    104e:	0c f0       	brlt	.+2      	; 0x1052 <gc_execute_line+0x51e>
    1050:	c3 c7       	rjmp	.+3974   	; 0x1fd8 <gc_execute_line+0x14a4>
  // [1. Comments ]: MSG's NOT SUPPORTED. Comment handling performed by protocol.

  // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
  //   is not defined after switching to G94 from G93.
  // NOTE: For jogging, ignore prior feed rate mode. Enforce G94 and check for required F word.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    1052:	38 a1       	ldd	r19, Y+32	; 0x20
    1054:	33 23       	and	r19, r19
    1056:	e1 f0       	breq	.+56     	; 0x1090 <gc_execute_line+0x55c>
    if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); }
    1058:	20 fe       	sbrs	r2, 0
    105a:	c0 c7       	rjmp	.+3968   	; 0x1fdc <gc_execute_line+0x14a8>
    if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
    105c:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <gc_block+0x3>
    1060:	81 30       	cpi	r24, 0x01	; 1
    1062:	09 f0       	breq	.+2      	; 0x1066 <gc_execute_line+0x532>
    1064:	54 c0       	rjmp	.+168    	; 0x110e <gc_execute_line+0x5da>
    1066:	0a ee       	ldi	r16, 0xEA	; 234
    1068:	15 e0       	ldi	r17, 0x05	; 5
    106a:	23 e3       	ldi	r18, 0x33	; 51
    106c:	33 e3       	ldi	r19, 0x33	; 51
    106e:	4b ec       	ldi	r20, 0xCB	; 203
    1070:	51 e4       	ldi	r21, 0x41	; 65
    1072:	d8 01       	movw	r26, r16
    1074:	1c 96       	adiw	r26, 0x0c	; 12
    1076:	6d 91       	ld	r22, X+
    1078:	7d 91       	ld	r23, X+
    107a:	8d 91       	ld	r24, X+
    107c:	9c 91       	ld	r25, X
    107e:	1f 97       	sbiw	r26, 0x0f	; 15
    1080:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    1084:	f8 01       	movw	r30, r16
    1086:	64 87       	std	Z+12, r22	; 0x0c
    1088:	75 87       	std	Z+13, r23	; 0x0d
    108a:	86 87       	std	Z+14, r24	; 0x0e
    108c:	97 87       	std	Z+15, r25	; 0x0f
    108e:	3f c0       	rjmp	.+126    	; 0x110e <gc_execute_line+0x5da>
  } else {
    if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
    1090:	80 91 ec 05 	lds	r24, 0x05EC	; 0x8005ec <gc_block+0x2>
    1094:	81 30       	cpi	r24, 0x01	; 1
    1096:	61 f4       	brne	.+24     	; 0x10b0 <gc_execute_line+0x57c>
      // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
      if (axis_command == AXIS_COMMAND_MOTION_MODE) {
    1098:	fe 8d       	ldd	r31, Y+30	; 0x1e
    109a:	f2 30       	cpi	r31, 0x02	; 2
    109c:	c1 f5       	brne	.+112    	; 0x110e <gc_execute_line+0x5da>
        if ((gc_block.modal.motion != MOTION_MODE_NONE) && (gc_block.modal.motion != MOTION_MODE_SEEK)) {
    109e:	80 91 eb 05 	lds	r24, 0x05EB	; 0x8005eb <gc_block+0x1>
    10a2:	80 35       	cpi	r24, 0x50	; 80
    10a4:	a1 f1       	breq	.+104    	; 0x110e <gc_execute_line+0x5da>
    10a6:	88 23       	and	r24, r24
    10a8:	91 f1       	breq	.+100    	; 0x110e <gc_execute_line+0x5da>
          if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    10aa:	20 fe       	sbrs	r2, 0
    10ac:	99 c7       	rjmp	.+3890   	; 0x1fe0 <gc_execute_line+0x14ac>
    10ae:	2f c0       	rjmp	.+94     	; 0x110e <gc_execute_line+0x5da>
      // value in the block. If no F word is passed with a motion command that requires a feed rate, this will error
      // out in the motion modes error-checking. However, if no F word is passed with NO motion command that requires
      // a feed rate, we simply move on and the state feed rate value gets updated to zero and remains undefined.
    } else { // = G94
      // - In units per mm mode: If F word passed, ensure value is in mm/min, otherwise push last state value.
      if (gc_state.modal.feed_rate == FEED_RATE_MODE_UNITS_PER_MIN) { // Last state is also G94
    10b0:	80 91 ab 05 	lds	r24, 0x05AB	; 0x8005ab <gc_state+0x1>
    10b4:	81 11       	cpse	r24, r1
    10b6:	2b c0       	rjmp	.+86     	; 0x110e <gc_execute_line+0x5da>
        if (bit_istrue(value_words,bit(WORD_F))) {
    10b8:	20 fe       	sbrs	r2, 0
    10ba:	19 c0       	rjmp	.+50     	; 0x10ee <gc_execute_line+0x5ba>
          if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.f *= MM_PER_INCH; }
    10bc:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <gc_block+0x3>
    10c0:	81 30       	cpi	r24, 0x01	; 1
    10c2:	29 f5       	brne	.+74     	; 0x110e <gc_execute_line+0x5da>
    10c4:	0a ee       	ldi	r16, 0xEA	; 234
    10c6:	15 e0       	ldi	r17, 0x05	; 5
    10c8:	23 e3       	ldi	r18, 0x33	; 51
    10ca:	33 e3       	ldi	r19, 0x33	; 51
    10cc:	4b ec       	ldi	r20, 0xCB	; 203
    10ce:	51 e4       	ldi	r21, 0x41	; 65
    10d0:	d8 01       	movw	r26, r16
    10d2:	1c 96       	adiw	r26, 0x0c	; 12
    10d4:	6d 91       	ld	r22, X+
    10d6:	7d 91       	ld	r23, X+
    10d8:	8d 91       	ld	r24, X+
    10da:	9c 91       	ld	r25, X
    10dc:	1f 97       	sbiw	r26, 0x0f	; 15
    10de:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    10e2:	f8 01       	movw	r30, r16
    10e4:	64 87       	std	Z+12, r22	; 0x0c
    10e6:	75 87       	std	Z+13, r23	; 0x0d
    10e8:	86 87       	std	Z+14, r24	; 0x0e
    10ea:	97 87       	std	Z+15, r25	; 0x0f
    10ec:	10 c0       	rjmp	.+32     	; 0x110e <gc_execute_line+0x5da>
        } else {
          gc_block.values.f = gc_state.feed_rate; // Push last state feed rate
    10ee:	80 91 b9 05 	lds	r24, 0x05B9	; 0x8005b9 <gc_state+0xf>
    10f2:	90 91 ba 05 	lds	r25, 0x05BA	; 0x8005ba <gc_state+0x10>
    10f6:	a0 91 bb 05 	lds	r26, 0x05BB	; 0x8005bb <gc_state+0x11>
    10fa:	b0 91 bc 05 	lds	r27, 0x05BC	; 0x8005bc <gc_state+0x12>
    10fe:	80 93 f6 05 	sts	0x05F6, r24	; 0x8005f6 <gc_block+0xc>
    1102:	90 93 f7 05 	sts	0x05F7, r25	; 0x8005f7 <gc_block+0xd>
    1106:	a0 93 f8 05 	sts	0x05F8, r26	; 0x8005f8 <gc_block+0xe>
    110a:	b0 93 f9 05 	sts	0x05F9, r27	; 0x8005f9 <gc_block+0xf>
    }
  }
  // bit_false(value_words,bit(WORD_F)); // NOTE: Single-meaning value word. Set at end of error-checking.

  // [4. Set spindle speed ]: S is negative (done.)
  if (bit_isfalse(value_words,bit(WORD_S))) { gc_block.values.s = gc_state.spindle_speed; }
    110e:	30 fc       	sbrc	r3, 0
    1110:	10 c0       	rjmp	.+32     	; 0x1132 <gc_execute_line+0x5fe>
    1112:	80 91 b5 05 	lds	r24, 0x05B5	; 0x8005b5 <gc_state+0xb>
    1116:	90 91 b6 05 	lds	r25, 0x05B6	; 0x8005b6 <gc_state+0xc>
    111a:	a0 91 b7 05 	lds	r26, 0x05B7	; 0x8005b7 <gc_state+0xd>
    111e:	b0 91 b8 05 	lds	r27, 0x05B8	; 0x8005b8 <gc_state+0xe>
    1122:	80 93 13 06 	sts	0x0613, r24	; 0x800613 <gc_block+0x29>
    1126:	90 93 14 06 	sts	0x0614, r25	; 0x800614 <gc_block+0x2a>
    112a:	a0 93 15 06 	sts	0x0615, r26	; 0x800615 <gc_block+0x2b>
    112e:	b0 93 16 06 	sts	0x0616, r27	; 0x800616 <gc_block+0x2c>
      }
    }
  #endif

  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    1132:	80 91 ea 05 	lds	r24, 0x05EA	; 0x8005ea <gc_block>
    1136:	84 30       	cpi	r24, 0x04	; 4
    1138:	21 f4       	brne	.+8      	; 0x1142 <gc_execute_line+0x60e>
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    113a:	26 fe       	sbrs	r2, 6
    113c:	53 c7       	rjmp	.+3750   	; 0x1fe4 <gc_execute_line+0x14b0>
    bit_false(value_words,bit(WORD_P));
    113e:	e8 94       	clt
    1140:	26 f8       	bld	r2, 6
  }

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    1142:	80 91 ef 05 	lds	r24, 0x05EF	; 0x8005ef <gc_block+0x5>
    1146:	88 23       	and	r24, r24
    1148:	49 f0       	breq	.+18     	; 0x115c <gc_execute_line+0x628>
    114a:	81 30       	cpi	r24, 0x01	; 1
    114c:	09 f4       	brne	.+2      	; 0x1150 <gc_execute_line+0x61c>
    114e:	9c c7       	rjmp	.+3896   	; 0x2088 <gc_execute_line+0x1554>
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
      axis_linear = X_AXIS;
    1150:	1b a6       	std	Y+43, r1	; 0x2b
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
      axis_1 = Z_AXIS;
    1152:	f2 e0       	ldi	r31, 0x02	; 2
    1154:	fa a3       	std	Y+34, r31	; 0x22
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
      break;
    default: // case PLANE_SELECT_YZ:
      axis_0 = Y_AXIS;
    1156:	21 e0       	ldi	r18, 0x01	; 1
    1158:	29 a3       	std	Y+33, r18	; 0x21
    115a:	9b c7       	rjmp	.+3894   	; 0x2092 <gc_execute_line+0x155e>
  }

  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    115c:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <gc_block+0x3>
    1160:	81 30       	cpi	r24, 0x01	; 1
    1162:	a1 f5       	brne	.+104    	; 0x11cc <gc_execute_line+0x698>
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
    1164:	32 e0       	ldi	r19, 0x02	; 2
    1166:	3b a7       	std	Y+43, r19	; 0x2b

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
    1168:	41 e0       	ldi	r20, 0x01	; 1
    116a:	4a a3       	std	Y+34, r20	; 0x22
  }

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
    116c:	19 a2       	std	Y+33, r1	; 0x21
    116e:	0f 2e       	mov	r0, r31
    1170:	fa ee       	ldi	r31, 0xEA	; 234
    1172:	af 2e       	mov	r10, r31
    1174:	f5 e0       	ldi	r31, 0x05	; 5
    1176:	bf 2e       	mov	r11, r31
    1178:	f0 2d       	mov	r31, r0
    117a:	00 e0       	ldi	r16, 0x00	; 0
    117c:	10 e0       	ldi	r17, 0x00	; 0
  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
      if (bit_istrue(axis_words,bit(idx)) ) {
    117e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1180:	c8 2e       	mov	r12, r24
    1182:	d1 2c       	mov	r13, r1
    1184:	c6 01       	movw	r24, r12
    1186:	00 2e       	mov	r0, r16
    1188:	02 c0       	rjmp	.+4      	; 0x118e <gc_execute_line+0x65a>
    118a:	95 95       	asr	r25
    118c:	87 95       	ror	r24
    118e:	0a 94       	dec	r0
    1190:	e2 f7       	brpl	.-8      	; 0x118a <gc_execute_line+0x656>
    1192:	80 ff       	sbrs	r24, 0
    1194:	12 c0       	rjmp	.+36     	; 0x11ba <gc_execute_line+0x686>
        gc_block.values.xyz[idx] *= MM_PER_INCH;
    1196:	23 e3       	ldi	r18, 0x33	; 51
    1198:	33 e3       	ldi	r19, 0x33	; 51
    119a:	4b ec       	ldi	r20, 0xCB	; 203
    119c:	51 e4       	ldi	r21, 0x41	; 65
    119e:	d5 01       	movw	r26, r10
    11a0:	9e 96       	adiw	r26, 0x2e	; 46
    11a2:	6d 91       	ld	r22, X+
    11a4:	7d 91       	ld	r23, X+
    11a6:	8d 91       	ld	r24, X+
    11a8:	9c 91       	ld	r25, X
    11aa:	d1 97       	sbiw	r26, 0x31	; 49
    11ac:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    11b0:	f5 01       	movw	r30, r10
    11b2:	66 a7       	std	Z+46, r22	; 0x2e
    11b4:	77 a7       	std	Z+47, r23	; 0x2f
    11b6:	80 ab       	std	Z+48, r24	; 0x30
    11b8:	91 ab       	std	Z+49, r25	; 0x31
    11ba:	0f 5f       	subi	r16, 0xFF	; 255
    11bc:	1f 4f       	sbci	r17, 0xFF	; 255
    11be:	f4 e0       	ldi	r31, 0x04	; 4
    11c0:	af 0e       	add	r10, r31
    11c2:	b1 1c       	adc	r11, r1

  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    11c4:	03 30       	cpi	r16, 0x03	; 3
    11c6:	11 05       	cpc	r17, r1
    11c8:	e9 f6       	brne	.-70     	; 0x1184 <gc_execute_line+0x650>
    11ca:	05 c0       	rjmp	.+10     	; 0x11d6 <gc_execute_line+0x6a2>
  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
    11cc:	22 e0       	ldi	r18, 0x02	; 2
    11ce:	2b a7       	std	Y+43, r18	; 0x2b

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
    11d0:	31 e0       	ldi	r19, 0x01	; 1
    11d2:	3a a3       	std	Y+34, r19	; 0x22
  }

  // [11. Set active plane ]: N/A
  switch (gc_block.modal.plane_select) {
    case PLANE_SELECT_XY:
      axis_0 = X_AXIS;
    11d4:	19 a2       	std	Y+33, r1	; 0x21
  // [14. Cutter length compensation ]: G43 NOT SUPPORTED, but G43.1 and G49 are.
  // [G43.1 Errors]: Motion command in same line.
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    11d6:	4e 8d       	ldd	r20, Y+30	; 0x1e
    11d8:	43 30       	cpi	r20, 0x03	; 3
    11da:	41 f4       	brne	.+16     	; 0x11ec <gc_execute_line+0x6b8>
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
    11dc:	80 91 f0 05 	lds	r24, 0x05F0	; 0x8005f0 <gc_block+0x6>
    11e0:	81 30       	cpi	r24, 0x01	; 1
    11e2:	21 f4       	brne	.+8      	; 0x11ec <gc_execute_line+0x6b8>
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    11e4:	8d 8d       	ldd	r24, Y+29	; 0x1d
    11e6:	84 30       	cpi	r24, 0x04	; 4
    11e8:	09 f0       	breq	.+2      	; 0x11ec <gc_execute_line+0x6b8>
    11ea:	fe c6       	rjmp	.+3580   	; 0x1fe8 <gc_execute_line+0x14b4>
  // TODO: An EEPROM read of the coordinate data may require a buffer sync when the cycle
  // is active. The read pauses the processor temporarily and may cause a rare crash. For
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  float block_coord_system[N_AXIS];
  memcpy(block_coord_system,gc_state.coord_system,sizeof(gc_state.coord_system));
    11ec:	8c e0       	ldi	r24, 0x0C	; 12
    11ee:	ee ec       	ldi	r30, 0xCE	; 206
    11f0:	f5 e0       	ldi	r31, 0x05	; 5
    11f2:	de 01       	movw	r26, r28
    11f4:	16 96       	adiw	r26, 0x06	; 6
    11f6:	01 90       	ld	r0, Z+
    11f8:	0d 92       	st	X+, r0
    11fa:	8a 95       	dec	r24
    11fc:	e1 f7       	brne	.-8      	; 0x11f6 <gc_execute_line+0x6c2>
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    11fe:	f1 fe       	sbrs	r15, 1
    1200:	11 c0       	rjmp	.+34     	; 0x1224 <gc_execute_line+0x6f0>
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    1202:	80 91 f1 05 	lds	r24, 0x05F1	; 0x8005f1 <gc_block+0x7>
    1206:	87 30       	cpi	r24, 0x07	; 7
    1208:	08 f0       	brcs	.+2      	; 0x120c <gc_execute_line+0x6d8>
    120a:	f0 c6       	rjmp	.+3552   	; 0x1fec <gc_execute_line+0x14b8>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    120c:	90 91 b0 05 	lds	r25, 0x05B0	; 0x8005b0 <gc_state+0x6>
    1210:	89 17       	cp	r24, r25
    1212:	41 f0       	breq	.+16     	; 0x1224 <gc_execute_line+0x6f0>
      if (!(settings_read_coord_data(gc_block.modal.coord_select,block_coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    1214:	be 01       	movw	r22, r28
    1216:	6a 5f       	subi	r22, 0xFA	; 250
    1218:	7f 4f       	sbci	r23, 0xFF	; 255
    121a:	0e 94 4e 23 	call	0x469c	; 0x469c <settings_read_coord_data>
    121e:	88 23       	and	r24, r24
    1220:	09 f4       	brne	.+2      	; 0x1224 <gc_execute_line+0x6f0>
    1222:	e6 c6       	rjmp	.+3532   	; 0x1ff0 <gc_execute_line+0x14bc>
  // [19. Remaining non-modal actions ]: Check go to predefined position, set G10, or set axis offsets.
  // NOTE: We need to separate the non-modal commands that are axis word-using (G10/G28/G30/G92), as these
  // commands all treat axis words differently. G10 as absolute offsets or computes current position as
  // the axis value, G92 similarly to G10 L20, and G28/30 as an intermediate target position that observes
  // all the current coordinate system and G92 offsets.
  switch (gc_block.non_modal_command) {
    1224:	b0 90 ea 05 	lds	r11, 0x05EA	; 0x8005ea <gc_block>
    1228:	9a e0       	ldi	r25, 0x0A	; 10
    122a:	b9 16       	cp	r11, r25
    122c:	29 f0       	breq	.+10     	; 0x1238 <gc_execute_line+0x704>
    122e:	ac e5       	ldi	r26, 0x5C	; 92
    1230:	ba 16       	cp	r11, r26
    1232:	09 f4       	brne	.+2      	; 0x1236 <gc_execute_line+0x702>
    1234:	9a c0       	rjmp	.+308    	; 0x136a <gc_execute_line+0x836>
    1236:	0e c1       	rjmp	.+540    	; 0x1454 <gc_execute_line+0x920>
    case NON_MODAL_SET_COORDINATE_DATA:
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    1238:	bd 8d       	ldd	r27, Y+29	; 0x1d
    123a:	bb 23       	and	r27, r27
    123c:	09 f4       	brne	.+2      	; 0x1240 <gc_execute_line+0x70c>
    123e:	da c6       	rjmp	.+3508   	; 0x1ff4 <gc_execute_line+0x14c0>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    1240:	c1 01       	movw	r24, r2
    1242:	80 75       	andi	r24, 0x50	; 80
    1244:	99 27       	eor	r25, r25
    1246:	89 2b       	or	r24, r25
    1248:	09 f4       	brne	.+2      	; 0x124c <gc_execute_line+0x718>
    124a:	d6 c6       	rjmp	.+3500   	; 0x1ff8 <gc_execute_line+0x14c4>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
    124c:	60 91 0b 06 	lds	r22, 0x060B	; 0x80060b <gc_block+0x21>
    1250:	70 91 0c 06 	lds	r23, 0x060C	; 0x80060c <gc_block+0x22>
    1254:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <gc_block+0x23>
    1258:	90 91 0e 06 	lds	r25, 0x060E	; 0x80060e <gc_block+0x24>
    125c:	0e 94 a9 32 	call	0x6552	; 0x6552 <trunc>
    1260:	0e 94 e7 2f 	call	0x5fce	; 0x5fce <__fixunssfsi>
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    1264:	67 30       	cpi	r22, 0x07	; 7
    1266:	08 f0       	brcs	.+2      	; 0x126a <gc_execute_line+0x736>
    1268:	c9 c6       	rjmp	.+3474   	; 0x1ffc <gc_execute_line+0x14c8>
      if (gc_block.values.l != 20) {
    126a:	80 91 06 06 	lds	r24, 0x0606	; 0x800606 <gc_block+0x1c>
    126e:	84 31       	cpi	r24, 0x14	; 20
    1270:	29 f0       	breq	.+10     	; 0x127c <gc_execute_line+0x748>
        if (gc_block.values.l == 2) {
    1272:	82 30       	cpi	r24, 0x02	; 2
    1274:	09 f0       	breq	.+2      	; 0x1278 <gc_execute_line+0x744>
    1276:	c4 c6       	rjmp	.+3464   	; 0x2000 <gc_execute_line+0x14cc>
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    1278:	27 fc       	sbrc	r2, 7
    127a:	c4 c6       	rjmp	.+3464   	; 0x2004 <gc_execute_line+0x14d0>
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
      }
      bit_false(value_words,(bit(WORD_L)|bit(WORD_P)));
    127c:	ef ea       	ldi	r30, 0xAF	; 175
    127e:	2e 22       	and	r2, r30

      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
    1280:	66 23       	and	r22, r22
    1282:	19 f0       	breq	.+6      	; 0x128a <gc_execute_line+0x756>
    1284:	61 50       	subi	r22, 0x01	; 1
    1286:	6b 8f       	std	Y+27, r22	; 0x1b
    1288:	03 c0       	rjmp	.+6      	; 0x1290 <gc_execute_line+0x75c>
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
    128a:	f0 91 f1 05 	lds	r31, 0x05F1	; 0x8005f1 <gc_block+0x7>
    128e:	fb 8f       	std	Y+27, r31	; 0x1b
      
      // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    1290:	6a ef       	ldi	r22, 0xFA	; 250
    1292:	75 e0       	ldi	r23, 0x05	; 5
    1294:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1296:	0e 94 4e 23 	call	0x469c	; 0x469c <settings_read_coord_data>
    129a:	88 23       	and	r24, r24
    129c:	09 f4       	brne	.+2      	; 0x12a0 <gc_execute_line+0x76c>
    129e:	b4 c6       	rjmp	.+3432   	; 0x2008 <gc_execute_line+0x14d4>

      // Pre-calculate the coordinate data changes.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
          if (gc_block.values.l == 20) {
    12a0:	20 91 06 06 	lds	r18, 0x0606	; 0x800606 <gc_block+0x1c>
    12a4:	2b a3       	std	Y+35, r18	; 0x23
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            // WPos = MPos - WCS - G92 - TLO  ->  WCS = MPos - G92 - TLO - WPos
            gc_block.values.ijk[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.ijk[idx] -= gc_state.tool_length_offset; }
    12a6:	40 90 e6 05 	lds	r4, 0x05E6	; 0x8005e6 <gc_state+0x3c>
    12aa:	50 90 e7 05 	lds	r5, 0x05E7	; 0x8005e7 <gc_state+0x3d>
    12ae:	60 90 e8 05 	lds	r6, 0x05E8	; 0x8005e8 <gc_state+0x3e>
    12b2:	70 90 e9 05 	lds	r7, 0x05E9	; 0x8005e9 <gc_state+0x3f>
    12b6:	0a ee       	ldi	r16, 0xEA	; 234
    12b8:	15 e0       	ldi	r17, 0x05	; 5
    12ba:	0f 2e       	mov	r0, r31
    12bc:	fa ea       	ldi	r31, 0xAA	; 170
    12be:	cf 2e       	mov	r12, r31
    12c0:	f5 e0       	ldi	r31, 0x05	; 5
    12c2:	df 2e       	mov	r13, r31
    12c4:	f0 2d       	mov	r31, r0
    12c6:	a1 2c       	mov	r10, r1
    12c8:	b1 2c       	mov	r11, r1
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]

      // Pre-calculate the coordinate data changes.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        // Update axes defined only in block. Always in machine coordinates. Can change non-active system.
        if (bit_istrue(axis_words,bit(idx)) ) {
    12ca:	3d 8d       	ldd	r19, Y+29	; 0x1d
    12cc:	83 2e       	mov	r8, r19
    12ce:	91 2c       	mov	r9, r1
    12d0:	c4 01       	movw	r24, r8
    12d2:	0a 2c       	mov	r0, r10
    12d4:	02 c0       	rjmp	.+4      	; 0x12da <gc_execute_line+0x7a6>
    12d6:	95 95       	asr	r25
    12d8:	87 95       	ror	r24
    12da:	0a 94       	dec	r0
    12dc:	e2 f7       	brpl	.-8      	; 0x12d6 <gc_execute_line+0x7a2>
    12de:	80 ff       	sbrs	r24, 0
    12e0:	36 c0       	rjmp	.+108    	; 0x134e <gc_execute_line+0x81a>
          if (gc_block.values.l == 20) {
    12e2:	4b a1       	ldd	r20, Y+35	; 0x23
    12e4:	44 31       	cpi	r20, 0x14	; 20
    12e6:	51 f5       	brne	.+84     	; 0x133c <gc_execute_line+0x808>
            // L20: Update coordinate system axis at current position (with modifiers) with programmed value
            // WPos = MPos - WCS - G92 - TLO  ->  WCS = MPos - G92 - TLO - WPos
            gc_block.values.ijk[idx] = gc_state.position[idx]-gc_state.coord_offset[idx]-gc_block.values.xyz[idx];
    12e8:	d6 01       	movw	r26, r12
    12ea:	d0 96       	adiw	r26, 0x30	; 48
    12ec:	2d 91       	ld	r18, X+
    12ee:	3d 91       	ld	r19, X+
    12f0:	4d 91       	ld	r20, X+
    12f2:	5c 91       	ld	r21, X
    12f4:	d3 97       	sbiw	r26, 0x33	; 51
    12f6:	58 96       	adiw	r26, 0x18	; 24
    12f8:	6d 91       	ld	r22, X+
    12fa:	7d 91       	ld	r23, X+
    12fc:	8d 91       	ld	r24, X+
    12fe:	9c 91       	ld	r25, X
    1300:	5b 97       	sbiw	r26, 0x1b	; 27
    1302:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    1306:	f8 01       	movw	r30, r16
    1308:	26 a5       	ldd	r18, Z+46	; 0x2e
    130a:	37 a5       	ldd	r19, Z+47	; 0x2f
    130c:	40 a9       	ldd	r20, Z+48	; 0x30
    130e:	51 a9       	ldd	r21, Z+49	; 0x31
    1310:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    1314:	d8 01       	movw	r26, r16
    1316:	50 96       	adiw	r26, 0x10	; 16
    1318:	6d 93       	st	X+, r22
    131a:	7d 93       	st	X+, r23
    131c:	8d 93       	st	X+, r24
    131e:	9c 93       	st	X, r25
    1320:	53 97       	sbiw	r26, 0x13	; 19
            if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.ijk[idx] -= gc_state.tool_length_offset; }
    1322:	b2 e0       	ldi	r27, 0x02	; 2
    1324:	ab 12       	cpse	r10, r27
    1326:	13 c0       	rjmp	.+38     	; 0x134e <gc_execute_line+0x81a>
    1328:	a3 01       	movw	r20, r6
    132a:	92 01       	movw	r18, r4
    132c:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    1330:	f8 01       	movw	r30, r16
    1332:	60 8b       	std	Z+16, r22	; 0x10
    1334:	71 8b       	std	Z+17, r23	; 0x11
    1336:	82 8b       	std	Z+18, r24	; 0x12
    1338:	93 8b       	std	Z+19, r25	; 0x13
    133a:	09 c0       	rjmp	.+18     	; 0x134e <gc_execute_line+0x81a>
          } else {
            // L2: Update coordinate system axis to programmed value.
            gc_block.values.ijk[idx] = gc_block.values.xyz[idx];
    133c:	f8 01       	movw	r30, r16
    133e:	86 a5       	ldd	r24, Z+46	; 0x2e
    1340:	97 a5       	ldd	r25, Z+47	; 0x2f
    1342:	a0 a9       	ldd	r26, Z+48	; 0x30
    1344:	b1 a9       	ldd	r27, Z+49	; 0x31
    1346:	80 8b       	std	Z+16, r24	; 0x10
    1348:	91 8b       	std	Z+17, r25	; 0x11
    134a:	a2 8b       	std	Z+18, r26	; 0x12
    134c:	b3 8b       	std	Z+19, r27	; 0x13
    134e:	ff ef       	ldi	r31, 0xFF	; 255
    1350:	af 1a       	sub	r10, r31
    1352:	bf 0a       	sbc	r11, r31
    1354:	0c 5f       	subi	r16, 0xFC	; 252
    1356:	1f 4f       	sbci	r17, 0xFF	; 255
    1358:	24 e0       	ldi	r18, 0x04	; 4
    135a:	c2 0e       	add	r12, r18
    135c:	d1 1c       	adc	r13, r1
      
      // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]

      // Pre-calculate the coordinate data changes.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    135e:	33 e0       	ldi	r19, 0x03	; 3
    1360:	a3 16       	cp	r10, r19
    1362:	b1 04       	cpc	r11, r1
    1364:	09 f0       	breq	.+2      	; 0x1368 <gc_execute_line+0x834>
    1366:	b4 cf       	rjmp	.-152    	; 0x12d0 <gc_execute_line+0x79c>
    1368:	a6 c6       	rjmp	.+3404   	; 0x20b6 <gc_execute_line+0x1582>
        } // Else, keep current stored value.
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    136a:	4d 8d       	ldd	r20, Y+29	; 0x1d
    136c:	44 23       	and	r20, r20
    136e:	09 f4       	brne	.+2      	; 0x1372 <gc_execute_line+0x83e>
    1370:	4d c6       	rjmp	.+3226   	; 0x200c <gc_execute_line+0x14d8>
    1372:	0f 2e       	mov	r0, r31
    1374:	fa ea       	ldi	r31, 0xAA	; 170
    1376:	af 2e       	mov	r10, r31
    1378:	f5 e0       	ldi	r31, 0x05	; 5
    137a:	bf 2e       	mov	r11, r31
    137c:	f0 2d       	mov	r31, r0
    137e:	4e 01       	movw	r8, r28
    1380:	86 e0       	ldi	r24, 0x06	; 6
    1382:	88 0e       	add	r8, r24
    1384:	91 1c       	adc	r9, r1
    1386:	0a ee       	ldi	r16, 0xEA	; 234
    1388:	15 e0       	ldi	r17, 0x05	; 5
    138a:	c1 2c       	mov	r12, r1
    138c:	d1 2c       	mov	r13, r1

      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
        if (bit_istrue(axis_words,bit(idx)) ) {
    138e:	64 2e       	mov	r6, r20
    1390:	71 2c       	mov	r7, r1
    1392:	c3 01       	movw	r24, r6
    1394:	0c 2c       	mov	r0, r12
    1396:	02 c0       	rjmp	.+4      	; 0x139c <gc_execute_line+0x868>
    1398:	95 95       	asr	r25
    139a:	87 95       	ror	r24
    139c:	0a 94       	dec	r0
    139e:	e2 f7       	brpl	.-8      	; 0x1398 <gc_execute_line+0x864>
    13a0:	80 ff       	sbrs	r24, 0
    13a2:	3c c0       	rjmp	.+120    	; 0x141c <gc_execute_line+0x8e8>
          // WPos = MPos - WCS - G92 - TLO  ->  G92 = MPos - WCS - TLO - WPos
          gc_block.values.xyz[idx] = gc_state.position[idx]-block_coord_system[idx]-gc_block.values.xyz[idx];
    13a4:	d4 01       	movw	r26, r8
    13a6:	2d 91       	ld	r18, X+
    13a8:	3d 91       	ld	r19, X+
    13aa:	4d 91       	ld	r20, X+
    13ac:	5c 91       	ld	r21, X
    13ae:	f5 01       	movw	r30, r10
    13b0:	60 8d       	ldd	r22, Z+24	; 0x18
    13b2:	71 8d       	ldd	r23, Z+25	; 0x19
    13b4:	82 8d       	ldd	r24, Z+26	; 0x1a
    13b6:	93 8d       	ldd	r25, Z+27	; 0x1b
    13b8:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    13bc:	d8 01       	movw	r26, r16
    13be:	9e 96       	adiw	r26, 0x2e	; 46
    13c0:	2d 91       	ld	r18, X+
    13c2:	3d 91       	ld	r19, X+
    13c4:	4d 91       	ld	r20, X+
    13c6:	5c 91       	ld	r21, X
    13c8:	d1 97       	sbiw	r26, 0x31	; 49
    13ca:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    13ce:	f8 01       	movw	r30, r16
    13d0:	66 a7       	std	Z+46, r22	; 0x2e
    13d2:	77 a7       	std	Z+47, r23	; 0x2f
    13d4:	80 ab       	std	Z+48, r24	; 0x30
    13d6:	91 ab       	std	Z+49, r25	; 0x31
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
    13d8:	f2 e0       	ldi	r31, 0x02	; 2
    13da:	cf 12       	cpse	r12, r31
    13dc:	29 c0       	rjmp	.+82     	; 0x1430 <gc_execute_line+0x8fc>
    13de:	86 01       	movw	r16, r12
    13e0:	00 0f       	add	r16, r16
    13e2:	11 1f       	adc	r17, r17
    13e4:	00 0f       	add	r16, r16
    13e6:	11 1f       	adc	r17, r17
    13e8:	06 51       	subi	r16, 0x16	; 22
    13ea:	1a 4f       	sbci	r17, 0xFA	; 250
    13ec:	20 91 e6 05 	lds	r18, 0x05E6	; 0x8005e6 <gc_state+0x3c>
    13f0:	30 91 e7 05 	lds	r19, 0x05E7	; 0x8005e7 <gc_state+0x3d>
    13f4:	40 91 e8 05 	lds	r20, 0x05E8	; 0x8005e8 <gc_state+0x3e>
    13f8:	50 91 e9 05 	lds	r21, 0x05E9	; 0x8005e9 <gc_state+0x3f>
    13fc:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    1400:	d8 01       	movw	r26, r16
    1402:	9e 96       	adiw	r26, 0x2e	; 46
    1404:	6d 93       	st	X+, r22
    1406:	7d 93       	st	X+, r23
    1408:	8d 93       	st	X+, r24
    140a:	9c 93       	st	X, r25
    140c:	d1 97       	sbiw	r26, 0x31	; 49
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    140e:	10 91 eb 05 	lds	r17, 0x05EB	; 0x8005eb <gc_block+0x1>
    1412:	10 35       	cpi	r17, 0x50	; 80
    1414:	09 f4       	brne	.+2      	; 0x1418 <gc_execute_line+0x8e4>
    1416:	fc c5       	rjmp	.+3064   	; 0x2010 <gc_execute_line+0x14dc>
    1418:	1b 8e       	std	Y+27, r1	; 0x1b
    141a:	f8 c0       	rjmp	.+496    	; 0x160c <gc_execute_line+0xad8>
        if (bit_istrue(axis_words,bit(idx)) ) {
          // WPos = MPos - WCS - G92 - TLO  ->  G92 = MPos - WCS - TLO - WPos
          gc_block.values.xyz[idx] = gc_state.position[idx]-block_coord_system[idx]-gc_block.values.xyz[idx];
          if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] -= gc_state.tool_length_offset; }
        } else {
          gc_block.values.xyz[idx] = gc_state.coord_offset[idx];
    141c:	f5 01       	movw	r30, r10
    141e:	80 a9       	ldd	r24, Z+48	; 0x30
    1420:	91 a9       	ldd	r25, Z+49	; 0x31
    1422:	a2 a9       	ldd	r26, Z+50	; 0x32
    1424:	b3 a9       	ldd	r27, Z+51	; 0x33
    1426:	f8 01       	movw	r30, r16
    1428:	86 a7       	std	Z+46, r24	; 0x2e
    142a:	97 a7       	std	Z+47, r25	; 0x2f
    142c:	a0 ab       	std	Z+48, r26	; 0x30
    142e:	b1 ab       	std	Z+49, r27	; 0x31
    1430:	ff ef       	ldi	r31, 0xFF	; 255
    1432:	cf 1a       	sub	r12, r31
    1434:	df 0a       	sbc	r13, r31
    1436:	24 e0       	ldi	r18, 0x04	; 4
    1438:	a2 0e       	add	r10, r18
    143a:	b1 1c       	adc	r11, r1
    143c:	34 e0       	ldi	r19, 0x04	; 4
    143e:	83 0e       	add	r8, r19
    1440:	91 1c       	adc	r9, r1
    1442:	0c 5f       	subi	r16, 0xFC	; 252
    1444:	1f 4f       	sbci	r17, 0xFF	; 255
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]

      // Update axes defined only in block. Offsets current system to defined value. Does not update when
      // active coordinate system is selected, but is still active unless G92.1 disables it.
      for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used.
    1446:	43 e0       	ldi	r20, 0x03	; 3
    1448:	c4 16       	cp	r12, r20
    144a:	d1 04       	cpc	r13, r1
    144c:	09 f0       	breq	.+2      	; 0x1450 <gc_execute_line+0x91c>
    144e:	a1 cf       	rjmp	.-190    	; 0x1392 <gc_execute_line+0x85e>
  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes

  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    1450:	1b 8e       	std	Y+27, r1	; 0x1b
    1452:	31 c6       	rjmp	.+3170   	; 0x20b6 <gc_execute_line+0x1582>

      // At this point, the rest of the explicit axis commands treat the axis values as the traditional
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
    1454:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1456:	83 30       	cpi	r24, 0x03	; 3
    1458:	09 f4       	brne	.+2      	; 0x145c <gc_execute_line+0x928>
    145a:	90 c0       	rjmp	.+288    	; 0x157c <gc_execute_line+0xa48>
        if (axis_words) {
    145c:	9d 8d       	ldd	r25, Y+29	; 0x1d
    145e:	99 23       	and	r25, r25
    1460:	09 f4       	brne	.+2      	; 0x1464 <gc_execute_line+0x930>
    1462:	8c c0       	rjmp	.+280    	; 0x157c <gc_execute_line+0xa48>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    1464:	a0 90 ee 05 	lds	r10, 0x05EE	; 0x8005ee <gc_block+0x4>
    1468:	0f 2e       	mov	r0, r31
    146a:	fa ea       	ldi	r31, 0xAA	; 170
    146c:	cf 2e       	mov	r12, r31
    146e:	f5 e0       	ldi	r31, 0x05	; 5
    1470:	df 2e       	mov	r13, r31
    1472:	f0 2d       	mov	r31, r0
    1474:	0a ee       	ldi	r16, 0xEA	; 234
    1476:	15 e0       	ldi	r17, 0x05	; 5
    1478:	3e 01       	movw	r6, r28
    147a:	a6 e0       	ldi	r26, 0x06	; 6
    147c:	6a 0e       	add	r6, r26
    147e:	71 1c       	adc	r7, r1
    1480:	81 2c       	mov	r8, r1
    1482:	91 2c       	mov	r9, r1
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
            if ( bit_isfalse(axis_words,bit(idx)) ) {
    1484:	49 2e       	mov	r4, r25
    1486:	51 2c       	mov	r5, r1
    1488:	9c 8e       	std	Y+28, r9	; 0x1c
    148a:	8b 8e       	std	Y+27, r8	; 0x1b
    148c:	c2 01       	movw	r24, r4
    148e:	08 2c       	mov	r0, r8
    1490:	02 c0       	rjmp	.+4      	; 0x1496 <gc_execute_line+0x962>
    1492:	95 95       	asr	r25
    1494:	87 95       	ror	r24
    1496:	0a 94       	dec	r0
    1498:	e2 f7       	brpl	.-8      	; 0x1492 <gc_execute_line+0x95e>
    149a:	80 fd       	sbrc	r24, 0
    149c:	0b c0       	rjmp	.+22     	; 0x14b4 <gc_execute_line+0x980>
              gc_block.values.xyz[idx] = gc_state.position[idx]; // No axis word in block. Keep same axis position.
    149e:	f6 01       	movw	r30, r12
    14a0:	80 8d       	ldd	r24, Z+24	; 0x18
    14a2:	91 8d       	ldd	r25, Z+25	; 0x19
    14a4:	a2 8d       	ldd	r26, Z+26	; 0x1a
    14a6:	b3 8d       	ldd	r27, Z+27	; 0x1b
    14a8:	f8 01       	movw	r30, r16
    14aa:	86 a7       	std	Z+46, r24	; 0x2e
    14ac:	97 a7       	std	Z+47, r25	; 0x2f
    14ae:	a0 ab       	std	Z+48, r26	; 0x30
    14b0:	b1 ab       	std	Z+49, r27	; 0x31
    14b2:	54 c0       	rjmp	.+168    	; 0x155c <gc_execute_line+0xa28>
            } else {
              // Update specified value according to distance mode or ignore if absolute override is active.
              // NOTE: G53 is never active with G28/30 since they are in the same modal group.
              if (gc_block.non_modal_command != NON_MODAL_ABSOLUTE_OVERRIDE) {
    14b4:	f5 e3       	ldi	r31, 0x35	; 53
    14b6:	bf 16       	cp	r11, r31
    14b8:	09 f4       	brne	.+2      	; 0x14bc <gc_execute_line+0x988>
    14ba:	50 c0       	rjmp	.+160    	; 0x155c <gc_execute_line+0xa28>
                // Apply coordinate offsets based on distance mode.
                if (gc_block.modal.distance == DISTANCE_MODE_ABSOLUTE) {
    14bc:	a1 10       	cpse	r10, r1
    14be:	3b c0       	rjmp	.+118    	; 0x1536 <gc_execute_line+0xa02>
                  gc_block.values.xyz[idx] += block_coord_system[idx] + gc_state.coord_offset[idx];
    14c0:	d6 01       	movw	r26, r12
    14c2:	d0 96       	adiw	r26, 0x30	; 48
    14c4:	2d 91       	ld	r18, X+
    14c6:	3d 91       	ld	r19, X+
    14c8:	4d 91       	ld	r20, X+
    14ca:	5c 91       	ld	r21, X
    14cc:	d3 97       	sbiw	r26, 0x33	; 51
    14ce:	f3 01       	movw	r30, r6
    14d0:	60 81       	ld	r22, Z
    14d2:	71 81       	ldd	r23, Z+1	; 0x01
    14d4:	82 81       	ldd	r24, Z+2	; 0x02
    14d6:	93 81       	ldd	r25, Z+3	; 0x03
    14d8:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    14dc:	d8 01       	movw	r26, r16
    14de:	9e 96       	adiw	r26, 0x2e	; 46
    14e0:	2d 91       	ld	r18, X+
    14e2:	3d 91       	ld	r19, X+
    14e4:	4d 91       	ld	r20, X+
    14e6:	5c 91       	ld	r21, X
    14e8:	d1 97       	sbiw	r26, 0x31	; 49
    14ea:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    14ee:	9b 01       	movw	r18, r22
    14f0:	ac 01       	movw	r20, r24
    14f2:	f8 01       	movw	r30, r16
    14f4:	66 a7       	std	Z+46, r22	; 0x2e
    14f6:	77 a7       	std	Z+47, r23	; 0x2f
    14f8:	80 ab       	std	Z+48, r24	; 0x30
    14fa:	91 ab       	std	Z+49, r25	; 0x31
                  if (idx == TOOL_LENGTH_OFFSET_AXIS) { gc_block.values.xyz[idx] += gc_state.tool_length_offset; }
    14fc:	f2 e0       	ldi	r31, 0x02	; 2
    14fe:	8f 12       	cpse	r8, r31
    1500:	2d c0       	rjmp	.+90     	; 0x155c <gc_execute_line+0xa28>
    1502:	0b 8d       	ldd	r16, Y+27	; 0x1b
    1504:	1c 8d       	ldd	r17, Y+28	; 0x1c
    1506:	00 0f       	add	r16, r16
    1508:	11 1f       	adc	r17, r17
    150a:	00 0f       	add	r16, r16
    150c:	11 1f       	adc	r17, r17
    150e:	06 51       	subi	r16, 0x16	; 22
    1510:	1a 4f       	sbci	r17, 0xFA	; 250
    1512:	60 91 e6 05 	lds	r22, 0x05E6	; 0x8005e6 <gc_state+0x3c>
    1516:	70 91 e7 05 	lds	r23, 0x05E7	; 0x8005e7 <gc_state+0x3d>
    151a:	80 91 e8 05 	lds	r24, 0x05E8	; 0x8005e8 <gc_state+0x3e>
    151e:	90 91 e9 05 	lds	r25, 0x05E9	; 0x8005e9 <gc_state+0x3f>
    1522:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    1526:	d8 01       	movw	r26, r16
    1528:	9e 96       	adiw	r26, 0x2e	; 46
    152a:	6d 93       	st	X+, r22
    152c:	7d 93       	st	X+, r23
    152e:	8d 93       	st	X+, r24
    1530:	9c 93       	st	X, r25
    1532:	d1 97       	sbiw	r26, 0x31	; 49
    1534:	23 c0       	rjmp	.+70     	; 0x157c <gc_execute_line+0xa48>
                } else {  // Incremental mode
                  gc_block.values.xyz[idx] += gc_state.position[idx];
    1536:	f6 01       	movw	r30, r12
    1538:	20 8d       	ldd	r18, Z+24	; 0x18
    153a:	31 8d       	ldd	r19, Z+25	; 0x19
    153c:	42 8d       	ldd	r20, Z+26	; 0x1a
    153e:	53 8d       	ldd	r21, Z+27	; 0x1b
    1540:	d8 01       	movw	r26, r16
    1542:	9e 96       	adiw	r26, 0x2e	; 46
    1544:	6d 91       	ld	r22, X+
    1546:	7d 91       	ld	r23, X+
    1548:	8d 91       	ld	r24, X+
    154a:	9c 91       	ld	r25, X
    154c:	d1 97       	sbiw	r26, 0x31	; 49
    154e:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    1552:	f8 01       	movw	r30, r16
    1554:	66 a7       	std	Z+46, r22	; 0x2e
    1556:	77 a7       	std	Z+47, r23	; 0x2f
    1558:	80 ab       	std	Z+48, r24	; 0x30
    155a:	91 ab       	std	Z+49, r25	; 0x31
    155c:	ff ef       	ldi	r31, 0xFF	; 255
    155e:	8f 1a       	sub	r8, r31
    1560:	9f 0a       	sbc	r9, r31
    1562:	24 e0       	ldi	r18, 0x04	; 4
    1564:	c2 0e       	add	r12, r18
    1566:	d1 1c       	adc	r13, r1
    1568:	0c 5f       	subi	r16, 0xFC	; 252
    156a:	1f 4f       	sbci	r17, 0xFF	; 255
    156c:	34 e0       	ldi	r19, 0x04	; 4
    156e:	63 0e       	add	r6, r19
    1570:	71 1c       	adc	r7, r1
      // target position with the coordinate system offsets, G92 offsets, absolute override, and distance
      // modes applied. This includes the motion mode commands. We can now pre-compute the target position.
      // NOTE: Tool offsets may be appended to these conversions when/if this feature is added.
      if (axis_command != AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // TLO block any axis command.
        if (axis_words) {
          for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    1572:	43 e0       	ldi	r20, 0x03	; 3
    1574:	84 16       	cp	r8, r20
    1576:	91 04       	cpc	r9, r1
    1578:	09 f0       	breq	.+2      	; 0x157c <gc_execute_line+0xa48>
    157a:	86 cf       	rjmp	.-244    	; 0x1488 <gc_execute_line+0x954>
          }
        }
      }

      // Check remaining non-modal commands for errors.
      switch (gc_block.non_modal_command) {
    157c:	8e e1       	ldi	r24, 0x1E	; 30
    157e:	b8 16       	cp	r11, r24
    1580:	31 f0       	breq	.+12     	; 0x158e <gc_execute_line+0xa5a>
    1582:	95 e3       	ldi	r25, 0x35	; 53
    1584:	b9 16       	cp	r11, r25
    1586:	99 f1       	breq	.+102    	; 0x15ee <gc_execute_line+0xaba>
    1588:	ac e1       	ldi	r26, 0x1C	; 28
    158a:	ba 12       	cpse	r11, r26
    158c:	35 c0       	rjmp	.+106    	; 0x15f8 <gc_execute_line+0xac4>
        case NON_MODAL_GO_HOME_0: // G28
        case NON_MODAL_GO_HOME_1: // G30
          // [G28/30 Errors]: Cutter compensation is enabled.
          // Retreive G28/30 go-home position data (in machine coordinates) from EEPROM
          // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
          if (gc_block.non_modal_command == NON_MODAL_GO_HOME_0) {
    158e:	bc e1       	ldi	r27, 0x1C	; 28
    1590:	bb 12       	cpse	r11, r27
    1592:	09 c0       	rjmp	.+18     	; 0x15a6 <gc_execute_line+0xa72>
            if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    1594:	6a ef       	ldi	r22, 0xFA	; 250
    1596:	75 e0       	ldi	r23, 0x05	; 5
    1598:	86 e0       	ldi	r24, 0x06	; 6
    159a:	0e 94 4e 23 	call	0x469c	; 0x469c <settings_read_coord_data>
    159e:	88 23       	and	r24, r24
    15a0:	09 f4       	brne	.+2      	; 0x15a4 <gc_execute_line+0xa70>
    15a2:	38 c5       	rjmp	.+2672   	; 0x2014 <gc_execute_line+0x14e0>
    15a4:	7c c5       	rjmp	.+2808   	; 0x209e <gc_execute_line+0x156a>
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    15a6:	6a ef       	ldi	r22, 0xFA	; 250
    15a8:	75 e0       	ldi	r23, 0x05	; 5
    15aa:	87 e0       	ldi	r24, 0x07	; 7
    15ac:	0e 94 4e 23 	call	0x469c	; 0x469c <settings_read_coord_data>
    15b0:	88 23       	and	r24, r24
    15b2:	09 f4       	brne	.+2      	; 0x15b6 <gc_execute_line+0xa82>
    15b4:	31 c5       	rjmp	.+2658   	; 0x2018 <gc_execute_line+0x14e4>
    15b6:	73 c5       	rjmp	.+2790   	; 0x209e <gc_execute_line+0x156a>
          }
          if (axis_words) {
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
    15b8:	a9 01       	movw	r20, r18
    15ba:	08 2e       	mov	r0, r24
    15bc:	02 c0       	rjmp	.+4      	; 0x15c2 <gc_execute_line+0xa8e>
    15be:	55 95       	asr	r21
    15c0:	47 95       	ror	r20
    15c2:	0a 94       	dec	r0
    15c4:	e2 f7       	brpl	.-8      	; 0x15be <gc_execute_line+0xa8a>
    15c6:	40 fd       	sbrc	r20, 0
    15c8:	0a c0       	rjmp	.+20     	; 0x15de <gc_execute_line+0xaaa>
    15ca:	58 96       	adiw	r26, 0x18	; 24
    15cc:	4d 91       	ld	r20, X+
    15ce:	5d 91       	ld	r21, X+
    15d0:	6d 91       	ld	r22, X+
    15d2:	7c 91       	ld	r23, X
    15d4:	5b 97       	sbiw	r26, 0x1b	; 27
    15d6:	40 8b       	std	Z+16, r20	; 0x10
    15d8:	51 8b       	std	Z+17, r21	; 0x11
    15da:	62 8b       	std	Z+18, r22	; 0x12
    15dc:	73 8b       	std	Z+19, r23	; 0x13
    15de:	01 96       	adiw	r24, 0x01	; 1
    15e0:	14 96       	adiw	r26, 0x04	; 4
    15e2:	34 96       	adiw	r30, 0x04	; 4
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
          }
          if (axis_words) {
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
    15e4:	83 30       	cpi	r24, 0x03	; 3
    15e6:	91 05       	cpc	r25, r1
    15e8:	39 f7       	brne	.-50     	; 0x15b8 <gc_execute_line+0xa84>
  memset(&gc_block, 0, sizeof(parser_block_t)); // Initialize the parser block struct.
  memcpy(&gc_block.modal,&gc_state.modal,sizeof(gc_modal_t)); // Copy current modes

  uint8_t axis_command = AXIS_COMMAND_NONE;
  uint8_t axis_0, axis_1, axis_linear;
  uint8_t coord_select = 0; // Tracks G10 P coordinate selection for execution
    15ea:	1b 8e       	std	Y+27, r1	; 0x1b
    15ec:	64 c5       	rjmp	.+2760   	; 0x20b6 <gc_execute_line+0x1582>
          // NOTE: If axis words are passed here, they are interpreted as an implicit motion mode.
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
    15ee:	80 91 eb 05 	lds	r24, 0x05EB	; 0x8005eb <gc_block+0x1>
    15f2:	82 30       	cpi	r24, 0x02	; 2
    15f4:	08 f0       	brcs	.+2      	; 0x15f8 <gc_execute_line+0xac4>
    15f6:	12 c5       	rjmp	.+2596   	; 0x201c <gc_execute_line+0x14e8>
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    15f8:	10 91 eb 05 	lds	r17, 0x05EB	; 0x8005eb <gc_block+0x1>
    15fc:	10 35       	cpi	r17, 0x50	; 80
    15fe:	29 f4       	brne	.+10     	; 0x160a <gc_execute_line+0xad6>
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    1600:	ed 8d       	ldd	r30, Y+29	; 0x1d
    1602:	e1 11       	cpse	r30, r1
    1604:	0d c5       	rjmp	.+2586   	; 0x2020 <gc_execute_line+0x14ec>
    1606:	1b 8e       	std	Y+27, r1	; 0x1b
    1608:	46 c2       	rjmp	.+1164   	; 0x1a96 <gc_execute_line+0xf62>
    160a:	1b 8e       	std	Y+27, r1	; 0x1b

  // Check remaining motion modes, if axis word are implicit (exist and not used by G10/28/30/92), or
  // was explicitly commanded in the g-code block.
  } else if ( axis_command == AXIS_COMMAND_MOTION_MODE ) {
    160c:	fe 8d       	ldd	r31, Y+30	; 0x1e
    160e:	f2 30       	cpi	r31, 0x02	; 2
    1610:	09 f0       	breq	.+2      	; 0x1614 <gc_execute_line+0xae0>
    1612:	41 c2       	rjmp	.+1154   	; 0x1a96 <gc_execute_line+0xf62>

    if (gc_block.modal.motion == MOTION_MODE_SEEK) {
    1614:	11 11       	cpse	r17, r1
    1616:	05 c0       	rjmp	.+10     	; 0x1622 <gc_execute_line+0xaee>
      // [G0 Errors]: Axis letter not configured or without real value (done.)
      // Axis words are optional. If missing, set axis command flag to ignore execution.
      if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    1618:	2d 8d       	ldd	r18, Y+29	; 0x1d
    161a:	21 11       	cpse	r18, r1
    161c:	3c c2       	rjmp	.+1144   	; 0x1a96 <gc_execute_line+0xf62>
    161e:	1e 8e       	std	Y+30, r1	; 0x1e
    1620:	3a c2       	rjmp	.+1140   	; 0x1a96 <gc_execute_line+0xf62>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    1622:	20 e0       	ldi	r18, 0x00	; 0
    1624:	30 e0       	ldi	r19, 0x00	; 0
    1626:	a9 01       	movw	r20, r18
    1628:	60 91 f6 05 	lds	r22, 0x05F6	; 0x8005f6 <gc_block+0xc>
    162c:	70 91 f7 05 	lds	r23, 0x05F7	; 0x8005f7 <gc_block+0xd>
    1630:	80 91 f8 05 	lds	r24, 0x05F8	; 0x8005f8 <gc_block+0xe>
    1634:	90 91 f9 05 	lds	r25, 0x05F9	; 0x8005f9 <gc_block+0xf>
    1638:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    163c:	88 23       	and	r24, r24
    163e:	09 f4       	brne	.+2      	; 0x1642 <gc_execute_line+0xb0e>
    1640:	f1 c4       	rjmp	.+2530   	; 0x2024 <gc_execute_line+0x14f0>

      switch (gc_block.modal.motion) {
    1642:	1c 38       	cpi	r17, 0x8C	; 140
    1644:	09 f4       	brne	.+2      	; 0x1648 <gc_execute_line+0xb14>
    1646:	0f c2       	rjmp	.+1054   	; 0x1a66 <gc_execute_line+0xf32>
    1648:	40 f4       	brcc	.+16     	; 0x165a <gc_execute_line+0xb26>
    164a:	12 30       	cpi	r17, 0x02	; 2
    164c:	a1 f0       	breq	.+40     	; 0x1676 <gc_execute_line+0xb42>
    164e:	13 30       	cpi	r17, 0x03	; 3
    1650:	a9 f0       	breq	.+42     	; 0x167c <gc_execute_line+0xb48>
    1652:	11 30       	cpi	r17, 0x01	; 1
    1654:	09 f0       	breq	.+2      	; 0x1658 <gc_execute_line+0xb24>
    1656:	1f c2       	rjmp	.+1086   	; 0x1a96 <gc_execute_line+0xf62>
    1658:	09 c0       	rjmp	.+18     	; 0x166c <gc_execute_line+0xb38>
    165a:	1e 38       	cpi	r17, 0x8E	; 142
    165c:	09 f4       	brne	.+2      	; 0x1660 <gc_execute_line+0xb2c>
    165e:	03 c2       	rjmp	.+1030   	; 0x1a66 <gc_execute_line+0xf32>
    1660:	08 f4       	brcc	.+2      	; 0x1664 <gc_execute_line+0xb30>
    1662:	fe c1       	rjmp	.+1020   	; 0x1a60 <gc_execute_line+0xf2c>
    1664:	1f 38       	cpi	r17, 0x8F	; 143
    1666:	09 f4       	brne	.+2      	; 0x166a <gc_execute_line+0xb36>
    1668:	fb c1       	rjmp	.+1014   	; 0x1a60 <gc_execute_line+0xf2c>
    166a:	15 c2       	rjmp	.+1066   	; 0x1a96 <gc_execute_line+0xf62>
        case MOTION_MODE_LINEAR:
          // [G1 Errors]: Feed rate undefined. Axis letter not configured or without real value.
          // Axis words are optional. If missing, set axis command flag to ignore execution.
          if (!axis_words) { axis_command = AXIS_COMMAND_NONE; }
    166c:	3d 8d       	ldd	r19, Y+29	; 0x1d
    166e:	31 11       	cpse	r19, r1
    1670:	12 c2       	rjmp	.+1060   	; 0x1a96 <gc_execute_line+0xf62>
    1672:	1e 8e       	std	Y+30, r1	; 0x1e
    1674:	10 c2       	rjmp	.+1056   	; 0x1a96 <gc_execute_line+0xf62>
          break;
        case MOTION_MODE_CW_ARC: 
          gc_parser_flags |= GC_PARSER_ARC_IS_CLOCKWISE; // No break intentional.
    1676:	48 a1       	ldd	r20, Y+32	; 0x20
    1678:	44 60       	ori	r20, 0x04	; 4
    167a:	48 a3       	std	Y+32, r20	; 0x20
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.

          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    167c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    167e:	88 23       	and	r24, r24
    1680:	09 f4       	brne	.+2      	; 0x1684 <gc_execute_line+0xb50>
    1682:	d2 c4       	rjmp	.+2468   	; 0x2028 <gc_execute_line+0x14f4>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    1684:	b9 a1       	ldd	r27, Y+33	; 0x21
    1686:	ab 2f       	mov	r26, r27
    1688:	b0 e0       	ldi	r27, 0x00	; 0
    168a:	bd a7       	std	Y+45, r27	; 0x2d
    168c:	ac a7       	std	Y+44, r26	; 0x2c
    168e:	ea a1       	ldd	r30, Y+34	; 0x22
    1690:	ce 2e       	mov	r12, r30
    1692:	d1 2c       	mov	r13, r1
    1694:	81 e0       	ldi	r24, 0x01	; 1
    1696:	90 e0       	ldi	r25, 0x00	; 0
    1698:	8c 01       	movw	r16, r24
    169a:	09 a0       	ldd	r0, Y+33	; 0x21
    169c:	02 c0       	rjmp	.+4      	; 0x16a2 <gc_execute_line+0xb6e>
    169e:	00 0f       	add	r16, r16
    16a0:	11 1f       	adc	r17, r17
    16a2:	0a 94       	dec	r0
    16a4:	e2 f7       	brpl	.-8      	; 0x169e <gc_execute_line+0xb6a>
    16a6:	02 c0       	rjmp	.+4      	; 0x16ac <gc_execute_line+0xb78>
    16a8:	88 0f       	add	r24, r24
    16aa:	99 1f       	adc	r25, r25
    16ac:	ea 95       	dec	r30
    16ae:	e2 f7       	brpl	.-8      	; 0x16a8 <gc_execute_line+0xb74>
    16b0:	08 2b       	or	r16, r24
    16b2:	19 2b       	or	r17, r25
    16b4:	fd 8d       	ldd	r31, Y+29	; 0x1d
    16b6:	8f 2f       	mov	r24, r31
    16b8:	90 e0       	ldi	r25, 0x00	; 0
    16ba:	80 23       	and	r24, r16
    16bc:	91 23       	and	r25, r17
    16be:	89 2b       	or	r24, r25
    16c0:	09 f4       	brne	.+2      	; 0x16c4 <gc_execute_line+0xb90>
    16c2:	b4 c4       	rjmp	.+2408   	; 0x202c <gc_execute_line+0x14f8>

          // Calculate the change in position along each selected axis
          float x,y;
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
    16c4:	fd 01       	movw	r30, r26
    16c6:	ee 0f       	add	r30, r30
    16c8:	ff 1f       	adc	r31, r31
    16ca:	ee 0f       	add	r30, r30
    16cc:	ff 1f       	adc	r31, r31
    16ce:	e6 51       	subi	r30, 0x16	; 22
    16d0:	fa 4f       	sbci	r31, 0xFA	; 250
    16d2:	aa 0f       	add	r26, r26
    16d4:	bb 1f       	adc	r27, r27
    16d6:	aa 0f       	add	r26, r26
    16d8:	bb 1f       	adc	r27, r27
    16da:	ae 53       	subi	r26, 0x3E	; 62
    16dc:	ba 4f       	sbci	r27, 0xFA	; 250
    16de:	2d 91       	ld	r18, X+
    16e0:	3d 91       	ld	r19, X+
    16e2:	4d 91       	ld	r20, X+
    16e4:	5c 91       	ld	r21, X
    16e6:	66 a5       	ldd	r22, Z+46	; 0x2e
    16e8:	77 a5       	ldd	r23, Z+47	; 0x2f
    16ea:	80 a9       	ldd	r24, Z+48	; 0x30
    16ec:	91 a9       	ldd	r25, Z+49	; 0x31
    16ee:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    16f2:	6b a3       	std	Y+35, r22	; 0x23
    16f4:	7c a3       	std	Y+36, r23	; 0x24
    16f6:	8d a3       	std	Y+37, r24	; 0x25
    16f8:	9e a3       	std	Y+38, r25	; 0x26
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target
    16fa:	f6 01       	movw	r30, r12
    16fc:	ee 0f       	add	r30, r30
    16fe:	ff 1f       	adc	r31, r31
    1700:	ee 0f       	add	r30, r30
    1702:	ff 1f       	adc	r31, r31
    1704:	e6 51       	subi	r30, 0x16	; 22
    1706:	fa 4f       	sbci	r31, 0xFA	; 250
    1708:	d6 01       	movw	r26, r12
    170a:	aa 0f       	add	r26, r26
    170c:	bb 1f       	adc	r27, r27
    170e:	aa 0f       	add	r26, r26
    1710:	bb 1f       	adc	r27, r27
    1712:	ae 53       	subi	r26, 0x3E	; 62
    1714:	ba 4f       	sbci	r27, 0xFA	; 250
    1716:	2d 91       	ld	r18, X+
    1718:	3d 91       	ld	r19, X+
    171a:	4d 91       	ld	r20, X+
    171c:	5c 91       	ld	r21, X
    171e:	66 a5       	ldd	r22, Z+46	; 0x2e
    1720:	77 a5       	ldd	r23, Z+47	; 0x2f
    1722:	80 a9       	ldd	r24, Z+48	; 0x30
    1724:	91 a9       	ldd	r25, Z+49	; 0x31
    1726:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    172a:	6f a3       	std	Y+39, r22	; 0x27
    172c:	78 a7       	std	Y+40, r23	; 0x28
    172e:	89 a7       	std	Y+41, r24	; 0x29
    1730:	9a a7       	std	Y+42, r25	; 0x2a

          if (value_words & bit(WORD_R)) { // Arc Radius Mode
    1732:	27 fe       	sbrs	r2, 7
    1734:	ea c0       	rjmp	.+468    	; 0x190a <gc_execute_line+0xdd6>
            bit_false(value_words,bit(WORD_R));
    1736:	e8 94       	clt
    1738:	27 f8       	bld	r2, 7
            if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    173a:	4c e0       	ldi	r20, 0x0C	; 12
    173c:	50 e0       	ldi	r21, 0x00	; 0
    173e:	68 e1       	ldi	r22, 0x18	; 24
    1740:	76 e0       	ldi	r23, 0x06	; 6
    1742:	82 ec       	ldi	r24, 0xC2	; 194
    1744:	95 e0       	ldi	r25, 0x05	; 5
    1746:	0e 94 e4 32 	call	0x65c8	; 0x65c8 <memcmp>
    174a:	89 2b       	or	r24, r25
    174c:	09 f4       	brne	.+2      	; 0x1750 <gc_execute_line+0xc1c>
    174e:	70 c4       	rjmp	.+2272   	; 0x2030 <gc_execute_line+0x14fc>

            // Convert radius value to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) { gc_block.values.r *= MM_PER_INCH; }
    1750:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <gc_block+0x3>
    1754:	81 30       	cpi	r24, 0x01	; 1
    1756:	a1 f4       	brne	.+40     	; 0x1780 <gc_execute_line+0xc4c>
    1758:	0a ee       	ldi	r16, 0xEA	; 234
    175a:	15 e0       	ldi	r17, 0x05	; 5
    175c:	23 e3       	ldi	r18, 0x33	; 51
    175e:	33 e3       	ldi	r19, 0x33	; 51
    1760:	4b ec       	ldi	r20, 0xCB	; 203
    1762:	51 e4       	ldi	r21, 0x41	; 65
    1764:	d8 01       	movw	r26, r16
    1766:	95 96       	adiw	r26, 0x25	; 37
    1768:	6d 91       	ld	r22, X+
    176a:	7d 91       	ld	r23, X+
    176c:	8d 91       	ld	r24, X+
    176e:	9c 91       	ld	r25, X
    1770:	98 97       	sbiw	r26, 0x28	; 40
    1772:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    1776:	f8 01       	movw	r30, r16
    1778:	65 a3       	std	Z+37, r22	; 0x25
    177a:	76 a3       	std	Z+38, r23	; 0x26
    177c:	87 a3       	std	Z+39, r24	; 0x27
    177e:	90 a7       	std	Z+40, r25	; 0x28
                j = (y + (x * h_x2_div_d))/2
            */

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;
    1780:	80 90 0f 06 	lds	r8, 0x060F	; 0x80060f <gc_block+0x25>
    1784:	90 90 10 06 	lds	r9, 0x0610	; 0x800610 <gc_block+0x26>
    1788:	a0 90 11 06 	lds	r10, 0x0611	; 0x800611 <gc_block+0x27>
    178c:	b0 90 12 06 	lds	r11, 0x0612	; 0x800612 <gc_block+0x28>
    1790:	20 e0       	ldi	r18, 0x00	; 0
    1792:	30 e0       	ldi	r19, 0x00	; 0
    1794:	40 e8       	ldi	r20, 0x80	; 128
    1796:	50 e4       	ldi	r21, 0x40	; 64
    1798:	c5 01       	movw	r24, r10
    179a:	b4 01       	movw	r22, r8
    179c:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    17a0:	a5 01       	movw	r20, r10
    17a2:	94 01       	movw	r18, r8
    17a4:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    17a8:	4b 01       	movw	r8, r22
    17aa:	5c 01       	movw	r10, r24
    17ac:	2b a1       	ldd	r18, Y+35	; 0x23
    17ae:	3c a1       	ldd	r19, Y+36	; 0x24
    17b0:	4d a1       	ldd	r20, Y+37	; 0x25
    17b2:	5e a1       	ldd	r21, Y+38	; 0x26
    17b4:	ca 01       	movw	r24, r20
    17b6:	b9 01       	movw	r22, r18
    17b8:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    17bc:	9b 01       	movw	r18, r22
    17be:	ac 01       	movw	r20, r24
    17c0:	c5 01       	movw	r24, r10
    17c2:	b4 01       	movw	r22, r8
    17c4:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    17c8:	4b 01       	movw	r8, r22
    17ca:	5c 01       	movw	r10, r24
    17cc:	2f a1       	ldd	r18, Y+39	; 0x27
    17ce:	38 a5       	ldd	r19, Y+40	; 0x28
    17d0:	49 a5       	ldd	r20, Y+41	; 0x29
    17d2:	5a a5       	ldd	r21, Y+42	; 0x2a
    17d4:	ca 01       	movw	r24, r20
    17d6:	b9 01       	movw	r22, r18
    17d8:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    17dc:	9b 01       	movw	r18, r22
    17de:	ac 01       	movw	r20, r24
    17e0:	c5 01       	movw	r24, r10
    17e2:	b4 01       	movw	r22, r8
    17e4:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    17e8:	4b 01       	movw	r8, r22
    17ea:	5c 01       	movw	r10, r24

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    17ec:	20 e0       	ldi	r18, 0x00	; 0
    17ee:	30 e0       	ldi	r19, 0x00	; 0
    17f0:	a9 01       	movw	r20, r18
    17f2:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    17f6:	88 23       	and	r24, r24
    17f8:	0c f4       	brge	.+2      	; 0x17fc <gc_execute_line+0xcc8>
    17fa:	1c c4       	rjmp	.+2104   	; 0x2034 <gc_execute_line+0x1500>

            // Finish computing h_x2_div_d.
            h_x2_div_d = -sqrt(h_x2_div_d)/hypot_f(x,y); // == -(h * 2 / d)
    17fc:	c5 01       	movw	r24, r10
    17fe:	b4 01       	movw	r22, r8
    1800:	0e 94 65 32 	call	0x64ca	; 0x64ca <sqrt>
    1804:	4b 01       	movw	r8, r22
    1806:	5c 01       	movw	r10, r24
    1808:	2f a1       	ldd	r18, Y+39	; 0x27
    180a:	38 a5       	ldd	r19, Y+40	; 0x28
    180c:	49 a5       	ldd	r20, Y+41	; 0x29
    180e:	5a a5       	ldd	r21, Y+42	; 0x2a
    1810:	6b a1       	ldd	r22, Y+35	; 0x23
    1812:	7c a1       	ldd	r23, Y+36	; 0x24
    1814:	8d a1       	ldd	r24, Y+37	; 0x25
    1816:	9e a1       	ldd	r25, Y+38	; 0x26
    1818:	0e 94 eb 2a 	call	0x55d6	; 0x55d6 <hypot_f>
    181c:	9b 01       	movw	r18, r22
    181e:	ac 01       	movw	r20, r24
    1820:	c5 01       	movw	r24, r10
    1822:	b4 01       	movw	r22, r8
    1824:	90 58       	subi	r25, 0x80	; 128
    1826:	0e 94 6e 2f 	call	0x5edc	; 0x5edc <__divsf3>
    182a:	4b 01       	movw	r8, r22
    182c:	5c 01       	movw	r10, r24
            // Invert the sign of h_x2_div_d if the circle is counter clockwise (see sketch below)
            if (gc_block.modal.motion == MOTION_MODE_CCW_ARC) { h_x2_div_d = -h_x2_div_d; }
    182e:	80 91 eb 05 	lds	r24, 0x05EB	; 0x8005eb <gc_block+0x1>
    1832:	83 30       	cpi	r24, 0x03	; 3
    1834:	21 f4       	brne	.+8      	; 0x183e <gc_execute_line+0xd0a>
    1836:	b7 fa       	bst	r11, 7
    1838:	b0 94       	com	r11
    183a:	b7 f8       	bld	r11, 7
    183c:	b0 94       	com	r11
            */
            // Negative R is g-code-alese for "I want a circle with more than 180 degrees of travel" (go figure!),
            // even though it is advised against ever generating such circles in a single line of g-code. By
            // inverting the sign of h_x2_div_d the center of the circles is placed on the opposite side of the line of
            // travel and thus we get the unadvisably long arcs as prescribed.
            if (gc_block.values.r < 0) {
    183e:	40 90 0f 06 	lds	r4, 0x060F	; 0x80060f <gc_block+0x25>
    1842:	50 90 10 06 	lds	r5, 0x0610	; 0x800610 <gc_block+0x26>
    1846:	60 90 11 06 	lds	r6, 0x0611	; 0x800611 <gc_block+0x27>
    184a:	70 90 12 06 	lds	r7, 0x0612	; 0x800612 <gc_block+0x28>
    184e:	20 e0       	ldi	r18, 0x00	; 0
    1850:	30 e0       	ldi	r19, 0x00	; 0
    1852:	a9 01       	movw	r20, r18
    1854:	c3 01       	movw	r24, r6
    1856:	b2 01       	movw	r22, r4
    1858:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    185c:	88 23       	and	r24, r24
    185e:	84 f4       	brge	.+32     	; 0x1880 <gc_execute_line+0xd4c>
                h_x2_div_d = -h_x2_div_d;
    1860:	b7 fa       	bst	r11, 7
    1862:	b0 94       	com	r11
    1864:	b7 f8       	bld	r11, 7
    1866:	b0 94       	com	r11
                gc_block.values.r = -gc_block.values.r; // Finished with r. Set to positive for mc_arc
    1868:	77 fa       	bst	r7, 7
    186a:	70 94       	com	r7
    186c:	77 f8       	bld	r7, 7
    186e:	70 94       	com	r7
    1870:	40 92 0f 06 	sts	0x060F, r4	; 0x80060f <gc_block+0x25>
    1874:	50 92 10 06 	sts	0x0610, r5	; 0x800610 <gc_block+0x26>
    1878:	60 92 11 06 	sts	0x0611, r6	; 0x800611 <gc_block+0x27>
    187c:	70 92 12 06 	sts	0x0612, r7	; 0x800612 <gc_block+0x28>
            }
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
    1880:	0c a5       	ldd	r16, Y+44	; 0x2c
    1882:	1d a5       	ldd	r17, Y+45	; 0x2d
    1884:	00 0f       	add	r16, r16
    1886:	11 1f       	adc	r17, r17
    1888:	00 0f       	add	r16, r16
    188a:	11 1f       	adc	r17, r17
    188c:	06 50       	subi	r16, 0x06	; 6
    188e:	1a 4f       	sbci	r17, 0xFA	; 250
    1890:	2f a1       	ldd	r18, Y+39	; 0x27
    1892:	38 a5       	ldd	r19, Y+40	; 0x28
    1894:	49 a5       	ldd	r20, Y+41	; 0x29
    1896:	5a a5       	ldd	r21, Y+42	; 0x2a
    1898:	c5 01       	movw	r24, r10
    189a:	b4 01       	movw	r22, r8
    189c:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    18a0:	9b 01       	movw	r18, r22
    18a2:	ac 01       	movw	r20, r24
    18a4:	6b a1       	ldd	r22, Y+35	; 0x23
    18a6:	7c a1       	ldd	r23, Y+36	; 0x24
    18a8:	8d a1       	ldd	r24, Y+37	; 0x25
    18aa:	9e a1       	ldd	r25, Y+38	; 0x26
    18ac:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    18b0:	20 e0       	ldi	r18, 0x00	; 0
    18b2:	30 e0       	ldi	r19, 0x00	; 0
    18b4:	40 e0       	ldi	r20, 0x00	; 0
    18b6:	5f e3       	ldi	r21, 0x3F	; 63
    18b8:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    18bc:	d8 01       	movw	r26, r16
    18be:	6d 93       	st	X+, r22
    18c0:	7d 93       	st	X+, r23
    18c2:	8d 93       	st	X+, r24
    18c4:	9c 93       	st	X, r25
    18c6:	13 97       	sbiw	r26, 0x03	; 3
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));
    18c8:	86 01       	movw	r16, r12
    18ca:	00 0f       	add	r16, r16
    18cc:	11 1f       	adc	r17, r17
    18ce:	00 0f       	add	r16, r16
    18d0:	11 1f       	adc	r17, r17
    18d2:	06 50       	subi	r16, 0x06	; 6
    18d4:	1a 4f       	sbci	r17, 0xFA	; 250
    18d6:	2b a1       	ldd	r18, Y+35	; 0x23
    18d8:	3c a1       	ldd	r19, Y+36	; 0x24
    18da:	4d a1       	ldd	r20, Y+37	; 0x25
    18dc:	5e a1       	ldd	r21, Y+38	; 0x26
    18de:	c5 01       	movw	r24, r10
    18e0:	b4 01       	movw	r22, r8
    18e2:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    18e6:	2f a1       	ldd	r18, Y+39	; 0x27
    18e8:	38 a5       	ldd	r19, Y+40	; 0x28
    18ea:	49 a5       	ldd	r20, Y+41	; 0x29
    18ec:	5a a5       	ldd	r21, Y+42	; 0x2a
    18ee:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    18f2:	20 e0       	ldi	r18, 0x00	; 0
    18f4:	30 e0       	ldi	r19, 0x00	; 0
    18f6:	40 e0       	ldi	r20, 0x00	; 0
    18f8:	5f e3       	ldi	r21, 0x3F	; 63
    18fa:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    18fe:	f8 01       	movw	r30, r16
    1900:	60 83       	st	Z, r22
    1902:	71 83       	std	Z+1, r23	; 0x01
    1904:	82 83       	std	Z+2, r24	; 0x02
    1906:	93 83       	std	Z+3, r25	; 0x03
    1908:	c6 c0       	rjmp	.+396    	; 0x1a96 <gc_execute_line+0xf62>

          } else { // Arc Center Format Offset Mode
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    190a:	ff 8d       	ldd	r31, Y+31	; 0x1f
    190c:	8f 2e       	mov	r8, r31
    190e:	91 2c       	mov	r9, r1
    1910:	08 21       	and	r16, r8
    1912:	19 21       	and	r17, r9
    1914:	01 2b       	or	r16, r17
    1916:	09 f4       	brne	.+2      	; 0x191a <gc_execute_line+0xde6>
    1918:	8f c3       	rjmp	.+1822   	; 0x2038 <gc_execute_line+0x1504>
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));
    191a:	21 ef       	ldi	r18, 0xF1	; 241
    191c:	22 22       	and	r2, r18

            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
    191e:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <gc_block+0x3>
    1922:	81 30       	cpi	r24, 0x01	; 1
    1924:	41 f5       	brne	.+80     	; 0x1976 <gc_execute_line+0xe42>
    1926:	0a ee       	ldi	r16, 0xEA	; 234
    1928:	15 e0       	ldi	r17, 0x05	; 5
    192a:	a1 2c       	mov	r10, r1
    192c:	b1 2c       	mov	r11, r1
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
    192e:	c4 01       	movw	r24, r8
    1930:	0a 2c       	mov	r0, r10
    1932:	02 c0       	rjmp	.+4      	; 0x1938 <gc_execute_line+0xe04>
    1934:	95 95       	asr	r25
    1936:	87 95       	ror	r24
    1938:	0a 94       	dec	r0
    193a:	e2 f7       	brpl	.-8      	; 0x1934 <gc_execute_line+0xe00>
    193c:	80 ff       	sbrs	r24, 0
    193e:	12 c0       	rjmp	.+36     	; 0x1964 <gc_execute_line+0xe30>
    1940:	23 e3       	ldi	r18, 0x33	; 51
    1942:	33 e3       	ldi	r19, 0x33	; 51
    1944:	4b ec       	ldi	r20, 0xCB	; 203
    1946:	51 e4       	ldi	r21, 0x41	; 65
    1948:	d8 01       	movw	r26, r16
    194a:	50 96       	adiw	r26, 0x10	; 16
    194c:	6d 91       	ld	r22, X+
    194e:	7d 91       	ld	r23, X+
    1950:	8d 91       	ld	r24, X+
    1952:	9c 91       	ld	r25, X
    1954:	53 97       	sbiw	r26, 0x13	; 19
    1956:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    195a:	f8 01       	movw	r30, r16
    195c:	60 8b       	std	Z+16, r22	; 0x10
    195e:	71 8b       	std	Z+17, r23	; 0x11
    1960:	82 8b       	std	Z+18, r24	; 0x12
    1962:	93 8b       	std	Z+19, r25	; 0x13
    1964:	ff ef       	ldi	r31, 0xFF	; 255
    1966:	af 1a       	sub	r10, r31
    1968:	bf 0a       	sbc	r11, r31
    196a:	0c 5f       	subi	r16, 0xFC	; 252
    196c:	1f 4f       	sbci	r17, 0xFF	; 255
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
            bit_false(value_words,(bit(WORD_I)|bit(WORD_J)|bit(WORD_K)));

            // Convert IJK values to proper units.
            if (gc_block.modal.units == UNITS_MODE_INCHES) {
              for (idx=0; idx<N_AXIS; idx++) { // Axes indices are consistent, so loop may be used to save flash space.
    196e:	23 e0       	ldi	r18, 0x03	; 3
    1970:	a2 16       	cp	r10, r18
    1972:	b1 04       	cpc	r11, r1
    1974:	e1 f6       	brne	.-72     	; 0x192e <gc_execute_line+0xdfa>
              }
            }

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
    1976:	c6 01       	movw	r24, r12
    1978:	88 0f       	add	r24, r24
    197a:	99 1f       	adc	r25, r25
    197c:	88 0f       	add	r24, r24
    197e:	99 1f       	adc	r25, r25
    1980:	dc 01       	movw	r26, r24
    1982:	a6 50       	subi	r26, 0x06	; 6
    1984:	ba 4f       	sbci	r27, 0xFA	; 250
    1986:	6d 01       	movw	r12, r26
            float target_r = hypot_f(x,y);
    1988:	2d 91       	ld	r18, X+
    198a:	3d 91       	ld	r19, X+
    198c:	4d 91       	ld	r20, X+
    198e:	5c 91       	ld	r21, X
    1990:	6f a1       	ldd	r22, Y+39	; 0x27
    1992:	78 a5       	ldd	r23, Y+40	; 0x28
    1994:	89 a5       	ldd	r24, Y+41	; 0x29
    1996:	9a a5       	ldd	r25, Y+42	; 0x2a
    1998:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    199c:	4b 01       	movw	r8, r22
    199e:	5c 01       	movw	r10, r24
                if (ijk_words & bit(idx)) { gc_block.values.ijk[idx] *= MM_PER_INCH; }
              }
            }

            // Arc radius from center to target
            x -= gc_block.values.ijk[axis_0]; // Delta x between circle center and target
    19a0:	0c a5       	ldd	r16, Y+44	; 0x2c
    19a2:	1d a5       	ldd	r17, Y+45	; 0x2d
    19a4:	00 0f       	add	r16, r16
    19a6:	11 1f       	adc	r17, r17
    19a8:	00 0f       	add	r16, r16
    19aa:	11 1f       	adc	r17, r17
    19ac:	06 50       	subi	r16, 0x06	; 6
    19ae:	1a 4f       	sbci	r17, 0xFA	; 250
            y -= gc_block.values.ijk[axis_1]; // Delta y between circle center and target
            float target_r = hypot_f(x,y);
    19b0:	f8 01       	movw	r30, r16
    19b2:	20 81       	ld	r18, Z
    19b4:	31 81       	ldd	r19, Z+1	; 0x01
    19b6:	42 81       	ldd	r20, Z+2	; 0x02
    19b8:	53 81       	ldd	r21, Z+3	; 0x03
    19ba:	6b a1       	ldd	r22, Y+35	; 0x23
    19bc:	7c a1       	ldd	r23, Y+36	; 0x24
    19be:	8d a1       	ldd	r24, Y+37	; 0x25
    19c0:	9e a1       	ldd	r25, Y+38	; 0x26
    19c2:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    19c6:	a5 01       	movw	r20, r10
    19c8:	94 01       	movw	r18, r8
    19ca:	0e 94 eb 2a 	call	0x55d6	; 0x55d6 <hypot_f>
    19ce:	4b 01       	movw	r8, r22
    19d0:	5c 01       	movw	r10, r24

            // Compute arc radius for mc_arc. Defined from current location to center.
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]);
    19d2:	d6 01       	movw	r26, r12
    19d4:	2d 91       	ld	r18, X+
    19d6:	3d 91       	ld	r19, X+
    19d8:	4d 91       	ld	r20, X+
    19da:	5c 91       	ld	r21, X
    19dc:	f8 01       	movw	r30, r16
    19de:	60 81       	ld	r22, Z
    19e0:	71 81       	ldd	r23, Z+1	; 0x01
    19e2:	82 81       	ldd	r24, Z+2	; 0x02
    19e4:	93 81       	ldd	r25, Z+3	; 0x03
    19e6:	0e 94 eb 2a 	call	0x55d6	; 0x55d6 <hypot_f>
    19ea:	2b 01       	movw	r4, r22
    19ec:	3c 01       	movw	r6, r24
    19ee:	60 93 0f 06 	sts	0x060F, r22	; 0x80060f <gc_block+0x25>
    19f2:	70 93 10 06 	sts	0x0610, r23	; 0x800610 <gc_block+0x26>
    19f6:	80 93 11 06 	sts	0x0611, r24	; 0x800611 <gc_block+0x27>
    19fa:	90 93 12 06 	sts	0x0612, r25	; 0x800612 <gc_block+0x28>

            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
    19fe:	9b 01       	movw	r18, r22
    1a00:	ac 01       	movw	r20, r24
    1a02:	c5 01       	movw	r24, r10
    1a04:	b4 01       	movw	r22, r8
    1a06:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    1a0a:	4b 01       	movw	r8, r22
    1a0c:	5c 01       	movw	r10, r24
    1a0e:	e8 94       	clt
    1a10:	b7 f8       	bld	r11, 7
            if (delta_r > 0.005) {
    1a12:	2a e0       	ldi	r18, 0x0A	; 10
    1a14:	37 ed       	ldi	r19, 0xD7	; 215
    1a16:	43 ea       	ldi	r20, 0xA3	; 163
    1a18:	5b e3       	ldi	r21, 0x3B	; 59
    1a1a:	c5 01       	movw	r24, r10
    1a1c:	b4 01       	movw	r22, r8
    1a1e:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    1a22:	18 16       	cp	r1, r24
    1a24:	c4 f5       	brge	.+112    	; 0x1a96 <gc_execute_line+0xf62>
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    1a26:	20 e0       	ldi	r18, 0x00	; 0
    1a28:	30 e0       	ldi	r19, 0x00	; 0
    1a2a:	40 e0       	ldi	r20, 0x00	; 0
    1a2c:	5f e3       	ldi	r21, 0x3F	; 63
    1a2e:	c5 01       	movw	r24, r10
    1a30:	b4 01       	movw	r22, r8
    1a32:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    1a36:	18 16       	cp	r1, r24
    1a38:	0c f4       	brge	.+2      	; 0x1a3c <gc_execute_line+0xf08>
    1a3a:	00 c3       	rjmp	.+1536   	; 0x203c <gc_execute_line+0x1508>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    1a3c:	2f e6       	ldi	r18, 0x6F	; 111
    1a3e:	32 e1       	ldi	r19, 0x12	; 18
    1a40:	43 e8       	ldi	r20, 0x83	; 131
    1a42:	5a e3       	ldi	r21, 0x3A	; 58
    1a44:	c3 01       	movw	r24, r6
    1a46:	b2 01       	movw	r22, r4
    1a48:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    1a4c:	9b 01       	movw	r18, r22
    1a4e:	ac 01       	movw	r20, r24
    1a50:	c5 01       	movw	r24, r10
    1a52:	b4 01       	movw	r22, r8
    1a54:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    1a58:	18 16       	cp	r1, r24
    1a5a:	0c f4       	brge	.+2      	; 0x1a5e <gc_execute_line+0xf2a>
    1a5c:	f1 c2       	rjmp	.+1506   	; 0x2040 <gc_execute_line+0x150c>
    1a5e:	1b c0       	rjmp	.+54     	; 0x1a96 <gc_execute_line+0xf62>
            }
          }
          break;
        case MOTION_MODE_PROBE_TOWARD_NO_ERROR: case MOTION_MODE_PROBE_AWAY_NO_ERROR:
          gc_parser_flags |= GC_PARSER_PROBE_IS_NO_ERROR; // No break intentional.
    1a60:	f8 a1       	ldd	r31, Y+32	; 0x20
    1a62:	f0 61       	ori	r31, 0x10	; 16
    1a64:	f8 a3       	std	Y+32, r31	; 0x20
        case MOTION_MODE_PROBE_TOWARD: case MOTION_MODE_PROBE_AWAY:
          if ((gc_block.modal.motion == MOTION_MODE_PROBE_AWAY) || 
    1a66:	1e 58       	subi	r17, 0x8E	; 142
    1a68:	12 30       	cpi	r17, 0x02	; 2
    1a6a:	18 f4       	brcc	.+6      	; 0x1a72 <gc_execute_line+0xf3e>
              (gc_block.modal.motion == MOTION_MODE_PROBE_AWAY_NO_ERROR)) { gc_parser_flags |= GC_PARSER_PROBE_IS_AWAY; }
    1a6c:	28 a1       	ldd	r18, Y+32	; 0x20
    1a6e:	28 60       	ori	r18, 0x08	; 8
    1a70:	28 a3       	std	Y+32, r18	; 0x20
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    1a72:	3d 8d       	ldd	r19, Y+29	; 0x1d
    1a74:	33 23       	and	r19, r19
    1a76:	09 f4       	brne	.+2      	; 0x1a7a <gc_execute_line+0xf46>
    1a78:	e5 c2       	rjmp	.+1482   	; 0x2044 <gc_execute_line+0x1510>
          if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    1a7a:	4c e0       	ldi	r20, 0x0C	; 12
    1a7c:	50 e0       	ldi	r21, 0x00	; 0
    1a7e:	68 e1       	ldi	r22, 0x18	; 24
    1a80:	76 e0       	ldi	r23, 0x06	; 6
    1a82:	82 ec       	ldi	r24, 0xC2	; 194
    1a84:	95 e0       	ldi	r25, 0x05	; 5
    1a86:	0e 94 e4 32 	call	0x65c8	; 0x65c8 <memcmp>
    1a8a:	89 2b       	or	r24, r25
    1a8c:	09 f4       	brne	.+2      	; 0x1a90 <gc_execute_line+0xf5c>
    1a8e:	dc c2       	rjmp	.+1464   	; 0x2048 <gc_execute_line+0x1514>
    1a90:	02 c0       	rjmp	.+4      	; 0x1a96 <gc_execute_line+0xf62>
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    1a92:	1b 8e       	std	Y+27, r1	; 0x1b
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
            }
          } else {
            axis_command = AXIS_COMMAND_NONE; // Set to none if no intermediate motion.
    1a94:	1e 8e       	std	Y+30, r1	; 0x1e

  // [21. Program flow ]: No error checks required.

  // [0. Non-specific error-checks]: Complete unused value words check, i.e. IJK used when in arc
  // radius mode, or axis words that aren't used in the block.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    1a96:	48 a1       	ldd	r20, Y+32	; 0x20
    1a98:	41 70       	andi	r20, 0x01	; 1
    1a9a:	d4 2e       	mov	r13, r20
    1a9c:	88 a1       	ldd	r24, Y+32	; 0x20
    1a9e:	80 ff       	sbrs	r24, 0
    1aa0:	03 c0       	rjmp	.+6      	; 0x1aa8 <gc_execute_line+0xf74>
    // Jogging only uses the F feed rate and XYZ value words. N is valid, but S and T are invalid.
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)));
    1aa2:	c1 01       	movw	r24, r2
    1aa4:	8e 7d       	andi	r24, 0xDE	; 222
    1aa6:	03 c0       	rjmp	.+6      	; 0x1aae <gc_execute_line+0xf7a>
  } else {
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words.
    1aa8:	c1 01       	movw	r24, r2
    1aaa:	8e 7d       	andi	r24, 0xDE	; 222
    1aac:	9c 7f       	andi	r25, 0xFC	; 252
  }
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words.
    1aae:	ae 8d       	ldd	r26, Y+30	; 0x1e
    1ab0:	a1 11       	cpse	r26, r1
    1ab2:	93 7e       	andi	r25, 0xE3	; 227
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    1ab4:	89 2b       	or	r24, r25
    1ab6:	09 f0       	breq	.+2      	; 0x1aba <gc_execute_line+0xf86>
    1ab8:	c9 c2       	rjmp	.+1426   	; 0x204c <gc_execute_line+0x1518>
  */

  // Initialize planner data struct for motion blocks.
  plan_line_data_t plan_data;
  plan_line_data_t *pl_data = &plan_data;
  memset(pl_data,0,sizeof(plan_line_data_t)); // Zero pl_data struct
    1aba:	fe 01       	movw	r30, r28
    1abc:	72 96       	adiw	r30, 0x12	; 18
    1abe:	89 e0       	ldi	r24, 0x09	; 9
    1ac0:	df 01       	movw	r26, r30
    1ac2:	1d 92       	st	X+, r1
    1ac4:	8a 95       	dec	r24
    1ac6:	e9 f7       	brne	.-6      	; 0x1ac2 <gc_execute_line+0xf8e>

  // Intercept jog commands and complete error checking for valid jog commands and execute.
  // NOTE: G-code parser state is not updated, except the position to ensure sequential jog
  // targets are computed correctly. The final parser position after a jog is updated in
  // protocol_execute_realtime() when jogging completes or is canceled.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    1ac8:	dd 20       	and	r13, r13
    1aca:	59 f1       	breq	.+86     	; 0x1b22 <gc_execute_line+0xfee>
    // Only distance and unit modal commands and G53 absolute override command are allowed.
    // NOTE: Feed rate word and axis word checks have already been performed in STEP 3.
    if (command_words & ~(bit(MODAL_GROUP_G3) | bit(MODAL_GROUP_G6) | bit(MODAL_GROUP_G0)) ) { FAIL(STATUS_INVALID_JOG_COMMAND) };
    1acc:	b6 eb       	ldi	r27, 0xB6	; 182
    1ace:	eb 22       	and	r14, r27
    1ad0:	ef 28       	or	r14, r15
    1ad2:	09 f0       	breq	.+2      	; 0x1ad6 <gc_execute_line+0xfa2>
    1ad4:	bd c2       	rjmp	.+1402   	; 0x2050 <gc_execute_line+0x151c>
    if (!(gc_block.non_modal_command == NON_MODAL_ABSOLUTE_OVERRIDE || gc_block.non_modal_command == NON_MODAL_NO_ACTION)) { FAIL(STATUS_INVALID_JOG_COMMAND); }
    1ad6:	80 91 ea 05 	lds	r24, 0x05EA	; 0x8005ea <gc_block>
    1ada:	85 33       	cpi	r24, 0x35	; 53
    1adc:	11 f0       	breq	.+4      	; 0x1ae2 <gc_execute_line+0xfae>
    1ade:	81 11       	cpse	r24, r1
    1ae0:	b9 c2       	rjmp	.+1394   	; 0x2054 <gc_execute_line+0x1520>

    // Initialize planner data to current spindle and coolant modal state.
    pl_data->spindle_speed = gc_state.spindle_speed;
    1ae2:	ea ea       	ldi	r30, 0xAA	; 170
    1ae4:	f5 e0       	ldi	r31, 0x05	; 5
    1ae6:	83 85       	ldd	r24, Z+11	; 0x0b
    1ae8:	94 85       	ldd	r25, Z+12	; 0x0c
    1aea:	a5 85       	ldd	r26, Z+13	; 0x0d
    1aec:	b6 85       	ldd	r27, Z+14	; 0x0e
    1aee:	8e 8b       	std	Y+22, r24	; 0x16
    1af0:	9f 8b       	std	Y+23, r25	; 0x17
    1af2:	a8 8f       	std	Y+24, r26	; 0x18
    1af4:	b9 8f       	std	Y+25, r27	; 0x19
    plan_data.condition = (gc_state.modal.spindle | gc_state.modal.coolant);
    1af6:	91 85       	ldd	r25, Z+9	; 0x09
    1af8:	80 85       	ldd	r24, Z+8	; 0x08
    1afa:	89 2b       	or	r24, r25
    1afc:	8a 8f       	std	Y+26, r24	; 0x1a

    uint8_t status = jog_execute(&plan_data, &gc_block);
    1afe:	6a ee       	ldi	r22, 0xEA	; 234
    1b00:	75 e0       	ldi	r23, 0x05	; 5
    1b02:	ce 01       	movw	r24, r28
    1b04:	42 96       	adiw	r24, 0x12	; 18
    1b06:	0e 94 90 2c 	call	0x5920	; 0x5920 <jog_execute>
    if (status == STATUS_OK) { memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); }
    1b0a:	81 11       	cpse	r24, r1
    1b0c:	f1 c2       	rjmp	.+1506   	; 0x20f0 <gc_execute_line+0x15bc>
    1b0e:	9c e0       	ldi	r25, 0x0C	; 12
    1b10:	e8 e1       	ldi	r30, 0x18	; 24
    1b12:	f6 e0       	ldi	r31, 0x06	; 6
    1b14:	a2 ec       	ldi	r26, 0xC2	; 194
    1b16:	b5 e0       	ldi	r27, 0x05	; 5
    1b18:	01 90       	ld	r0, Z+
    1b1a:	0d 92       	st	X+, r0
    1b1c:	9a 95       	dec	r25
    1b1e:	e1 f7       	brne	.-8      	; 0x1b18 <gc_execute_line+0xfe4>
    1b20:	e7 c2       	rjmp	.+1486   	; 0x20f0 <gc_execute_line+0x15bc>
    return(status);
  }
  
  // If in laser mode, setup laser power based on current and past parser conditions.
  if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    1b22:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <settings+0x45>
    1b26:	81 ff       	sbrs	r24, 1
    1b28:	26 c0       	rjmp	.+76     	; 0x1b76 <gc_execute_line+0x1042>
    if ( !((gc_block.modal.motion == MOTION_MODE_LINEAR) || (gc_block.modal.motion == MOTION_MODE_CW_ARC) 
    1b2a:	80 91 eb 05 	lds	r24, 0x05EB	; 0x8005eb <gc_block+0x1>
    1b2e:	81 50       	subi	r24, 0x01	; 1
    1b30:	83 30       	cpi	r24, 0x03	; 3
    1b32:	18 f0       	brcs	.+6      	; 0x1b3a <gc_execute_line+0x1006>
        || (gc_block.modal.motion == MOTION_MODE_CCW_ARC)) ) {
      gc_parser_flags |= GC_PARSER_LASER_DISABLE;
    1b34:	e8 a1       	ldd	r30, Y+32	; 0x20
    1b36:	e0 64       	ori	r30, 0x40	; 64
    1b38:	e8 a3       	std	Y+32, r30	; 0x20
    }

    // Any motion mode with axis words is allowed to be passed from a spindle speed update. 
    // NOTE: G1 and G0 without axis words sets axis_command to none. G28/30 are intentionally omitted.
    // TODO: Check sync conditions for M3 enabled motions that don't enter the planner. (zero length).
    if (axis_words && (axis_command == AXIS_COMMAND_MOTION_MODE)) { 
    1b3a:	fd 8d       	ldd	r31, Y+29	; 0x1d
    1b3c:	ff 23       	and	r31, r31
    1b3e:	39 f0       	breq	.+14     	; 0x1b4e <gc_execute_line+0x101a>
    1b40:	2e 8d       	ldd	r18, Y+30	; 0x1e
    1b42:	22 30       	cpi	r18, 0x02	; 2
    1b44:	21 f4       	brne	.+8      	; 0x1b4e <gc_execute_line+0x101a>
      gc_parser_flags |= GC_PARSER_LASER_ISMOTION; 
    1b46:	38 a1       	ldd	r19, Y+32	; 0x20
    1b48:	30 68       	ori	r19, 0x80	; 128
    1b4a:	38 a3       	std	Y+32, r19	; 0x20
    1b4c:	14 c0       	rjmp	.+40     	; 0x1b76 <gc_execute_line+0x1042>
    } else {
      // M3 constant power laser requires planner syncs to update the laser when changing between
      // a G1/2/3 motion mode state and vice versa when there is no motion in the line.
      if (gc_state.modal.spindle == SPINDLE_ENABLE_CW) {
    1b4e:	80 91 b3 05 	lds	r24, 0x05B3	; 0x8005b3 <gc_state+0x9>
    1b52:	80 31       	cpi	r24, 0x10	; 16
    1b54:	81 f4       	brne	.+32     	; 0x1b76 <gc_execute_line+0x1042>
        if ((gc_state.modal.motion == MOTION_MODE_LINEAR) || (gc_state.modal.motion == MOTION_MODE_CW_ARC) 
    1b56:	80 91 aa 05 	lds	r24, 0x05AA	; 0x8005aa <gc_state>
    1b5a:	81 50       	subi	r24, 0x01	; 1
    1b5c:	83 30       	cpi	r24, 0x03	; 3
    1b5e:	30 f4       	brcc	.+12     	; 0x1b6c <gc_execute_line+0x1038>
            || (gc_state.modal.motion == MOTION_MODE_CCW_ARC)) {
          if (bit_istrue(gc_parser_flags,GC_PARSER_LASER_DISABLE)) { 
    1b60:	48 a1       	ldd	r20, Y+32	; 0x20
    1b62:	46 ff       	sbrs	r20, 6
    1b64:	08 c0       	rjmp	.+16     	; 0x1b76 <gc_execute_line+0x1042>
            gc_parser_flags |= GC_PARSER_LASER_FORCE_SYNC; // Change from G1/2/3 motion mode.
    1b66:	40 62       	ori	r20, 0x20	; 32
    1b68:	48 a3       	std	Y+32, r20	; 0x20
    1b6a:	05 c0       	rjmp	.+10     	; 0x1b76 <gc_execute_line+0x1042>
          }
        } else {
          // When changing to a G1 motion mode without axis words from a non-G1/2/3 motion mode.
          if (bit_isfalse(gc_parser_flags,GC_PARSER_LASER_DISABLE)) { 
    1b6c:	88 a1       	ldd	r24, Y+32	; 0x20
    1b6e:	86 fd       	sbrc	r24, 6
    1b70:	02 c0       	rjmp	.+4      	; 0x1b76 <gc_execute_line+0x1042>
            gc_parser_flags |= GC_PARSER_LASER_FORCE_SYNC;
    1b72:	80 62       	ori	r24, 0x20	; 32
    1b74:	88 a3       	std	Y+32, r24	; 0x20
    }
  }

  // [0. Non-specific/common error-checks and miscellaneous setup]:
  // NOTE: If no line number is present, the value is zero.
  gc_state.line_number = gc_block.values.n;
    1b76:	ea ea       	ldi	r30, 0xAA	; 170
    1b78:	f5 e0       	ldi	r31, 0x05	; 5
    1b7a:	aa ee       	ldi	r26, 0xEA	; 234
    1b7c:	b5 e0       	ldi	r27, 0x05	; 5
    1b7e:	5d 96       	adiw	r26, 0x1d	; 29
    1b80:	4d 91       	ld	r20, X+
    1b82:	5d 91       	ld	r21, X+
    1b84:	6d 91       	ld	r22, X+
    1b86:	7c 91       	ld	r23, X
    1b88:	90 97       	sbiw	r26, 0x20	; 32
    1b8a:	44 8b       	std	Z+20, r20	; 0x14
    1b8c:	55 8b       	std	Z+21, r21	; 0x15
    1b8e:	66 8b       	std	Z+22, r22	; 0x16
    1b90:	77 8b       	std	Z+23, r23	; 0x17
  #endif

  // [1. Comments feedback ]:  NOT SUPPORTED

  // [2. Set feed rate mode ]:
  gc_state.modal.feed_rate = gc_block.modal.feed_rate;
    1b92:	12 96       	adiw	r26, 0x02	; 2
    1b94:	8c 91       	ld	r24, X
    1b96:	81 83       	std	Z+1, r24	; 0x01
  if (gc_state.modal.feed_rate) { pl_data->condition |= PL_COND_FLAG_INVERSE_TIME; } // Set condition flag for planner use.
    1b98:	88 23       	and	r24, r24
    1b9a:	11 f0       	breq	.+4      	; 0x1ba0 <gc_execute_line+0x106c>
    1b9c:	88 e0       	ldi	r24, 0x08	; 8
    1b9e:	8a 8f       	std	Y+26, r24	; 0x1a

  // [3. Set feed rate ]:
  gc_state.feed_rate = gc_block.values.f; // Always copy this value. See feed rate error-checking.
    1ba0:	aa ee       	ldi	r26, 0xEA	; 234
    1ba2:	b5 e0       	ldi	r27, 0x05	; 5
    1ba4:	1c 96       	adiw	r26, 0x0c	; 12
    1ba6:	4d 91       	ld	r20, X+
    1ba8:	5d 91       	ld	r21, X+
    1baa:	6d 91       	ld	r22, X+
    1bac:	7c 91       	ld	r23, X
    1bae:	1f 97       	sbiw	r26, 0x0f	; 15
    1bb0:	ea ea       	ldi	r30, 0xAA	; 170
    1bb2:	f5 e0       	ldi	r31, 0x05	; 5
    1bb4:	47 87       	std	Z+15, r20	; 0x0f
    1bb6:	50 8b       	std	Z+16, r21	; 0x10
    1bb8:	61 8b       	std	Z+17, r22	; 0x11
    1bba:	72 8b       	std	Z+18, r23	; 0x12
  pl_data->feed_rate = gc_state.feed_rate; // Record data for planner use.
    1bbc:	4a 8b       	std	Y+18, r20	; 0x12
    1bbe:	5b 8b       	std	Y+19, r21	; 0x13
    1bc0:	6c 8b       	std	Y+20, r22	; 0x14
    1bc2:	7d 8b       	std	Y+21, r23	; 0x15

  // [4. Set spindle speed ]:
  if ((gc_state.spindle_speed != gc_block.values.s) || bit_istrue(gc_parser_flags,GC_PARSER_LASER_FORCE_SYNC)) {
    1bc4:	99 96       	adiw	r26, 0x29	; 41
    1bc6:	8d 90       	ld	r8, X+
    1bc8:	9d 90       	ld	r9, X+
    1bca:	ad 90       	ld	r10, X+
    1bcc:	bc 90       	ld	r11, X
    1bce:	9c 97       	sbiw	r26, 0x2c	; 44
    1bd0:	a5 01       	movw	r20, r10
    1bd2:	94 01       	movw	r18, r8
    1bd4:	63 85       	ldd	r22, Z+11	; 0x0b
    1bd6:	74 85       	ldd	r23, Z+12	; 0x0c
    1bd8:	85 85       	ldd	r24, Z+13	; 0x0d
    1bda:	96 85       	ldd	r25, Z+14	; 0x0e
    1bdc:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    1be0:	81 11       	cpse	r24, r1
    1be2:	03 c0       	rjmp	.+6      	; 0x1bea <gc_execute_line+0x10b6>
    1be4:	98 a1       	ldd	r25, Y+32	; 0x20
    1be6:	95 ff       	sbrs	r25, 5
    1be8:	23 c0       	rjmp	.+70     	; 0x1c30 <gc_execute_line+0x10fc>
    if (gc_state.modal.spindle != SPINDLE_DISABLE) { 
    1bea:	80 91 b3 05 	lds	r24, 0x05B3	; 0x8005b3 <gc_state+0x9>
    1bee:	88 23       	and	r24, r24
    1bf0:	79 f0       	breq	.+30     	; 0x1c10 <gc_execute_line+0x10dc>
      #ifdef VARIABLE_SPINDLE
        if (bit_isfalse(gc_parser_flags,GC_PARSER_LASER_ISMOTION)) {
    1bf2:	a8 a1       	ldd	r26, Y+32	; 0x20
    1bf4:	aa 23       	and	r26, r26
    1bf6:	64 f0       	brlt	.+24     	; 0x1c10 <gc_execute_line+0x10dc>
          if (bit_istrue(gc_parser_flags,GC_PARSER_LASER_DISABLE)) {
    1bf8:	a6 ff       	sbrs	r26, 6
    1bfa:	06 c0       	rjmp	.+12     	; 0x1c08 <gc_execute_line+0x10d4>
             spindle_sync(gc_state.modal.spindle, 0.0);
    1bfc:	40 e0       	ldi	r20, 0x00	; 0
    1bfe:	50 e0       	ldi	r21, 0x00	; 0
    1c00:	ba 01       	movw	r22, r20
    1c02:	0e 94 99 11 	call	0x2332	; 0x2332 <spindle_sync>
    1c06:	04 c0       	rjmp	.+8      	; 0x1c10 <gc_execute_line+0x10dc>
          } else { spindle_sync(gc_state.modal.spindle, gc_block.values.s); }
    1c08:	b5 01       	movw	r22, r10
    1c0a:	a4 01       	movw	r20, r8
    1c0c:	0e 94 99 11 	call	0x2332	; 0x2332 <spindle_sync>
        }
      #else
        spindle_sync(gc_state.modal.spindle, 0.0);
      #endif
    }
    gc_state.spindle_speed = gc_block.values.s; // Update spindle speed state.
    1c10:	80 91 13 06 	lds	r24, 0x0613	; 0x800613 <gc_block+0x29>
    1c14:	90 91 14 06 	lds	r25, 0x0614	; 0x800614 <gc_block+0x2a>
    1c18:	a0 91 15 06 	lds	r26, 0x0615	; 0x800615 <gc_block+0x2b>
    1c1c:	b0 91 16 06 	lds	r27, 0x0616	; 0x800616 <gc_block+0x2c>
    1c20:	80 93 b5 05 	sts	0x05B5, r24	; 0x8005b5 <gc_state+0xb>
    1c24:	90 93 b6 05 	sts	0x05B6, r25	; 0x8005b6 <gc_state+0xc>
    1c28:	a0 93 b7 05 	sts	0x05B7, r26	; 0x8005b7 <gc_state+0xd>
    1c2c:	b0 93 b8 05 	sts	0x05B8, r27	; 0x8005b8 <gc_state+0xe>
  }
  // NOTE: Pass zero spindle speed for all restricted laser motions.
  if (bit_isfalse(gc_parser_flags,GC_PARSER_LASER_DISABLE)) {
    1c30:	b8 a1       	ldd	r27, Y+32	; 0x20
    1c32:	b6 fd       	sbrc	r27, 6
    1c34:	0c c0       	rjmp	.+24     	; 0x1c4e <gc_execute_line+0x111a>
    pl_data->spindle_speed = gc_state.spindle_speed; // Record data for planner use. 
    1c36:	80 91 b5 05 	lds	r24, 0x05B5	; 0x8005b5 <gc_state+0xb>
    1c3a:	90 91 b6 05 	lds	r25, 0x05B6	; 0x8005b6 <gc_state+0xc>
    1c3e:	a0 91 b7 05 	lds	r26, 0x05B7	; 0x8005b7 <gc_state+0xd>
    1c42:	b0 91 b8 05 	lds	r27, 0x05B8	; 0x8005b8 <gc_state+0xe>
    1c46:	8e 8b       	std	Y+22, r24	; 0x16
    1c48:	9f 8b       	std	Y+23, r25	; 0x17
    1c4a:	a8 8f       	std	Y+24, r26	; 0x18
    1c4c:	b9 8f       	std	Y+25, r27	; 0x19
  } // else { pl_data->spindle_speed = 0.0; } // Initialized as zero already.
  
  // [5. Select tool ]: NOT SUPPORTED. Only tracks tool value.
  gc_state.tool = gc_block.values.t;
    1c4e:	ea ea       	ldi	r30, 0xAA	; 170
    1c50:	f5 e0       	ldi	r31, 0x05	; 5
    1c52:	aa ee       	ldi	r26, 0xEA	; 234
    1c54:	b5 e0       	ldi	r27, 0x05	; 5
    1c56:	9d 96       	adiw	r26, 0x2d	; 45
    1c58:	8c 91       	ld	r24, X
    1c5a:	9d 97       	sbiw	r26, 0x2d	; 45
    1c5c:	83 8b       	std	Z+19, r24	; 0x13

  // [6. Change tool ]: NOT SUPPORTED

  // [7. Spindle control ]:
  if (gc_state.modal.spindle != gc_block.modal.spindle) {
    1c5e:	1a 96       	adiw	r26, 0x0a	; 10
    1c60:	8c 91       	ld	r24, X
    1c62:	91 85       	ldd	r25, Z+9	; 0x09
    1c64:	98 17       	cp	r25, r24
    1c66:	51 f0       	breq	.+20     	; 0x1c7c <gc_execute_line+0x1148>
    // Update spindle control and apply spindle speed when enabling it in this block.
    // NOTE: All spindle state changes are synced, even in laser mode. Also, pl_data,
    // rather than gc_state, is used to manage laser state for non-laser motions.
    spindle_sync(gc_block.modal.spindle, pl_data->spindle_speed);
    1c68:	4e 89       	ldd	r20, Y+22	; 0x16
    1c6a:	5f 89       	ldd	r21, Y+23	; 0x17
    1c6c:	68 8d       	ldd	r22, Y+24	; 0x18
    1c6e:	79 8d       	ldd	r23, Y+25	; 0x19
    1c70:	0e 94 99 11 	call	0x2332	; 0x2332 <spindle_sync>
    gc_state.modal.spindle = gc_block.modal.spindle;
    1c74:	80 91 f4 05 	lds	r24, 0x05F4	; 0x8005f4 <gc_block+0xa>
    1c78:	80 93 b3 05 	sts	0x05B3, r24	; 0x8005b3 <gc_state+0x9>
  }
  pl_data->condition |= gc_state.modal.spindle; // Set condition flag for planner use.
    1c7c:	ea ea       	ldi	r30, 0xAA	; 170
    1c7e:	f5 e0       	ldi	r31, 0x05	; 5
    1c80:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1c82:	81 85       	ldd	r24, Z+9	; 0x09
    1c84:	89 2b       	or	r24, r25
    1c86:	8a 8f       	std	Y+26, r24	; 0x1a

  // [8. Coolant control ]:
  if (gc_state.modal.coolant != gc_block.modal.coolant) {
    1c88:	80 91 f3 05 	lds	r24, 0x05F3	; 0x8005f3 <gc_block+0x9>
    1c8c:	90 85       	ldd	r25, Z+8	; 0x08
    1c8e:	98 17       	cp	r25, r24
    1c90:	31 f0       	breq	.+12     	; 0x1c9e <gc_execute_line+0x116a>
    // NOTE: Coolant M-codes are modal. Only one command per line is allowed. But, multiple states
    // can exist at the same time, while coolant disable clears all states.
    coolant_sync(gc_block.modal.coolant);
    1c92:	0e 94 ca 11 	call	0x2394	; 0x2394 <coolant_sync>
    gc_state.modal.coolant = gc_block.modal.coolant;
    1c96:	80 91 f3 05 	lds	r24, 0x05F3	; 0x8005f3 <gc_block+0x9>
    1c9a:	80 93 b2 05 	sts	0x05B2, r24	; 0x8005b2 <gc_state+0x8>
  }
  pl_data->condition |= gc_state.modal.coolant; // Set condition flag for planner use.
    1c9e:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1ca0:	80 91 b2 05 	lds	r24, 0x05B2	; 0x8005b2 <gc_state+0x8>
    1ca4:	89 2b       	or	r24, r25
    1ca6:	8a 8f       	std	Y+26, r24	; 0x1a
      mc_override_ctrl_update(gc_state.modal.override);
    }
  #endif

  // [10. Dwell ]:
  if (gc_block.non_modal_command == NON_MODAL_DWELL) { mc_dwell(gc_block.values.p); }
    1ca8:	80 91 ea 05 	lds	r24, 0x05EA	; 0x8005ea <gc_block>
    1cac:	84 30       	cpi	r24, 0x04	; 4
    1cae:	51 f4       	brne	.+20     	; 0x1cc4 <gc_execute_line+0x1190>
    1cb0:	60 91 0b 06 	lds	r22, 0x060B	; 0x80060b <gc_block+0x21>
    1cb4:	70 91 0c 06 	lds	r23, 0x060C	; 0x80060c <gc_block+0x22>
    1cb8:	80 91 0d 06 	lds	r24, 0x060D	; 0x80060d <gc_block+0x23>
    1cbc:	90 91 0e 06 	lds	r25, 0x060E	; 0x80060e <gc_block+0x24>
    1cc0:	0e 94 cf 04 	call	0x99e	; 0x99e <mc_dwell>

  // [11. Set active plane ]:
  gc_state.modal.plane_select = gc_block.modal.plane_select;
    1cc4:	ea ea       	ldi	r30, 0xAA	; 170
    1cc6:	f5 e0       	ldi	r31, 0x05	; 5
    1cc8:	aa ee       	ldi	r26, 0xEA	; 234
    1cca:	b5 e0       	ldi	r27, 0x05	; 5
    1ccc:	15 96       	adiw	r26, 0x05	; 5
    1cce:	8c 91       	ld	r24, X
    1cd0:	15 97       	sbiw	r26, 0x05	; 5
    1cd2:	84 83       	std	Z+4, r24	; 0x04

  // [12. Set length units ]:
  gc_state.modal.units = gc_block.modal.units;
    1cd4:	13 96       	adiw	r26, 0x03	; 3
    1cd6:	8c 91       	ld	r24, X
    1cd8:	82 83       	std	Z+2, r24	; 0x02

  // [14. Cutter length compensation ]: G43.1 and G49 supported. G43 NOT SUPPORTED.
  // NOTE: If G43 were supported, its operation wouldn't be any different from G43.1 in terms
  // of execution. The error-checking step would simply load the offset value into the correct
  // axis of the block XYZ value array.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates a change.
    1cda:	ee 8d       	ldd	r30, Y+30	; 0x1e
    1cdc:	e3 30       	cpi	r30, 0x03	; 3
    1cde:	71 f5       	brne	.+92     	; 0x1d3c <gc_execute_line+0x1208>
    gc_state.modal.tool_length = gc_block.modal.tool_length;
    1ce0:	80 91 f0 05 	lds	r24, 0x05F0	; 0x8005f0 <gc_block+0x6>
    1ce4:	80 93 af 05 	sts	0x05AF, r24	; 0x8005af <gc_state+0x5>
    if (gc_state.modal.tool_length == TOOL_LENGTH_OFFSET_CANCEL) { // G49
    1ce8:	81 11       	cpse	r24, r1
    1cea:	08 c0       	rjmp	.+16     	; 0x1cfc <gc_execute_line+0x11c8>
      gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS] = 0.0;
    1cec:	10 92 20 06 	sts	0x0620, r1	; 0x800620 <gc_block+0x36>
    1cf0:	10 92 21 06 	sts	0x0621, r1	; 0x800621 <gc_block+0x37>
    1cf4:	10 92 22 06 	sts	0x0622, r1	; 0x800622 <gc_block+0x38>
    1cf8:	10 92 23 06 	sts	0x0623, r1	; 0x800623 <gc_block+0x39>
    } // else G43.1
    if ( gc_state.tool_length_offset != gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS] ) {
    1cfc:	80 90 20 06 	lds	r8, 0x0620	; 0x800620 <gc_block+0x36>
    1d00:	90 90 21 06 	lds	r9, 0x0621	; 0x800621 <gc_block+0x37>
    1d04:	a0 90 22 06 	lds	r10, 0x0622	; 0x800622 <gc_block+0x38>
    1d08:	b0 90 23 06 	lds	r11, 0x0623	; 0x800623 <gc_block+0x39>
    1d0c:	a5 01       	movw	r20, r10
    1d0e:	94 01       	movw	r18, r8
    1d10:	60 91 e6 05 	lds	r22, 0x05E6	; 0x8005e6 <gc_state+0x3c>
    1d14:	70 91 e7 05 	lds	r23, 0x05E7	; 0x8005e7 <gc_state+0x3d>
    1d18:	80 91 e8 05 	lds	r24, 0x05E8	; 0x8005e8 <gc_state+0x3e>
    1d1c:	90 91 e9 05 	lds	r25, 0x05E9	; 0x8005e9 <gc_state+0x3f>
    1d20:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    1d24:	88 23       	and	r24, r24
    1d26:	51 f0       	breq	.+20     	; 0x1d3c <gc_execute_line+0x1208>
      gc_state.tool_length_offset = gc_block.values.xyz[TOOL_LENGTH_OFFSET_AXIS];
    1d28:	80 92 e6 05 	sts	0x05E6, r8	; 0x8005e6 <gc_state+0x3c>
    1d2c:	90 92 e7 05 	sts	0x05E7, r9	; 0x8005e7 <gc_state+0x3d>
    1d30:	a0 92 e8 05 	sts	0x05E8, r10	; 0x8005e8 <gc_state+0x3e>
    1d34:	b0 92 e9 05 	sts	0x05E9, r11	; 0x8005e9 <gc_state+0x3f>
      system_flag_wco_change();
    1d38:	0e 94 8a 2d 	call	0x5b14	; 0x5b14 <system_flag_wco_change>
    }
  }

  // [15. Coordinate system selection ]:
  if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
    1d3c:	80 91 f1 05 	lds	r24, 0x05F1	; 0x8005f1 <gc_block+0x7>
    1d40:	90 91 b0 05 	lds	r25, 0x05B0	; 0x8005b0 <gc_state+0x6>
    1d44:	98 17       	cp	r25, r24
    1d46:	69 f0       	breq	.+26     	; 0x1d62 <gc_execute_line+0x122e>
    gc_state.modal.coord_select = gc_block.modal.coord_select;
    1d48:	80 93 b0 05 	sts	0x05B0, r24	; 0x8005b0 <gc_state+0x6>
    memcpy(gc_state.coord_system,block_coord_system,N_AXIS*sizeof(float));
    1d4c:	8c e0       	ldi	r24, 0x0C	; 12
    1d4e:	fe 01       	movw	r30, r28
    1d50:	36 96       	adiw	r30, 0x06	; 6
    1d52:	ae ec       	ldi	r26, 0xCE	; 206
    1d54:	b5 e0       	ldi	r27, 0x05	; 5
    1d56:	01 90       	ld	r0, Z+
    1d58:	0d 92       	st	X+, r0
    1d5a:	8a 95       	dec	r24
    1d5c:	e1 f7       	brne	.-8      	; 0x1d56 <gc_execute_line+0x1222>
    system_flag_wco_change();
    1d5e:	0e 94 8a 2d 	call	0x5b14	; 0x5b14 <system_flag_wco_change>

  // [16. Set path control mode ]: G61.1/G64 NOT SUPPORTED
  // gc_state.modal.control = gc_block.modal.control; // NOTE: Always default.

  // [17. Set distance mode ]:
  gc_state.modal.distance = gc_block.modal.distance;
    1d62:	ea ee       	ldi	r30, 0xEA	; 234
    1d64:	f5 e0       	ldi	r31, 0x05	; 5
    1d66:	84 81       	ldd	r24, Z+4	; 0x04
    1d68:	80 93 ad 05 	sts	0x05AD, r24	; 0x8005ad <gc_state+0x3>

  // [18. Set retract mode ]: NOT SUPPORTED

  // [19. Go to predefined position, Set G10, or Set axis offsets ]:
  switch(gc_block.non_modal_command) {
    1d6c:	80 81       	ld	r24, Z
    1d6e:	86 32       	cpi	r24, 0x26	; 38
    1d70:	09 f4       	brne	.+2      	; 0x1d74 <gc_execute_line+0x1240>
    1d72:	46 c0       	rjmp	.+140    	; 0x1e00 <gc_execute_line+0x12cc>
    1d74:	38 f4       	brcc	.+14     	; 0x1d84 <gc_execute_line+0x1250>
    1d76:	8c 31       	cpi	r24, 0x1C	; 28
    1d78:	29 f1       	breq	.+74     	; 0x1dc4 <gc_execute_line+0x1290>
    1d7a:	8e 31       	cpi	r24, 0x1E	; 30
    1d7c:	19 f1       	breq	.+70     	; 0x1dc4 <gc_execute_line+0x1290>
    1d7e:	8a 30       	cpi	r24, 0x0A	; 10
    1d80:	59 f0       	breq	.+22     	; 0x1d98 <gc_execute_line+0x1264>
    1d82:	5f c0       	rjmp	.+190    	; 0x1e42 <gc_execute_line+0x130e>
    1d84:	8c 35       	cpi	r24, 0x5C	; 92
    1d86:	09 f4       	brne	.+2      	; 0x1d8a <gc_execute_line+0x1256>
    1d88:	47 c0       	rjmp	.+142    	; 0x1e18 <gc_execute_line+0x12e4>
    1d8a:	86 36       	cpi	r24, 0x66	; 102
    1d8c:	09 f4       	brne	.+2      	; 0x1d90 <gc_execute_line+0x125c>
    1d8e:	50 c0       	rjmp	.+160    	; 0x1e30 <gc_execute_line+0x12fc>
    1d90:	88 32       	cpi	r24, 0x28	; 40
    1d92:	09 f0       	breq	.+2      	; 0x1d96 <gc_execute_line+0x1262>
    1d94:	56 c0       	rjmp	.+172    	; 0x1e42 <gc_execute_line+0x130e>
    1d96:	3a c0       	rjmp	.+116    	; 0x1e0c <gc_execute_line+0x12d8>
    case NON_MODAL_SET_COORDINATE_DATA:
      settings_write_coord_data(coord_select,gc_block.values.ijk);
    1d98:	6a ef       	ldi	r22, 0xFA	; 250
    1d9a:	75 e0       	ldi	r23, 0x05	; 5
    1d9c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1d9e:	0e 94 b4 22 	call	0x4568	; 0x4568 <settings_write_coord_data>
      // Update system coordinate system if currently active.
      if (gc_state.modal.coord_select == coord_select) {
    1da2:	80 91 b0 05 	lds	r24, 0x05B0	; 0x8005b0 <gc_state+0x6>
    1da6:	fb 8d       	ldd	r31, Y+27	; 0x1b
    1da8:	8f 13       	cpse	r24, r31
    1daa:	4b c0       	rjmp	.+150    	; 0x1e42 <gc_execute_line+0x130e>
        memcpy(gc_state.coord_system,gc_block.values.ijk,N_AXIS*sizeof(float));
    1dac:	8c e0       	ldi	r24, 0x0C	; 12
    1dae:	ea ef       	ldi	r30, 0xFA	; 250
    1db0:	f5 e0       	ldi	r31, 0x05	; 5
    1db2:	ae ec       	ldi	r26, 0xCE	; 206
    1db4:	b5 e0       	ldi	r27, 0x05	; 5
    1db6:	01 90       	ld	r0, Z+
    1db8:	0d 92       	st	X+, r0
    1dba:	8a 95       	dec	r24
    1dbc:	e1 f7       	brne	.-8      	; 0x1db6 <gc_execute_line+0x1282>
        system_flag_wco_change();
    1dbe:	0e 94 8a 2d 	call	0x5b14	; 0x5b14 <system_flag_wco_change>
    1dc2:	3f c0       	rjmp	.+126    	; 0x1e42 <gc_execute_line+0x130e>
      }
      break;
    case NON_MODAL_GO_HOME_0: case NON_MODAL_GO_HOME_1:
      // Move to intermediate position before going home. Obeys current coordinate system and offsets
      // and absolute and incremental modes.
      pl_data->condition |= PL_COND_FLAG_RAPID_MOTION; // Set rapid motion condition flag.
    1dc4:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1dc6:	81 60       	ori	r24, 0x01	; 1
    1dc8:	8a 8f       	std	Y+26, r24	; 0x1a
      if (axis_command) { mc_line(gc_block.values.xyz, pl_data); }
    1dca:	2e 8d       	ldd	r18, Y+30	; 0x1e
    1dcc:	22 23       	and	r18, r18
    1dce:	39 f0       	breq	.+14     	; 0x1dde <gc_execute_line+0x12aa>
    1dd0:	be 01       	movw	r22, r28
    1dd2:	6e 5e       	subi	r22, 0xEE	; 238
    1dd4:	7f 4f       	sbci	r23, 0xFF	; 255
    1dd6:	88 e1       	ldi	r24, 0x18	; 24
    1dd8:	96 e0       	ldi	r25, 0x06	; 6
    1dda:	0e 94 ad 01 	call	0x35a	; 0x35a <mc_line>
      mc_line(gc_block.values.ijk, pl_data);
    1dde:	be 01       	movw	r22, r28
    1de0:	6e 5e       	subi	r22, 0xEE	; 238
    1de2:	7f 4f       	sbci	r23, 0xFF	; 255
    1de4:	8a ef       	ldi	r24, 0xFA	; 250
    1de6:	95 e0       	ldi	r25, 0x05	; 5
    1de8:	0e 94 ad 01 	call	0x35a	; 0x35a <mc_line>
      memcpy(gc_state.position, gc_block.values.ijk, N_AXIS*sizeof(float));
    1dec:	8c e0       	ldi	r24, 0x0C	; 12
    1dee:	ea ef       	ldi	r30, 0xFA	; 250
    1df0:	f5 e0       	ldi	r31, 0x05	; 5
    1df2:	a2 ec       	ldi	r26, 0xC2	; 194
    1df4:	b5 e0       	ldi	r27, 0x05	; 5
    1df6:	01 90       	ld	r0, Z+
    1df8:	0d 92       	st	X+, r0
    1dfa:	8a 95       	dec	r24
    1dfc:	e1 f7       	brne	.-8      	; 0x1df6 <gc_execute_line+0x12c2>
      break;
    1dfe:	21 c0       	rjmp	.+66     	; 0x1e42 <gc_execute_line+0x130e>
    case NON_MODAL_SET_HOME_0:
      settings_write_coord_data(SETTING_INDEX_G28,gc_state.position);
    1e00:	62 ec       	ldi	r22, 0xC2	; 194
    1e02:	75 e0       	ldi	r23, 0x05	; 5
    1e04:	86 e0       	ldi	r24, 0x06	; 6
    1e06:	0e 94 b4 22 	call	0x4568	; 0x4568 <settings_write_coord_data>
      break;
    1e0a:	1b c0       	rjmp	.+54     	; 0x1e42 <gc_execute_line+0x130e>
    case NON_MODAL_SET_HOME_1:
      settings_write_coord_data(SETTING_INDEX_G30,gc_state.position);
    1e0c:	62 ec       	ldi	r22, 0xC2	; 194
    1e0e:	75 e0       	ldi	r23, 0x05	; 5
    1e10:	87 e0       	ldi	r24, 0x07	; 7
    1e12:	0e 94 b4 22 	call	0x4568	; 0x4568 <settings_write_coord_data>
      break;
    1e16:	15 c0       	rjmp	.+42     	; 0x1e42 <gc_execute_line+0x130e>
    case NON_MODAL_SET_COORDINATE_OFFSET:
      memcpy(gc_state.coord_offset,gc_block.values.xyz,sizeof(gc_block.values.xyz));
    1e18:	8c e0       	ldi	r24, 0x0C	; 12
    1e1a:	e8 e1       	ldi	r30, 0x18	; 24
    1e1c:	f6 e0       	ldi	r31, 0x06	; 6
    1e1e:	aa ed       	ldi	r26, 0xDA	; 218
    1e20:	b5 e0       	ldi	r27, 0x05	; 5
    1e22:	01 90       	ld	r0, Z+
    1e24:	0d 92       	st	X+, r0
    1e26:	8a 95       	dec	r24
    1e28:	e1 f7       	brne	.-8      	; 0x1e22 <gc_execute_line+0x12ee>
      system_flag_wco_change();
    1e2a:	0e 94 8a 2d 	call	0x5b14	; 0x5b14 <system_flag_wco_change>
      break;
    1e2e:	09 c0       	rjmp	.+18     	; 0x1e42 <gc_execute_line+0x130e>
    case NON_MODAL_RESET_COORDINATE_OFFSET:
      clear_vector(gc_state.coord_offset); // Disable G92 offsets by zeroing offset vector.
    1e30:	8c e0       	ldi	r24, 0x0C	; 12
    1e32:	ea ed       	ldi	r30, 0xDA	; 218
    1e34:	f5 e0       	ldi	r31, 0x05	; 5
    1e36:	df 01       	movw	r26, r30
    1e38:	1d 92       	st	X+, r1
    1e3a:	8a 95       	dec	r24
    1e3c:	e9 f7       	brne	.-6      	; 0x1e38 <gc_execute_line+0x1304>
      system_flag_wco_change();
    1e3e:	0e 94 8a 2d 	call	0x5b14	; 0x5b14 <system_flag_wco_change>


  // [20. Motion modes ]:
  // NOTE: Commands G10,G28,G30,G92 lock out and prevent axis words from use in motion modes.
  // Enter motion modes only if there are axis words or a motion mode command word in the block.
  gc_state.modal.motion = gc_block.modal.motion;
    1e42:	80 91 eb 05 	lds	r24, 0x05EB	; 0x8005eb <gc_block+0x1>
    1e46:	80 93 aa 05 	sts	0x05AA, r24	; 0x8005aa <gc_state>
  if (gc_state.modal.motion != MOTION_MODE_NONE) {
    1e4a:	80 35       	cpi	r24, 0x50	; 80
    1e4c:	09 f4       	brne	.+2      	; 0x1e50 <gc_execute_line+0x131c>
    1e4e:	56 c0       	rjmp	.+172    	; 0x1efc <gc_execute_line+0x13c8>
    if (axis_command == AXIS_COMMAND_MOTION_MODE) {
    1e50:	be 8d       	ldd	r27, Y+30	; 0x1e
    1e52:	b2 30       	cpi	r27, 0x02	; 2
    1e54:	09 f0       	breq	.+2      	; 0x1e58 <gc_execute_line+0x1324>
    1e56:	52 c0       	rjmp	.+164    	; 0x1efc <gc_execute_line+0x13c8>
      uint8_t gc_update_pos = GC_UPDATE_POS_TARGET;
      if (gc_state.modal.motion == MOTION_MODE_LINEAR) {
    1e58:	81 30       	cpi	r24, 0x01	; 1
    1e5a:	41 f4       	brne	.+16     	; 0x1e6c <gc_execute_line+0x1338>
        mc_line(gc_block.values.xyz, pl_data);
    1e5c:	be 01       	movw	r22, r28
    1e5e:	6e 5e       	subi	r22, 0xEE	; 238
    1e60:	7f 4f       	sbci	r23, 0xFF	; 255
    1e62:	88 e1       	ldi	r24, 0x18	; 24
    1e64:	96 e0       	ldi	r25, 0x06	; 6
    1e66:	0e 94 ad 01 	call	0x35a	; 0x35a <mc_line>
    1e6a:	3a c0       	rjmp	.+116    	; 0x1ee0 <gc_execute_line+0x13ac>
      } else if (gc_state.modal.motion == MOTION_MODE_SEEK) {
    1e6c:	81 11       	cpse	r24, r1
    1e6e:	0b c0       	rjmp	.+22     	; 0x1e86 <gc_execute_line+0x1352>
        pl_data->condition |= PL_COND_FLAG_RAPID_MOTION; // Set rapid motion condition flag.
    1e70:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1e72:	81 60       	ori	r24, 0x01	; 1
    1e74:	8a 8f       	std	Y+26, r24	; 0x1a
        mc_line(gc_block.values.xyz, pl_data);
    1e76:	be 01       	movw	r22, r28
    1e78:	6e 5e       	subi	r22, 0xEE	; 238
    1e7a:	7f 4f       	sbci	r23, 0xFF	; 255
    1e7c:	88 e1       	ldi	r24, 0x18	; 24
    1e7e:	96 e0       	ldi	r25, 0x06	; 6
    1e80:	0e 94 ad 01 	call	0x35a	; 0x35a <mc_line>
    1e84:	2d c0       	rjmp	.+90     	; 0x1ee0 <gc_execute_line+0x13ac>
      } else if ((gc_state.modal.motion == MOTION_MODE_CW_ARC) || (gc_state.modal.motion == MOTION_MODE_CCW_ARC)) {
    1e86:	82 50       	subi	r24, 0x02	; 2
    1e88:	82 30       	cpi	r24, 0x02	; 2
    1e8a:	e8 f4       	brcc	.+58     	; 0x1ec6 <gc_execute_line+0x1392>
        mc_arc(gc_block.values.xyz, pl_data, gc_state.position, gc_block.values.ijk, gc_block.values.r,
    1e8c:	e0 90 0f 06 	lds	r14, 0x060F	; 0x80060f <gc_block+0x25>
    1e90:	f0 90 10 06 	lds	r15, 0x0610	; 0x800610 <gc_block+0x26>
    1e94:	00 91 11 06 	lds	r16, 0x0611	; 0x800611 <gc_block+0x27>
    1e98:	10 91 12 06 	lds	r17, 0x0612	; 0x800612 <gc_block+0x28>
    1e9c:	e8 a1       	ldd	r30, Y+32	; 0x20
    1e9e:	e2 fb       	bst	r30, 2
    1ea0:	88 27       	eor	r24, r24
    1ea2:	80 f9       	bld	r24, 0
    1ea4:	8f 93       	push	r24
    1ea6:	8b a4       	ldd	r8, Y+43	; 0x2b
    1ea8:	aa a0       	ldd	r10, Y+34	; 0x22
    1eaa:	c9 a0       	ldd	r12, Y+33	; 0x21
    1eac:	2a ef       	ldi	r18, 0xFA	; 250
    1eae:	35 e0       	ldi	r19, 0x05	; 5
    1eb0:	42 ec       	ldi	r20, 0xC2	; 194
    1eb2:	55 e0       	ldi	r21, 0x05	; 5
    1eb4:	be 01       	movw	r22, r28
    1eb6:	6e 5e       	subi	r22, 0xEE	; 238
    1eb8:	7f 4f       	sbci	r23, 0xFF	; 255
    1eba:	88 e1       	ldi	r24, 0x18	; 24
    1ebc:	96 e0       	ldi	r25, 0x06	; 6
    1ebe:	0e 94 ee 01 	call	0x3dc	; 0x3dc <mc_arc>
    1ec2:	0f 90       	pop	r0
    1ec4:	0d c0       	rjmp	.+26     	; 0x1ee0 <gc_execute_line+0x13ac>
            axis_0, axis_1, axis_linear, bit_istrue(gc_parser_flags,GC_PARSER_ARC_IS_CLOCKWISE));
      } else {
        // NOTE: gc_block.values.xyz is returned from mc_probe_cycle with the updated position value. So
        // upon a successful probing cycle, the machine position and the returned value should be the same.
        #ifndef ALLOW_FEED_OVERRIDE_DURING_PROBE_CYCLES
          pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
    1ec6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1ec8:	84 60       	ori	r24, 0x04	; 4
    1eca:	8a 8f       	std	Y+26, r24	; 0x1a
        #endif
        gc_update_pos = mc_probe_cycle(gc_block.values.xyz, pl_data, gc_parser_flags);
    1ecc:	48 a1       	ldd	r20, Y+32	; 0x20
    1ece:	be 01       	movw	r22, r28
    1ed0:	6e 5e       	subi	r22, 0xEE	; 238
    1ed2:	7f 4f       	sbci	r23, 0xFF	; 255
    1ed4:	88 e1       	ldi	r24, 0x18	; 24
    1ed6:	96 e0       	ldi	r25, 0x06	; 6
    1ed8:	0e 94 e5 04 	call	0x9ca	; 0x9ca <mc_probe_cycle>
      }  
     
      // As far as the parser is concerned, the position is now == target. In reality the
      // motion control system might still be processing the action and the real tool position
      // in any intermediate location.
      if (gc_update_pos == GC_UPDATE_POS_TARGET) {
    1edc:	81 11       	cpse	r24, r1
    1ede:	0a c0       	rjmp	.+20     	; 0x1ef4 <gc_execute_line+0x13c0>
        memcpy(gc_state.position, gc_block.values.xyz, sizeof(gc_block.values.xyz)); // gc_state.position[] = gc_block.values.xyz[]
    1ee0:	8c e0       	ldi	r24, 0x0C	; 12
    1ee2:	e8 e1       	ldi	r30, 0x18	; 24
    1ee4:	f6 e0       	ldi	r31, 0x06	; 6
    1ee6:	a2 ec       	ldi	r26, 0xC2	; 194
    1ee8:	b5 e0       	ldi	r27, 0x05	; 5
    1eea:	01 90       	ld	r0, Z+
    1eec:	0d 92       	st	X+, r0
    1eee:	8a 95       	dec	r24
    1ef0:	e1 f7       	brne	.-8      	; 0x1eea <gc_execute_line+0x13b6>
    1ef2:	04 c0       	rjmp	.+8      	; 0x1efc <gc_execute_line+0x13c8>
      } else if (gc_update_pos == GC_UPDATE_POS_SYSTEM) {
    1ef4:	81 30       	cpi	r24, 0x01	; 1
    1ef6:	11 f4       	brne	.+4      	; 0x1efc <gc_execute_line+0x13c8>
        gc_sync_position(); // gc_state.position[] = sys_position
    1ef8:	0e 94 93 05 	call	0xb26	; 0xb26 <gc_sync_position>
  }

  // [21. Program flow ]:
  // M0,M1,M2,M30: Perform non-running program flow actions. During a program pause, the buffer may
  // refill and can only be resumed by the cycle start run-time command.
  gc_state.modal.program_flow = gc_block.modal.program_flow;
    1efc:	80 91 f2 05 	lds	r24, 0x05F2	; 0x8005f2 <gc_block+0x8>
    1f00:	80 93 b1 05 	sts	0x05B1, r24	; 0x8005b1 <gc_state+0x7>
  if (gc_state.modal.program_flow) {
    1f04:	88 23       	and	r24, r24
    1f06:	09 f4       	brne	.+2      	; 0x1f0a <gc_execute_line+0x13d6>
    1f08:	f3 c0       	rjmp	.+486    	; 0x20f0 <gc_execute_line+0x15bc>
    protocol_buffer_synchronize(); // Sync and finish all remaining buffered motions before moving on.
    1f0a:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <protocol_buffer_synchronize>
    if (gc_state.modal.program_flow == PROGRAM_FLOW_PAUSED) {
    1f0e:	80 91 b1 05 	lds	r24, 0x05B1	; 0x8005b1 <gc_state+0x7>
    1f12:	83 30       	cpi	r24, 0x03	; 3
    1f14:	51 f4       	brne	.+20     	; 0x1f2a <gc_execute_line+0x13f6>
      if (sys.state != STATE_CHECK_MODE) {
    1f16:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    1f1a:	82 30       	cpi	r24, 0x02	; 2
    1f1c:	79 f1       	breq	.+94     	; 0x1f7c <gc_execute_line+0x1448>
        system_set_exec_state_flag(EXEC_FEED_HOLD); // Use feed hold for program pause.
    1f1e:	88 e0       	ldi	r24, 0x08	; 8
    1f20:	0e 94 31 2e 	call	0x5c62	; 0x5c62 <system_set_exec_state_flag>
        protocol_execute_realtime(); // Execute suspend.
    1f24:	0e 94 9e 14 	call	0x293c	; 0x293c <protocol_execute_realtime>
    1f28:	29 c0       	rjmp	.+82     	; 0x1f7c <gc_execute_line+0x1448>
    } else { // == PROGRAM_FLOW_COMPLETED
      // Upon program complete, only a subset of g-codes reset to certain defaults, according to
      // LinuxCNC's program end descriptions and testing. Only modal groups [G-code 1,2,3,5,7,12]
      // and [M-code 7,8,9] reset to [G1,G17,G90,G94,G40,G54,M5,M9,M48]. The remaining modal groups
      // [G-code 4,6,8,10,13,14,15] and [M-code 4,5,6] and the modal words [F,S,T,H] do not reset.
      gc_state.modal.motion = MOTION_MODE_LINEAR;
    1f2a:	ea ea       	ldi	r30, 0xAA	; 170
    1f2c:	f5 e0       	ldi	r31, 0x05	; 5
    1f2e:	81 e0       	ldi	r24, 0x01	; 1
    1f30:	80 83       	st	Z, r24
      gc_state.modal.plane_select = PLANE_SELECT_XY;
    1f32:	14 82       	std	Z+4, r1	; 0x04
      gc_state.modal.distance = DISTANCE_MODE_ABSOLUTE;
    1f34:	13 82       	std	Z+3, r1	; 0x03
      gc_state.modal.feed_rate = FEED_RATE_MODE_UNITS_PER_MIN;
    1f36:	11 82       	std	Z+1, r1	; 0x01
      // gc_state.modal.cutter_comp = CUTTER_COMP_DISABLE; // Not supported.
      gc_state.modal.coord_select = 0; // G54
    1f38:	16 82       	std	Z+6, r1	; 0x06
      gc_state.modal.spindle = SPINDLE_DISABLE;
    1f3a:	11 86       	std	Z+9, r1	; 0x09
      gc_state.modal.coolant = COOLANT_DISABLE;
    1f3c:	10 86       	std	Z+8, r1	; 0x08
          gc_state.modal.override = OVERRIDE_PARKING_MOTION;
        #endif
      #endif

      #ifdef RESTORE_OVERRIDES_AFTER_PROGRAM_END
        sys.f_override = DEFAULT_FEED_OVERRIDE;
    1f3e:	ec e7       	ldi	r30, 0x7C	; 124
    1f40:	f5 e0       	ldi	r31, 0x05	; 5
    1f42:	84 e6       	ldi	r24, 0x64	; 100
    1f44:	87 83       	std	Z+7, r24	; 0x07
        sys.r_override = DEFAULT_RAPID_OVERRIDE;
    1f46:	80 87       	std	Z+8, r24	; 0x08
        sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE;
    1f48:	81 87       	std	Z+9, r24	; 0x09
      #endif

      // Execute coordinate change and spindle/coolant stop.
      if (sys.state != STATE_CHECK_MODE) {
    1f4a:	80 81       	ld	r24, Z
    1f4c:	82 30       	cpi	r24, 0x02	; 2
    1f4e:	99 f0       	breq	.+38     	; 0x1f76 <gc_execute_line+0x1442>
        if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    1f50:	6e ec       	ldi	r22, 0xCE	; 206
    1f52:	75 e0       	ldi	r23, 0x05	; 5
    1f54:	80 e0       	ldi	r24, 0x00	; 0
    1f56:	0e 94 4e 23 	call	0x469c	; 0x469c <settings_read_coord_data>
    1f5a:	88 23       	and	r24, r24
    1f5c:	09 f4       	brne	.+2      	; 0x1f60 <gc_execute_line+0x142c>
    1f5e:	7c c0       	rjmp	.+248    	; 0x2058 <gc_execute_line+0x1524>
        system_flag_wco_change(); // Set to refresh immediately just in case something altered.
    1f60:	0e 94 8a 2d 	call	0x5b14	; 0x5b14 <system_flag_wco_change>
        spindle_set_state(SPINDLE_DISABLE,0.0);
    1f64:	40 e0       	ldi	r20, 0x00	; 0
    1f66:	50 e0       	ldi	r21, 0x00	; 0
    1f68:	ba 01       	movw	r22, r20
    1f6a:	80 e0       	ldi	r24, 0x00	; 0
    1f6c:	0e 94 71 11 	call	0x22e2	; 0x22e2 <spindle_set_state>
        coolant_set_state(COOLANT_DISABLE);
    1f70:	80 e0       	ldi	r24, 0x00	; 0
    1f72:	0e 94 be 11 	call	0x237c	; 0x237c <coolant_set_state>
      }
      report_feedback_message(MESSAGE_PROGRAM_END);
    1f76:	88 e0       	ldi	r24, 0x08	; 8
    1f78:	0e 94 ff 2c 	call	0x59fe	; 0x59fe <report_feedback_message>
    }
    gc_state.modal.program_flow = PROGRAM_FLOW_RUNNING; // Reset program flow.
    1f7c:	10 92 b1 05 	sts	0x05B1, r1	; 0x8005b1 <gc_state+0x7>
  }

  // TODO: % to denote start of program.

  return(STATUS_OK);
    1f80:	8d 2d       	mov	r24, r13
    1f82:	b6 c0       	rjmp	.+364    	; 0x20f0 <gc_execute_line+0x15bc>

  while (line[char_counter] != 0) { // Loop until no more g-code words in line.

    // Import the next g-code word, expecting a letter followed by a value. Otherwise, error out.
    letter = line[char_counter];
    if((letter < 'A') || (letter > 'Z')) { FAIL(STATUS_EXPECTED_COMMAND_LETTER); } // [Expected word letter]
    1f84:	81 e0       	ldi	r24, 0x01	; 1
    1f86:	b4 c0       	rjmp	.+360    	; 0x20f0 <gc_execute_line+0x15bc>
    char_counter++;
    if (!read_float(line, &char_counter, &value)) { FAIL(STATUS_BAD_NUMBER_FORMAT); } // [Expected word value]
    1f88:	82 e0       	ldi	r24, 0x02	; 2
    1f8a:	b2 c0       	rjmp	.+356    	; 0x20f0 <gc_execute_line+0x15bc>
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
    1f8c:	84 e1       	ldi	r24, 0x14	; 20
    1f8e:	b0 c0       	rjmp	.+352    	; 0x20f0 <gc_execute_line+0x15bc>
        switch(int_value) {
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    1f90:	88 e1       	ldi	r24, 0x18	; 24
    1f92:	ae c0       	rjmp	.+348    	; 0x20f0 <gc_execute_line+0x15bc>
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
              if (!((mantissa == 0) || (mantissa == 10))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); }
    1f94:	84 e1       	ldi	r24, 0x14	; 20
    1f96:	ac c0       	rjmp	.+344    	; 0x20f0 <gc_execute_line+0x15bc>
            }                
            break;
          case 0: case 1: case 2: case 3: case 38:
            // Check for G0/1/2/3/38 being called with G10/28/30/92 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
    1f98:	88 e1       	ldi	r24, 0x18	; 24
    1f9a:	aa c0       	rjmp	.+340    	; 0x20f0 <gc_execute_line+0x15bc>
          case 80:
            word_bit = MODAL_GROUP_G1;
            gc_block.modal.motion = int_value;
            if (int_value == 38){
              if (!((mantissa == 20) || (mantissa == 30) || (mantissa == 40) || (mantissa == 50))) {
                FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G38.x command]
    1f9c:	84 e1       	ldi	r24, 0x14	; 20
    1f9e:	a8 c0       	rjmp	.+336    	; 0x20f0 <gc_execute_line+0x15bc>
            if (mantissa == 0) {
              word_bit = MODAL_GROUP_G3;
              gc_block.modal.distance = int_value - 90;
            } else {
              word_bit = MODAL_GROUP_G4;
              if ((mantissa != 10) || (int_value == 90)) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G90.1 not supported]
    1fa0:	84 e1       	ldi	r24, 0x14	; 20
    1fa2:	a6 c0       	rjmp	.+332    	; 0x20f0 <gc_execute_line+0x15bc>
    1fa4:	84 e1       	ldi	r24, 0x14	; 20
    1fa6:	a4 c0       	rjmp	.+328    	; 0x20f0 <gc_execute_line+0x15bc>
          case 43: case 49:
            word_bit = MODAL_GROUP_G8;
            // NOTE: The NIST g-code standard vaguely states that when a tool length offset is changed,
            // there cannot be any axis motion or coordinate offsets updated. Meaning G43, G43.1, and G49
            // all are explicit axis commands, regardless if they require axis words or not.
            if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict] }
    1fa8:	88 e1       	ldi	r24, 0x18	; 24
    1faa:	a2 c0       	rjmp	.+324    	; 0x20f0 <gc_execute_line+0x15bc>
            axis_command = AXIS_COMMAND_TOOL_LENGTH_OFFSET;
            if (int_value == 49) { // G49
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_CANCEL;
            } else if (mantissa == 10) { // G43.1
              gc_block.modal.tool_length = TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC;
            } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported G43.x command]
    1fac:	84 e1       	ldi	r24, 0x14	; 20
    1fae:	a0 c0       	rjmp	.+320    	; 0x20f0 <gc_execute_line+0x15bc>
            word_bit = MODAL_GROUP_G12;
            gc_block.modal.coord_select = int_value - 54; // Shift to array indexing.
            break;
          case 61:
            word_bit = MODAL_GROUP_G13;
            if (mantissa != 0) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G61.1 not supported]
    1fb0:	84 e1       	ldi	r24, 0x14	; 20
    1fb2:	9e c0       	rjmp	.+316    	; 0x20f0 <gc_execute_line+0x15bc>
            // gc_block.modal.control = CONTROL_MODE_EXACT_PATH; // G61
            break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported G command]
        }
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [Unsupported or invalid Gxx.x command]
    1fb4:	87 e1       	ldi	r24, 0x17	; 23
    1fb6:	9c c0       	rjmp	.+312    	; 0x20f0 <gc_execute_line+0x15bc>
        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    1fb8:	85 e1       	ldi	r24, 0x15	; 21
    1fba:	9a c0       	rjmp	.+308    	; 0x20f0 <gc_execute_line+0x15bc>
        break;

      case 'M':

        // Determine 'M' command and its modal group
        if (mantissa > 0) { FAIL(STATUS_GCODE_COMMAND_VALUE_NOT_INTEGER); } // [No Mxx.x commands]
    1fbc:	87 e1       	ldi	r24, 0x17	; 23
    1fbe:	98 c0       	rjmp	.+304    	; 0x20f0 <gc_execute_line+0x15bc>
            case 56:
              word_bit = MODAL_GROUP_M9;
              gc_block.modal.override = OVERRIDE_PARKING_MOTION;
              break;
          #endif
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); // [Unsupported M command]
    1fc0:	84 e1       	ldi	r24, 0x14	; 20
    1fc2:	96 c0       	rjmp	.+300    	; 0x20f0 <gc_execute_line+0x15bc>
        }

        // Check for more than one command per modal group violations in the current block
        // NOTE: Variable 'word_bit' is always assigned, if the command is valid.
        if ( bit_istrue(command_words,bit(word_bit)) ) { FAIL(STATUS_GCODE_MODAL_GROUP_VIOLATION); }
    1fc4:	85 e1       	ldi	r24, 0x15	; 21
    1fc6:	94 c0       	rjmp	.+296    	; 0x20f0 <gc_execute_line+0x15bc>
            gc_block.values.t = int_value;
						break;
          case 'X': word_bit = WORD_X; gc_block.values.xyz[X_AXIS] = value; axis_words |= (1<<X_AXIS); break;
          case 'Y': word_bit = WORD_Y; gc_block.values.xyz[Y_AXIS] = value; axis_words |= (1<<Y_AXIS); break;
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
    1fc8:	84 e1       	ldi	r24, 0x14	; 20
    1fca:	92 c0       	rjmp	.+292    	; 0x20f0 <gc_execute_line+0x15bc>
          // NOTE: For certain commands, P value must be an integer, but none of these commands are supported.
          // case 'Q': // Not supported
          case 'R': word_bit = WORD_R; gc_block.values.r = value; break;
          case 'S': word_bit = WORD_S; gc_block.values.s = value; break;
          case 'T': word_bit = WORD_T; 
					  if (value > MAX_TOOL_NUMBER) { FAIL(STATUS_GCODE_MAX_VALUE_EXCEEDED); }
    1fcc:	86 e2       	ldi	r24, 0x26	; 38
    1fce:	90 c0       	rjmp	.+288    	; 0x20f0 <gc_execute_line+0x15bc>
          case 'Z': word_bit = WORD_Z; gc_block.values.xyz[Z_AXIS] = value; axis_words |= (1<<Z_AXIS); break;
          default: FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND);
        }

        // NOTE: Variable 'word_bit' is always assigned, if the non-command letter is valid.
        if (bit_istrue(value_words,bit(word_bit))) { FAIL(STATUS_GCODE_WORD_REPEATED); } // [Word repeated]
    1fd0:	89 e1       	ldi	r24, 0x19	; 25
    1fd2:	8e c0       	rjmp	.+284    	; 0x20f0 <gc_execute_line+0x15bc>
        // Check for invalid negative values for words F, N, P, T, and S.
        // NOTE: Negative value check is done here simply for code-efficiency.
        if ( bit(word_bit) & (bit(WORD_F)|bit(WORD_N)|bit(WORD_P)|bit(WORD_T)|bit(WORD_S)) ) {
          if (value < 0.0) { FAIL(STATUS_NEGATIVE_VALUE); } // [Word value cannot be negative]
    1fd4:	84 e0       	ldi	r24, 0x04	; 4
    1fd6:	8c c0       	rjmp	.+280    	; 0x20f0 <gc_execute_line+0x15bc>
  }

  // Check for valid line number N value.
  if (bit_istrue(value_words,bit(WORD_N))) {
    // Line number value cannot be less than zero (done) or greater than max line number.
    if (gc_block.values.n > MAX_LINE_NUMBER) { FAIL(STATUS_GCODE_INVALID_LINE_NUMBER); } // [Exceeds max line number]
    1fd8:	8b e1       	ldi	r24, 0x1B	; 27
    1fda:	8a c0       	rjmp	.+276    	; 0x20f0 <gc_execute_line+0x15bc>

  // [2. Set feed rate mode ]: G93 F word missing with G1,G2/3 active, implicitly or explicitly. Feed rate
  //   is not defined after switching to G94 from G93.
  // NOTE: For jogging, ignore prior feed rate mode. Enforce G94 and check for required F word.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); }
    1fdc:	86 e1       	ldi	r24, 0x16	; 22
    1fde:	88 c0       	rjmp	.+272    	; 0x20f0 <gc_execute_line+0x15bc>
  } else {
    if (gc_block.modal.feed_rate == FEED_RATE_MODE_INVERSE_TIME) { // = G93
      // NOTE: G38 can also operate in inverse time, but is undefined as an error. Missing F word check added here.
      if (axis_command == AXIS_COMMAND_MOTION_MODE) {
        if ((gc_block.modal.motion != MOTION_MODE_NONE) && (gc_block.modal.motion != MOTION_MODE_SEEK)) {
          if (bit_isfalse(value_words,bit(WORD_F))) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [F word missing]
    1fe0:	86 e1       	ldi	r24, 0x16	; 22
    1fe2:	86 c0       	rjmp	.+268    	; 0x20f0 <gc_execute_line+0x15bc>
    }
  #endif

  // [10. Dwell ]: P value missing. P is negative (done.) NOTE: See below.
  if (gc_block.non_modal_command == NON_MODAL_DWELL) {
    if (bit_isfalse(value_words,bit(WORD_P))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P word missing]
    1fe4:	8c e1       	ldi	r24, 0x1C	; 28
    1fe6:	84 c0       	rjmp	.+264    	; 0x20f0 <gc_execute_line+0x15bc>
  //   NOTE: Although not explicitly stated so, G43.1 should be applied to only one valid
  //   axis that is configured (in config.h). There should be an error if the configured axis
  //   is absent or if any of the other axis words are present.
  if (axis_command == AXIS_COMMAND_TOOL_LENGTH_OFFSET ) { // Indicates called in block.
    if (gc_block.modal.tool_length == TOOL_LENGTH_OFFSET_ENABLE_DYNAMIC) {
      if (axis_words ^ (1<<TOOL_LENGTH_OFFSET_AXIS)) { FAIL(STATUS_GCODE_G43_DYNAMIC_AXIS_ERROR); }
    1fe8:	85 e2       	ldi	r24, 0x25	; 37
    1fea:	82 c0       	rjmp	.+260    	; 0x20f0 <gc_execute_line+0x15bc>
  // future versions on processors with enough memory, all coordinate data should be stored
  // in memory and written to EEPROM only when there is not a cycle active.
  float block_coord_system[N_AXIS];
  memcpy(block_coord_system,gc_state.coord_system,sizeof(gc_state.coord_system));
  if ( bit_istrue(command_words,bit(MODAL_GROUP_G12)) ) { // Check if called in block
    if (gc_block.modal.coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    1fec:	8d e1       	ldi	r24, 0x1D	; 29
    1fee:	80 c0       	rjmp	.+256    	; 0x20f0 <gc_execute_line+0x15bc>
    if (gc_state.modal.coord_select != gc_block.modal.coord_select) {
      if (!(settings_read_coord_data(gc_block.modal.coord_select,block_coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    1ff0:	87 e0       	ldi	r24, 0x07	; 7
    1ff2:	7e c0       	rjmp	.+252    	; 0x20f0 <gc_execute_line+0x15bc>
  switch (gc_block.non_modal_command) {
    case NON_MODAL_SET_COORDINATE_DATA:
      // [G10 Errors]: L missing and is not 2 or 20. P word missing. (Negative P value done.)
      // [G10 L2 Errors]: R word NOT SUPPORTED. P value not 0 to nCoordSys(max 9). Axis words missing.
      // [G10 L20 Errors]: P must be 0 to nCoordSys(max 9). Axis words missing.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS) }; // [No axis words]
    1ff4:	8a e1       	ldi	r24, 0x1A	; 26
    1ff6:	7c c0       	rjmp	.+248    	; 0x20f0 <gc_execute_line+0x15bc>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
    1ff8:	8c e1       	ldi	r24, 0x1C	; 28
    1ffa:	7a c0       	rjmp	.+244    	; 0x20f0 <gc_execute_line+0x15bc>
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
    1ffc:	8d e1       	ldi	r24, 0x1D	; 29
    1ffe:	78 c0       	rjmp	.+240    	; 0x20f0 <gc_execute_line+0x15bc>
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
        } else { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [Unsupported L]
    2000:	84 e1       	ldi	r24, 0x14	; 20
    2002:	76 c0       	rjmp	.+236    	; 0x20f0 <gc_execute_line+0x15bc>
      if (bit_isfalse(value_words,((1<<WORD_P)|(1<<WORD_L)))) { FAIL(STATUS_GCODE_VALUE_WORD_MISSING); } // [P/L word missing]
      coord_select = trunc(gc_block.values.p); // Convert p value to int.
      if (coord_select > N_COORDINATE_SYSTEM) { FAIL(STATUS_GCODE_UNSUPPORTED_COORD_SYS); } // [Greater than N sys]
      if (gc_block.values.l != 20) {
        if (gc_block.values.l == 2) {
          if (bit_istrue(value_words,bit(WORD_R))) { FAIL(STATUS_GCODE_UNSUPPORTED_COMMAND); } // [G10 L2 R not supported]
    2004:	84 e1       	ldi	r24, 0x14	; 20
    2006:	74 c0       	rjmp	.+232    	; 0x20f0 <gc_execute_line+0x15bc>
      // Determine coordinate system to change and try to load from EEPROM.
      if (coord_select > 0) { coord_select--; } // Adjust P1-P6 index to EEPROM coordinate data indexing.
      else { coord_select = gc_block.modal.coord_select; } // Index P0 as the active coordinate system
      
      // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
      if (!settings_read_coord_data(coord_select,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); } // [EEPROM read fail]
    2008:	87 e0       	ldi	r24, 0x07	; 7
    200a:	72 c0       	rjmp	.+228    	; 0x20f0 <gc_execute_line+0x15bc>
        } // Else, keep current stored value.
      }
      break;
    case NON_MODAL_SET_COORDINATE_OFFSET:
      // [G92 Errors]: No axis words.
      if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    200c:	8a e1       	ldi	r24, 0x1A	; 26
    200e:	70 c0       	rjmp	.+224    	; 0x20f0 <gc_execute_line+0x15bc>

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    2010:	8f e1       	ldi	r24, 0x1F	; 31
    2012:	6e c0       	rjmp	.+220    	; 0x20f0 <gc_execute_line+0x15bc>
        case NON_MODAL_GO_HOME_1: // G30
          // [G28/30 Errors]: Cutter compensation is enabled.
          // Retreive G28/30 go-home position data (in machine coordinates) from EEPROM
          // NOTE: Store parameter data in IJK values. By rule, they are not in use with this command.
          if (gc_block.non_modal_command == NON_MODAL_GO_HOME_0) {
            if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    2014:	87 e0       	ldi	r24, 0x07	; 7
    2016:	6c c0       	rjmp	.+216    	; 0x20f0 <gc_execute_line+0x15bc>
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
    2018:	87 e0       	ldi	r24, 0x07	; 7
    201a:	6a c0       	rjmp	.+212    	; 0x20f0 <gc_execute_line+0x15bc>
          break;
        case NON_MODAL_ABSOLUTE_OVERRIDE:
          // [G53 Errors]: G0 and G1 are not active. Cutter compensation is enabled.
          // NOTE: All explicit axis word commands are in this modal group. So no implicit check necessary.
          if (!(gc_block.modal.motion == MOTION_MODE_SEEK || gc_block.modal.motion == MOTION_MODE_LINEAR)) {
            FAIL(STATUS_GCODE_G53_INVALID_MOTION_MODE); // [G53 G0/1 not active]
    201c:	8e e1       	ldi	r24, 0x1E	; 30
    201e:	68 c0       	rjmp	.+208    	; 0x20f0 <gc_execute_line+0x15bc>

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    2020:	8f e1       	ldi	r24, 0x1F	; 31
    2022:	66 c0       	rjmp	.+204    	; 0x20f0 <gc_execute_line+0x15bc>

    // All remaining motion modes (all but G0 and G80), require a valid feed rate value. In units per mm mode,
    // the value must be positive. In inverse time mode, a positive value must be passed with each block.
    } else {
      // Check if feed rate is defined for the motion modes that require it.
      if (gc_block.values.f == 0.0) { FAIL(STATUS_GCODE_UNDEFINED_FEED_RATE); } // [Feed rate undefined]
    2024:	86 e1       	ldi	r24, 0x16	; 22
    2026:	64 c0       	rjmp	.+200    	; 0x20f0 <gc_execute_line+0x15bc>
          // [G2/3 Offset-Mode Errors]: No axis words and/or offsets in selected plane. The radius to the current
          //   point and the radius to the target point differs more than 0.002mm (EMC def. 0.5mm OR 0.005mm and 0.1% radius).
          // [G2/3 Full-Circle-Mode Errors]: NOT SUPPORTED. Axis words exist. No offsets programmed. P must be an integer.
          // NOTE: Both radius and offsets are required for arc tracing and are pre-computed with the error-checking.

          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    2028:	8a e1       	ldi	r24, 0x1A	; 26
    202a:	62 c0       	rjmp	.+196    	; 0x20f0 <gc_execute_line+0x15bc>
          if (!(axis_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_AXIS_WORDS_IN_PLANE); } // [No axis words in plane]
    202c:	80 e2       	ldi	r24, 0x20	; 32
    202e:	60 c0       	rjmp	.+192    	; 0x20f0 <gc_execute_line+0x15bc>
          x = gc_block.values.xyz[axis_0]-gc_state.position[axis_0]; // Delta x between current position and target
          y = gc_block.values.xyz[axis_1]-gc_state.position[axis_1]; // Delta y between current position and target

          if (value_words & bit(WORD_R)) { // Arc Radius Mode
            bit_false(value_words,bit(WORD_R));
            if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    2030:	81 e2       	ldi	r24, 0x21	; 33
    2032:	5e c0       	rjmp	.+188    	; 0x20f0 <gc_execute_line+0x15bc>

            // First, use h_x2_div_d to compute 4*h^2 to check if it is negative or r is smaller
            // than d. If so, the sqrt of a negative number is complex and error out.
            float h_x2_div_d = 4.0 * gc_block.values.r*gc_block.values.r - x*x - y*y;

            if (h_x2_div_d < 0) { FAIL(STATUS_GCODE_ARC_RADIUS_ERROR); } // [Arc radius error]
    2034:	82 e2       	ldi	r24, 0x22	; 34
    2036:	5c c0       	rjmp	.+184    	; 0x20f0 <gc_execute_line+0x15bc>
            // Complete the operation by calculating the actual center of the arc
            gc_block.values.ijk[axis_0] = 0.5*(x-(y*h_x2_div_d));
            gc_block.values.ijk[axis_1] = 0.5*(y+(x*h_x2_div_d));

          } else { // Arc Center Format Offset Mode
            if (!(ijk_words & (bit(axis_0)|bit(axis_1)))) { FAIL(STATUS_GCODE_NO_OFFSETS_IN_PLANE); } // [No offsets in plane]
    2038:	83 e2       	ldi	r24, 0x23	; 35
    203a:	5a c0       	rjmp	.+180    	; 0x20f0 <gc_execute_line+0x15bc>
            gc_block.values.r = hypot_f(gc_block.values.ijk[axis_0], gc_block.values.ijk[axis_1]);

            // Compute difference between current location and target radii for final error-checks.
            float delta_r = fabs(target_r-gc_block.values.r);
            if (delta_r > 0.005) {
              if (delta_r > 0.5) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.5mm
    203c:	81 e2       	ldi	r24, 0x21	; 33
    203e:	58 c0       	rjmp	.+176    	; 0x20f0 <gc_execute_line+0x15bc>
              if (delta_r > (0.001*gc_block.values.r)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Arc definition error] > 0.005mm AND 0.1% radius
    2040:	81 e2       	ldi	r24, 0x21	; 33
    2042:	56 c0       	rjmp	.+172    	; 0x20f0 <gc_execute_line+0x15bc>
              (gc_block.modal.motion == MOTION_MODE_PROBE_AWAY_NO_ERROR)) { gc_parser_flags |= GC_PARSER_PROBE_IS_AWAY; }
          // [G38 Errors]: Target is same current. No axis words. Cutter compensation is enabled. Feed rate
          //   is undefined. Probe is triggered. NOTE: Probe check moved to probe cycle. Instead of returning
          //   an error, it issues an alarm to prevent further motion to the probe. It's also done there to
          //   allow the planner buffer to empty and move off the probe trigger before another probing cycle.
          if (!axis_words) { FAIL(STATUS_GCODE_NO_AXIS_WORDS); } // [No axis words]
    2044:	8a e1       	ldi	r24, 0x1A	; 26
    2046:	54 c0       	rjmp	.+168    	; 0x20f0 <gc_execute_line+0x15bc>
          if (isequal_position_vector(gc_state.position, gc_block.values.xyz)) { FAIL(STATUS_GCODE_INVALID_TARGET); } // [Invalid target]
    2048:	81 e2       	ldi	r24, 0x21	; 33
    204a:	52 c0       	rjmp	.+164    	; 0x20f0 <gc_execute_line+0x15bc>
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)));
  } else {
    bit_false(value_words,(bit(WORD_N)|bit(WORD_F)|bit(WORD_S)|bit(WORD_T))); // Remove single-meaning value words.
  }
  if (axis_command) { bit_false(value_words,(bit(WORD_X)|bit(WORD_Y)|bit(WORD_Z))); } // Remove axis words.
  if (value_words) { FAIL(STATUS_GCODE_UNUSED_WORDS); } // [Unused words]
    204c:	84 e2       	ldi	r24, 0x24	; 36
    204e:	50 c0       	rjmp	.+160    	; 0x20f0 <gc_execute_line+0x15bc>
  // targets are computed correctly. The final parser position after a jog is updated in
  // protocol_execute_realtime() when jogging completes or is canceled.
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) {
    // Only distance and unit modal commands and G53 absolute override command are allowed.
    // NOTE: Feed rate word and axis word checks have already been performed in STEP 3.
    if (command_words & ~(bit(MODAL_GROUP_G3) | bit(MODAL_GROUP_G6) | bit(MODAL_GROUP_G0)) ) { FAIL(STATUS_INVALID_JOG_COMMAND) };
    2050:	80 e1       	ldi	r24, 0x10	; 16
    2052:	4e c0       	rjmp	.+156    	; 0x20f0 <gc_execute_line+0x15bc>
    if (!(gc_block.non_modal_command == NON_MODAL_ABSOLUTE_OVERRIDE || gc_block.non_modal_command == NON_MODAL_NO_ACTION)) { FAIL(STATUS_INVALID_JOG_COMMAND); }
    2054:	80 e1       	ldi	r24, 0x10	; 16
    2056:	4c c0       	rjmp	.+152    	; 0x20f0 <gc_execute_line+0x15bc>
        sys.spindle_speed_ovr = DEFAULT_SPINDLE_SPEED_OVERRIDE;
      #endif

      // Execute coordinate change and spindle/coolant stop.
      if (sys.state != STATE_CHECK_MODE) {
        if (!(settings_read_coord_data(gc_state.modal.coord_select,gc_state.coord_system))) { FAIL(STATUS_SETTING_READ_FAIL); }
    2058:	87 e0       	ldi	r24, 0x07	; 7
    205a:	4a c0       	rjmp	.+148    	; 0x20f0 <gc_execute_line+0x15bc>

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    // [G80 Errors]: Axis word are programmed while G80 is active.
    // NOTE: Even non-modal commands or TLO that use axis words will throw this strict error.
    if (axis_words) { FAIL(STATUS_GCODE_AXIS_WORDS_EXIST); } // [No axis words allowed]
    205c:	8f e1       	ldi	r24, 0x1F	; 31
    205e:	48 c0       	rjmp	.+144    	; 0x20f0 <gc_execute_line+0x15bc>
  char letter;
  float value;
  uint8_t int_value = 0;
  uint16_t mantissa = 0;
  if (gc_parser_flags & GC_PARSER_JOG_MOTION) { char_counter = 3; } // Start parsing after `$J=`
  else { char_counter = 0; }
    2060:	19 82       	std	Y+1, r1	; 0x01
  uint8_t ijk_words = 0; // IJK tracking

  // Initialize command and value words and parser flags variables.
  uint16_t command_words = 0; // Tracks G and M command words. Also used for modal group violations.
  uint16_t value_words = 0; // Tracks value words.
  uint8_t gc_parser_flags = GC_PARSER_NONE;
    2062:	18 a2       	std	Y+32, r1	; 0x20
    2064:	0c 94 d4 05 	jmp	0xba8	; 0xba8 <gc_execute_line+0x74>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
    2068:	aa ee       	ldi	r26, 0xEA	; 234
    206a:	b5 e0       	ldi	r27, 0x05	; 5
    206c:	ac 92       	st	X, r10
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
    206e:	bc e1       	ldi	r27, 0x1C	; 28
    2070:	ab 12       	cpse	r10, r27
    2072:	27 c0       	rjmp	.+78     	; 0x20c2 <gc_execute_line+0x158e>
    2074:	0c 94 4b 06 	jmp	0xc96	; 0xc96 <gc_execute_line+0x162>
              axis_command = AXIS_COMMAND_NON_MODAL;
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
    2078:	ea ee       	ldi	r30, 0xEA	; 234
    207a:	f5 e0       	ldi	r31, 0x05	; 5
    207c:	a0 82       	st	Z, r10
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
    207e:	fc e1       	ldi	r31, 0x1C	; 28
    2080:	af 12       	cpse	r10, r31
    2082:	25 c0       	rjmp	.+74     	; 0x20ce <gc_execute_line+0x159a>
    2084:	0c 94 4f 06 	jmp	0xc9e	; 0xc9e <gc_execute_line+0x16a>
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
      axis_linear = Y_AXIS;
    2088:	21 e0       	ldi	r18, 0x01	; 1
    208a:	2b a7       	std	Y+43, r18	; 0x2b
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
      axis_1 = X_AXIS;
    208c:	1a a2       	std	Y+34, r1	; 0x22
      axis_0 = X_AXIS;
      axis_1 = Y_AXIS;
      axis_linear = Z_AXIS;
      break;
    case PLANE_SELECT_ZX:
      axis_0 = Z_AXIS;
    208e:	32 e0       	ldi	r19, 0x02	; 2
    2090:	39 a3       	std	Y+33, r19	; 0x21
  }

  // [12. Set length units ]: N/A
  // Pre-convert XYZ coordinate values to millimeters, if applicable.
  uint8_t idx;
  if (gc_block.modal.units == UNITS_MODE_INCHES) {
    2092:	80 91 ed 05 	lds	r24, 0x05ED	; 0x8005ed <gc_block+0x3>
    2096:	81 30       	cpi	r24, 0x01	; 1
    2098:	09 f0       	breq	.+2      	; 0x209c <gc_execute_line+0x1568>
    209a:	9d c8       	rjmp	.-3782   	; 0x11d6 <gc_execute_line+0x6a2>
    209c:	68 c8       	rjmp	.-3888   	; 0x116e <gc_execute_line+0x63a>
          if (gc_block.non_modal_command == NON_MODAL_GO_HOME_0) {
            if (!settings_read_coord_data(SETTING_INDEX_G28,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
          } else { // == NON_MODAL_GO_HOME_1
            if (!settings_read_coord_data(SETTING_INDEX_G30,gc_block.values.ijk)) { FAIL(STATUS_SETTING_READ_FAIL); }
          }
          if (axis_words) {
    209e:	4d 8d       	ldd	r20, Y+29	; 0x1d
    20a0:	44 23       	and	r20, r20
    20a2:	f1 f0       	breq	.+60     	; 0x20e0 <gc_execute_line+0x15ac>
    20a4:	aa ea       	ldi	r26, 0xAA	; 170
    20a6:	b5 e0       	ldi	r27, 0x05	; 5
    20a8:	ea ee       	ldi	r30, 0xEA	; 234
    20aa:	f5 e0       	ldi	r31, 0x05	; 5
    20ac:	80 e0       	ldi	r24, 0x00	; 0
    20ae:	90 e0       	ldi	r25, 0x00	; 0
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
    20b0:	24 2f       	mov	r18, r20
    20b2:	30 e0       	ldi	r19, 0x00	; 0
    20b4:	81 ca       	rjmp	.-2814   	; 0x15b8 <gc_execute_line+0xa84>
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    20b6:	10 91 eb 05 	lds	r17, 0x05EB	; 0x8005eb <gc_block+0x1>
    20ba:	10 35       	cpi	r17, 0x50	; 80
    20bc:	09 f0       	breq	.+2      	; 0x20c0 <gc_execute_line+0x158c>
    20be:	a6 ca       	rjmp	.-2740   	; 0x160c <gc_execute_line+0xad8>
    20c0:	cd cf       	rjmp	.-102    	; 0x205c <gc_execute_line+0x1528>
            }
            // No break. Continues to next line.
          case 4: case 53:
            word_bit = MODAL_GROUP_G0;
            gc_block.non_modal_command = int_value;
            if ((int_value == 28) || (int_value == 30) || (int_value == 92)) {
    20c2:	ae e1       	ldi	r26, 0x1E	; 30
    20c4:	aa 12       	cpse	r10, r26
    20c6:	0c 94 46 06 	jmp	0xc8c	; 0xc8c <gc_execute_line+0x158>
    20ca:	0c 94 4b 06 	jmp	0xc96	; 0xc96 <gc_execute_line+0x162>
    20ce:	be e1       	ldi	r27, 0x1E	; 30
    20d0:	ab 16       	cp	r10, r27
    20d2:	11 f4       	brne	.+4      	; 0x20d8 <gc_execute_line+0x15a4>
    20d4:	0c 94 52 06 	jmp	0xca4	; 0xca4 <gc_execute_line+0x170>
          case 10: case 28: case 30: case 92:
            // Check for G10/28/30/92 being called with G0/1/2/3/38 on same block.
            // * G43.1 is also an axis command but is not explicitly defined this way.
            if (mantissa == 0) { // Ignore G28.1, G30.1, and G92.1
              if (axis_command) { FAIL(STATUS_GCODE_AXIS_COMMAND_CONFLICT); } // [Axis word/command conflict]
              axis_command = AXIS_COMMAND_NON_MODAL;
    20d8:	e1 e0       	ldi	r30, 0x01	; 1
    20da:	ee 8f       	std	Y+30, r30	; 0x1e
    20dc:	0c 94 46 06 	jmp	0xc8c	; 0xc8c <gc_execute_line+0x158>
          break;
      }
  }

  // [20. Motion modes ]:
  if (gc_block.modal.motion == MOTION_MODE_NONE) {
    20e0:	10 91 eb 05 	lds	r17, 0x05EB	; 0x8005eb <gc_block+0x1>
    20e4:	10 35       	cpi	r17, 0x50	; 80
    20e6:	09 f4       	brne	.+2      	; 0x20ea <gc_execute_line+0x15b6>
    20e8:	d4 cc       	rjmp	.-1624   	; 0x1a92 <gc_execute_line+0xf5e>
    20ea:	1b 8e       	std	Y+27, r1	; 0x1b
            // Move only the axes specified in secondary move.
            for (idx=0; idx<N_AXIS; idx++) {
              if (!(axis_words & (1<<idx))) { gc_block.values.ijk[idx] = gc_state.position[idx]; }
            }
          } else {
            axis_command = AXIS_COMMAND_NONE; // Set to none if no intermediate motion.
    20ec:	1e 8e       	std	Y+30, r1	; 0x1e
    20ee:	8e ca       	rjmp	.-2788   	; 0x160c <gc_execute_line+0xad8>
  }

  // TODO: % to denote start of program.

  return(STATUS_OK);
}
    20f0:	ad 96       	adiw	r28, 0x2d	; 45
    20f2:	0f b6       	in	r0, 0x3f	; 63
    20f4:	f8 94       	cli
    20f6:	de bf       	out	0x3e, r29	; 62
    20f8:	0f be       	out	0x3f, r0	; 63
    20fa:	cd bf       	out	0x3d, r28	; 61
    20fc:	df 91       	pop	r29
    20fe:	cf 91       	pop	r28
    2100:	1f 91       	pop	r17
    2102:	0f 91       	pop	r16
    2104:	ff 90       	pop	r15
    2106:	ef 90       	pop	r14
    2108:	df 90       	pop	r13
    210a:	cf 90       	pop	r12
    210c:	bf 90       	pop	r11
    210e:	af 90       	pop	r10
    2110:	9f 90       	pop	r9
    2112:	8f 90       	pop	r8
    2114:	7f 90       	pop	r7
    2116:	6f 90       	pop	r6
    2118:	5f 90       	pop	r5
    211a:	4f 90       	pop	r4
    211c:	3f 90       	pop	r3
    211e:	2f 90       	pop	r2
    2120:	08 95       	ret

00002122 <spindle_stop>:
// Called by various main program and ISR routines. Keep routine small, fast, and efficient.
// Called by spindle_init(), spindle_set_speed(), spindle_set_state(), and mc_reset().
void spindle_stop()
{
  #ifdef VARIABLE_SPINDLE
    SPINDLE_TCCRA_REGISTER &= ~(1<<SPINDLE_COMB_BIT); // Disable PWM. Output voltage is zero.
    2122:	e0 eb       	ldi	r30, 0xB0	; 176
    2124:	f0 e0       	ldi	r31, 0x00	; 0
    2126:	80 81       	ld	r24, Z
    2128:	8f 77       	andi	r24, 0x7F	; 127
    212a:	80 83       	st	Z, r24
    212c:	08 95       	ret

0000212e <spindle_init>:
void spindle_init()
{
  #ifdef VARIABLE_SPINDLE
    // Configure variable spindle PWM and enable pin, if requried. On the Uno, PWM and enable are
    // combined unless configured otherwise.
    SPINDLE_PWM_DDR |= (1<<SPINDLE_PWM_BIT); // Configure as PWM output pin.
    212e:	23 9a       	sbi	0x04, 3	; 4
    SPINDLE_TCCRA_REGISTER = SPINDLE_TCCRA_INIT_MASK; // Configure PWM output compare timer
    2130:	83 e0       	ldi	r24, 0x03	; 3
    2132:	80 93 b0 00 	sts	0x00B0, r24	; 0x8000b0 <__DATA_REGION_ORIGIN__+0x50>
    SPINDLE_TCCRB_REGISTER = SPINDLE_TCCRB_INIT_MASK;
    2136:	84 e0       	ldi	r24, 0x04	; 4
    2138:	80 93 b1 00 	sts	0x00B1, r24	; 0x8000b1 <__DATA_REGION_ORIGIN__+0x51>
    #ifdef USE_SPINDLE_DIR_AS_ENABLE_PIN
      SPINDLE_ENABLE_DDR |= (1<<SPINDLE_ENABLE_BIT); // Configure as output pin.
    #else
      #ifndef ENABLE_DUAL_AXIS
        SPINDLE_DIRECTION_DDR |= (1<<SPINDLE_DIRECTION_BIT); // Configure as output pin.
    213c:	25 9a       	sbi	0x04, 5	; 4
      #endif
    #endif
    pwm_gradient = SPINDLE_PWM_RANGE/(settings.rpm_max-settings.rpm_min);
    213e:	20 91 4f 07 	lds	r18, 0x074F	; 0x80074f <settings+0x41>
    2142:	30 91 50 07 	lds	r19, 0x0750	; 0x800750 <settings+0x42>
    2146:	40 91 51 07 	lds	r20, 0x0751	; 0x800751 <settings+0x43>
    214a:	50 91 52 07 	lds	r21, 0x0752	; 0x800752 <settings+0x44>
    214e:	60 91 4b 07 	lds	r22, 0x074B	; 0x80074b <settings+0x3d>
    2152:	70 91 4c 07 	lds	r23, 0x074C	; 0x80074c <settings+0x3e>
    2156:	80 91 4d 07 	lds	r24, 0x074D	; 0x80074d <settings+0x3f>
    215a:	90 91 4e 07 	lds	r25, 0x074E	; 0x80074e <settings+0x40>
    215e:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    2162:	9b 01       	movw	r18, r22
    2164:	ac 01       	movw	r20, r24
    2166:	60 e0       	ldi	r22, 0x00	; 0
    2168:	70 e0       	ldi	r23, 0x00	; 0
    216a:	8e e7       	ldi	r24, 0x7E	; 126
    216c:	93 e4       	ldi	r25, 0x43	; 67
    216e:	0e 94 6e 2f 	call	0x5edc	; 0x5edc <__divsf3>
    2172:	60 93 02 01 	sts	0x0102, r22	; 0x800102 <__data_end>
    2176:	70 93 03 01 	sts	0x0103, r23	; 0x800103 <__data_end+0x1>
    217a:	80 93 04 01 	sts	0x0104, r24	; 0x800104 <__data_end+0x2>
    217e:	90 93 05 01 	sts	0x0105, r25	; 0x800105 <__data_end+0x3>
    #ifndef ENABLE_DUAL_AXIS
      SPINDLE_DIRECTION_DDR |= (1<<SPINDLE_DIRECTION_BIT); // Configure as output pin.
    #endif
  #endif

  spindle_stop();
    2182:	0e 94 91 10 	call	0x2122	; 0x2122 <spindle_stop>
    2186:	08 95       	ret

00002188 <spindle_set_speed>:
#ifdef VARIABLE_SPINDLE
  // Sets spindle speed PWM output and enable pin, if configured. Called by spindle_set_state()
  // and stepper ISR. Keep routine small and efficient.
  void spindle_set_speed(uint8_t pwm_value)
  {
    SPINDLE_OCR_REGISTER = pwm_value; // Set PWM output level.
    2188:	80 93 b3 00 	sts	0x00B3, r24	; 0x8000b3 <__DATA_REGION_ORIGIN__+0x53>
        #else
          SPINDLE_ENABLE_PORT |= (1<<SPINDLE_ENABLE_BIT);
        #endif
      }
    #else
      if (pwm_value == SPINDLE_PWM_OFF_VALUE) {
    218c:	81 11       	cpse	r24, r1
    218e:	06 c0       	rjmp	.+12     	; 0x219c <spindle_set_speed+0x14>
        SPINDLE_TCCRA_REGISTER &= ~(1<<SPINDLE_COMB_BIT); // Disable PWM. Output voltage is zero.
    2190:	e0 eb       	ldi	r30, 0xB0	; 176
    2192:	f0 e0       	ldi	r31, 0x00	; 0
    2194:	80 81       	ld	r24, Z
    2196:	8f 77       	andi	r24, 0x7F	; 127
    2198:	80 83       	st	Z, r24
    219a:	08 95       	ret
      } else {
        SPINDLE_TCCRA_REGISTER |= (1<<SPINDLE_COMB_BIT); // Ensure PWM output is enabled.
    219c:	e0 eb       	ldi	r30, 0xB0	; 176
    219e:	f0 e0       	ldi	r31, 0x00	; 0
    21a0:	80 81       	ld	r24, Z
    21a2:	80 68       	ori	r24, 0x80	; 128
    21a4:	80 83       	st	Z, r24
    21a6:	08 95       	ret

000021a8 <spindle_compute_pwm_value>:
    
  #else 
  
    // Called by spindle_set_state() and step segment generator. Keep routine small and efficient.
    uint8_t spindle_compute_pwm_value(float rpm) // 328p PWM register is 8-bit.
    {
    21a8:	4f 92       	push	r4
    21aa:	5f 92       	push	r5
    21ac:	6f 92       	push	r6
    21ae:	7f 92       	push	r7
    21b0:	8f 92       	push	r8
    21b2:	9f 92       	push	r9
    21b4:	af 92       	push	r10
    21b6:	bf 92       	push	r11
    21b8:	cf 92       	push	r12
    21ba:	df 92       	push	r13
    21bc:	ef 92       	push	r14
    21be:	ff 92       	push	r15
    21c0:	2b 01       	movw	r4, r22
    21c2:	3c 01       	movw	r6, r24
      uint8_t pwm_value;
      rpm *= (0.010*sys.spindle_speed_ovr); // Scale by spindle speed override value.
      // Calculate PWM register value based on rpm max/min settings and programmed rpm.
      if ((settings.rpm_min >= settings.rpm_max) || (rpm >= settings.rpm_max)) {
    21c4:	80 90 4f 07 	lds	r8, 0x074F	; 0x80074f <settings+0x41>
    21c8:	90 90 50 07 	lds	r9, 0x0750	; 0x800750 <settings+0x42>
    21cc:	a0 90 51 07 	lds	r10, 0x0751	; 0x800751 <settings+0x43>
    21d0:	b0 90 52 07 	lds	r11, 0x0752	; 0x800752 <settings+0x44>
    21d4:	c0 90 4b 07 	lds	r12, 0x074B	; 0x80074b <settings+0x3d>
    21d8:	d0 90 4c 07 	lds	r13, 0x074C	; 0x80074c <settings+0x3e>
    21dc:	e0 90 4d 07 	lds	r14, 0x074D	; 0x80074d <settings+0x3f>
    21e0:	f0 90 4e 07 	lds	r15, 0x074E	; 0x80074e <settings+0x40>
    21e4:	a7 01       	movw	r20, r14
    21e6:	96 01       	movw	r18, r12
    21e8:	c5 01       	movw	r24, r10
    21ea:	b4 01       	movw	r22, r8
    21ec:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    21f0:	88 23       	and	r24, r24
    21f2:	cc f4       	brge	.+50     	; 0x2226 <spindle_compute_pwm_value+0x7e>
  
    // Called by spindle_set_state() and step segment generator. Keep routine small and efficient.
    uint8_t spindle_compute_pwm_value(float rpm) // 328p PWM register is 8-bit.
    {
      uint8_t pwm_value;
      rpm *= (0.010*sys.spindle_speed_ovr); // Scale by spindle speed override value.
    21f4:	60 91 85 05 	lds	r22, 0x0585	; 0x800585 <sys+0x9>
    21f8:	70 e0       	ldi	r23, 0x00	; 0
    21fa:	80 e0       	ldi	r24, 0x00	; 0
    21fc:	90 e0       	ldi	r25, 0x00	; 0
    21fe:	0e 94 18 30 	call	0x6030	; 0x6030 <__floatsisf>
    2202:	2a e0       	ldi	r18, 0x0A	; 10
    2204:	37 ed       	ldi	r19, 0xD7	; 215
    2206:	43 e2       	ldi	r20, 0x23	; 35
    2208:	5c e3       	ldi	r21, 0x3C	; 60
    220a:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    220e:	a3 01       	movw	r20, r6
    2210:	92 01       	movw	r18, r4
    2212:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    2216:	2b 01       	movw	r4, r22
    2218:	3c 01       	movw	r6, r24
      // Calculate PWM register value based on rpm max/min settings and programmed rpm.
      if ((settings.rpm_min >= settings.rpm_max) || (rpm >= settings.rpm_max)) {
    221a:	a7 01       	movw	r20, r14
    221c:	96 01       	movw	r18, r12
    221e:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    2222:	88 23       	and	r24, r24
    2224:	54 f0       	brlt	.+20     	; 0x223a <spindle_compute_pwm_value+0x92>
        // No PWM range possible. Set simple on/off spindle control pin state.
        sys.spindle_speed = settings.rpm_max;
    2226:	c0 92 89 05 	sts	0x0589, r12	; 0x800589 <sys+0xd>
    222a:	d0 92 8a 05 	sts	0x058A, r13	; 0x80058a <sys+0xe>
    222e:	e0 92 8b 05 	sts	0x058B, r14	; 0x80058b <sys+0xf>
    2232:	f0 92 8c 05 	sts	0x058C, r15	; 0x80058c <sys+0x10>
        pwm_value = SPINDLE_PWM_MAX_VALUE;
    2236:	8f ef       	ldi	r24, 0xFF	; 255
    2238:	47 c0       	rjmp	.+142    	; 0x22c8 <spindle_compute_pwm_value+0x120>
      } else if (rpm <= settings.rpm_min) {
    223a:	a5 01       	movw	r20, r10
    223c:	94 01       	movw	r18, r8
    223e:	c3 01       	movw	r24, r6
    2240:	b2 01       	movw	r22, r4
    2242:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    2246:	18 16       	cp	r1, r24
    2248:	e4 f0       	brlt	.+56     	; 0x2282 <spindle_compute_pwm_value+0xda>
        if (rpm == 0.0) { // S0 disables spindle
    224a:	20 e0       	ldi	r18, 0x00	; 0
    224c:	30 e0       	ldi	r19, 0x00	; 0
    224e:	a9 01       	movw	r20, r18
    2250:	c3 01       	movw	r24, r6
    2252:	b2 01       	movw	r22, r4
    2254:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    2258:	81 11       	cpse	r24, r1
    225a:	09 c0       	rjmp	.+18     	; 0x226e <spindle_compute_pwm_value+0xc6>
          sys.spindle_speed = 0.0;
    225c:	10 92 89 05 	sts	0x0589, r1	; 0x800589 <sys+0xd>
    2260:	10 92 8a 05 	sts	0x058A, r1	; 0x80058a <sys+0xe>
    2264:	10 92 8b 05 	sts	0x058B, r1	; 0x80058b <sys+0xf>
    2268:	10 92 8c 05 	sts	0x058C, r1	; 0x80058c <sys+0x10>
    226c:	2d c0       	rjmp	.+90     	; 0x22c8 <spindle_compute_pwm_value+0x120>
          pwm_value = SPINDLE_PWM_OFF_VALUE;
        } else { // Set minimum PWM output
          sys.spindle_speed = settings.rpm_min;
    226e:	80 92 89 05 	sts	0x0589, r8	; 0x800589 <sys+0xd>
    2272:	90 92 8a 05 	sts	0x058A, r9	; 0x80058a <sys+0xe>
    2276:	a0 92 8b 05 	sts	0x058B, r10	; 0x80058b <sys+0xf>
    227a:	b0 92 8c 05 	sts	0x058C, r11	; 0x80058c <sys+0x10>
          pwm_value = SPINDLE_PWM_MIN_VALUE;
    227e:	81 e0       	ldi	r24, 0x01	; 1
    2280:	23 c0       	rjmp	.+70     	; 0x22c8 <spindle_compute_pwm_value+0x120>
        }
      } else { 
        // Compute intermediate PWM value with linear spindle speed model.
        // NOTE: A nonlinear model could be installed here, if required, but keep it VERY light-weight.
        sys.spindle_speed = rpm;
    2282:	40 92 89 05 	sts	0x0589, r4	; 0x800589 <sys+0xd>
    2286:	50 92 8a 05 	sts	0x058A, r5	; 0x80058a <sys+0xe>
    228a:	60 92 8b 05 	sts	0x058B, r6	; 0x80058b <sys+0xf>
    228e:	70 92 8c 05 	sts	0x058C, r7	; 0x80058c <sys+0x10>
        pwm_value = floor((rpm-settings.rpm_min)*pwm_gradient) + SPINDLE_PWM_MIN_VALUE;
    2292:	a5 01       	movw	r20, r10
    2294:	94 01       	movw	r18, r8
    2296:	c3 01       	movw	r24, r6
    2298:	b2 01       	movw	r22, r4
    229a:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    229e:	20 91 02 01 	lds	r18, 0x0102	; 0x800102 <__data_end>
    22a2:	30 91 03 01 	lds	r19, 0x0103	; 0x800103 <__data_end+0x1>
    22a6:	40 91 04 01 	lds	r20, 0x0104	; 0x800104 <__data_end+0x2>
    22aa:	50 91 05 01 	lds	r21, 0x0105	; 0x800105 <__data_end+0x3>
    22ae:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    22b2:	0e 94 53 30 	call	0x60a6	; 0x60a6 <floor>
    22b6:	20 e0       	ldi	r18, 0x00	; 0
    22b8:	30 e0       	ldi	r19, 0x00	; 0
    22ba:	40 e8       	ldi	r20, 0x80	; 128
    22bc:	5f e3       	ldi	r21, 0x3F	; 63
    22be:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    22c2:	0e 94 e7 2f 	call	0x5fce	; 0x5fce <__fixunssfsi>
    22c6:	86 2f       	mov	r24, r22
      }
      return(pwm_value);
    }
    22c8:	ff 90       	pop	r15
    22ca:	ef 90       	pop	r14
    22cc:	df 90       	pop	r13
    22ce:	cf 90       	pop	r12
    22d0:	bf 90       	pop	r11
    22d2:	af 90       	pop	r10
    22d4:	9f 90       	pop	r9
    22d6:	8f 90       	pop	r8
    22d8:	7f 90       	pop	r7
    22da:	6f 90       	pop	r6
    22dc:	5f 90       	pop	r5
    22de:	4f 90       	pop	r4
    22e0:	08 95       	ret

000022e2 <spindle_set_state>:
  void spindle_set_state(uint8_t state, float rpm)
#else
  void _spindle_set_state(uint8_t state)
#endif
{
  if (sys.abort) { return; } // Block during abort.
    22e2:	90 91 7d 05 	lds	r25, 0x057D	; 0x80057d <sys+0x1>
    22e6:	91 11       	cpse	r25, r1
    22e8:	23 c0       	rjmp	.+70     	; 0x2330 <spindle_set_state+0x4e>

  if (state == SPINDLE_DISABLE) { // Halt or set spindle direction and rpm.
    22ea:	81 11       	cpse	r24, r1
    22ec:	0b c0       	rjmp	.+22     	; 0x2304 <spindle_set_state+0x22>
  
    #ifdef VARIABLE_SPINDLE
      sys.spindle_speed = 0.0;
    22ee:	10 92 89 05 	sts	0x0589, r1	; 0x800589 <sys+0xd>
    22f2:	10 92 8a 05 	sts	0x058A, r1	; 0x80058a <sys+0xe>
    22f6:	10 92 8b 05 	sts	0x058B, r1	; 0x80058b <sys+0xf>
    22fa:	10 92 8c 05 	sts	0x058C, r1	; 0x80058c <sys+0x10>
    #endif
    spindle_stop();
    22fe:	0e 94 91 10 	call	0x2122	; 0x2122 <spindle_stop>
    2302:	14 c0       	rjmp	.+40     	; 0x232c <spindle_set_state+0x4a>
  
  } else {
    
    #if !defined(USE_SPINDLE_DIR_AS_ENABLE_PIN) && !defined(ENABLE_DUAL_AXIS)
      if (state == SPINDLE_ENABLE_CW) {
    2304:	80 31       	cpi	r24, 0x10	; 16
    2306:	11 f4       	brne	.+4      	; 0x230c <spindle_set_state+0x2a>
        SPINDLE_DIRECTION_PORT &= ~(1<<SPINDLE_DIRECTION_BIT);
    2308:	2d 98       	cbi	0x05, 5	; 5
    230a:	0a c0       	rjmp	.+20     	; 0x2320 <spindle_set_state+0x3e>
      } else {
        SPINDLE_DIRECTION_PORT |= (1<<SPINDLE_DIRECTION_BIT);
    230c:	2d 9a       	sbi	0x05, 5	; 5
      }
    #endif
  
    #ifdef VARIABLE_SPINDLE
      // NOTE: Assumes all calls to this function is when Grbl is not moving or must remain off.
      if (settings.flags & BITFLAG_LASER_MODE) { 
    230e:	90 91 53 07 	lds	r25, 0x0753	; 0x800753 <settings+0x45>
    2312:	91 ff       	sbrs	r25, 1
    2314:	05 c0       	rjmp	.+10     	; 0x2320 <spindle_set_state+0x3e>
        if (state == SPINDLE_ENABLE_CCW) { rpm = 0.0; } // TODO: May need to be rpm_min*(100/MAX_SPINDLE_SPEED_OVERRIDE);
    2316:	80 32       	cpi	r24, 0x20	; 32
    2318:	19 f4       	brne	.+6      	; 0x2320 <spindle_set_state+0x3e>
    231a:	40 e0       	ldi	r20, 0x00	; 0
    231c:	50 e0       	ldi	r21, 0x00	; 0
    231e:	ba 01       	movw	r22, r20
      }
      spindle_set_speed(spindle_compute_pwm_value(rpm));
    2320:	cb 01       	movw	r24, r22
    2322:	ba 01       	movw	r22, r20
    2324:	0e 94 d4 10 	call	0x21a8	; 0x21a8 <spindle_compute_pwm_value>
    2328:	0e 94 c4 10 	call	0x2188	; 0x2188 <spindle_set_speed>
      #endif    
    #endif
  
  }
  
  sys.report_ovr_counter = 0; // Set to report change immediately
    232c:	10 92 87 05 	sts	0x0587, r1	; 0x800587 <sys+0xb>
    2330:	08 95       	ret

00002332 <spindle_sync>:

// G-code parser entry-point for setting spindle state. Forces a planner buffer sync and bails 
// if an abort or check-mode is active.
#ifdef VARIABLE_SPINDLE
  void spindle_sync(uint8_t state, float rpm)
  {
    2332:	cf 92       	push	r12
    2334:	df 92       	push	r13
    2336:	ef 92       	push	r14
    2338:	ff 92       	push	r15
    233a:	cf 93       	push	r28
    if (sys.state == STATE_CHECK_MODE) { return; }
    233c:	90 91 7c 05 	lds	r25, 0x057C	; 0x80057c <sys>
    2340:	92 30       	cpi	r25, 0x02	; 2
    2342:	51 f0       	breq	.+20     	; 0x2358 <spindle_sync+0x26>
    2344:	6a 01       	movw	r12, r20
    2346:	7b 01       	movw	r14, r22
    2348:	c8 2f       	mov	r28, r24
    protocol_buffer_synchronize(); // Empty planner buffer to ensure spindle is set when programmed.
    234a:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <protocol_buffer_synchronize>
    spindle_set_state(state,rpm);
    234e:	b7 01       	movw	r22, r14
    2350:	a6 01       	movw	r20, r12
    2352:	8c 2f       	mov	r24, r28
    2354:	0e 94 71 11 	call	0x22e2	; 0x22e2 <spindle_set_state>
  }
    2358:	cf 91       	pop	r28
    235a:	ff 90       	pop	r15
    235c:	ef 90       	pop	r14
    235e:	df 90       	pop	r13
    2360:	cf 90       	pop	r12
    2362:	08 95       	ret

00002364 <coolant_get_state>:
{
  uint8_t cl_state = COOLANT_STATE_DISABLE;
  #ifdef INVERT_COOLANT_FLOOD_PIN
    if (bit_isfalse(COOLANT_FLOOD_PORT,(1 << COOLANT_FLOOD_BIT))) {
  #else
    if (bit_istrue(COOLANT_FLOOD_PORT,(1 << COOLANT_FLOOD_BIT))) {
    2364:	43 9b       	sbis	0x08, 3	; 8
    2366:	02 c0       	rjmp	.+4      	; 0x236c <coolant_get_state+0x8>
  #endif
    cl_state |= COOLANT_STATE_FLOOD;
    2368:	80 e4       	ldi	r24, 0x40	; 64
    236a:	08 95       	ret


// Returns current coolant output state. Overrides may alter it from programmed state.
uint8_t coolant_get_state()
{
  uint8_t cl_state = COOLANT_STATE_DISABLE;
    236c:	80 e0       	ldi	r24, 0x00	; 0
    #endif
      cl_state |= COOLANT_STATE_MIST;
    }
  #endif
  return(cl_state);
}
    236e:	08 95       	ret

00002370 <coolant_stop>:
void coolant_stop()
{
  #ifdef INVERT_COOLANT_FLOOD_PIN
    COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
  #else
    COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
    2370:	43 98       	cbi	0x08, 3	; 8
    2372:	08 95       	ret

00002374 <coolant_init>:
#include "grbl.h"


void coolant_init()
{
  COOLANT_FLOOD_DDR |= (1 << COOLANT_FLOOD_BIT); // Configure as output pin
    2374:	3b 9a       	sbi	0x07, 3	; 7
  #ifdef ENABLE_M7
    COOLANT_MIST_DDR |= (1 << COOLANT_MIST_BIT);
  #endif
  coolant_stop();
    2376:	0e 94 b8 11 	call	0x2370	; 0x2370 <coolant_stop>
    237a:	08 95       	ret

0000237c <coolant_set_state>:
// if enabled. Also sets a flag to report an update to a coolant state.
// Called by coolant toggle override, parking restore, parking retract, sleep mode, g-code
// parser program end, and g-code parser coolant_sync().
void coolant_set_state(uint8_t mode)
{
  if (sys.abort) { return; } // Block during abort.  
    237c:	90 91 7d 05 	lds	r25, 0x057D	; 0x80057d <sys+0x1>
    2380:	91 11       	cpse	r25, r1
    2382:	07 c0       	rjmp	.+14     	; 0x2392 <coolant_set_state+0x16>
  
	if (mode & COOLANT_FLOOD_ENABLE) {
    2384:	86 ff       	sbrs	r24, 6
    2386:	02 c0       	rjmp	.+4      	; 0x238c <coolant_set_state+0x10>
		#ifdef INVERT_COOLANT_FLOOD_PIN
			COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
		#else
			COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
    2388:	43 9a       	sbi	0x08, 3	; 8
    238a:	01 c0       	rjmp	.+2      	; 0x238e <coolant_set_state+0x12>
		#endif
	} else {
	  #ifdef INVERT_COOLANT_FLOOD_PIN
			COOLANT_FLOOD_PORT |= (1 << COOLANT_FLOOD_BIT);
		#else
			COOLANT_FLOOD_PORT &= ~(1 << COOLANT_FLOOD_BIT);
    238c:	43 98       	cbi	0x08, 3	; 8
				COOLANT_MIST_PORT &= ~(1 << COOLANT_MIST_BIT);
			#endif
		}
	#endif
	
  sys.report_ovr_counter = 0; // Set to report change immediately
    238e:	10 92 87 05 	sts	0x0587, r1	; 0x800587 <sys+0xb>
    2392:	08 95       	ret

00002394 <coolant_sync>:


// G-code parser entry-point for setting coolant state. Forces a planner buffer sync and bails 
// if an abort or check-mode is active.
void coolant_sync(uint8_t mode)
{
    2394:	cf 93       	push	r28
  if (sys.state == STATE_CHECK_MODE) { return; }
    2396:	90 91 7c 05 	lds	r25, 0x057C	; 0x80057c <sys>
    239a:	92 30       	cpi	r25, 0x02	; 2
    239c:	31 f0       	breq	.+12     	; 0x23aa <coolant_sync+0x16>
    239e:	c8 2f       	mov	r28, r24
  protocol_buffer_synchronize(); // Ensure coolant turns on when specified in program.
    23a0:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <protocol_buffer_synchronize>
  coolant_set_state(mode);
    23a4:	8c 2f       	mov	r24, r28
    23a6:	0e 94 be 11 	call	0x237c	; 0x237c <coolant_set_state>
}
    23aa:	cf 91       	pop	r28
    23ac:	08 95       	ret

000023ae <serial_init>:
    if (tail == RX_RING_BUFFER) { tail = 0; }
    serial_rx_buffer_tail = tail;

    return data;
  }
}
    23ae:	e0 ec       	ldi	r30, 0xC0	; 192
    23b0:	f0 e0       	ldi	r31, 0x00	; 0
    23b2:	80 81       	ld	r24, Z
    23b4:	82 60       	ori	r24, 0x02	; 2
    23b6:	80 83       	st	Z, r24
    23b8:	10 92 c5 00 	sts	0x00C5, r1	; 0x8000c5 <__DATA_REGION_ORIGIN__+0x65>
    23bc:	80 e1       	ldi	r24, 0x10	; 16
    23be:	80 93 c4 00 	sts	0x00C4, r24	; 0x8000c4 <__DATA_REGION_ORIGIN__+0x64>
    23c2:	e1 ec       	ldi	r30, 0xC1	; 193
    23c4:	f0 e0       	ldi	r31, 0x00	; 0
    23c6:	80 81       	ld	r24, Z
    23c8:	88 69       	ori	r24, 0x98	; 152
    23ca:	80 83       	st	Z, r24
    23cc:	08 95       	ret

000023ce <__vector_19>:
    23ce:	1f 92       	push	r1
    23d0:	0f 92       	push	r0
    23d2:	0f b6       	in	r0, 0x3f	; 63
    23d4:	0f 92       	push	r0
    23d6:	11 24       	eor	r1, r1
    23d8:	8f 93       	push	r24
    23da:	9f 93       	push	r25
    23dc:	ef 93       	push	r30
    23de:	ff 93       	push	r31
    23e0:	80 91 06 01 	lds	r24, 0x0106	; 0x800106 <serial_tx_buffer_tail>
    23e4:	e8 2f       	mov	r30, r24
    23e6:	f0 e0       	ldi	r31, 0x00	; 0
    23e8:	ec 5d       	subi	r30, 0xDC	; 220
    23ea:	f9 4f       	sbci	r31, 0xF9	; 249
    23ec:	90 81       	ld	r25, Z
    23ee:	90 93 c6 00 	sts	0x00C6, r25	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
    23f2:	8f 5f       	subi	r24, 0xFF	; 255
    23f4:	89 36       	cpi	r24, 0x69	; 105
    23f6:	09 f4       	brne	.+2      	; 0x23fa <__vector_19+0x2c>
    23f8:	80 e0       	ldi	r24, 0x00	; 0
    23fa:	80 93 06 01 	sts	0x0106, r24	; 0x800106 <serial_tx_buffer_tail>
    23fe:	90 91 07 01 	lds	r25, 0x0107	; 0x800107 <serial_tx_buffer_head>
    2402:	89 13       	cpse	r24, r25
    2404:	05 c0       	rjmp	.+10     	; 0x2410 <__vector_19+0x42>
    2406:	e1 ec       	ldi	r30, 0xC1	; 193
    2408:	f0 e0       	ldi	r31, 0x00	; 0
    240a:	80 81       	ld	r24, Z
    240c:	8f 7d       	andi	r24, 0xDF	; 223
    240e:	80 83       	st	Z, r24
    2410:	ff 91       	pop	r31
    2412:	ef 91       	pop	r30
    2414:	9f 91       	pop	r25
    2416:	8f 91       	pop	r24
    2418:	0f 90       	pop	r0
    241a:	0f be       	out	0x3f, r0	; 63
    241c:	0f 90       	pop	r0
    241e:	1f 90       	pop	r1
    2420:	18 95       	reti

00002422 <__vector_18>:


ISR(SERIAL_RX)
{
    2422:	1f 92       	push	r1
    2424:	0f 92       	push	r0
    2426:	0f b6       	in	r0, 0x3f	; 63
    2428:	0f 92       	push	r0
    242a:	11 24       	eor	r1, r1
    242c:	2f 93       	push	r18
    242e:	3f 93       	push	r19
    2430:	4f 93       	push	r20
    2432:	5f 93       	push	r21
    2434:	6f 93       	push	r22
    2436:	7f 93       	push	r23
    2438:	8f 93       	push	r24
    243a:	9f 93       	push	r25
    243c:	af 93       	push	r26
    243e:	bf 93       	push	r27
    2440:	ef 93       	push	r30
    2442:	ff 93       	push	r31
  uint8_t data = UDR0;
    2444:	e0 91 c6 00 	lds	r30, 0x00C6	; 0x8000c6 <__DATA_REGION_ORIGIN__+0x66>
  uint8_t next_head;

  // Pick off realtime command characters directly from the serial stream. These characters are
  // not passed into the main buffer, but these set system state flag bits for realtime execution.
  switch (data) {
    2448:	e1 32       	cpi	r30, 0x21	; 33
    244a:	a1 f0       	breq	.+40     	; 0x2474 <__vector_18+0x52>
    244c:	18 f4       	brcc	.+6      	; 0x2454 <__vector_18+0x32>
    244e:	e8 31       	cpi	r30, 0x18	; 24
    2450:	31 f0       	breq	.+12     	; 0x245e <__vector_18+0x3c>
    2452:	14 c0       	rjmp	.+40     	; 0x247c <__vector_18+0x5a>
    2454:	ef 33       	cpi	r30, 0x3F	; 63
    2456:	31 f0       	breq	.+12     	; 0x2464 <__vector_18+0x42>
    2458:	ee 37       	cpi	r30, 0x7E	; 126
    245a:	41 f0       	breq	.+16     	; 0x246c <__vector_18+0x4a>
    245c:	0f c0       	rjmp	.+30     	; 0x247c <__vector_18+0x5a>
    case CMD_RESET:         mc_reset(); break; // Call motion control reset routine.
    245e:	0e 94 5d 05 	call	0xaba	; 0xaba <mc_reset>
    2462:	7e c0       	rjmp	.+252    	; 0x2560 <__vector_18+0x13e>
    case CMD_STATUS_REPORT: system_set_exec_state_flag(EXEC_STATUS_REPORT); break; // Set as true
    2464:	81 e0       	ldi	r24, 0x01	; 1
    2466:	0e 94 31 2e 	call	0x5c62	; 0x5c62 <system_set_exec_state_flag>
    246a:	7a c0       	rjmp	.+244    	; 0x2560 <__vector_18+0x13e>
    case CMD_CYCLE_START:   system_set_exec_state_flag(EXEC_CYCLE_START); break; // Set as true
    246c:	82 e0       	ldi	r24, 0x02	; 2
    246e:	0e 94 31 2e 	call	0x5c62	; 0x5c62 <system_set_exec_state_flag>
    2472:	76 c0       	rjmp	.+236    	; 0x2560 <__vector_18+0x13e>
    case CMD_FEED_HOLD:     system_set_exec_state_flag(EXEC_FEED_HOLD); break; // Set as true
    2474:	88 e0       	ldi	r24, 0x08	; 8
    2476:	0e 94 31 2e 	call	0x5c62	; 0x5c62 <system_set_exec_state_flag>
    247a:	72 c0       	rjmp	.+228    	; 0x2560 <__vector_18+0x13e>
    default :
      if (data > 0x7F) { // Real-time control characters are extended ACSII only.
    247c:	ee 23       	and	r30, r30
    247e:	0c f0       	brlt	.+2      	; 0x2482 <__vector_18+0x60>
    2480:	5e c0       	rjmp	.+188    	; 0x253e <__vector_18+0x11c>
        switch(data) {
    2482:	8e 2f       	mov	r24, r30
    2484:	90 e0       	ldi	r25, 0x00	; 0
    2486:	fc 01       	movw	r30, r24
    2488:	e4 58       	subi	r30, 0x84	; 132
    248a:	f1 09       	sbc	r31, r1
    248c:	ed 31       	cpi	r30, 0x1D	; 29
    248e:	f1 05       	cpc	r31, r1
    2490:	08 f0       	brcs	.+2      	; 0x2494 <__vector_18+0x72>
    2492:	66 c0       	rjmp	.+204    	; 0x2560 <__vector_18+0x13e>
    2494:	e9 53       	subi	r30, 0x39	; 57
    2496:	ff 4f       	sbci	r31, 0xFF	; 255
    2498:	0c 94 cf 32 	jmp	0x659e	; 0x659e <__tablejump2__>
          case CMD_SAFETY_DOOR:   system_set_exec_state_flag(EXEC_SAFETY_DOOR); break; // Set as true
    249c:	80 e2       	ldi	r24, 0x20	; 32
    249e:	0e 94 31 2e 	call	0x5c62	; 0x5c62 <system_set_exec_state_flag>
    24a2:	5e c0       	rjmp	.+188    	; 0x2560 <__vector_18+0x13e>
          case CMD_JOG_CANCEL:   
            if (sys.state & STATE_JOG) { // Block all other states from invoking motion cancel.
    24a4:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    24a8:	85 ff       	sbrs	r24, 5
    24aa:	5a c0       	rjmp	.+180    	; 0x2560 <__vector_18+0x13e>
              system_set_exec_state_flag(EXEC_MOTION_CANCEL); 
    24ac:	80 e4       	ldi	r24, 0x40	; 64
    24ae:	0e 94 31 2e 	call	0x5c62	; 0x5c62 <system_set_exec_state_flag>
    24b2:	56 c0       	rjmp	.+172    	; 0x2560 <__vector_18+0x13e>
            }
            break; 
          #ifdef DEBUG
            case CMD_DEBUG_REPORT: {uint8_t sreg = SREG; cli(); bit_true(sys_rt_exec_debug,EXEC_DEBUG_REPORT); SREG = sreg;} break;
    24b4:	9f b7       	in	r25, 0x3f	; 63
    24b6:	f8 94       	cli
    24b8:	80 91 a9 05 	lds	r24, 0x05A9	; 0x8005a9 <sys_rt_exec_debug>
    24bc:	81 60       	ori	r24, 0x01	; 1
    24be:	80 93 a9 05 	sts	0x05A9, r24	; 0x8005a9 <sys_rt_exec_debug>
    24c2:	9f bf       	out	0x3f, r25	; 63
    24c4:	4d c0       	rjmp	.+154    	; 0x2560 <__vector_18+0x13e>
          #endif
          case CMD_FEED_OVR_RESET: system_set_exec_motion_override_flag(EXEC_FEED_OVR_RESET); break;
    24c6:	81 e0       	ldi	r24, 0x01	; 1
    24c8:	0e 94 50 2e 	call	0x5ca0	; 0x5ca0 <system_set_exec_motion_override_flag>
    24cc:	49 c0       	rjmp	.+146    	; 0x2560 <__vector_18+0x13e>
          case CMD_FEED_OVR_COARSE_PLUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_COARSE_PLUS); break;
    24ce:	82 e0       	ldi	r24, 0x02	; 2
    24d0:	0e 94 50 2e 	call	0x5ca0	; 0x5ca0 <system_set_exec_motion_override_flag>
    24d4:	45 c0       	rjmp	.+138    	; 0x2560 <__vector_18+0x13e>
          case CMD_FEED_OVR_COARSE_MINUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_COARSE_MINUS); break;
    24d6:	84 e0       	ldi	r24, 0x04	; 4
    24d8:	0e 94 50 2e 	call	0x5ca0	; 0x5ca0 <system_set_exec_motion_override_flag>
    24dc:	41 c0       	rjmp	.+130    	; 0x2560 <__vector_18+0x13e>
          case CMD_FEED_OVR_FINE_PLUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_FINE_PLUS); break;
    24de:	88 e0       	ldi	r24, 0x08	; 8
    24e0:	0e 94 50 2e 	call	0x5ca0	; 0x5ca0 <system_set_exec_motion_override_flag>
    24e4:	3d c0       	rjmp	.+122    	; 0x2560 <__vector_18+0x13e>
          case CMD_FEED_OVR_FINE_MINUS: system_set_exec_motion_override_flag(EXEC_FEED_OVR_FINE_MINUS); break;
    24e6:	80 e1       	ldi	r24, 0x10	; 16
    24e8:	0e 94 50 2e 	call	0x5ca0	; 0x5ca0 <system_set_exec_motion_override_flag>
    24ec:	39 c0       	rjmp	.+114    	; 0x2560 <__vector_18+0x13e>
          case CMD_RAPID_OVR_RESET: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_RESET); break;
    24ee:	80 e2       	ldi	r24, 0x20	; 32
    24f0:	0e 94 50 2e 	call	0x5ca0	; 0x5ca0 <system_set_exec_motion_override_flag>
    24f4:	35 c0       	rjmp	.+106    	; 0x2560 <__vector_18+0x13e>
          case CMD_RAPID_OVR_MEDIUM: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_MEDIUM); break;
    24f6:	80 e4       	ldi	r24, 0x40	; 64
    24f8:	0e 94 50 2e 	call	0x5ca0	; 0x5ca0 <system_set_exec_motion_override_flag>
    24fc:	31 c0       	rjmp	.+98     	; 0x2560 <__vector_18+0x13e>
          case CMD_RAPID_OVR_LOW: system_set_exec_motion_override_flag(EXEC_RAPID_OVR_LOW); break;
    24fe:	80 e8       	ldi	r24, 0x80	; 128
    2500:	0e 94 50 2e 	call	0x5ca0	; 0x5ca0 <system_set_exec_motion_override_flag>
    2504:	2d c0       	rjmp	.+90     	; 0x2560 <__vector_18+0x13e>
          case CMD_SPINDLE_OVR_RESET: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_RESET); break;
    2506:	81 e0       	ldi	r24, 0x01	; 1
    2508:	0e 94 59 2e 	call	0x5cb2	; 0x5cb2 <system_set_exec_accessory_override_flag>
    250c:	29 c0       	rjmp	.+82     	; 0x2560 <__vector_18+0x13e>
          case CMD_SPINDLE_OVR_COARSE_PLUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_COARSE_PLUS); break;
    250e:	82 e0       	ldi	r24, 0x02	; 2
    2510:	0e 94 59 2e 	call	0x5cb2	; 0x5cb2 <system_set_exec_accessory_override_flag>
    2514:	25 c0       	rjmp	.+74     	; 0x2560 <__vector_18+0x13e>
          case CMD_SPINDLE_OVR_COARSE_MINUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_COARSE_MINUS); break;
    2516:	84 e0       	ldi	r24, 0x04	; 4
    2518:	0e 94 59 2e 	call	0x5cb2	; 0x5cb2 <system_set_exec_accessory_override_flag>
    251c:	21 c0       	rjmp	.+66     	; 0x2560 <__vector_18+0x13e>
          case CMD_SPINDLE_OVR_FINE_PLUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_FINE_PLUS); break;
    251e:	88 e0       	ldi	r24, 0x08	; 8
    2520:	0e 94 59 2e 	call	0x5cb2	; 0x5cb2 <system_set_exec_accessory_override_flag>
    2524:	1d c0       	rjmp	.+58     	; 0x2560 <__vector_18+0x13e>
          case CMD_SPINDLE_OVR_FINE_MINUS: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_FINE_MINUS); break;
    2526:	80 e1       	ldi	r24, 0x10	; 16
    2528:	0e 94 59 2e 	call	0x5cb2	; 0x5cb2 <system_set_exec_accessory_override_flag>
    252c:	19 c0       	rjmp	.+50     	; 0x2560 <__vector_18+0x13e>
          case CMD_SPINDLE_OVR_STOP: system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP); break;
    252e:	80 e2       	ldi	r24, 0x20	; 32
    2530:	0e 94 59 2e 	call	0x5cb2	; 0x5cb2 <system_set_exec_accessory_override_flag>
    2534:	15 c0       	rjmp	.+42     	; 0x2560 <__vector_18+0x13e>
          case CMD_COOLANT_FLOOD_OVR_TOGGLE: system_set_exec_accessory_override_flag(EXEC_COOLANT_FLOOD_OVR_TOGGLE); break;
    2536:	80 e4       	ldi	r24, 0x40	; 64
    2538:	0e 94 59 2e 	call	0x5cb2	; 0x5cb2 <system_set_exec_accessory_override_flag>
    253c:	11 c0       	rjmp	.+34     	; 0x2560 <__vector_18+0x13e>
            case CMD_COOLANT_MIST_OVR_TOGGLE: system_set_exec_accessory_override_flag(EXEC_COOLANT_MIST_OVR_TOGGLE); break;
          #endif
        }
        // Throw away any unfound extended-ASCII character by not passing it to the serial buffer.
      } else { // Write character to buffer
        next_head = serial_rx_buffer_head + 1;
    253e:	a0 91 09 01 	lds	r26, 0x0109	; 0x800109 <serial_rx_buffer_head>
    2542:	81 e0       	ldi	r24, 0x01	; 1
    2544:	8a 0f       	add	r24, r26
        if (next_head == RX_RING_BUFFER) { next_head = 0; }
    2546:	81 38       	cpi	r24, 0x81	; 129
    2548:	09 f4       	brne	.+2      	; 0x254c <__vector_18+0x12a>
    254a:	80 e0       	ldi	r24, 0x00	; 0

        // Write data to buffer unless it is full.
        if (next_head != serial_rx_buffer_tail) {
    254c:	90 91 08 01 	lds	r25, 0x0108	; 0x800108 <serial_rx_buffer_tail>
    2550:	89 17       	cp	r24, r25
    2552:	31 f0       	breq	.+12     	; 0x2560 <__vector_18+0x13e>
          serial_rx_buffer[serial_rx_buffer_head] = data;
    2554:	b0 e0       	ldi	r27, 0x00	; 0
    2556:	a3 57       	subi	r26, 0x73	; 115
    2558:	b9 4f       	sbci	r27, 0xF9	; 249
    255a:	ec 93       	st	X, r30
          serial_rx_buffer_head = next_head;
    255c:	80 93 09 01 	sts	0x0109, r24	; 0x800109 <serial_rx_buffer_head>
        }
      }
  }
}
    2560:	ff 91       	pop	r31
    2562:	ef 91       	pop	r30
    2564:	bf 91       	pop	r27
    2566:	af 91       	pop	r26
    2568:	9f 91       	pop	r25
    256a:	8f 91       	pop	r24
    256c:	7f 91       	pop	r23
    256e:	6f 91       	pop	r22
    2570:	5f 91       	pop	r21
    2572:	4f 91       	pop	r20
    2574:	3f 91       	pop	r19
    2576:	2f 91       	pop	r18
    2578:	0f 90       	pop	r0
    257a:	0f be       	out	0x3f, r0	; 63
    257c:	0f 90       	pop	r0
    257e:	1f 90       	pop	r1
    2580:	18 95       	reti

00002582 <serial_reset_read_buffer>:


void serial_reset_read_buffer()
{
  serial_rx_buffer_tail = serial_rx_buffer_head;
    2582:	80 91 09 01 	lds	r24, 0x0109	; 0x800109 <serial_rx_buffer_head>
    2586:	80 93 08 01 	sts	0x0108, r24	; 0x800108 <serial_rx_buffer_tail>
    258a:	08 95       	ret

0000258c <gcode_get_byte>:

static void protocol_exec_rt_suspend();

uint8_t gcode_get_byte(void)
{
	return pgm_read_byte(p_gcode++);
    258c:	e0 91 00 01 	lds	r30, 0x0100	; 0x800100 <__data_start>
    2590:	f0 91 01 01 	lds	r31, 0x0101	; 0x800101 <__data_start+0x1>
    2594:	cf 01       	movw	r24, r30
    2596:	01 96       	adiw	r24, 0x01	; 1
    2598:	90 93 01 01 	sts	0x0101, r25	; 0x800101 <__data_start+0x1>
    259c:	80 93 00 01 	sts	0x0100, r24	; 0x800100 <__data_start>
    25a0:	84 91       	lpm	r24, Z
}
    25a2:	08 95       	ret

000025a4 <protocol_auto_cycle_start>:
// when one of these conditions exist respectively: There are no more blocks sent (i.e. streaming
// is finished, single commands), a command that needs to wait for the motions in the buffer to
// execute calls a buffer sync, or the planner buffer is full and ready to go.
void protocol_auto_cycle_start()
{
  if (plan_get_current_block() != NULL) { // Check if there are any blocks in the buffer.
    25a4:	0e 94 47 25 	call	0x4a8e	; 0x4a8e <plan_get_current_block>
    25a8:	89 2b       	or	r24, r25
    25aa:	19 f0       	breq	.+6      	; 0x25b2 <protocol_auto_cycle_start+0xe>
    system_set_exec_state_flag(EXEC_CYCLE_START); // If so, execute them!
    25ac:	82 e0       	ldi	r24, 0x02	; 2
    25ae:	0e 94 31 2e 	call	0x5c62	; 0x5c62 <system_set_exec_state_flag>
    25b2:	08 95       	ret

000025b4 <protocol_exec_rt_system>:

// Executes run-time commands, when required. This function primarily operates as Grbl's state
// machine and controls the various real-time features Grbl has to offer.
// NOTE: Do not alter this unless you know exactly what you are doing!
void protocol_exec_rt_system()
{
    25b4:	cf 93       	push	r28
  uint8_t rt_exec; // Temp variable to avoid calling volatile multiple times.
  rt_exec = sys_rt_exec_alarm; // Copy volatile sys_rt_exec_alarm.
    25b6:	c0 91 a8 05 	lds	r28, 0x05A8	; 0x8005a8 <sys_rt_exec_alarm>
  if (rt_exec) { // Enter only if any bit flag is true
    25ba:	cc 23       	and	r28, r28
    25bc:	a9 f0       	breq	.+42     	; 0x25e8 <protocol_exec_rt_system+0x34>
    // System alarm. Everything has shutdown by something that has gone severely wrong. Report
    // the source of the error to the user. If critical, Grbl disables by entering an infinite
    // loop until system reset/abort.
    sys.state = STATE_ALARM; // Set system alarm state
    25be:	81 e0       	ldi	r24, 0x01	; 1
    25c0:	80 93 7c 05 	sts	0x057C, r24	; 0x80057c <sys>
    report_alarm_message(rt_exec);
    25c4:	8c 2f       	mov	r24, r28
    25c6:	0e 94 fe 2c 	call	0x59fc	; 0x59fc <report_alarm_message>
    // Halt everything upon a critical event flag. Currently hard and soft limits flag this.
    if ((rt_exec == EXEC_ALARM_HARD_LIMIT) || (rt_exec == EXEC_ALARM_SOFT_LIMIT)) {
    25ca:	c1 50       	subi	r28, 0x01	; 1
    25cc:	c2 30       	cpi	r28, 0x02	; 2
    25ce:	50 f4       	brcc	.+20     	; 0x25e4 <protocol_exec_rt_system+0x30>
      report_feedback_message(MESSAGE_CRITICAL_EVENT);
    25d0:	81 e0       	ldi	r24, 0x01	; 1
    25d2:	0e 94 ff 2c 	call	0x59fe	; 0x59fe <report_feedback_message>
      system_clear_exec_state_flag(EXEC_RESET); // Disable any existing reset
    25d6:	80 e1       	ldi	r24, 0x10	; 16
    25d8:	0e 94 3a 2e 	call	0x5c74	; 0x5c74 <system_clear_exec_state_flag>
        // Block everything, except reset and status reports, until user issues reset or power
        // cycles. Hard limits typically occur while unattended or not paying attention. Gives
        // the user and a GUI time to do what is needed before resetting, like killing the
        // incoming stream. The same could be said about soft limits. While the position is not
        // lost, continued streaming could cause a serious crash if by chance it gets executed.
      } while (bit_isfalse(sys_rt_exec_state,EXEC_RESET));
    25dc:	80 91 8e 05 	lds	r24, 0x058E	; 0x80058e <sys_rt_exec_state>
    25e0:	84 ff       	sbrs	r24, 4
    25e2:	fc cf       	rjmp	.-8      	; 0x25dc <protocol_exec_rt_system+0x28>
    }
    system_clear_exec_alarm(); // Clear alarm
    25e4:	0e 94 4a 2e 	call	0x5c94	; 0x5c94 <system_clear_exec_alarm>
  }

  rt_exec = sys_rt_exec_state; // Copy volatile sys_rt_exec_state.
    25e8:	c0 91 8e 05 	lds	r28, 0x058E	; 0x80058e <sys_rt_exec_state>
  if (rt_exec) {
    25ec:	cc 23       	and	r28, r28
    25ee:	09 f4       	brne	.+2      	; 0x25f2 <protocol_exec_rt_system+0x3e>
    25f0:	f8 c0       	rjmp	.+496    	; 0x27e2 <protocol_exec_rt_system+0x22e>

    // Execute system abort.
    if (rt_exec & EXEC_RESET) {
    25f2:	c4 ff       	sbrs	r28, 4
    25f4:	04 c0       	rjmp	.+8      	; 0x25fe <protocol_exec_rt_system+0x4a>
      sys.abort = true;  // Only place this is set true.
    25f6:	81 e0       	ldi	r24, 0x01	; 1
    25f8:	80 93 7d 05 	sts	0x057D, r24	; 0x80057d <sys+0x1>
      return; // Nothing else to do but exit.
    25fc:	9d c1       	rjmp	.+826    	; 0x2938 <protocol_exec_rt_system+0x384>
    }

    // Execute and serial print status
    if (rt_exec & EXEC_STATUS_REPORT) {
    25fe:	c0 ff       	sbrs	r28, 0
    2600:	05 c0       	rjmp	.+10     	; 0x260c <protocol_exec_rt_system+0x58>
      report_realtime_status();
    2602:	0e 94 05 2d 	call	0x5a0a	; 0x5a0a <report_realtime_status>
      system_clear_exec_state_flag(EXEC_STATUS_REPORT);
    2606:	81 e0       	ldi	r24, 0x01	; 1
    2608:	0e 94 3a 2e 	call	0x5c74	; 0x5c74 <system_clear_exec_state_flag>
    }

    // NOTE: Once hold is initiated, the system immediately enters a suspend state to block all
    // main program processes until either reset or resumed. This ensures a hold completes safely.
    if (rt_exec & (EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR | EXEC_SLEEP)) {
    260c:	8c 2f       	mov	r24, r28
    260e:	88 7e       	andi	r24, 0xE8	; 232
    2610:	09 f4       	brne	.+2      	; 0x2614 <protocol_exec_rt_system+0x60>
    2612:	64 c0       	rjmp	.+200    	; 0x26dc <protocol_exec_rt_system+0x128>

      // State check for allowable states for hold methods.
      if (!(sys.state & (STATE_ALARM | STATE_CHECK_MODE))) {
    2614:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    2618:	98 2f       	mov	r25, r24
    261a:	93 70       	andi	r25, 0x03	; 3
    261c:	09 f0       	breq	.+2      	; 0x2620 <protocol_exec_rt_system+0x6c>
    261e:	4d c0       	rjmp	.+154    	; 0x26ba <protocol_exec_rt_system+0x106>
      
        // If in CYCLE or JOG states, immediately initiate a motion HOLD.
        if (sys.state & (STATE_CYCLE | STATE_JOG)) {
    2620:	88 72       	andi	r24, 0x28	; 40
    2622:	99 f0       	breq	.+38     	; 0x264a <protocol_exec_rt_system+0x96>
          if (!(sys.suspend & (SUSPEND_MOTION_CANCEL | SUSPEND_JOG_CANCEL))) { // Block, if already holding.
    2624:	80 91 7e 05 	lds	r24, 0x057E	; 0x80057e <sys+0x2>
    2628:	80 7c       	andi	r24, 0xC0	; 192
    262a:	79 f4       	brne	.+30     	; 0x264a <protocol_exec_rt_system+0x96>
            st_update_plan_block_parameters(); // Notify stepper module to recompute for hold deceleration.
    262c:	0e 94 68 19 	call	0x32d0	; 0x32d0 <st_update_plan_block_parameters>
            sys.step_control = STEP_CONTROL_EXECUTE_HOLD; // Initiate suspend state with active flag.
    2630:	ec e7       	ldi	r30, 0x7C	; 124
    2632:	f5 e0       	ldi	r31, 0x05	; 5
    2634:	82 e0       	ldi	r24, 0x02	; 2
    2636:	84 83       	std	Z+4, r24	; 0x04
            if (sys.state == STATE_JOG) { // Jog cancelled upon any hold event, except for sleeping.
    2638:	80 81       	ld	r24, Z
    263a:	80 32       	cpi	r24, 0x20	; 32
    263c:	31 f4       	brne	.+12     	; 0x264a <protocol_exec_rt_system+0x96>
              if (!(rt_exec & EXEC_SLEEP)) { sys.suspend |= SUSPEND_JOG_CANCEL; } 
    263e:	cc 23       	and	r28, r28
    2640:	bc f0       	brlt	.+46     	; 0x2670 <protocol_exec_rt_system+0xbc>
    2642:	92 81       	ldd	r25, Z+2	; 0x02
    2644:	90 68       	ori	r25, 0x80	; 128
    2646:	92 83       	std	Z+2, r25	; 0x02
    2648:	13 c0       	rjmp	.+38     	; 0x2670 <protocol_exec_rt_system+0xbc>
            }
          }
        }
        // If IDLE, Grbl is not in motion. Simply indicate suspend state and hold is complete.
        if (sys.state == STATE_IDLE) { sys.suspend = SUSPEND_HOLD_COMPLETE; }
    264a:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    264e:	81 11       	cpse	r24, r1
    2650:	06 c0       	rjmp	.+12     	; 0x265e <protocol_exec_rt_system+0xaa>
    2652:	91 e0       	ldi	r25, 0x01	; 1
    2654:	90 93 7e 05 	sts	0x057E, r25	; 0x80057e <sys+0x2>

        // Execute and flag a motion cancel with deceleration and return to idle. Used primarily by probing cycle
        // to halt and cancel the remainder of the motion.
        if (rt_exec & EXEC_MOTION_CANCEL) {
    2658:	c6 fd       	sbrc	r28, 6
    265a:	05 c0       	rjmp	.+10     	; 0x2666 <protocol_exec_rt_system+0xb2>
    265c:	65 c1       	rjmp	.+714    	; 0x2928 <protocol_exec_rt_system+0x374>
    265e:	c6 ff       	sbrs	r28, 6
    2660:	07 c0       	rjmp	.+14     	; 0x2670 <protocol_exec_rt_system+0xbc>
          // MOTION_CANCEL only occurs during a CYCLE, but a HOLD and SAFETY_DOOR may been initiated beforehand
          // to hold the CYCLE. Motion cancel is valid for a single planner block motion only, while jog cancel
          // will handle and clear multiple planner block motions.
          if (!(sys.state & STATE_JOG)) { sys.suspend |= SUSPEND_MOTION_CANCEL; } // NOTE: State is STATE_CYCLE.
    2662:	85 fd       	sbrc	r24, 5
    2664:	05 c0       	rjmp	.+10     	; 0x2670 <protocol_exec_rt_system+0xbc>
    2666:	ec e7       	ldi	r30, 0x7C	; 124
    2668:	f5 e0       	ldi	r31, 0x05	; 5
    266a:	92 81       	ldd	r25, Z+2	; 0x02
    266c:	90 64       	ori	r25, 0x40	; 64
    266e:	92 83       	std	Z+2, r25	; 0x02
        }

        // Execute a feed hold with deceleration, if required. Then, suspend system.
        if (rt_exec & EXEC_FEED_HOLD) {
    2670:	c3 ff       	sbrs	r28, 3
    2672:	05 c0       	rjmp	.+10     	; 0x267e <protocol_exec_rt_system+0xca>
          // Block SAFETY_DOOR, JOG, and SLEEP states from changing to HOLD state.
          if (!(sys.state & (STATE_SAFETY_DOOR | STATE_JOG | STATE_SLEEP))) { sys.state = STATE_HOLD; }
    2674:	80 7e       	andi	r24, 0xE0	; 224
    2676:	19 f4       	brne	.+6      	; 0x267e <protocol_exec_rt_system+0xca>
    2678:	80 e1       	ldi	r24, 0x10	; 16
    267a:	80 93 7c 05 	sts	0x057C, r24	; 0x80057c <sys>
        }

        // Execute a safety door stop with a feed hold and disable spindle/coolant.
        // NOTE: Safety door differs from feed holds by stopping everything no matter state, disables powered
        // devices (spindle/coolant), and blocks resuming until switch is re-engaged.
        if (rt_exec & EXEC_SAFETY_DOOR) {
    267e:	c5 ff       	sbrs	r28, 5
    2680:	1c c0       	rjmp	.+56     	; 0x26ba <protocol_exec_rt_system+0x106>
          report_feedback_message(MESSAGE_SAFETY_DOOR_AJAR);
    2682:	86 e0       	ldi	r24, 0x06	; 6
    2684:	0e 94 ff 2c 	call	0x59fe	; 0x59fe <report_feedback_message>
          // If jogging, block safety door methods until jog cancel is complete. Just flag that it happened.
          if (!(sys.suspend & SUSPEND_JOG_CANCEL)) {
    2688:	80 91 7e 05 	lds	r24, 0x057E	; 0x80057e <sys+0x2>
    268c:	88 23       	and	r24, r24
    268e:	84 f0       	brlt	.+32     	; 0x26b0 <protocol_exec_rt_system+0xfc>
            // Check if the safety re-opened during a restore parking motion only. Ignore if
            // already retracting, parked or in sleep state.
            if (sys.state == STATE_SAFETY_DOOR) {
    2690:	90 91 7c 05 	lds	r25, 0x057C	; 0x80057c <sys>
    2694:	90 34       	cpi	r25, 0x40	; 64
    2696:	39 f4       	brne	.+14     	; 0x26a6 <protocol_exec_rt_system+0xf2>
              if (sys.suspend & SUSPEND_INITIATE_RESTORE) { // Actively restoring
    2698:	83 ff       	sbrs	r24, 3
    269a:	07 c0       	rjmp	.+14     	; 0x26aa <protocol_exec_rt_system+0xf6>
                    sys.step_control = (STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION);
                    sys.suspend &= ~(SUSPEND_HOLD_COMPLETE);
                  } // else NO_MOTION is active.
                #endif
                sys.suspend &= ~(SUSPEND_RETRACT_COMPLETE | SUSPEND_INITIATE_RESTORE | SUSPEND_RESTORE_COMPLETE);
                sys.suspend |= SUSPEND_RESTART_RETRACT;
    269c:	83 7e       	andi	r24, 0xE3	; 227
    269e:	82 60       	ori	r24, 0x02	; 2
    26a0:	80 93 7e 05 	sts	0x057E, r24	; 0x80057e <sys+0x2>
    26a4:	02 c0       	rjmp	.+4      	; 0x26aa <protocol_exec_rt_system+0xf6>
              }
            }
            if (sys.state != STATE_SLEEP) { sys.state = STATE_SAFETY_DOOR; }
    26a6:	90 38       	cpi	r25, 0x80	; 128
    26a8:	19 f0       	breq	.+6      	; 0x26b0 <protocol_exec_rt_system+0xfc>
    26aa:	80 e4       	ldi	r24, 0x40	; 64
    26ac:	80 93 7c 05 	sts	0x057C, r24	; 0x80057c <sys>
          }
          // NOTE: This flag doesn't change when the door closes, unlike sys.state. Ensures any parking motions
          // are executed if the door switch closes and the state returns to HOLD.
          sys.suspend |= SUSPEND_SAFETY_DOOR_AJAR;
    26b0:	ec e7       	ldi	r30, 0x7C	; 124
    26b2:	f5 e0       	ldi	r31, 0x05	; 5
    26b4:	82 81       	ldd	r24, Z+2	; 0x02
    26b6:	80 62       	ori	r24, 0x20	; 32
    26b8:	82 83       	std	Z+2, r24	; 0x02
        }
        
      }

      if (rt_exec & EXEC_SLEEP) {
    26ba:	cc 23       	and	r28, r28
    26bc:	64 f4       	brge	.+24     	; 0x26d6 <protocol_exec_rt_system+0x122>
        if (sys.state == STATE_ALARM) { sys.suspend |= (SUSPEND_RETRACT_COMPLETE|SUSPEND_HOLD_COMPLETE); }
    26be:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    26c2:	81 30       	cpi	r24, 0x01	; 1
    26c4:	29 f4       	brne	.+10     	; 0x26d0 <protocol_exec_rt_system+0x11c>
    26c6:	ec e7       	ldi	r30, 0x7C	; 124
    26c8:	f5 e0       	ldi	r31, 0x05	; 5
    26ca:	82 81       	ldd	r24, Z+2	; 0x02
    26cc:	85 60       	ori	r24, 0x05	; 5
    26ce:	82 83       	std	Z+2, r24	; 0x02
        sys.state = STATE_SLEEP; 
    26d0:	80 e8       	ldi	r24, 0x80	; 128
    26d2:	80 93 7c 05 	sts	0x057C, r24	; 0x80057c <sys>
      }

      system_clear_exec_state_flag((EXEC_MOTION_CANCEL | EXEC_FEED_HOLD | EXEC_SAFETY_DOOR | EXEC_SLEEP));
    26d6:	88 ee       	ldi	r24, 0xE8	; 232
    26d8:	0e 94 3a 2e 	call	0x5c74	; 0x5c74 <system_clear_exec_state_flag>
    }

    // Execute a cycle start by starting the stepper interrupt to begin executing the blocks in queue.
    if (rt_exec & EXEC_CYCLE_START) {
    26dc:	c1 ff       	sbrs	r28, 1
    26de:	43 c0       	rjmp	.+134    	; 0x2766 <protocol_exec_rt_system+0x1b2>
      // Block if called at same time as the hold commands: feed hold, motion cancel, and safety door.
      // Ensures auto-cycle-start doesn't resume a hold without an explicit user-input.
      if (!(rt_exec & (EXEC_FEED_HOLD | EXEC_MOTION_CANCEL | EXEC_SAFETY_DOOR))) {
    26e0:	8c 2f       	mov	r24, r28
    26e2:	88 76       	andi	r24, 0x68	; 104
    26e4:	e9 f5       	brne	.+122    	; 0x2760 <protocol_exec_rt_system+0x1ac>
        // Resume door state when parking motion has retracted and door has been closed.
        if ((sys.state == STATE_SAFETY_DOOR) && !(sys.suspend & SUSPEND_SAFETY_DOOR_AJAR)) {
    26e6:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    26ea:	80 34       	cpi	r24, 0x40	; 64
    26ec:	79 f4       	brne	.+30     	; 0x270c <protocol_exec_rt_system+0x158>
    26ee:	80 91 7e 05 	lds	r24, 0x057E	; 0x80057e <sys+0x2>
    26f2:	85 fd       	sbrc	r24, 5
    26f4:	35 c0       	rjmp	.+106    	; 0x2760 <protocol_exec_rt_system+0x1ac>
          if (sys.suspend & SUSPEND_RESTORE_COMPLETE) {
    26f6:	84 ff       	sbrs	r24, 4
    26f8:	03 c0       	rjmp	.+6      	; 0x2700 <protocol_exec_rt_system+0x14c>
            sys.state = STATE_IDLE; // Set to IDLE to immediately resume the cycle.
    26fa:	10 92 7c 05 	sts	0x057C, r1	; 0x80057c <sys>
    26fe:	18 c0       	rjmp	.+48     	; 0x2730 <protocol_exec_rt_system+0x17c>
          } else if (sys.suspend & SUSPEND_RETRACT_COMPLETE) {
    2700:	82 ff       	sbrs	r24, 2
    2702:	2e c0       	rjmp	.+92     	; 0x2760 <protocol_exec_rt_system+0x1ac>
            // Flag to re-energize powered components and restore original position, if disabled by SAFETY_DOOR.
            // NOTE: For a safety door to resume, the switch must be closed, as indicated by HOLD state, and
            // the retraction execution is complete, which implies the initial feed hold is not active. To
            // restore normal operation, the restore procedures must be initiated by the following flag. Once,
            // they are complete, it will call CYCLE_START automatically to resume and exit the suspend.
            sys.suspend |= SUSPEND_INITIATE_RESTORE;
    2704:	88 60       	ori	r24, 0x08	; 8
    2706:	80 93 7e 05 	sts	0x057E, r24	; 0x80057e <sys+0x2>
    270a:	2a c0       	rjmp	.+84     	; 0x2760 <protocol_exec_rt_system+0x1ac>
          }
        }
        // Cycle start only when IDLE or when a hold is complete and ready to resume.
        if ((sys.state == STATE_IDLE) || ((sys.state & STATE_HOLD) && (sys.suspend & SUSPEND_HOLD_COMPLETE))) {
    270c:	88 23       	and	r24, r24
    270e:	81 f0       	breq	.+32     	; 0x2730 <protocol_exec_rt_system+0x17c>
    2710:	84 ff       	sbrs	r24, 4
    2712:	26 c0       	rjmp	.+76     	; 0x2760 <protocol_exec_rt_system+0x1ac>
    2714:	90 91 7e 05 	lds	r25, 0x057E	; 0x80057e <sys+0x2>
    2718:	90 ff       	sbrs	r25, 0
    271a:	22 c0       	rjmp	.+68     	; 0x2760 <protocol_exec_rt_system+0x1ac>
          if (sys.state == STATE_HOLD && sys.spindle_stop_ovr) {
    271c:	80 31       	cpi	r24, 0x10	; 16
    271e:	41 f4       	brne	.+16     	; 0x2730 <protocol_exec_rt_system+0x17c>
    2720:	80 91 86 05 	lds	r24, 0x0586	; 0x800586 <sys+0xa>
    2724:	88 23       	and	r24, r24
    2726:	21 f0       	breq	.+8      	; 0x2730 <protocol_exec_rt_system+0x17c>
            sys.spindle_stop_ovr |= SPINDLE_STOP_OVR_RESTORE_CYCLE; // Set to restore in suspend routine and cycle start after.
    2728:	88 60       	ori	r24, 0x08	; 8
    272a:	80 93 86 05 	sts	0x0586, r24	; 0x800586 <sys+0xa>
    272e:	18 c0       	rjmp	.+48     	; 0x2760 <protocol_exec_rt_system+0x1ac>
          } else {
            // Start cycle only if queued motions exist in planner buffer and the motion is not canceled.
            sys.step_control = STEP_CONTROL_NORMAL_OP; // Restore step control to normal operation
    2730:	10 92 80 05 	sts	0x0580, r1	; 0x800580 <sys+0x4>
            if (plan_get_current_block() && bit_isfalse(sys.suspend,SUSPEND_MOTION_CANCEL)) {
    2734:	0e 94 47 25 	call	0x4a8e	; 0x4a8e <plan_get_current_block>
    2738:	89 2b       	or	r24, r25
    273a:	71 f0       	breq	.+28     	; 0x2758 <protocol_exec_rt_system+0x1a4>
    273c:	80 91 7e 05 	lds	r24, 0x057E	; 0x80057e <sys+0x2>
    2740:	86 fd       	sbrc	r24, 6
    2742:	0a c0       	rjmp	.+20     	; 0x2758 <protocol_exec_rt_system+0x1a4>
              sys.suspend = SUSPEND_DISABLE; // Break suspend state.
    2744:	ec e7       	ldi	r30, 0x7C	; 124
    2746:	f5 e0       	ldi	r31, 0x05	; 5
    2748:	12 82       	std	Z+2, r1	; 0x02
              sys.state = STATE_CYCLE;
    274a:	88 e0       	ldi	r24, 0x08	; 8
    274c:	80 83       	st	Z, r24
              st_prep_buffer(); // Initialize step segment buffer before beginning cycle.
    274e:	0e 94 88 19 	call	0x3310	; 0x3310 <st_prep_buffer>
              st_wake_up();
    2752:	0e 94 7f 16 	call	0x2cfe	; 0x2cfe <st_wake_up>
    2756:	04 c0       	rjmp	.+8      	; 0x2760 <protocol_exec_rt_system+0x1ac>
            } else { // Otherwise, do nothing. Set and resume IDLE state.
              sys.suspend = SUSPEND_DISABLE; // Break suspend state.
    2758:	ec e7       	ldi	r30, 0x7C	; 124
    275a:	f5 e0       	ldi	r31, 0x05	; 5
    275c:	12 82       	std	Z+2, r1	; 0x02
              sys.state = STATE_IDLE;
    275e:	10 82       	st	Z, r1
            }
          }
        }
      }
      system_clear_exec_state_flag(EXEC_CYCLE_START);
    2760:	82 e0       	ldi	r24, 0x02	; 2
    2762:	0e 94 3a 2e 	call	0x5c74	; 0x5c74 <system_clear_exec_state_flag>
    }

    if (rt_exec & EXEC_CYCLE_STOP) {
    2766:	c2 ff       	sbrs	r28, 2
    2768:	3c c0       	rjmp	.+120    	; 0x27e2 <protocol_exec_rt_system+0x22e>
      // Reinitializes the cycle plan and stepper system after a feed hold for a resume. Called by
      // realtime command execution in the main program, ensuring that the planner re-plans safely.
      // NOTE: Bresenham algorithm variables are still maintained through both the planner and stepper
      // cycle reinitializations. The stepper path should continue exactly as if nothing has happened.
      // NOTE: EXEC_CYCLE_STOP is set by the stepper subsystem when a cycle or feed hold completes.
      if ((sys.state & (STATE_HOLD|STATE_SAFETY_DOOR|STATE_SLEEP)) && !(sys.soft_limit) && !(sys.suspend & SUSPEND_JOG_CANCEL)) {
    276a:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    276e:	80 7d       	andi	r24, 0xD0	; 208
    2770:	b9 f0       	breq	.+46     	; 0x27a0 <protocol_exec_rt_system+0x1ec>
    2772:	80 91 7f 05 	lds	r24, 0x057F	; 0x80057f <sys+0x3>
    2776:	81 11       	cpse	r24, r1
    2778:	13 c0       	rjmp	.+38     	; 0x27a0 <protocol_exec_rt_system+0x1ec>
    277a:	80 91 7e 05 	lds	r24, 0x057E	; 0x80057e <sys+0x2>
    277e:	88 23       	and	r24, r24
    2780:	9c f0       	brlt	.+38     	; 0x27a8 <protocol_exec_rt_system+0x1f4>
        // Hold complete. Set to indicate ready to resume.  Remain in HOLD or DOOR states until user
        // has issued a resume command or reset.
        plan_cycle_reinitialize();
    2782:	0e 94 d4 29 	call	0x53a8	; 0x53a8 <plan_cycle_reinitialize>
        if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { sys.suspend |= SUSPEND_HOLD_COMPLETE; }
    2786:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <sys+0x4>
    278a:	81 ff       	sbrs	r24, 1
    278c:	05 c0       	rjmp	.+10     	; 0x2798 <protocol_exec_rt_system+0x1e4>
    278e:	ec e7       	ldi	r30, 0x7C	; 124
    2790:	f5 e0       	ldi	r31, 0x05	; 5
    2792:	92 81       	ldd	r25, Z+2	; 0x02
    2794:	91 60       	ori	r25, 0x01	; 1
    2796:	92 83       	std	Z+2, r25	; 0x02
        bit_false(sys.step_control,(STEP_CONTROL_EXECUTE_HOLD | STEP_CONTROL_EXECUTE_SYS_MOTION));
    2798:	89 7f       	andi	r24, 0xF9	; 249
    279a:	80 93 80 05 	sts	0x0580, r24	; 0x800580 <sys+0x4>
    279e:	1e c0       	rjmp	.+60     	; 0x27dc <protocol_exec_rt_system+0x228>
      } else {
        // Motion complete. Includes CYCLE/JOG/HOMING states and jog cancel/motion cancel/soft limit events.
        // NOTE: Motion and jog cancel both immediately return to idle after the hold completes.
        if (sys.suspend & SUSPEND_JOG_CANCEL) {   // For jog cancel, flush buffers and sync positions.
    27a0:	80 91 7e 05 	lds	r24, 0x057E	; 0x80057e <sys+0x2>
    27a4:	88 23       	and	r24, r24
    27a6:	54 f4       	brge	.+20     	; 0x27bc <protocol_exec_rt_system+0x208>
          sys.step_control = STEP_CONTROL_NORMAL_OP;
    27a8:	10 92 80 05 	sts	0x0580, r1	; 0x800580 <sys+0x4>
          plan_reset();
    27ac:	0e 94 20 25 	call	0x4a40	; 0x4a40 <plan_reset>
          st_reset();
    27b0:	0e 94 13 19 	call	0x3226	; 0x3226 <st_reset>
          gc_sync_position();
    27b4:	0e 94 93 05 	call	0xb26	; 0xb26 <gc_sync_position>
          plan_sync_position();
    27b8:	0e 94 c2 29 	call	0x5384	; 0x5384 <plan_sync_position>
        }
        if (sys.suspend & SUSPEND_SAFETY_DOOR_AJAR) { // Only occurs when safety door opens during jog.
    27bc:	80 91 7e 05 	lds	r24, 0x057E	; 0x80057e <sys+0x2>
    27c0:	85 ff       	sbrs	r24, 5
    27c2:	08 c0       	rjmp	.+16     	; 0x27d4 <protocol_exec_rt_system+0x220>
          sys.suspend &= ~(SUSPEND_JOG_CANCEL);
          sys.suspend |= SUSPEND_HOLD_COMPLETE;
    27c4:	ec e7       	ldi	r30, 0x7C	; 124
    27c6:	f5 e0       	ldi	r31, 0x05	; 5
    27c8:	8f 77       	andi	r24, 0x7F	; 127
    27ca:	81 60       	ori	r24, 0x01	; 1
    27cc:	82 83       	std	Z+2, r24	; 0x02
          sys.state = STATE_SAFETY_DOOR;
    27ce:	80 e4       	ldi	r24, 0x40	; 64
    27d0:	80 83       	st	Z, r24
    27d2:	04 c0       	rjmp	.+8      	; 0x27dc <protocol_exec_rt_system+0x228>
        } else {
          sys.suspend = SUSPEND_DISABLE;
    27d4:	ec e7       	ldi	r30, 0x7C	; 124
    27d6:	f5 e0       	ldi	r31, 0x05	; 5
    27d8:	12 82       	std	Z+2, r1	; 0x02
          sys.state = STATE_IDLE;
    27da:	10 82       	st	Z, r1
        }
      }
      system_clear_exec_state_flag(EXEC_CYCLE_STOP);
    27dc:	84 e0       	ldi	r24, 0x04	; 4
    27de:	0e 94 3a 2e 	call	0x5c74	; 0x5c74 <system_clear_exec_state_flag>
    }
  }

  // Execute overrides.
  rt_exec = sys_rt_exec_motion_override; // Copy volatile sys_rt_exec_motion_override
    27e2:	c0 91 7b 05 	lds	r28, 0x057B	; 0x80057b <sys_rt_exec_motion_override>
  if (rt_exec) {
    27e6:	cc 23       	and	r28, r28
    27e8:	81 f1       	breq	.+96     	; 0x284a <protocol_exec_rt_system+0x296>
    system_clear_exec_motion_overrides(); // Clear all motion override flags.
    27ea:	0e 94 62 2e 	call	0x5cc4	; 0x5cc4 <system_clear_exec_motion_overrides>

    uint8_t new_f_override =  sys.f_override;
    27ee:	20 91 83 05 	lds	r18, 0x0583	; 0x800583 <sys+0x7>
    if (rt_exec & EXEC_FEED_OVR_RESET) { new_f_override = DEFAULT_FEED_OVERRIDE; }
    27f2:	c0 ff       	sbrs	r28, 0
    27f4:	02 c0       	rjmp	.+4      	; 0x27fa <protocol_exec_rt_system+0x246>
    27f6:	84 e6       	ldi	r24, 0x64	; 100
    27f8:	01 c0       	rjmp	.+2      	; 0x27fc <protocol_exec_rt_system+0x248>
  // Execute overrides.
  rt_exec = sys_rt_exec_motion_override; // Copy volatile sys_rt_exec_motion_override
  if (rt_exec) {
    system_clear_exec_motion_overrides(); // Clear all motion override flags.

    uint8_t new_f_override =  sys.f_override;
    27fa:	82 2f       	mov	r24, r18
    if (rt_exec & EXEC_FEED_OVR_RESET) { new_f_override = DEFAULT_FEED_OVERRIDE; }
    if (rt_exec & EXEC_FEED_OVR_COARSE_PLUS) { new_f_override += FEED_OVERRIDE_COARSE_INCREMENT; }
    27fc:	c1 fd       	sbrc	r28, 1
    27fe:	86 5f       	subi	r24, 0xF6	; 246
    if (rt_exec & EXEC_FEED_OVR_COARSE_MINUS) { new_f_override -= FEED_OVERRIDE_COARSE_INCREMENT; }
    2800:	c2 fd       	sbrc	r28, 2
    2802:	8a 50       	subi	r24, 0x0A	; 10
    if (rt_exec & EXEC_FEED_OVR_FINE_PLUS) { new_f_override += FEED_OVERRIDE_FINE_INCREMENT; }
    2804:	c3 fd       	sbrc	r28, 3
    2806:	8f 5f       	subi	r24, 0xFF	; 255
    if (rt_exec & EXEC_FEED_OVR_FINE_MINUS) { new_f_override -= FEED_OVERRIDE_FINE_INCREMENT; }
    2808:	c4 fd       	sbrc	r28, 4
    280a:	81 50       	subi	r24, 0x01	; 1
    new_f_override = min(new_f_override,MAX_FEED_RATE_OVERRIDE);
    280c:	89 3c       	cpi	r24, 0xC9	; 201
    280e:	08 f0       	brcs	.+2      	; 0x2812 <protocol_exec_rt_system+0x25e>
    2810:	88 ec       	ldi	r24, 0xC8	; 200
    new_f_override = max(new_f_override,MIN_FEED_RATE_OVERRIDE);
    2812:	8a 30       	cpi	r24, 0x0A	; 10
    2814:	08 f4       	brcc	.+2      	; 0x2818 <protocol_exec_rt_system+0x264>
    2816:	8a e0       	ldi	r24, 0x0A	; 10

    uint8_t new_r_override = sys.r_override;
    2818:	30 91 84 05 	lds	r19, 0x0584	; 0x800584 <sys+0x8>
    if (rt_exec & EXEC_RAPID_OVR_RESET) { new_r_override = DEFAULT_RAPID_OVERRIDE; }
    281c:	c5 ff       	sbrs	r28, 5
    281e:	02 c0       	rjmp	.+4      	; 0x2824 <protocol_exec_rt_system+0x270>
    2820:	94 e6       	ldi	r25, 0x64	; 100
    2822:	01 c0       	rjmp	.+2      	; 0x2826 <protocol_exec_rt_system+0x272>
    if (rt_exec & EXEC_FEED_OVR_FINE_PLUS) { new_f_override += FEED_OVERRIDE_FINE_INCREMENT; }
    if (rt_exec & EXEC_FEED_OVR_FINE_MINUS) { new_f_override -= FEED_OVERRIDE_FINE_INCREMENT; }
    new_f_override = min(new_f_override,MAX_FEED_RATE_OVERRIDE);
    new_f_override = max(new_f_override,MIN_FEED_RATE_OVERRIDE);

    uint8_t new_r_override = sys.r_override;
    2824:	93 2f       	mov	r25, r19
    if (rt_exec & EXEC_RAPID_OVR_RESET) { new_r_override = DEFAULT_RAPID_OVERRIDE; }
    if (rt_exec & EXEC_RAPID_OVR_MEDIUM) { new_r_override = RAPID_OVERRIDE_MEDIUM; }
    2826:	c6 fd       	sbrc	r28, 6
    2828:	92 e3       	ldi	r25, 0x32	; 50
    if (rt_exec & EXEC_RAPID_OVR_LOW) { new_r_override = RAPID_OVERRIDE_LOW; }
    282a:	cc 23       	and	r28, r28
    282c:	0c f4       	brge	.+2      	; 0x2830 <protocol_exec_rt_system+0x27c>
    282e:	99 e1       	ldi	r25, 0x19	; 25

    if ((new_f_override != sys.f_override) || (new_r_override != sys.r_override)) {
    2830:	28 13       	cpse	r18, r24
    2832:	02 c0       	rjmp	.+4      	; 0x2838 <protocol_exec_rt_system+0x284>
    2834:	93 17       	cp	r25, r19
    2836:	49 f0       	breq	.+18     	; 0x284a <protocol_exec_rt_system+0x296>
      sys.f_override = new_f_override;
    2838:	ec e7       	ldi	r30, 0x7C	; 124
    283a:	f5 e0       	ldi	r31, 0x05	; 5
    283c:	87 83       	std	Z+7, r24	; 0x07
      sys.r_override = new_r_override;
    283e:	90 87       	std	Z+8, r25	; 0x08
      sys.report_ovr_counter = 0; // Set to report change immediately
    2840:	13 86       	std	Z+11, r1	; 0x0b
      plan_update_velocity_profile_parameters();
    2842:	0e 94 f5 25 	call	0x4bea	; 0x4bea <plan_update_velocity_profile_parameters>
      plan_cycle_reinitialize();
    2846:	0e 94 d4 29 	call	0x53a8	; 0x53a8 <plan_cycle_reinitialize>
    }
  }

  rt_exec = sys_rt_exec_accessory_override;
    284a:	c0 91 8d 05 	lds	r28, 0x058D	; 0x80058d <sys_rt_exec_accessory_override>
  if (rt_exec) {
    284e:	cc 23       	and	r28, r28
    2850:	09 f4       	brne	.+2      	; 0x2854 <protocol_exec_rt_system+0x2a0>
    2852:	58 c0       	rjmp	.+176    	; 0x2904 <protocol_exec_rt_system+0x350>
    system_clear_exec_accessory_overrides(); // Clear all accessory override flags.
    2854:	0e 94 68 2e 	call	0x5cd0	; 0x5cd0 <system_clear_exec_accessory_overrides>

    // NOTE: Unlike motion overrides, spindle overrides do not require a planner reinitialization.
    uint8_t last_s_override =  sys.spindle_speed_ovr;
    2858:	90 91 85 05 	lds	r25, 0x0585	; 0x800585 <sys+0x9>
    if (rt_exec & EXEC_SPINDLE_OVR_RESET) { last_s_override = DEFAULT_SPINDLE_SPEED_OVERRIDE; }
    285c:	c0 ff       	sbrs	r28, 0
    285e:	02 c0       	rjmp	.+4      	; 0x2864 <protocol_exec_rt_system+0x2b0>
    2860:	84 e6       	ldi	r24, 0x64	; 100
    2862:	01 c0       	rjmp	.+2      	; 0x2866 <protocol_exec_rt_system+0x2b2>
  rt_exec = sys_rt_exec_accessory_override;
  if (rt_exec) {
    system_clear_exec_accessory_overrides(); // Clear all accessory override flags.

    // NOTE: Unlike motion overrides, spindle overrides do not require a planner reinitialization.
    uint8_t last_s_override =  sys.spindle_speed_ovr;
    2864:	89 2f       	mov	r24, r25
    if (rt_exec & EXEC_SPINDLE_OVR_RESET) { last_s_override = DEFAULT_SPINDLE_SPEED_OVERRIDE; }
    if (rt_exec & EXEC_SPINDLE_OVR_COARSE_PLUS) { last_s_override += SPINDLE_OVERRIDE_COARSE_INCREMENT; }
    2866:	c1 fd       	sbrc	r28, 1
    2868:	86 5f       	subi	r24, 0xF6	; 246
    if (rt_exec & EXEC_SPINDLE_OVR_COARSE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_COARSE_INCREMENT; }
    286a:	c2 fd       	sbrc	r28, 2
    286c:	8a 50       	subi	r24, 0x0A	; 10
    if (rt_exec & EXEC_SPINDLE_OVR_FINE_PLUS) { last_s_override += SPINDLE_OVERRIDE_FINE_INCREMENT; }
    286e:	c3 fd       	sbrc	r28, 3
    2870:	8f 5f       	subi	r24, 0xFF	; 255
    if (rt_exec & EXEC_SPINDLE_OVR_FINE_MINUS) { last_s_override -= SPINDLE_OVERRIDE_FINE_INCREMENT; }
    2872:	c4 fd       	sbrc	r28, 4
    2874:	81 50       	subi	r24, 0x01	; 1
    last_s_override = min(last_s_override,MAX_SPINDLE_SPEED_OVERRIDE);
    2876:	89 3c       	cpi	r24, 0xC9	; 201
    2878:	08 f0       	brcs	.+2      	; 0x287c <protocol_exec_rt_system+0x2c8>
    287a:	88 ec       	ldi	r24, 0xC8	; 200
    last_s_override = max(last_s_override,MIN_SPINDLE_SPEED_OVERRIDE);
    287c:	8a 30       	cpi	r24, 0x0A	; 10
    287e:	08 f4       	brcc	.+2      	; 0x2882 <protocol_exec_rt_system+0x2ce>
    2880:	8a e0       	ldi	r24, 0x0A	; 10

    if (last_s_override != sys.spindle_speed_ovr) {
    2882:	98 17       	cp	r25, r24
    2884:	b9 f0       	breq	.+46     	; 0x28b4 <protocol_exec_rt_system+0x300>
      sys.spindle_speed_ovr = last_s_override;
    2886:	ec e7       	ldi	r30, 0x7C	; 124
    2888:	f5 e0       	ldi	r31, 0x05	; 5
    288a:	81 87       	std	Z+9, r24	; 0x09
      // NOTE: Spindle speed overrides during HOLD state are taken care of by suspend function.
      if (sys.state == STATE_IDLE) { spindle_set_state(gc_state.modal.spindle, gc_state.spindle_speed); }
    288c:	80 81       	ld	r24, Z
    288e:	81 11       	cpse	r24, r1
    2890:	0a c0       	rjmp	.+20     	; 0x28a6 <protocol_exec_rt_system+0x2f2>
    2892:	ea ea       	ldi	r30, 0xAA	; 170
    2894:	f5 e0       	ldi	r31, 0x05	; 5
    2896:	43 85       	ldd	r20, Z+11	; 0x0b
    2898:	54 85       	ldd	r21, Z+12	; 0x0c
    289a:	65 85       	ldd	r22, Z+13	; 0x0d
    289c:	76 85       	ldd	r23, Z+14	; 0x0e
    289e:	81 85       	ldd	r24, Z+9	; 0x09
    28a0:	0e 94 71 11 	call	0x22e2	; 0x22e2 <spindle_set_state>
    28a4:	05 c0       	rjmp	.+10     	; 0x28b0 <protocol_exec_rt_system+0x2fc>
			else { bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM); }
    28a6:	ec e7       	ldi	r30, 0x7C	; 124
    28a8:	f5 e0       	ldi	r31, 0x05	; 5
    28aa:	84 81       	ldd	r24, Z+4	; 0x04
    28ac:	88 60       	ori	r24, 0x08	; 8
    28ae:	84 83       	std	Z+4, r24	; 0x04
      sys.report_ovr_counter = 0; // Set to report change immediately
    28b0:	10 92 87 05 	sts	0x0587, r1	; 0x800587 <sys+0xb>
    }

    if (rt_exec & EXEC_SPINDLE_OVR_STOP) {
    28b4:	c5 ff       	sbrs	r28, 5
    28b6:	12 c0       	rjmp	.+36     	; 0x28dc <protocol_exec_rt_system+0x328>
      // Spindle stop override allowed only while in HOLD state.
      // NOTE: Report counters are set in spindle_set_state() when spindle stop is executed.
      if (sys.state == STATE_HOLD) {
    28b8:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    28bc:	80 31       	cpi	r24, 0x10	; 16
    28be:	71 f4       	brne	.+28     	; 0x28dc <protocol_exec_rt_system+0x328>
        if (!(sys.spindle_stop_ovr)) { sys.spindle_stop_ovr = SPINDLE_STOP_OVR_INITIATE; }
    28c0:	80 91 86 05 	lds	r24, 0x0586	; 0x800586 <sys+0xa>
    28c4:	81 11       	cpse	r24, r1
    28c6:	04 c0       	rjmp	.+8      	; 0x28d0 <protocol_exec_rt_system+0x31c>
    28c8:	82 e0       	ldi	r24, 0x02	; 2
    28ca:	80 93 86 05 	sts	0x0586, r24	; 0x800586 <sys+0xa>
    28ce:	29 c0       	rjmp	.+82     	; 0x2922 <protocol_exec_rt_system+0x36e>
        else if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_ENABLED) { sys.spindle_stop_ovr |= SPINDLE_STOP_OVR_RESTORE; }
    28d0:	80 ff       	sbrs	r24, 0
    28d2:	27 c0       	rjmp	.+78     	; 0x2922 <protocol_exec_rt_system+0x36e>
    28d4:	84 60       	ori	r24, 0x04	; 4
    28d6:	80 93 86 05 	sts	0x0586, r24	; 0x800586 <sys+0xa>
    28da:	23 c0       	rjmp	.+70     	; 0x2922 <protocol_exec_rt_system+0x36e>
    }

    // NOTE: Since coolant state always performs a planner sync whenever it changes, the current
    // run state can be determined by checking the parser state.
    // NOTE: Coolant overrides only operate during IDLE, CYCLE, HOLD, and JOG states. Ignored otherwise.
    if (rt_exec & (EXEC_COOLANT_FLOOD_OVR_TOGGLE | EXEC_COOLANT_MIST_OVR_TOGGLE)) {
    28dc:	c0 7c       	andi	r28, 0xC0	; 192
    28de:	91 f0       	breq	.+36     	; 0x2904 <protocol_exec_rt_system+0x350>
      if ((sys.state == STATE_IDLE) || (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_JOG))) {
    28e0:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    28e4:	88 23       	and	r24, r24
    28e6:	11 f0       	breq	.+4      	; 0x28ec <protocol_exec_rt_system+0x338>
    28e8:	88 73       	andi	r24, 0x38	; 56
    28ea:	61 f0       	breq	.+24     	; 0x2904 <protocol_exec_rt_system+0x350>
        uint8_t coolant_state = gc_state.modal.coolant;
    28ec:	c0 91 b2 05 	lds	r28, 0x05B2	; 0x8005b2 <gc_state+0x8>
          if (rt_exec & EXEC_COOLANT_FLOOD_OVR_TOGGLE) {
            if (coolant_state & COOLANT_FLOOD_ENABLE) { bit_false(coolant_state,COOLANT_FLOOD_ENABLE); }
            else { coolant_state |= COOLANT_FLOOD_ENABLE; }
          }
        #else
          if (coolant_state & COOLANT_FLOOD_ENABLE) { bit_false(coolant_state,COOLANT_FLOOD_ENABLE); }
    28f0:	c6 ff       	sbrs	r28, 6
    28f2:	02 c0       	rjmp	.+4      	; 0x28f8 <protocol_exec_rt_system+0x344>
    28f4:	cf 7b       	andi	r28, 0xBF	; 191
    28f6:	01 c0       	rjmp	.+2      	; 0x28fa <protocol_exec_rt_system+0x346>
          else { coolant_state |= COOLANT_FLOOD_ENABLE; }
    28f8:	c0 64       	ori	r28, 0x40	; 64
        #endif
        coolant_set_state(coolant_state); // Report counter set in coolant_set_state().
    28fa:	8c 2f       	mov	r24, r28
    28fc:	0e 94 be 11 	call	0x237c	; 0x237c <coolant_set_state>
        gc_state.modal.coolant = coolant_state;
    2900:	c0 93 b2 05 	sts	0x05B2, r28	; 0x8005b2 <gc_state+0x8>
      }
    }
  }

  #ifdef DEBUG
    if (sys_rt_exec_debug) {
    2904:	80 91 a9 05 	lds	r24, 0x05A9	; 0x8005a9 <sys_rt_exec_debug>
    2908:	88 23       	and	r24, r24
    290a:	21 f0       	breq	.+8      	; 0x2914 <protocol_exec_rt_system+0x360>
      report_realtime_debug();
    290c:	0e 94 06 2d 	call	0x5a0c	; 0x5a0c <report_realtime_debug>
      sys_rt_exec_debug = 0;
    2910:	10 92 a9 05 	sts	0x05A9, r1	; 0x8005a9 <sys_rt_exec_debug>
    }
  #endif

  // Reload step segment buffer
  if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_SAFETY_DOOR | STATE_HOMING | STATE_SLEEP| STATE_JOG)) {
    2914:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    2918:	8c 7f       	andi	r24, 0xFC	; 252
    291a:	71 f0       	breq	.+28     	; 0x2938 <protocol_exec_rt_system+0x384>
    st_prep_buffer();
    291c:	0e 94 88 19 	call	0x3310	; 0x3310 <st_prep_buffer>
    2920:	0b c0       	rjmp	.+22     	; 0x2938 <protocol_exec_rt_system+0x384>
    }

    // NOTE: Since coolant state always performs a planner sync whenever it changes, the current
    // run state can be determined by checking the parser state.
    // NOTE: Coolant overrides only operate during IDLE, CYCLE, HOLD, and JOG states. Ignored otherwise.
    if (rt_exec & (EXEC_COOLANT_FLOOD_OVR_TOGGLE | EXEC_COOLANT_MIST_OVR_TOGGLE)) {
    2922:	c0 7c       	andi	r28, 0xC0	; 192
    2924:	19 f7       	brne	.-58     	; 0x28ec <protocol_exec_rt_system+0x338>
    2926:	03 c0       	rjmp	.+6      	; 0x292e <protocol_exec_rt_system+0x37a>
          // will handle and clear multiple planner block motions.
          if (!(sys.state & STATE_JOG)) { sys.suspend |= SUSPEND_MOTION_CANCEL; } // NOTE: State is STATE_CYCLE.
        }

        // Execute a feed hold with deceleration, if required. Then, suspend system.
        if (rt_exec & EXEC_FEED_HOLD) {
    2928:	c3 fd       	sbrc	r28, 3
    292a:	a6 ce       	rjmp	.-692    	; 0x2678 <protocol_exec_rt_system+0xc4>
    292c:	a8 ce       	rjmp	.-688    	; 0x267e <protocol_exec_rt_system+0xca>
      }
    }
  }

  #ifdef DEBUG
    if (sys_rt_exec_debug) {
    292e:	80 91 a9 05 	lds	r24, 0x05A9	; 0x8005a9 <sys_rt_exec_debug>
    2932:	88 23       	and	r24, r24
    2934:	99 f3       	breq	.-26     	; 0x291c <protocol_exec_rt_system+0x368>
    2936:	ea cf       	rjmp	.-44     	; 0x290c <protocol_exec_rt_system+0x358>
  // Reload step segment buffer
  if (sys.state & (STATE_CYCLE | STATE_HOLD | STATE_SAFETY_DOOR | STATE_HOMING | STATE_SLEEP| STATE_JOG)) {
    st_prep_buffer();
  }

}
    2938:	cf 91       	pop	r28
    293a:	08 95       	ret

0000293c <protocol_execute_realtime>:
// also provides a controlled way to execute certain tasks without having two or more instances of
// the same task, such as the planner recalculating the buffer upon a feedhold or overrides.
// NOTE: The sys_rt_exec_state variable flags are set by any process, step or serial interrupts, pinouts,
// limit switches, or the main program.
void protocol_execute_realtime()
{
    293c:	7f 92       	push	r7
    293e:	8f 92       	push	r8
    2940:	9f 92       	push	r9
    2942:	af 92       	push	r10
    2944:	bf 92       	push	r11
    2946:	cf 92       	push	r12
    2948:	df 92       	push	r13
    294a:	ef 92       	push	r14
    294c:	ff 92       	push	r15
    294e:	0f 93       	push	r16
    2950:	1f 93       	push	r17
    2952:	cf 93       	push	r28
    2954:	df 93       	push	r29
  protocol_exec_rt_system();
    2956:	0e 94 da 12 	call	0x25b4	; 0x25b4 <protocol_exec_rt_system>
  if (sys.suspend) { protocol_exec_rt_suspend(); }
    295a:	80 91 7e 05 	lds	r24, 0x057E	; 0x80057e <sys+0x2>
    295e:	88 23       	and	r24, r24
    2960:	09 f4       	brne	.+2      	; 0x2964 <protocol_execute_realtime+0x28>
    2962:	01 c1       	rjmp	.+514    	; 0x2b66 <protocol_execute_realtime+0x22a>
    #ifdef USE_LINE_NUMBERS
      pl_data->line_number = PARKING_MOTION_LINE_NUMBER;
    #endif
  #endif

  plan_block_t *block = plan_get_current_block();
    2964:	0e 94 47 25 	call	0x4a8e	; 0x4a8e <plan_get_current_block>
    2968:	ec 01       	movw	r28, r24
  uint8_t restore_condition;
  #ifdef VARIABLE_SPINDLE
    float restore_spindle_speed;
    if (block == NULL) {
    296a:	89 2b       	or	r24, r25
    296c:	51 f4       	brne	.+20     	; 0x2982 <protocol_execute_realtime+0x46>
      restore_condition = (gc_state.modal.spindle | gc_state.modal.coolant);
    296e:	ea ea       	ldi	r30, 0xAA	; 170
    2970:	f5 e0       	ldi	r31, 0x05	; 5
    2972:	d1 84       	ldd	r13, Z+9	; 0x09
    2974:	80 85       	ldd	r24, Z+8	; 0x08
    2976:	d8 2a       	or	r13, r24
      restore_spindle_speed = gc_state.spindle_speed;
    2978:	83 84       	ldd	r8, Z+11	; 0x0b
    297a:	94 84       	ldd	r9, Z+12	; 0x0c
    297c:	a5 84       	ldd	r10, Z+13	; 0x0d
    297e:	b6 84       	ldd	r11, Z+14	; 0x0e
    2980:	0b c0       	rjmp	.+22     	; 0x2998 <protocol_execute_realtime+0x5c>
    } else {
      restore_condition = (block->condition & PL_COND_SPINDLE_MASK) | coolant_get_state();
    2982:	89 89       	ldd	r24, Y+17	; 0x11
    2984:	18 2f       	mov	r17, r24
    2986:	10 73       	andi	r17, 0x30	; 48
    2988:	0e 94 b2 11 	call	0x2364	; 0x2364 <coolant_get_state>
    298c:	d8 2e       	mov	r13, r24
    298e:	d1 2a       	or	r13, r17
      restore_spindle_speed = block->spindle_speed;
    2990:	8e a4       	ldd	r8, Y+46	; 0x2e
    2992:	9f a4       	ldd	r9, Y+47	; 0x2f
    2994:	a8 a8       	ldd	r10, Y+48	; 0x30
    2996:	b9 a8       	ldd	r11, Y+49	; 0x31
    }
    #ifdef DISABLE_LASER_DURING_HOLD
      if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) { 
    2998:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <settings+0x45>
    299c:	81 ff       	sbrs	r24, 1
    299e:	03 c0       	rjmp	.+6      	; 0x29a6 <protocol_execute_realtime+0x6a>
        system_set_exec_accessory_override_flag(EXEC_SPINDLE_OVR_STOP);
    29a0:	80 e2       	ldi	r24, 0x20	; 32
    29a2:	0e 94 59 2e 	call	0x5cb2	; 0x5cb2 <system_set_exec_accessory_override_flag>
  #else
    if (block == NULL) { restore_condition = (gc_state.modal.spindle | gc_state.modal.coolant); }
    else { restore_condition = (block->condition & PL_COND_SPINDLE_MASK) | coolant_get_state(); }
  #endif

  while (sys.suspend) {
    29a6:	90 91 7e 05 	lds	r25, 0x057E	; 0x80057e <sys+0x2>
    29aa:	99 23       	and	r25, r25
    29ac:	09 f4       	brne	.+2      	; 0x29b0 <protocol_execute_realtime+0x74>
    29ae:	db c0       	rjmp	.+438    	; 0x2b66 <protocol_execute_realtime+0x22a>

    if (sys.abort) { return; }
    29b0:	80 91 7d 05 	lds	r24, 0x057D	; 0x80057d <sys+0x1>
    29b4:	81 11       	cpse	r24, r1
    29b6:	d7 c0       	rjmp	.+430    	; 0x2b66 <protocol_execute_realtime+0x22a>
    // Block until initial hold is complete and the machine has stopped motion.
    if (sys.suspend & SUSPEND_HOLD_COMPLETE) {

      // Parking manager. Handles de/re-energizing, switch state checks, and parking motions for 
      // the safety door and sleep states.
      if (sys.state & (STATE_SAFETY_DOOR | STATE_SLEEP)) {
    29b8:	cc e7       	ldi	r28, 0x7C	; 124
    29ba:	d5 e0       	ldi	r29, 0x05	; 5
          }
        } else {
          // Handles spindle state during hold. NOTE: Spindle speed overrides may be altered during hold state.
          // NOTE: STEP_CONTROL_UPDATE_SPINDLE_PWM is automatically reset upon resume in step generator.
          if (bit_istrue(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
            spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    29bc:	8d 2d       	mov	r24, r13
    29be:	80 73       	andi	r24, 0x30	; 48
    29c0:	c8 2e       	mov	r12, r24
            } else {
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
            }
          // Handles restoring of spindle state
          } else if (sys.spindle_stop_ovr & (SPINDLE_STOP_OVR_RESTORE | SPINDLE_STOP_OVR_RESTORE_CYCLE)) {
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    29c2:	0a ea       	ldi	r16, 0xAA	; 170
    29c4:	15 e0       	ldi	r17, 0x05	; 5
              report_feedback_message(MESSAGE_SPINDLE_RESTORE);
              if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    29c6:	0f 2e       	mov	r0, r31
    29c8:	f3 e5       	ldi	r31, 0x53	; 83
    29ca:	ef 2e       	mov	r14, r31
    29cc:	f7 e0       	ldi	r31, 0x07	; 7
    29ce:	ff 2e       	mov	r15, r31
    29d0:	f0 2d       	mov	r31, r0
        if (sys.spindle_stop_ovr) {
          // Handles beginning of spindle stop
          if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_INITIATE) {
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
              spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_ENABLED; // Set stop override state to enabled, if de-energized.
    29d2:	77 24       	eor	r7, r7
    29d4:	73 94       	inc	r7
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
              // Block if safety door re-opened during prior restore actions.
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
                // NOTE: Laser mode will honor this delay. An exhaust system is often controlled by this pin.
                coolant_set_state((restore_condition & (PL_COND_FLAG_COOLANT_FLOOD | PL_COND_FLAG_COOLANT_MIST)));
    29d6:	ed 2d       	mov	r30, r13
    29d8:	e0 7c       	andi	r30, 0xC0	; 192
    29da:	de 2e       	mov	r13, r30
    29dc:	03 c0       	rjmp	.+6      	; 0x29e4 <protocol_execute_realtime+0xa8>
    else { restore_condition = (block->condition & PL_COND_SPINDLE_MASK) | coolant_get_state(); }
  #endif

  while (sys.suspend) {

    if (sys.abort) { return; }
    29de:	29 81       	ldd	r18, Y+1	; 0x01
    29e0:	21 11       	cpse	r18, r1
    29e2:	c1 c0       	rjmp	.+386    	; 0x2b66 <protocol_execute_realtime+0x22a>

    // Block until initial hold is complete and the machine has stopped motion.
    if (sys.suspend & SUSPEND_HOLD_COMPLETE) {
    29e4:	90 ff       	sbrs	r25, 0
    29e6:	b2 c0       	rjmp	.+356    	; 0x2b4c <protocol_execute_realtime+0x210>

      // Parking manager. Handles de/re-energizing, switch state checks, and parking motions for 
      // the safety door and sleep states.
      if (sys.state & (STATE_SAFETY_DOOR | STATE_SLEEP)) {
    29e8:	28 81       	ld	r18, Y
    29ea:	32 2f       	mov	r19, r18
    29ec:	30 7c       	andi	r19, 0xC0	; 192
    29ee:	09 f4       	brne	.+2      	; 0x29f2 <protocol_execute_realtime+0xb6>
    29f0:	71 c0       	rjmp	.+226    	; 0x2ad4 <protocol_execute_realtime+0x198>
      
        // Handles retraction motions and de-energizing.
        if (bit_isfalse(sys.suspend,SUSPEND_RETRACT_COMPLETE)) {
    29f2:	92 fd       	sbrc	r25, 2
    29f4:	0f c0       	rjmp	.+30     	; 0x2a14 <protocol_execute_realtime+0xd8>

          // Ensure any prior spindle stop override is disabled at start of safety door routine.
          sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED;
    29f6:	1a 86       	std	Y+10, r1	; 0x0a

          #ifndef PARKING_ENABLE

            spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
    29f8:	40 e0       	ldi	r20, 0x00	; 0
    29fa:	50 e0       	ldi	r21, 0x00	; 0
    29fc:	ba 01       	movw	r22, r20
    29fe:	80 e0       	ldi	r24, 0x00	; 0
    2a00:	0e 94 71 11 	call	0x22e2	; 0x22e2 <spindle_set_state>
            coolant_set_state(COOLANT_DISABLE);     // De-energize
    2a04:	80 e0       	ldi	r24, 0x00	; 0
    2a06:	0e 94 be 11 	call	0x237c	; 0x237c <coolant_set_state>
            }

          #endif

          sys.suspend &= ~(SUSPEND_RESTART_RETRACT);
          sys.suspend |= SUSPEND_RETRACT_COMPLETE;
    2a0a:	8a 81       	ldd	r24, Y+2	; 0x02
    2a0c:	8d 7f       	andi	r24, 0xFD	; 253
    2a0e:	84 60       	ori	r24, 0x04	; 4
    2a10:	8a 83       	std	Y+2, r24	; 0x02
    2a12:	9c c0       	rjmp	.+312    	; 0x2b4c <protocol_execute_realtime+0x210>

        } else {

          
          if (sys.state == STATE_SLEEP) {
    2a14:	20 38       	cpi	r18, 0x80	; 128
    2a16:	d1 f4       	brne	.+52     	; 0x2a4c <protocol_execute_realtime+0x110>
            report_feedback_message(MESSAGE_SLEEP_MODE);
    2a18:	8b e0       	ldi	r24, 0x0B	; 11
    2a1a:	0e 94 ff 2c 	call	0x59fe	; 0x59fe <report_feedback_message>
            // Spindle and coolant should already be stopped, but do it again just to be sure.
            spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
    2a1e:	40 e0       	ldi	r20, 0x00	; 0
    2a20:	50 e0       	ldi	r21, 0x00	; 0
    2a22:	ba 01       	movw	r22, r20
    2a24:	80 e0       	ldi	r24, 0x00	; 0
    2a26:	0e 94 71 11 	call	0x22e2	; 0x22e2 <spindle_set_state>
            coolant_set_state(COOLANT_DISABLE); // De-energize
    2a2a:	80 e0       	ldi	r24, 0x00	; 0
    2a2c:	0e 94 be 11 	call	0x237c	; 0x237c <coolant_set_state>
            st_go_idle(); // Disable steppers
    2a30:	0e 94 97 16 	call	0x2d2e	; 0x2d2e <st_go_idle>
            while (!(sys.abort)) { protocol_exec_rt_system(); } // Do nothing until reset.
    2a34:	80 91 7d 05 	lds	r24, 0x057D	; 0x80057d <sys+0x1>
    2a38:	81 11       	cpse	r24, r1
    2a3a:	95 c0       	rjmp	.+298    	; 0x2b66 <protocol_execute_realtime+0x22a>
    2a3c:	cc e7       	ldi	r28, 0x7C	; 124
    2a3e:	d5 e0       	ldi	r29, 0x05	; 5
    2a40:	0e 94 da 12 	call	0x25b4	; 0x25b4 <protocol_exec_rt_system>
    2a44:	89 81       	ldd	r24, Y+1	; 0x01
    2a46:	88 23       	and	r24, r24
    2a48:	d9 f3       	breq	.-10     	; 0x2a40 <protocol_execute_realtime+0x104>
    2a4a:	8d c0       	rjmp	.+282    	; 0x2b66 <protocol_execute_realtime+0x22a>
            return; // Abort received. Return to re-initialize.
          }    
          
          // Allows resuming from parking/safety door. Actively checks if safety door is closed and ready to resume.
          if (sys.state == STATE_SAFETY_DOOR) {
    2a4c:	20 34       	cpi	r18, 0x40	; 64
    2a4e:	39 f4       	brne	.+14     	; 0x2a5e <protocol_execute_realtime+0x122>
            if (!(system_check_safety_door_ajar())) {
    2a50:	0e 94 64 2d 	call	0x5ac8	; 0x5ac8 <system_check_safety_door_ajar>
    2a54:	81 11       	cpse	r24, r1
    2a56:	03 c0       	rjmp	.+6      	; 0x2a5e <protocol_execute_realtime+0x122>
              sys.suspend &= ~(SUSPEND_SAFETY_DOOR_AJAR); // Reset door ajar flag to denote ready to resume.
    2a58:	8a 81       	ldd	r24, Y+2	; 0x02
    2a5a:	8f 7d       	andi	r24, 0xDF	; 223
    2a5c:	8a 83       	std	Y+2, r24	; 0x02
            }
          }

          // Handles parking restore and safety door resume.
          if (sys.suspend & SUSPEND_INITIATE_RESTORE) {
    2a5e:	8a 81       	ldd	r24, Y+2	; 0x02
    2a60:	83 ff       	sbrs	r24, 3
    2a62:	74 c0       	rjmp	.+232    	; 0x2b4c <protocol_execute_realtime+0x210>
                }
              }
            #endif

            // Delayed Tasks: Restart spindle and coolant, delay to power-up, then resume cycle.
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    2a64:	f8 01       	movw	r30, r16
    2a66:	91 85       	ldd	r25, Z+9	; 0x09
    2a68:	99 23       	and	r25, r25
    2a6a:	d1 f0       	breq	.+52     	; 0x2aa0 <protocol_execute_realtime+0x164>
              // Block if safety door re-opened during prior restore actions.
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    2a6c:	81 fd       	sbrc	r24, 1
    2a6e:	74 c0       	rjmp	.+232    	; 0x2b58 <protocol_execute_realtime+0x21c>
                if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    2a70:	f7 01       	movw	r30, r14
    2a72:	80 81       	ld	r24, Z
    2a74:	81 ff       	sbrs	r24, 1
    2a76:	08 c0       	rjmp	.+16     	; 0x2a88 <protocol_execute_realtime+0x14c>
                  // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
                  bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    2a78:	8c 81       	ldd	r24, Y+4	; 0x04
    2a7a:	88 60       	ori	r24, 0x08	; 8
    2a7c:	8c 83       	std	Y+4, r24	; 0x04
                  spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
                  delay_sec(SAFETY_DOOR_SPINDLE_DELAY, DELAY_MODE_SYS_SUSPEND);
                }
              }
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
    2a7e:	f8 01       	movw	r30, r16
    2a80:	80 85       	ldd	r24, Z+8	; 0x08
    2a82:	81 11       	cpse	r24, r1
    2a84:	14 c0       	rjmp	.+40     	; 0x2aae <protocol_execute_realtime+0x172>
    2a86:	6d c0       	rjmp	.+218    	; 0x2b62 <protocol_execute_realtime+0x226>
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
                if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
                  // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
                  bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
                } else {
                  spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    2a88:	b5 01       	movw	r22, r10
    2a8a:	a4 01       	movw	r20, r8
    2a8c:	8c 2d       	mov	r24, r12
    2a8e:	0e 94 71 11 	call	0x22e2	; 0x22e2 <spindle_set_state>
                  delay_sec(SAFETY_DOOR_SPINDLE_DELAY, DELAY_MODE_SYS_SUSPEND);
    2a92:	47 2d       	mov	r20, r7
    2a94:	60 e0       	ldi	r22, 0x00	; 0
    2a96:	70 e0       	ldi	r23, 0x00	; 0
    2a98:	80 e8       	ldi	r24, 0x80	; 128
    2a9a:	90 e4       	ldi	r25, 0x40	; 64
    2a9c:	0e 94 a3 2a 	call	0x5546	; 0x5546 <delay_sec>
                }
              }
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
    2aa0:	f8 01       	movw	r30, r16
    2aa2:	80 85       	ldd	r24, Z+8	; 0x08
    2aa4:	88 23       	and	r24, r24
    2aa6:	69 f0       	breq	.+26     	; 0x2ac2 <protocol_execute_realtime+0x186>
              // Block if safety door re-opened during prior restore actions.
              if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    2aa8:	8a 81       	ldd	r24, Y+2	; 0x02
    2aaa:	81 fd       	sbrc	r24, 1
    2aac:	4f c0       	rjmp	.+158    	; 0x2b4c <protocol_execute_realtime+0x210>
                // NOTE: Laser mode will honor this delay. An exhaust system is often controlled by this pin.
                coolant_set_state((restore_condition & (PL_COND_FLAG_COOLANT_FLOOD | PL_COND_FLAG_COOLANT_MIST)));
    2aae:	8d 2d       	mov	r24, r13
    2ab0:	0e 94 be 11 	call	0x237c	; 0x237c <coolant_set_state>
                delay_sec(SAFETY_DOOR_COOLANT_DELAY, DELAY_MODE_SYS_SUSPEND);
    2ab4:	47 2d       	mov	r20, r7
    2ab6:	60 e0       	ldi	r22, 0x00	; 0
    2ab8:	70 e0       	ldi	r23, 0x00	; 0
    2aba:	80 e8       	ldi	r24, 0x80	; 128
    2abc:	9f e3       	ldi	r25, 0x3F	; 63
    2abe:	0e 94 a3 2a 	call	0x5546	; 0x5546 <delay_sec>
                  mc_parking_motion(restore_target, pl_data);
                }
              }
            #endif

            if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    2ac2:	8a 81       	ldd	r24, Y+2	; 0x02
    2ac4:	81 fd       	sbrc	r24, 1
    2ac6:	42 c0       	rjmp	.+132    	; 0x2b4c <protocol_execute_realtime+0x210>
              sys.suspend |= SUSPEND_RESTORE_COMPLETE;
    2ac8:	80 61       	ori	r24, 0x10	; 16
    2aca:	8a 83       	std	Y+2, r24	; 0x02
              system_set_exec_state_flag(EXEC_CYCLE_START); // Set to resume program.
    2acc:	82 e0       	ldi	r24, 0x02	; 2
    2ace:	0e 94 31 2e 	call	0x5c62	; 0x5c62 <system_set_exec_state_flag>
    2ad2:	3c c0       	rjmp	.+120    	; 0x2b4c <protocol_execute_realtime+0x210>

      } else {

        // Feed hold manager. Controls spindle stop override states.
        // NOTE: Hold ensured as completed by condition check at the beginning of suspend routine.
        if (sys.spindle_stop_ovr) {
    2ad4:	9a 85       	ldd	r25, Y+10	; 0x0a
    2ad6:	99 23       	and	r25, r25
    2ad8:	71 f1       	breq	.+92     	; 0x2b36 <protocol_execute_realtime+0x1fa>
          // Handles beginning of spindle stop
          if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_INITIATE) {
    2ada:	91 ff       	sbrs	r25, 1
    2adc:	0e c0       	rjmp	.+28     	; 0x2afa <protocol_execute_realtime+0x1be>
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    2ade:	f8 01       	movw	r30, r16
    2ae0:	81 85       	ldd	r24, Z+9	; 0x09
    2ae2:	88 23       	and	r24, r24
    2ae4:	41 f0       	breq	.+16     	; 0x2af6 <protocol_execute_realtime+0x1ba>
              spindle_set_state(SPINDLE_DISABLE,0.0); // De-energize
    2ae6:	40 e0       	ldi	r20, 0x00	; 0
    2ae8:	50 e0       	ldi	r21, 0x00	; 0
    2aea:	ba 01       	movw	r22, r20
    2aec:	80 e0       	ldi	r24, 0x00	; 0
    2aee:	0e 94 71 11 	call	0x22e2	; 0x22e2 <spindle_set_state>
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_ENABLED; // Set stop override state to enabled, if de-energized.
    2af2:	7a 86       	std	Y+10, r7	; 0x0a
    2af4:	2b c0       	rjmp	.+86     	; 0x2b4c <protocol_execute_realtime+0x210>
            } else {
              sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
    2af6:	1a 86       	std	Y+10, r1	; 0x0a
    2af8:	29 c0       	rjmp	.+82     	; 0x2b4c <protocol_execute_realtime+0x210>
            }
          // Handles restoring of spindle state
          } else if (sys.spindle_stop_ovr & (SPINDLE_STOP_OVR_RESTORE | SPINDLE_STOP_OVR_RESTORE_CYCLE)) {
    2afa:	9c 70       	andi	r25, 0x0C	; 12
    2afc:	39 f1       	breq	.+78     	; 0x2b4c <protocol_execute_realtime+0x210>
            if (gc_state.modal.spindle != SPINDLE_DISABLE) {
    2afe:	f8 01       	movw	r30, r16
    2b00:	81 85       	ldd	r24, Z+9	; 0x09
    2b02:	88 23       	and	r24, r24
    2b04:	81 f0       	breq	.+32     	; 0x2b26 <protocol_execute_realtime+0x1ea>
              report_feedback_message(MESSAGE_SPINDLE_RESTORE);
    2b06:	8a e0       	ldi	r24, 0x0A	; 10
    2b08:	0e 94 ff 2c 	call	0x59fe	; 0x59fe <report_feedback_message>
              if (bit_istrue(settings.flags,BITFLAG_LASER_MODE)) {
    2b0c:	f7 01       	movw	r30, r14
    2b0e:	80 81       	ld	r24, Z
    2b10:	81 ff       	sbrs	r24, 1
    2b12:	04 c0       	rjmp	.+8      	; 0x2b1c <protocol_execute_realtime+0x1e0>
                // When in laser mode, ignore spindle spin-up delay. Set to turn on laser when cycle starts.
                bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    2b14:	8c 81       	ldd	r24, Y+4	; 0x04
    2b16:	88 60       	ori	r24, 0x08	; 8
    2b18:	8c 83       	std	Y+4, r24	; 0x04
    2b1a:	05 c0       	rjmp	.+10     	; 0x2b26 <protocol_execute_realtime+0x1ea>
              } else {
                spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    2b1c:	b5 01       	movw	r22, r10
    2b1e:	a4 01       	movw	r20, r8
    2b20:	8c 2d       	mov	r24, r12
    2b22:	0e 94 71 11 	call	0x22e2	; 0x22e2 <spindle_set_state>
              }
            }
            if (sys.spindle_stop_ovr & SPINDLE_STOP_OVR_RESTORE_CYCLE) {
    2b26:	8a 85       	ldd	r24, Y+10	; 0x0a
    2b28:	83 ff       	sbrs	r24, 3
    2b2a:	03 c0       	rjmp	.+6      	; 0x2b32 <protocol_execute_realtime+0x1f6>
              system_set_exec_state_flag(EXEC_CYCLE_START);  // Set to resume program.
    2b2c:	82 e0       	ldi	r24, 0x02	; 2
    2b2e:	0e 94 31 2e 	call	0x5c62	; 0x5c62 <system_set_exec_state_flag>
            }
            sys.spindle_stop_ovr = SPINDLE_STOP_OVR_DISABLED; // Clear stop override state
    2b32:	1a 86       	std	Y+10, r1	; 0x0a
    2b34:	0b c0       	rjmp	.+22     	; 0x2b4c <protocol_execute_realtime+0x210>
          }
        } else {
          // Handles spindle state during hold. NOTE: Spindle speed overrides may be altered during hold state.
          // NOTE: STEP_CONTROL_UPDATE_SPINDLE_PWM is automatically reset upon resume in step generator.
          if (bit_istrue(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
    2b36:	8c 81       	ldd	r24, Y+4	; 0x04
    2b38:	83 ff       	sbrs	r24, 3
    2b3a:	08 c0       	rjmp	.+16     	; 0x2b4c <protocol_execute_realtime+0x210>
            spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
    2b3c:	b5 01       	movw	r22, r10
    2b3e:	a4 01       	movw	r20, r8
    2b40:	8c 2d       	mov	r24, r12
    2b42:	0e 94 71 11 	call	0x22e2	; 0x22e2 <spindle_set_state>
            bit_false(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM);
    2b46:	8c 81       	ldd	r24, Y+4	; 0x04
    2b48:	87 7f       	andi	r24, 0xF7	; 247
    2b4a:	8c 83       	std	Y+4, r24	; 0x04
        }

      }
    }

    protocol_exec_rt_system();
    2b4c:	0e 94 da 12 	call	0x25b4	; 0x25b4 <protocol_exec_rt_system>
  #else
    if (block == NULL) { restore_condition = (gc_state.modal.spindle | gc_state.modal.coolant); }
    else { restore_condition = (block->condition & PL_COND_SPINDLE_MASK) | coolant_get_state(); }
  #endif

  while (sys.suspend) {
    2b50:	9a 81       	ldd	r25, Y+2	; 0x02
    2b52:	91 11       	cpse	r25, r1
    2b54:	44 cf       	rjmp	.-376    	; 0x29de <protocol_execute_realtime+0xa2>
    2b56:	07 c0       	rjmp	.+14     	; 0x2b66 <protocol_execute_realtime+0x22a>
                  spindle_set_state((restore_condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)), restore_spindle_speed);
                  delay_sec(SAFETY_DOOR_SPINDLE_DELAY, DELAY_MODE_SYS_SUSPEND);
                }
              }
            }
            if (gc_state.modal.coolant != COOLANT_DISABLE) {
    2b58:	f8 01       	movw	r30, r16
    2b5a:	80 85       	ldd	r24, Z+8	; 0x08
    2b5c:	81 11       	cpse	r24, r1
    2b5e:	f6 cf       	rjmp	.-20     	; 0x2b4c <protocol_execute_realtime+0x210>
    2b60:	b0 cf       	rjmp	.-160    	; 0x2ac2 <protocol_execute_realtime+0x186>
                  mc_parking_motion(restore_target, pl_data);
                }
              }
            #endif

            if (bit_isfalse(sys.suspend,SUSPEND_RESTART_RETRACT)) {
    2b62:	8a 81       	ldd	r24, Y+2	; 0x02
    2b64:	b1 cf       	rjmp	.-158    	; 0x2ac8 <protocol_execute_realtime+0x18c>
// limit switches, or the main program.
void protocol_execute_realtime()
{
  protocol_exec_rt_system();
  if (sys.suspend) { protocol_exec_rt_suspend(); }
}
    2b66:	df 91       	pop	r29
    2b68:	cf 91       	pop	r28
    2b6a:	1f 91       	pop	r17
    2b6c:	0f 91       	pop	r16
    2b6e:	ff 90       	pop	r15
    2b70:	ef 90       	pop	r14
    2b72:	df 90       	pop	r13
    2b74:	cf 90       	pop	r12
    2b76:	bf 90       	pop	r11
    2b78:	af 90       	pop	r10
    2b7a:	9f 90       	pop	r9
    2b7c:	8f 90       	pop	r8
    2b7e:	7f 90       	pop	r7
    2b80:	08 95       	ret

00002b82 <protocol_main_loop>:

/*
  GRBL PRIMARY LOOP:
*/
void protocol_main_loop()
{
    2b82:	df 92       	push	r13
    2b84:	ef 92       	push	r14
    2b86:	ff 92       	push	r15
    2b88:	0f 93       	push	r16
    2b8a:	1f 93       	push	r17
    2b8c:	cf 93       	push	r28
    2b8e:	df 93       	push	r29
  // Perform some machine checks to make sure everything is good to go.
  #ifdef CHECK_LIMITS_AT_INIT
    if (bit_istrue(settings.flags, BITFLAG_HARD_LIMIT_ENABLE)) {
    2b90:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <settings+0x45>
    2b94:	83 ff       	sbrs	r24, 3
    2b96:	0a c0       	rjmp	.+20     	; 0x2bac <protocol_main_loop+0x2a>
      if (limits_get_state()) {
    2b98:	0e 94 0c 2c 	call	0x5818	; 0x5818 <limits_get_state>
    2b9c:	88 23       	and	r24, r24
    2b9e:	31 f0       	breq	.+12     	; 0x2bac <protocol_main_loop+0x2a>
        sys.state = STATE_ALARM; // Ensure alarm state is active.
    2ba0:	81 e0       	ldi	r24, 0x01	; 1
    2ba2:	80 93 7c 05 	sts	0x057C, r24	; 0x80057c <sys>
        report_feedback_message(MESSAGE_CHECK_LIMITS);
    2ba6:	87 e0       	ldi	r24, 0x07	; 7
    2ba8:	0e 94 ff 2c 	call	0x59fe	; 0x59fe <report_feedback_message>
  #endif
  
  // Check for and report alarm state after a reset, error, or an initial power up.
  // NOTE: Sleep mode disables the stepper drivers and position can't be guaranteed.
  // Re-initialize the sleep state as an ALARM mode to ensure user homes or acknowledges.
  if (sys.state & (STATE_ALARM | STATE_SLEEP)) {
    2bac:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    2bb0:	81 78       	andi	r24, 0x81	; 129
    2bb2:	39 f0       	breq	.+14     	; 0x2bc2 <protocol_main_loop+0x40>
    report_feedback_message(MESSAGE_ALARM_LOCK);
    2bb4:	82 e0       	ldi	r24, 0x02	; 2
    2bb6:	0e 94 ff 2c 	call	0x59fe	; 0x59fe <report_feedback_message>
    sys.state = STATE_ALARM; // Ensure alarm state is set.
    2bba:	81 e0       	ldi	r24, 0x01	; 1
    2bbc:	80 93 7c 05 	sts	0x057C, r24	; 0x80057c <sys>
    2bc0:	11 c0       	rjmp	.+34     	; 0x2be4 <protocol_main_loop+0x62>
  } else {
    // Check if the safety door is open.
    sys.state = STATE_IDLE;
    2bc2:	10 92 7c 05 	sts	0x057C, r1	; 0x80057c <sys>
    if (system_check_safety_door_ajar()) {
    2bc6:	0e 94 64 2d 	call	0x5ac8	; 0x5ac8 <system_check_safety_door_ajar>
    2bca:	88 23       	and	r24, r24
    2bcc:	39 f0       	breq	.+14     	; 0x2bdc <protocol_main_loop+0x5a>
      bit_true(sys_rt_exec_state, EXEC_SAFETY_DOOR);
    2bce:	80 91 8e 05 	lds	r24, 0x058E	; 0x80058e <sys_rt_exec_state>
    2bd2:	80 62       	ori	r24, 0x20	; 32
    2bd4:	80 93 8e 05 	sts	0x058E, r24	; 0x80058e <sys_rt_exec_state>
      protocol_execute_realtime(); // Enter safety door mode. Should return as IDLE state.
    2bd8:	0e 94 9e 14 	call	0x293c	; 0x293c <protocol_execute_realtime>
    }
    // All systems go!
    system_execute_startup(line); // Execute startup script.
    2bdc:	8a e0       	ldi	r24, 0x0A	; 10
    2bde:	91 e0       	ldi	r25, 0x01	; 1
    2be0:	0e 94 66 2d 	call	0x5acc	; 0x5acc <system_execute_startup>

/*
  GRBL PRIMARY LOOP:
*/
void protocol_main_loop()
{
    2be4:	00 e0       	ldi	r16, 0x00	; 0
    2be6:	10 e0       	ldi	r17, 0x00	; 0
    // initial filtering by removing spaces and comments and capitalizing all letters.
#ifndef STANDALONE_CTRL
    while((c = serial_read()) != SERIAL_NO_DATA) 
#else
    // start from beginning
    p_gcode = (uint8_t *)(GCODE_ADDRESS);
    2be8:	0f 2e       	mov	r0, r31
    2bea:	e1 2c       	mov	r14, r1
    2bec:	f8 e6       	ldi	r31, 0x68	; 104
    2bee:	ff 2e       	mov	r15, r31
    2bf0:	f0 2d       	mov	r31, r0
      if ((c == '\n') || (c == '\r')) 
	  { // End of line reached

        protocol_execute_realtime(); // Runtime command check point.
		
        if (sys.abort) 
    2bf2:	cc e7       	ldi	r28, 0x7C	; 124
    2bf4:	d5 e0       	ldi	r29, 0x05	; 5
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    2bf6:	d1 2c       	mov	r13, r1
    // initial filtering by removing spaces and comments and capitalizing all letters.
#ifndef STANDALONE_CTRL
    while((c = serial_read()) != SERIAL_NO_DATA) 
#else
    // start from beginning
    p_gcode = (uint8_t *)(GCODE_ADDRESS);
    2bf8:	f0 92 01 01 	sts	0x0101, r15	; 0x800101 <__data_start+0x1>
    2bfc:	e0 92 00 01 	sts	0x0100, r14	; 0x800100 <__data_start>
  
    while((c = gcode_get_byte()) != SERIAL_NO_DATA)
    2c00:	54 c0       	rjmp	.+168    	; 0x2caa <protocol_main_loop+0x128>
#endif
	{
      if ((c == '\n') || (c == '\r')) 
    2c02:	8a 30       	cpi	r24, 0x0A	; 10
    2c04:	11 f0       	breq	.+4      	; 0x2c0a <protocol_main_loop+0x88>
    2c06:	8d 30       	cpi	r24, 0x0D	; 13
    2c08:	41 f5       	brne	.+80     	; 0x2c5a <protocol_main_loop+0xd8>
	  { // End of line reached

        protocol_execute_realtime(); // Runtime command check point.
    2c0a:	0e 94 9e 14 	call	0x293c	; 0x293c <protocol_execute_realtime>
		
        if (sys.abort) 
    2c0e:	89 81       	ldd	r24, Y+1	; 0x01
    2c10:	81 11       	cpse	r24, r1
    2c12:	58 c0       	rjmp	.+176    	; 0x2cc4 <protocol_main_loop+0x142>
		{ 
			return;
		} // Bail to calling function upon system abort

        line[char_counter] = 0; // Set string termination character.
    2c14:	e0 2f       	mov	r30, r16
    2c16:	f0 e0       	ldi	r31, 0x00	; 0
    2c18:	e6 5f       	subi	r30, 0xF6	; 246
    2c1a:	fe 4f       	sbci	r31, 0xFE	; 254
    2c1c:	10 82       	st	Z, r1

#ifdef REPORT_ECHO_LINE_RECEIVED
          report_echo_line_received(line);
    2c1e:	8a e0       	ldi	r24, 0x0A	; 10
    2c20:	91 e0       	ldi	r25, 0x01	; 1
    2c22:	0e 94 04 2d 	call	0x5a08	; 0x5a08 <report_echo_line_received>
#endif
		
        // Direct and execute one line of formatted input, and report status of execution.
        if (line_flags & LINE_FLAG_OVERFLOW) 
    2c26:	10 ff       	sbrs	r17, 0
    2c28:	06 c0       	rjmp	.+12     	; 0x2c36 <protocol_main_loop+0xb4>
		{
          // Report line overflow error.
          report_status_message(STATUS_OVERFLOW);
    2c2a:	8b e0       	ldi	r24, 0x0B	; 11
    2c2c:	0e 94 fd 2c 	call	0x59fa	; 0x59fa <report_status_message>
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    2c30:	0d 2d       	mov	r16, r13
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    2c32:	10 e0       	ldi	r17, 0x00	; 0
    2c34:	3a c0       	rjmp	.+116    	; 0x2caa <protocol_main_loop+0x128>
		{
          // Grbl '$' system command
          report_status_message(system_execute_line(line));
        }
#endif
		else if (sys.state & (STATE_ALARM | STATE_JOG)) 
    2c36:	88 81       	ld	r24, Y
    2c38:	81 72       	andi	r24, 0x21	; 33
    2c3a:	31 f0       	breq	.+12     	; 0x2c48 <protocol_main_loop+0xc6>
		{
          // Everything else is gcode. Block if in alarm or jog mode.
          report_status_message(STATUS_SYSTEM_GC_LOCK);
    2c3c:	89 e0       	ldi	r24, 0x09	; 9
    2c3e:	0e 94 fd 2c 	call	0x59fa	; 0x59fa <report_status_message>
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    2c42:	0d 2d       	mov	r16, r13
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    2c44:	10 e0       	ldi	r17, 0x00	; 0
    2c46:	31 c0       	rjmp	.+98     	; 0x2caa <protocol_main_loop+0x128>
          report_status_message(STATUS_SYSTEM_GC_LOCK);
        } 
		else 
		{
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
    2c48:	8a e0       	ldi	r24, 0x0A	; 10
    2c4a:	91 e0       	ldi	r25, 0x01	; 1
    2c4c:	0e 94 9a 05 	call	0xb34	; 0xb34 <gc_execute_line>
    2c50:	0e 94 fd 2c 	call	0x59fa	; 0x59fa <report_status_message>
        }

        // Reset tracking data for next line.
        line_flags = 0;
        char_counter = 0;
    2c54:	0d 2d       	mov	r16, r13
          // Parse and execute g-code block.
          report_status_message(gc_execute_line(line));
        }

        // Reset tracking data for next line.
        line_flags = 0;
    2c56:	10 e0       	ldi	r17, 0x00	; 0
    2c58:	28 c0       	rjmp	.+80     	; 0x2caa <protocol_main_loop+0x128>
        char_counter = 0;
      } 
	  else 
      {
        if (line_flags) 
    2c5a:	11 23       	and	r17, r17
    2c5c:	21 f0       	breq	.+8      	; 0x2c66 <protocol_main_loop+0xe4>
		{
          // Throw away all (except EOL) comment characters and overflow characters.
          if (c == ')') 
    2c5e:	89 32       	cpi	r24, 0x29	; 41
    2c60:	21 f5       	brne	.+72     	; 0x2caa <protocol_main_loop+0x128>
		  {
            // End of '()' comment. Resume line allowed.
            if (line_flags & LINE_FLAG_COMMENT_PARENTHESES)
			{ 
				line_flags &= ~(LINE_FLAG_COMMENT_PARENTHESES); 
    2c62:	1d 7f       	andi	r17, 0xFD	; 253
    2c64:	22 c0       	rjmp	.+68     	; 0x2caa <protocol_main_loop+0x128>
			}
          }
        } 
		else 
		{
          if (c <= ' ') 
    2c66:	81 32       	cpi	r24, 0x21	; 33
    2c68:	00 f1       	brcs	.+64     	; 0x2caa <protocol_main_loop+0x128>
		  {
            // Throw away whitepace and control characters
          } 
		  else if (c == '/') 
    2c6a:	8f 32       	cpi	r24, 0x2F	; 47
    2c6c:	f1 f0       	breq	.+60     	; 0x2caa <protocol_main_loop+0x128>
		  {
            // Block delete NOT SUPPORTED. Ignore character.
            // NOTE: If supported, would simply need to check the system if block delete is enabled.
          } 
		  else if (c == '(') 
    2c6e:	88 32       	cpi	r24, 0x28	; 40
    2c70:	b9 f0       	breq	.+46     	; 0x2ca0 <protocol_main_loop+0x11e>
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            line_flags |= LINE_FLAG_COMMENT_PARENTHESES;
          } 
		  else if (c == ';') 
    2c72:	8b 33       	cpi	r24, 0x3B	; 59
    2c74:	b9 f0       	breq	.+46     	; 0x2ca4 <protocol_main_loop+0x122>
            // NOTE: This maybe installed to tell Grbl when a program is running vs manual input,
            // where, during a program, the system auto-cycle start will continue to execute
            // everything until the next '%' sign. This will help fix resuming issues with certain
            // functions that empty the planner buffer to execute its task on-time.
          } 
		  else if (char_counter >= (LINE_BUFFER_SIZE-1)) 
    2c76:	0f 34       	cpi	r16, 0x4F	; 79
    2c78:	b8 f4       	brcc	.+46     	; 0x2ca8 <protocol_main_loop+0x126>
		  {
            // Detect line buffer overflow and set flag.
            line_flags |= LINE_FLAG_OVERFLOW;
          } 
		  else if (c >= 'a' && c <= 'z') 
    2c7a:	9f e9       	ldi	r25, 0x9F	; 159
    2c7c:	98 0f       	add	r25, r24
    2c7e:	9a 31       	cpi	r25, 0x1A	; 26
    2c80:	40 f4       	brcc	.+16     	; 0x2c92 <protocol_main_loop+0x110>
		  { // Upcase lowercase
            line[char_counter++] = c-'a'+'A';
    2c82:	e0 2f       	mov	r30, r16
    2c84:	f0 e0       	ldi	r31, 0x00	; 0
    2c86:	e6 5f       	subi	r30, 0xF6	; 246
    2c88:	fe 4f       	sbci	r31, 0xFE	; 254
    2c8a:	80 52       	subi	r24, 0x20	; 32
    2c8c:	80 83       	st	Z, r24
    2c8e:	0f 5f       	subi	r16, 0xFF	; 255
    2c90:	0c c0       	rjmp	.+24     	; 0x2caa <protocol_main_loop+0x128>
          } 
		  else 
		  {
            line[char_counter++] = c;
    2c92:	e0 2f       	mov	r30, r16
    2c94:	f0 e0       	ldi	r31, 0x00	; 0
    2c96:	e6 5f       	subi	r30, 0xF6	; 246
    2c98:	fe 4f       	sbci	r31, 0xFE	; 254
    2c9a:	80 83       	st	Z, r24
    2c9c:	0f 5f       	subi	r16, 0xFF	; 255
    2c9e:	05 c0       	rjmp	.+10     	; 0x2caa <protocol_main_loop+0x128>
		  {
            // Enable comments flag and ignore all characters until ')' or EOL.
            // NOTE: This doesn't follow the NIST definition exactly, but is good enough for now.
            // In the future, we could simply remove the items within the comments, but retain the
            // comment control characters, so that the g-code parser can error-check it.
            line_flags |= LINE_FLAG_COMMENT_PARENTHESES;
    2ca0:	12 e0       	ldi	r17, 0x02	; 2
    2ca2:	03 c0       	rjmp	.+6      	; 0x2caa <protocol_main_loop+0x128>
          } 
		  else if (c == ';') 
		  {
            // NOTE: ';' comment to EOL is a LinuxCNC definition. Not NIST.
            line_flags |= LINE_FLAG_COMMENT_SEMICOLON;
    2ca4:	14 e0       	ldi	r17, 0x04	; 4
    2ca6:	01 c0       	rjmp	.+2      	; 0x2caa <protocol_main_loop+0x128>
            // functions that empty the planner buffer to execute its task on-time.
          } 
		  else if (char_counter >= (LINE_BUFFER_SIZE-1)) 
		  {
            // Detect line buffer overflow and set flag.
            line_flags |= LINE_FLAG_OVERFLOW;
    2ca8:	11 e0       	ldi	r17, 0x01	; 1
    while((c = serial_read()) != SERIAL_NO_DATA) 
#else
    // start from beginning
    p_gcode = (uint8_t *)(GCODE_ADDRESS);
  
    while((c = gcode_get_byte()) != SERIAL_NO_DATA)
    2caa:	0e 94 c6 12 	call	0x258c	; 0x258c <gcode_get_byte>
    2cae:	8f 3f       	cpi	r24, 0xFF	; 255
    2cb0:	09 f0       	breq	.+2      	; 0x2cb4 <protocol_main_loop+0x132>
    2cb2:	a7 cf       	rjmp	.-178    	; 0x2c02 <protocol_main_loop+0x80>
    }

    // If there are no more characters in the serial read buffer to be processed and executed,
    // this indicates that g-code streaming has either filled the planner buffer or has
    // completed. In either case, auto-cycle start, if enabled, any queued moves.
    protocol_auto_cycle_start();
    2cb4:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <protocol_auto_cycle_start>

    protocol_execute_realtime();  // Runtime command check point.
    2cb8:	0e 94 9e 14 	call	0x293c	; 0x293c <protocol_execute_realtime>
    if (sys.abort) { return; } // Bail to main() program loop to reset system.
    2cbc:	89 81       	ldd	r24, Y+1	; 0x01
    2cbe:	88 23       	and	r24, r24
    2cc0:	09 f4       	brne	.+2      	; 0x2cc4 <protocol_main_loop+0x142>
    2cc2:	9a cf       	rjmp	.-204    	; 0x2bf8 <protocol_main_loop+0x76>
  }

  return; /* Never reached */
}
    2cc4:	df 91       	pop	r29
    2cc6:	cf 91       	pop	r28
    2cc8:	1f 91       	pop	r17
    2cca:	0f 91       	pop	r16
    2ccc:	ff 90       	pop	r15
    2cce:	ef 90       	pop	r14
    2cd0:	df 90       	pop	r13
    2cd2:	08 95       	ret

00002cd4 <protocol_buffer_synchronize>:


// Block until all buffered steps are executed or in a cycle state. Works with feed hold
// during a synchronize call, if it should happen. Also, waits for clean cycle end.
void protocol_buffer_synchronize()
{
    2cd4:	cf 93       	push	r28
    2cd6:	df 93       	push	r29
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
    2cd8:	0e 94 d2 12 	call	0x25a4	; 0x25a4 <protocol_auto_cycle_start>
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    if (sys.abort) { return; } // Check for system abort
    2cdc:	cc e7       	ldi	r28, 0x7C	; 124
    2cde:	d5 e0       	ldi	r29, 0x05	; 5
void protocol_buffer_synchronize()
{
  // If system is queued, ensure cycle resumes if the auto start flag is present.
  protocol_auto_cycle_start();
  do {
    protocol_execute_realtime();   // Check and execute run-time commands
    2ce0:	0e 94 9e 14 	call	0x293c	; 0x293c <protocol_execute_realtime>
    if (sys.abort) { return; } // Check for system abort
    2ce4:	89 81       	ldd	r24, Y+1	; 0x01
    2ce6:	81 11       	cpse	r24, r1
    2ce8:	07 c0       	rjmp	.+14     	; 0x2cf8 <protocol_buffer_synchronize+0x24>
  } while (plan_get_current_block() || (sys.state == STATE_CYCLE));
    2cea:	0e 94 47 25 	call	0x4a8e	; 0x4a8e <plan_get_current_block>
    2cee:	89 2b       	or	r24, r25
    2cf0:	b9 f7       	brne	.-18     	; 0x2ce0 <protocol_buffer_synchronize+0xc>
    2cf2:	88 81       	ld	r24, Y
    2cf4:	88 30       	cpi	r24, 0x08	; 8
    2cf6:	a1 f3       	breq	.-24     	; 0x2ce0 <protocol_buffer_synchronize+0xc>
}
    2cf8:	df 91       	pop	r29
    2cfa:	cf 91       	pop	r28
    2cfc:	08 95       	ret

00002cfe <st_wake_up>:
// Stepper state initialization. Cycle should only start if the st.cycle_start flag is
// enabled. Startup init and limits call this function but shouldn't start the cycle.
void st_wake_up()
{
  // Enable stepper drivers.
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    2cfe:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <settings+0x45>
    2d02:	82 ff       	sbrs	r24, 2
    2d04:	02 c0       	rjmp	.+4      	; 0x2d0a <st_wake_up+0xc>
    2d06:	28 9a       	sbi	0x05, 0	; 5
    2d08:	01 c0       	rjmp	.+2      	; 0x2d0c <st_wake_up+0xe>
  else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    2d0a:	28 98       	cbi	0x05, 0	; 5

  // Initialize stepper output bits to ensure first ISR call does not step.
  st.step_outbits = step_port_invert_mask;
    2d0c:	e4 e9       	ldi	r30, 0x94	; 148
    2d0e:	f1 e0       	ldi	r31, 0x01	; 1
    2d10:	80 91 90 01 	lds	r24, 0x0190	; 0x800190 <step_port_invert_mask>
    2d14:	86 87       	std	Z+14, r24	; 0x0e
    st.step_pulse_time = -(((settings.pulse_microseconds+STEP_PULSE_DELAY-2)*TICKS_PER_MICROSECOND) >> 3);
    // Set delay between direction pin write and step command.
    OCR0A = -(((settings.pulse_microseconds)*TICKS_PER_MICROSECOND) >> 3);
  #else // Normal operation
    // Set step pulse time. Ad hoc computation from oscilloscope. Uses two's complement.
    st.step_pulse_time = -(((settings.pulse_microseconds-2)*TICKS_PER_MICROSECOND) >> 3);
    2d16:	80 91 3e 07 	lds	r24, 0x073E	; 0x80073e <settings+0x30>
    2d1a:	88 0f       	add	r24, r24
    2d1c:	84 50       	subi	r24, 0x04	; 4
    2d1e:	81 95       	neg	r24
    2d20:	85 87       	std	Z+13, r24	; 0x0d
  #endif

  // Enable Stepper Driver Interrupt
  TIMSK1 |= (1<<OCIE1A);
    2d22:	ef e6       	ldi	r30, 0x6F	; 111
    2d24:	f0 e0       	ldi	r31, 0x00	; 0
    2d26:	80 81       	ld	r24, Z
    2d28:	82 60       	ori	r24, 0x02	; 2
    2d2a:	80 83       	st	Z, r24
    2d2c:	08 95       	ret

00002d2e <st_go_idle>:

// Stepper shutdown
void st_go_idle()
{
  // Disable Stepper Driver Interrupt. Allow Stepper Port Reset Interrupt to finish, if active.
  TIMSK1 &= ~(1<<OCIE1A); // Disable Timer1 interrupt
    2d2e:	ef e6       	ldi	r30, 0x6F	; 111
    2d30:	f0 e0       	ldi	r31, 0x00	; 0
    2d32:	80 81       	ld	r24, Z
    2d34:	8d 7f       	andi	r24, 0xFD	; 253
    2d36:	80 83       	st	Z, r24
  TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Reset clock to no prescaling.
    2d38:	e1 e8       	ldi	r30, 0x81	; 129
    2d3a:	f0 e0       	ldi	r31, 0x00	; 0
    2d3c:	80 81       	ld	r24, Z
    2d3e:	88 7f       	andi	r24, 0xF8	; 248
    2d40:	81 60       	ori	r24, 0x01	; 1
    2d42:	80 83       	st	Z, r24
  busy = false;
    2d44:	10 92 8e 01 	sts	0x018E, r1	; 0x80018e <busy>

  // Set stepper driver idle state, disabled or enabled, depending on settings and circumstances.
  bool pin_state = false; // Keep enabled.
  if (((settings.stepper_idle_lock_time != 0xff) || sys_rt_exec_alarm || sys.state == STATE_SLEEP) && sys.state != STATE_HOMING) {
    2d48:	80 91 41 07 	lds	r24, 0x0741	; 0x800741 <settings+0x33>
    2d4c:	8f 3f       	cpi	r24, 0xFF	; 255
    2d4e:	49 f4       	brne	.+18     	; 0x2d62 <st_go_idle+0x34>
    2d50:	90 91 a8 05 	lds	r25, 0x05A8	; 0x8005a8 <sys_rt_exec_alarm>
    2d54:	91 11       	cpse	r25, r1
    2d56:	05 c0       	rjmp	.+10     	; 0x2d62 <st_go_idle+0x34>
    2d58:	90 91 7c 05 	lds	r25, 0x057C	; 0x80057c <sys>
    2d5c:	90 38       	cpi	r25, 0x80	; 128
    2d5e:	81 f4       	brne	.+32     	; 0x2d80 <st_go_idle+0x52>
    2d60:	04 c0       	rjmp	.+8      	; 0x2d6a <st_go_idle+0x3c>
    2d62:	90 91 7c 05 	lds	r25, 0x057C	; 0x80057c <sys>
    2d66:	94 30       	cpi	r25, 0x04	; 4
    2d68:	59 f0       	breq	.+22     	; 0x2d80 <st_go_idle+0x52>
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    2d6a:	90 e0       	ldi	r25, 0x00	; 0
    2d6c:	0e 94 e0 2a 	call	0x55c0	; 0x55c0 <delay_ms>
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    2d70:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <settings+0x45>
    2d74:	82 fd       	sbrc	r24, 2
    2d76:	02 c0       	rjmp	.+4      	; 0x2d7c <st_go_idle+0x4e>
  if (pin_state) { STEPPERS_DISABLE_PORT |= (1<<STEPPERS_DISABLE_BIT); }
    2d78:	28 9a       	sbi	0x05, 0	; 5
    2d7a:	08 95       	ret
  else { STEPPERS_DISABLE_PORT &= ~(1<<STEPPERS_DISABLE_BIT); }
    2d7c:	28 98       	cbi	0x05, 0	; 5
}
    2d7e:	08 95       	ret
    // Force stepper dwell to lock axes for a defined amount of time to ensure the axes come to a complete
    // stop and not drift from residual inertial forces at the end of the last movement.
    delay_ms(settings.stepper_idle_lock_time);
    pin_state = true; // Override. Disable steppers.
  }
  if (bit_istrue(settings.flags,BITFLAG_INVERT_ST_ENABLE)) { pin_state = !pin_state; } // Apply pin invert.
    2d80:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <settings+0x45>
    2d84:	82 ff       	sbrs	r24, 2
    2d86:	fa cf       	rjmp	.-12     	; 0x2d7c <st_go_idle+0x4e>
    2d88:	f7 cf       	rjmp	.-18     	; 0x2d78 <st_go_idle+0x4a>

00002d8a <__vector_11>:
*/
// TODO: Replace direct updating of the int32 position counters in the ISR somehow. Perhaps use smaller
// int8 variables and update position counters only when a segment completes. This can get complicated
// with probing and homing cycles that require true real-time positions.
ISR(TIMER1_COMPA_vect)
{
    2d8a:	1f 92       	push	r1
    2d8c:	0f 92       	push	r0
    2d8e:	0f b6       	in	r0, 0x3f	; 63
    2d90:	0f 92       	push	r0
    2d92:	11 24       	eor	r1, r1
    2d94:	2f 93       	push	r18
    2d96:	3f 93       	push	r19
    2d98:	4f 93       	push	r20
    2d9a:	5f 93       	push	r21
    2d9c:	6f 93       	push	r22
    2d9e:	7f 93       	push	r23
    2da0:	8f 93       	push	r24
    2da2:	9f 93       	push	r25
    2da4:	af 93       	push	r26
    2da6:	bf 93       	push	r27
    2da8:	cf 93       	push	r28
    2daa:	df 93       	push	r29
    2dac:	ef 93       	push	r30
    2dae:	ff 93       	push	r31
  if (busy) { return; } // The busy-flag is used to avoid reentering this interrupt
    2db0:	80 91 8e 01 	lds	r24, 0x018E	; 0x80018e <busy>
    2db4:	81 11       	cpse	r24, r1
    2db6:	ce c1       	rjmp	.+924    	; 0x3154 <__vector_11+0x3ca>

  // Set the direction pins a couple of nanoseconds before we step the steppers
  DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | (st.dir_outbits & DIRECTION_MASK);
    2db8:	8b b1       	in	r24, 0x0b	; 11
    2dba:	e4 e9       	ldi	r30, 0x94	; 148
    2dbc:	f1 e0       	ldi	r31, 0x01	; 1
    2dbe:	97 85       	ldd	r25, Z+15	; 0x0f
    2dc0:	90 7e       	andi	r25, 0xE0	; 224
    2dc2:	8f 71       	andi	r24, 0x1F	; 31
    2dc4:	89 2b       	or	r24, r25
    2dc6:	8b b9       	out	0x0b, r24	; 11
    st.step_bits = (STEP_PORT & ~STEP_MASK) | st.step_outbits; // Store out_bits to prevent overwriting.
    #ifdef ENABLE_DUAL_AXIS
      st.step_bits_dual = (STEP_PORT_DUAL & ~STEP_MASK_DUAL) | st.step_outbits_dual;
    #endif
  #else  // Normal operation
    STEP_PORT = (STEP_PORT & ~STEP_MASK) | st.step_outbits;
    2dc8:	8b b1       	in	r24, 0x0b	; 11
    2dca:	83 7e       	andi	r24, 0xE3	; 227
    2dcc:	96 85       	ldd	r25, Z+14	; 0x0e
    2dce:	89 2b       	or	r24, r25
    2dd0:	8b b9       	out	0x0b, r24	; 11
    #endif
  #endif

  // Enable step pulse reset timer so that The Stepper Port Reset Interrupt can reset the signal after
  // exactly settings.pulse_microseconds microseconds, independent of the main Timer1 prescaler.
  TCNT0 = st.step_pulse_time; // Reload Timer0 counter
    2dd2:	85 85       	ldd	r24, Z+13	; 0x0d
    2dd4:	86 bd       	out	0x26, r24	; 38
  TCCR0B = (1<<CS01); // Begin Timer0. Full speed, 1/8 prescaler
    2dd6:	82 e0       	ldi	r24, 0x02	; 2
    2dd8:	85 bd       	out	0x25, r24	; 37

  busy = true;
    2dda:	81 e0       	ldi	r24, 0x01	; 1
    2ddc:	80 93 8e 01 	sts	0x018E, r24	; 0x80018e <busy>
  sei(); // Re-enable interrupts to allow Stepper Port Reset Interrupt to fire on-time.
    2de0:	78 94       	sei
         // NOTE: The remaining code in this ISR will finish before returning to main program.

  // If there is no step segment, attempt to pop one from the stepper buffer
  if (st.exec_segment == NULL) {
    2de2:	81 a1       	ldd	r24, Z+33	; 0x21
    2de4:	92 a1       	ldd	r25, Z+34	; 0x22
    2de6:	89 2b       	or	r24, r25
    2de8:	09 f0       	breq	.+2      	; 0x2dec <__vector_11+0x62>
    2dea:	a7 c0       	rjmp	.+334    	; 0x2f3a <__vector_11+0x1b0>
    // Anything in the buffer? If so, load and initialize next step segment.
    if (segment_buffer_head != segment_buffer_tail) {
    2dec:	80 91 93 01 	lds	r24, 0x0193	; 0x800193 <segment_buffer_tail>
    2df0:	90 91 92 01 	lds	r25, 0x0192	; 0x800192 <segment_buffer_head>
    2df4:	98 17       	cp	r25, r24
    2df6:	09 f4       	brne	.+2      	; 0x2dfa <__vector_11+0x70>
    2df8:	90 c0       	rjmp	.+288    	; 0x2f1a <__vector_11+0x190>
      // Initialize new step segment and load number of steps to execute
      st.exec_segment = &segment_buffer[segment_buffer_tail];
    2dfa:	e0 91 93 01 	lds	r30, 0x0193	; 0x800193 <segment_buffer_tail>
    2dfe:	a4 e9       	ldi	r26, 0x94	; 148
    2e00:	b1 e0       	ldi	r27, 0x01	; 1
    2e02:	87 e0       	ldi	r24, 0x07	; 7
    2e04:	e8 9f       	mul	r30, r24
    2e06:	f0 01       	movw	r30, r0
    2e08:	11 24       	eor	r1, r1
    2e0a:	e9 54       	subi	r30, 0x49	; 73
    2e0c:	fe 4f       	sbci	r31, 0xFE	; 254
    2e0e:	92 96       	adiw	r26, 0x22	; 34
    2e10:	fc 93       	st	X, r31
    2e12:	ee 93       	st	-X, r30
    2e14:	91 97       	sbiw	r26, 0x21	; 33
        // With AMASS is disabled, set timer prescaler for segments with slow step frequencies (< 250Hz).
        TCCR1B = (TCCR1B & ~(0x07<<CS10)) | (st.exec_segment->prescaler<<CS10);
      #endif

      // Initialize step segment timing per step and load number of steps to execute.
      OCR1A = st.exec_segment->cycles_per_tick;
    2e16:	82 81       	ldd	r24, Z+2	; 0x02
    2e18:	93 81       	ldd	r25, Z+3	; 0x03
    2e1a:	90 93 89 00 	sts	0x0089, r25	; 0x800089 <__DATA_REGION_ORIGIN__+0x29>
    2e1e:	80 93 88 00 	sts	0x0088, r24	; 0x800088 <__DATA_REGION_ORIGIN__+0x28>
      st.step_count = st.exec_segment->n_step; // NOTE: Can sometimes be zero when moving slow.
    2e22:	80 81       	ld	r24, Z
    2e24:	91 81       	ldd	r25, Z+1	; 0x01
    2e26:	5d 96       	adiw	r26, 0x1d	; 29
    2e28:	9c 93       	st	X, r25
    2e2a:	8e 93       	st	-X, r24
    2e2c:	5c 97       	sbiw	r26, 0x1c	; 28
      // If the new segment starts a new planner block, initialize stepper variables and counters.
      // NOTE: When the segment data index changes, this indicates a new planner block.
      if ( st.exec_block_index != st.exec_segment->st_block_index ) {
    2e2e:	84 81       	ldd	r24, Z+4	; 0x04
    2e30:	5e 96       	adiw	r26, 0x1e	; 30
    2e32:	9c 91       	ld	r25, X
    2e34:	5e 97       	sbiw	r26, 0x1e	; 30
    2e36:	98 17       	cp	r25, r24
    2e38:	49 f1       	breq	.+82     	; 0x2e8c <__vector_11+0x102>
        st.exec_block_index = st.exec_segment->st_block_index;
    2e3a:	ed 01       	movw	r28, r26
    2e3c:	8e 8f       	std	Y+30, r24	; 0x1e
        st.exec_block = &st_block_buffer[st.exec_block_index];
    2e3e:	90 e0       	ldi	r25, 0x00	; 0
    2e40:	88 0f       	add	r24, r24
    2e42:	99 1f       	adc	r25, r25
    2e44:	dc 01       	movw	r26, r24
    2e46:	aa 0f       	add	r26, r26
    2e48:	bb 1f       	adc	r27, r27
    2e4a:	aa 0f       	add	r26, r26
    2e4c:	bb 1f       	adc	r27, r27
    2e4e:	aa 0f       	add	r26, r26
    2e50:	bb 1f       	adc	r27, r27
    2e52:	8a 0f       	add	r24, r26
    2e54:	9b 1f       	adc	r25, r27
    2e56:	dc 01       	movw	r26, r24
    2e58:	af 51       	subi	r26, 0x1F	; 31
    2e5a:	be 4f       	sbci	r27, 0xFE	; 254
    2e5c:	b8 a3       	std	Y+32, r27	; 0x20
    2e5e:	af 8f       	std	Y+31, r26	; 0x1f

        // Initialize Bresenham line and distance counters
        st.counter_x = st.counter_y = st.counter_z = (st.exec_block->step_event_count >> 1);
    2e60:	1c 96       	adiw	r26, 0x0c	; 12
    2e62:	8d 91       	ld	r24, X+
    2e64:	9d 91       	ld	r25, X+
    2e66:	0d 90       	ld	r0, X+
    2e68:	bc 91       	ld	r27, X
    2e6a:	a0 2d       	mov	r26, r0
    2e6c:	b6 95       	lsr	r27
    2e6e:	a7 95       	ror	r26
    2e70:	97 95       	ror	r25
    2e72:	87 95       	ror	r24
    2e74:	88 87       	std	Y+8, r24	; 0x08
    2e76:	99 87       	std	Y+9, r25	; 0x09
    2e78:	aa 87       	std	Y+10, r26	; 0x0a
    2e7a:	bb 87       	std	Y+11, r27	; 0x0b
    2e7c:	8c 83       	std	Y+4, r24	; 0x04
    2e7e:	9d 83       	std	Y+5, r25	; 0x05
    2e80:	ae 83       	std	Y+6, r26	; 0x06
    2e82:	bf 83       	std	Y+7, r27	; 0x07
    2e84:	88 83       	st	Y, r24
    2e86:	99 83       	std	Y+1, r25	; 0x01
    2e88:	aa 83       	std	Y+2, r26	; 0x02
    2e8a:	bb 83       	std	Y+3, r27	; 0x03
      }
      st.dir_outbits = st.exec_block->direction_bits ^ dir_port_invert_mask;
    2e8c:	a4 e9       	ldi	r26, 0x94	; 148
    2e8e:	b1 e0       	ldi	r27, 0x01	; 1
    2e90:	5f 96       	adiw	r26, 0x1f	; 31
    2e92:	cd 91       	ld	r28, X+
    2e94:	dc 91       	ld	r29, X
    2e96:	90 97       	sbiw	r26, 0x20	; 32
    2e98:	98 89       	ldd	r25, Y+16	; 0x10
    2e9a:	80 91 8f 01 	lds	r24, 0x018F	; 0x80018f <dir_port_invert_mask>
    2e9e:	89 27       	eor	r24, r25
    2ea0:	1f 96       	adiw	r26, 0x0f	; 15
    2ea2:	8c 93       	st	X, r24
    2ea4:	1f 97       	sbiw	r26, 0x0f	; 15
        st.dir_outbits_dual = st.exec_block->direction_bits_dual ^ dir_port_invert_mask_dual;
      #endif

      #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
        // With AMASS enabled, adjust Bresenham axis increment counters according to AMASS level.
        st.steps[X_AXIS] = st.exec_block->steps[X_AXIS] >> st.exec_segment->amass_level;
    2ea6:	48 81       	ld	r20, Y
    2ea8:	59 81       	ldd	r21, Y+1	; 0x01
    2eaa:	6a 81       	ldd	r22, Y+2	; 0x02
    2eac:	7b 81       	ldd	r23, Y+3	; 0x03
    2eae:	05 80       	ldd	r0, Z+5	; 0x05
    2eb0:	04 c0       	rjmp	.+8      	; 0x2eba <__vector_11+0x130>
    2eb2:	76 95       	lsr	r23
    2eb4:	67 95       	ror	r22
    2eb6:	57 95       	ror	r21
    2eb8:	47 95       	ror	r20
    2eba:	0a 94       	dec	r0
    2ebc:	d2 f7       	brpl	.-12     	; 0x2eb2 <__vector_11+0x128>
    2ebe:	50 96       	adiw	r26, 0x10	; 16
    2ec0:	4d 93       	st	X+, r20
    2ec2:	5d 93       	st	X+, r21
    2ec4:	6d 93       	st	X+, r22
    2ec6:	7c 93       	st	X, r23
    2ec8:	53 97       	sbiw	r26, 0x13	; 19
        st.steps[Y_AXIS] = st.exec_block->steps[Y_AXIS] >> st.exec_segment->amass_level;
    2eca:	4c 81       	ldd	r20, Y+4	; 0x04
    2ecc:	5d 81       	ldd	r21, Y+5	; 0x05
    2ece:	6e 81       	ldd	r22, Y+6	; 0x06
    2ed0:	7f 81       	ldd	r23, Y+7	; 0x07
    2ed2:	05 80       	ldd	r0, Z+5	; 0x05
    2ed4:	04 c0       	rjmp	.+8      	; 0x2ede <__vector_11+0x154>
    2ed6:	76 95       	lsr	r23
    2ed8:	67 95       	ror	r22
    2eda:	57 95       	ror	r21
    2edc:	47 95       	ror	r20
    2ede:	0a 94       	dec	r0
    2ee0:	d2 f7       	brpl	.-12     	; 0x2ed6 <__vector_11+0x14c>
    2ee2:	54 96       	adiw	r26, 0x14	; 20
    2ee4:	4d 93       	st	X+, r20
    2ee6:	5d 93       	st	X+, r21
    2ee8:	6d 93       	st	X+, r22
    2eea:	7c 93       	st	X, r23
    2eec:	57 97       	sbiw	r26, 0x17	; 23
        st.steps[Z_AXIS] = st.exec_block->steps[Z_AXIS] >> st.exec_segment->amass_level;
    2eee:	48 85       	ldd	r20, Y+8	; 0x08
    2ef0:	59 85       	ldd	r21, Y+9	; 0x09
    2ef2:	6a 85       	ldd	r22, Y+10	; 0x0a
    2ef4:	7b 85       	ldd	r23, Y+11	; 0x0b
    2ef6:	05 80       	ldd	r0, Z+5	; 0x05
    2ef8:	04 c0       	rjmp	.+8      	; 0x2f02 <__vector_11+0x178>
    2efa:	76 95       	lsr	r23
    2efc:	67 95       	ror	r22
    2efe:	57 95       	ror	r21
    2f00:	47 95       	ror	r20
    2f02:	0a 94       	dec	r0
    2f04:	d2 f7       	brpl	.-12     	; 0x2efa <__vector_11+0x170>
    2f06:	58 96       	adiw	r26, 0x18	; 24
    2f08:	4d 93       	st	X+, r20
    2f0a:	5d 93       	st	X+, r21
    2f0c:	6d 93       	st	X+, r22
    2f0e:	7c 93       	st	X, r23
    2f10:	5b 97       	sbiw	r26, 0x1b	; 27
      #endif

      #ifdef VARIABLE_SPINDLE
        // Set real-time spindle output as segment is loaded, just prior to the first step.
        spindle_set_speed(st.exec_segment->spindle_pwm);
    2f12:	86 81       	ldd	r24, Z+6	; 0x06
    2f14:	0e 94 c4 10 	call	0x2188	; 0x2188 <spindle_set_speed>
    2f18:	10 c0       	rjmp	.+32     	; 0x2f3a <__vector_11+0x1b0>
      #endif

    } else {
      // Segment buffer empty. Shutdown.
      st_go_idle();
    2f1a:	0e 94 97 16 	call	0x2d2e	; 0x2d2e <st_go_idle>
      #ifdef VARIABLE_SPINDLE
        // Ensure pwm is set properly upon completion of rate-controlled motion.
        if (st.exec_block->is_pwm_rate_adjusted) { spindle_set_speed(SPINDLE_PWM_OFF_VALUE); }
    2f1e:	e0 91 b3 01 	lds	r30, 0x01B3	; 0x8001b3 <st+0x1f>
    2f22:	f0 91 b4 01 	lds	r31, 0x01B4	; 0x8001b4 <st+0x20>
    2f26:	81 89       	ldd	r24, Z+17	; 0x11
    2f28:	88 23       	and	r24, r24
    2f2a:	19 f0       	breq	.+6      	; 0x2f32 <__vector_11+0x1a8>
    2f2c:	80 e0       	ldi	r24, 0x00	; 0
    2f2e:	0e 94 c4 10 	call	0x2188	; 0x2188 <spindle_set_speed>
      #endif
      system_set_exec_state_flag(EXEC_CYCLE_STOP); // Flag main program for cycle end
    2f32:	84 e0       	ldi	r24, 0x04	; 4
    2f34:	0e 94 31 2e 	call	0x5c62	; 0x5c62 <system_set_exec_state_flag>
      return; // Nothing to do but exit.
    2f38:	0d c1       	rjmp	.+538    	; 0x3154 <__vector_11+0x3ca>
    }
  }


  // Check probing state.
  if (sys_probe_state == PROBE_ACTIVE) { probe_state_monitor(); }
    2f3a:	80 91 8f 05 	lds	r24, 0x058F	; 0x80058f <sys_probe_state>
    2f3e:	81 30       	cpi	r24, 0x01	; 1
    2f40:	11 f4       	brne	.+4      	; 0x2f46 <__vector_11+0x1bc>
    2f42:	0e 94 e8 2c 	call	0x59d0	; 0x59d0 <probe_state_monitor>

  // Reset step out bits.
  st.step_outbits = 0;
    2f46:	e4 e9       	ldi	r30, 0x94	; 148
    2f48:	f1 e0       	ldi	r31, 0x01	; 1
    2f4a:	16 86       	std	Z+14, r1	; 0x0e
    st.step_outbits_dual = 0;
  #endif

  // Execute step displacement profile by Bresenham line algorithm
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_x += st.steps[X_AXIS];
    2f4c:	40 81       	ld	r20, Z
    2f4e:	51 81       	ldd	r21, Z+1	; 0x01
    2f50:	62 81       	ldd	r22, Z+2	; 0x02
    2f52:	73 81       	ldd	r23, Z+3	; 0x03
    2f54:	80 89       	ldd	r24, Z+16	; 0x10
    2f56:	91 89       	ldd	r25, Z+17	; 0x11
    2f58:	a2 89       	ldd	r26, Z+18	; 0x12
    2f5a:	b3 89       	ldd	r27, Z+19	; 0x13
    2f5c:	84 0f       	add	r24, r20
    2f5e:	95 1f       	adc	r25, r21
    2f60:	a6 1f       	adc	r26, r22
    2f62:	b7 1f       	adc	r27, r23
    2f64:	80 83       	st	Z, r24
    2f66:	91 83       	std	Z+1, r25	; 0x01
    2f68:	a2 83       	std	Z+2, r26	; 0x02
    2f6a:	b3 83       	std	Z+3, r27	; 0x03
  #else
    st.counter_x += st.exec_block->steps[X_AXIS];
  #endif
  if (st.counter_x > st.exec_block->step_event_count) {
    2f6c:	07 8c       	ldd	r0, Z+31	; 0x1f
    2f6e:	f0 a1       	ldd	r31, Z+32	; 0x20
    2f70:	e0 2d       	mov	r30, r0
    2f72:	44 85       	ldd	r20, Z+12	; 0x0c
    2f74:	55 85       	ldd	r21, Z+13	; 0x0d
    2f76:	66 85       	ldd	r22, Z+14	; 0x0e
    2f78:	77 85       	ldd	r23, Z+15	; 0x0f
    2f7a:	48 17       	cp	r20, r24
    2f7c:	59 07       	cpc	r21, r25
    2f7e:	6a 07       	cpc	r22, r26
    2f80:	7b 07       	cpc	r23, r27
    2f82:	70 f5       	brcc	.+92     	; 0x2fe0 <__vector_11+0x256>
    st.step_outbits |= (1<<X_STEP_BIT);
    2f84:	c4 e9       	ldi	r28, 0x94	; 148
    2f86:	d1 e0       	ldi	r29, 0x01	; 1
    2f88:	24 e0       	ldi	r18, 0x04	; 4
    2f8a:	2e 87       	std	Y+14, r18	; 0x0e
    #if defined(ENABLE_DUAL_AXIS) && (DUAL_AXIS_SELECT == X_AXIS)
      st.step_outbits_dual = (1<<DUAL_STEP_BIT);
    #endif
    st.counter_x -= st.exec_block->step_event_count;
    2f8c:	44 85       	ldd	r20, Z+12	; 0x0c
    2f8e:	55 85       	ldd	r21, Z+13	; 0x0d
    2f90:	66 85       	ldd	r22, Z+14	; 0x0e
    2f92:	77 85       	ldd	r23, Z+15	; 0x0f
    2f94:	84 1b       	sub	r24, r20
    2f96:	95 0b       	sbc	r25, r21
    2f98:	a6 0b       	sbc	r26, r22
    2f9a:	b7 0b       	sbc	r27, r23
    2f9c:	88 83       	st	Y, r24
    2f9e:	99 83       	std	Y+1, r25	; 0x01
    2fa0:	aa 83       	std	Y+2, r26	; 0x02
    2fa2:	bb 83       	std	Y+3, r27	; 0x03
    if (st.exec_block->direction_bits & (1<<X_DIRECTION_BIT)) { sys_position[X_AXIS]--; }
    2fa4:	80 89       	ldd	r24, Z+16	; 0x10
    2fa6:	85 ff       	sbrs	r24, 5
    2fa8:	0e c0       	rjmp	.+28     	; 0x2fc6 <__vector_11+0x23c>
    2faa:	cc e9       	ldi	r28, 0x9C	; 156
    2fac:	d5 e0       	ldi	r29, 0x05	; 5
    2fae:	88 81       	ld	r24, Y
    2fb0:	99 81       	ldd	r25, Y+1	; 0x01
    2fb2:	aa 81       	ldd	r26, Y+2	; 0x02
    2fb4:	bb 81       	ldd	r27, Y+3	; 0x03
    2fb6:	01 97       	sbiw	r24, 0x01	; 1
    2fb8:	a1 09       	sbc	r26, r1
    2fba:	b1 09       	sbc	r27, r1
    2fbc:	88 83       	st	Y, r24
    2fbe:	99 83       	std	Y+1, r25	; 0x01
    2fc0:	aa 83       	std	Y+2, r26	; 0x02
    2fc2:	bb 83       	std	Y+3, r27	; 0x03
    2fc4:	0d c0       	rjmp	.+26     	; 0x2fe0 <__vector_11+0x256>
    else { sys_position[X_AXIS]++; }
    2fc6:	cc e9       	ldi	r28, 0x9C	; 156
    2fc8:	d5 e0       	ldi	r29, 0x05	; 5
    2fca:	88 81       	ld	r24, Y
    2fcc:	99 81       	ldd	r25, Y+1	; 0x01
    2fce:	aa 81       	ldd	r26, Y+2	; 0x02
    2fd0:	bb 81       	ldd	r27, Y+3	; 0x03
    2fd2:	01 96       	adiw	r24, 0x01	; 1
    2fd4:	a1 1d       	adc	r26, r1
    2fd6:	b1 1d       	adc	r27, r1
    2fd8:	88 83       	st	Y, r24
    2fda:	99 83       	std	Y+1, r25	; 0x01
    2fdc:	aa 83       	std	Y+2, r26	; 0x02
    2fde:	bb 83       	std	Y+3, r27	; 0x03
  }
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_y += st.steps[Y_AXIS];
    2fe0:	c4 e9       	ldi	r28, 0x94	; 148
    2fe2:	d1 e0       	ldi	r29, 0x01	; 1
    2fe4:	4c 81       	ldd	r20, Y+4	; 0x04
    2fe6:	5d 81       	ldd	r21, Y+5	; 0x05
    2fe8:	6e 81       	ldd	r22, Y+6	; 0x06
    2fea:	7f 81       	ldd	r23, Y+7	; 0x07
    2fec:	8c 89       	ldd	r24, Y+20	; 0x14
    2fee:	9d 89       	ldd	r25, Y+21	; 0x15
    2ff0:	ae 89       	ldd	r26, Y+22	; 0x16
    2ff2:	bf 89       	ldd	r27, Y+23	; 0x17
    2ff4:	84 0f       	add	r24, r20
    2ff6:	95 1f       	adc	r25, r21
    2ff8:	a6 1f       	adc	r26, r22
    2ffa:	b7 1f       	adc	r27, r23
    2ffc:	8c 83       	std	Y+4, r24	; 0x04
    2ffe:	9d 83       	std	Y+5, r25	; 0x05
    3000:	ae 83       	std	Y+6, r26	; 0x06
    3002:	bf 83       	std	Y+7, r27	; 0x07
  #else
    st.counter_y += st.exec_block->steps[Y_AXIS];
  #endif
  if (st.counter_y > st.exec_block->step_event_count) {
    3004:	44 85       	ldd	r20, Z+12	; 0x0c
    3006:	55 85       	ldd	r21, Z+13	; 0x0d
    3008:	66 85       	ldd	r22, Z+14	; 0x0e
    300a:	77 85       	ldd	r23, Z+15	; 0x0f
    300c:	48 17       	cp	r20, r24
    300e:	59 07       	cpc	r21, r25
    3010:	6a 07       	cpc	r22, r26
    3012:	7b 07       	cpc	r23, r27
    3014:	68 f5       	brcc	.+90     	; 0x3070 <__vector_11+0x2e6>
    st.step_outbits |= (1<<Y_STEP_BIT);
    3016:	2e 85       	ldd	r18, Y+14	; 0x0e
    3018:	28 60       	ori	r18, 0x08	; 8
    301a:	2e 87       	std	Y+14, r18	; 0x0e
    #if defined(ENABLE_DUAL_AXIS) && (DUAL_AXIS_SELECT == Y_AXIS)
      st.step_outbits_dual = (1<<DUAL_STEP_BIT);
    #endif
    st.counter_y -= st.exec_block->step_event_count;
    301c:	44 85       	ldd	r20, Z+12	; 0x0c
    301e:	55 85       	ldd	r21, Z+13	; 0x0d
    3020:	66 85       	ldd	r22, Z+14	; 0x0e
    3022:	77 85       	ldd	r23, Z+15	; 0x0f
    3024:	84 1b       	sub	r24, r20
    3026:	95 0b       	sbc	r25, r21
    3028:	a6 0b       	sbc	r26, r22
    302a:	b7 0b       	sbc	r27, r23
    302c:	8c 83       	std	Y+4, r24	; 0x04
    302e:	9d 83       	std	Y+5, r25	; 0x05
    3030:	ae 83       	std	Y+6, r26	; 0x06
    3032:	bf 83       	std	Y+7, r27	; 0x07
    if (st.exec_block->direction_bits & (1<<Y_DIRECTION_BIT)) { sys_position[Y_AXIS]--; }
    3034:	80 89       	ldd	r24, Z+16	; 0x10
    3036:	86 ff       	sbrs	r24, 6
    3038:	0e c0       	rjmp	.+28     	; 0x3056 <__vector_11+0x2cc>
    303a:	cc e9       	ldi	r28, 0x9C	; 156
    303c:	d5 e0       	ldi	r29, 0x05	; 5
    303e:	8c 81       	ldd	r24, Y+4	; 0x04
    3040:	9d 81       	ldd	r25, Y+5	; 0x05
    3042:	ae 81       	ldd	r26, Y+6	; 0x06
    3044:	bf 81       	ldd	r27, Y+7	; 0x07
    3046:	01 97       	sbiw	r24, 0x01	; 1
    3048:	a1 09       	sbc	r26, r1
    304a:	b1 09       	sbc	r27, r1
    304c:	8c 83       	std	Y+4, r24	; 0x04
    304e:	9d 83       	std	Y+5, r25	; 0x05
    3050:	ae 83       	std	Y+6, r26	; 0x06
    3052:	bf 83       	std	Y+7, r27	; 0x07
    3054:	0d c0       	rjmp	.+26     	; 0x3070 <__vector_11+0x2e6>
    else { sys_position[Y_AXIS]++; }
    3056:	cc e9       	ldi	r28, 0x9C	; 156
    3058:	d5 e0       	ldi	r29, 0x05	; 5
    305a:	8c 81       	ldd	r24, Y+4	; 0x04
    305c:	9d 81       	ldd	r25, Y+5	; 0x05
    305e:	ae 81       	ldd	r26, Y+6	; 0x06
    3060:	bf 81       	ldd	r27, Y+7	; 0x07
    3062:	01 96       	adiw	r24, 0x01	; 1
    3064:	a1 1d       	adc	r26, r1
    3066:	b1 1d       	adc	r27, r1
    3068:	8c 83       	std	Y+4, r24	; 0x04
    306a:	9d 83       	std	Y+5, r25	; 0x05
    306c:	ae 83       	std	Y+6, r26	; 0x06
    306e:	bf 83       	std	Y+7, r27	; 0x07
  }
  #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
    st.counter_z += st.steps[Z_AXIS];
    3070:	c4 e9       	ldi	r28, 0x94	; 148
    3072:	d1 e0       	ldi	r29, 0x01	; 1
    3074:	48 85       	ldd	r20, Y+8	; 0x08
    3076:	59 85       	ldd	r21, Y+9	; 0x09
    3078:	6a 85       	ldd	r22, Y+10	; 0x0a
    307a:	7b 85       	ldd	r23, Y+11	; 0x0b
    307c:	88 8d       	ldd	r24, Y+24	; 0x18
    307e:	99 8d       	ldd	r25, Y+25	; 0x19
    3080:	aa 8d       	ldd	r26, Y+26	; 0x1a
    3082:	bb 8d       	ldd	r27, Y+27	; 0x1b
    3084:	84 0f       	add	r24, r20
    3086:	95 1f       	adc	r25, r21
    3088:	a6 1f       	adc	r26, r22
    308a:	b7 1f       	adc	r27, r23
    308c:	88 87       	std	Y+8, r24	; 0x08
    308e:	99 87       	std	Y+9, r25	; 0x09
    3090:	aa 87       	std	Y+10, r26	; 0x0a
    3092:	bb 87       	std	Y+11, r27	; 0x0b
  #else
    st.counter_z += st.exec_block->steps[Z_AXIS];
  #endif
  if (st.counter_z > st.exec_block->step_event_count) {
    3094:	44 85       	ldd	r20, Z+12	; 0x0c
    3096:	55 85       	ldd	r21, Z+13	; 0x0d
    3098:	66 85       	ldd	r22, Z+14	; 0x0e
    309a:	77 85       	ldd	r23, Z+15	; 0x0f
    309c:	48 17       	cp	r20, r24
    309e:	59 07       	cpc	r21, r25
    30a0:	6a 07       	cpc	r22, r26
    30a2:	7b 07       	cpc	r23, r27
    30a4:	68 f5       	brcc	.+90     	; 0x3100 <__vector_11+0x376>
    st.step_outbits |= (1<<Z_STEP_BIT);
    30a6:	2e 85       	ldd	r18, Y+14	; 0x0e
    30a8:	20 61       	ori	r18, 0x10	; 16
    30aa:	2e 87       	std	Y+14, r18	; 0x0e
    st.counter_z -= st.exec_block->step_event_count;
    30ac:	44 85       	ldd	r20, Z+12	; 0x0c
    30ae:	55 85       	ldd	r21, Z+13	; 0x0d
    30b0:	66 85       	ldd	r22, Z+14	; 0x0e
    30b2:	77 85       	ldd	r23, Z+15	; 0x0f
    30b4:	84 1b       	sub	r24, r20
    30b6:	95 0b       	sbc	r25, r21
    30b8:	a6 0b       	sbc	r26, r22
    30ba:	b7 0b       	sbc	r27, r23
    30bc:	88 87       	std	Y+8, r24	; 0x08
    30be:	99 87       	std	Y+9, r25	; 0x09
    30c0:	aa 87       	std	Y+10, r26	; 0x0a
    30c2:	bb 87       	std	Y+11, r27	; 0x0b
    if (st.exec_block->direction_bits & (1<<Z_DIRECTION_BIT)) { sys_position[Z_AXIS]--; }
    30c4:	80 89       	ldd	r24, Z+16	; 0x10
    30c6:	88 23       	and	r24, r24
    30c8:	74 f4       	brge	.+28     	; 0x30e6 <__vector_11+0x35c>
    30ca:	ec e9       	ldi	r30, 0x9C	; 156
    30cc:	f5 e0       	ldi	r31, 0x05	; 5
    30ce:	80 85       	ldd	r24, Z+8	; 0x08
    30d0:	91 85       	ldd	r25, Z+9	; 0x09
    30d2:	a2 85       	ldd	r26, Z+10	; 0x0a
    30d4:	b3 85       	ldd	r27, Z+11	; 0x0b
    30d6:	01 97       	sbiw	r24, 0x01	; 1
    30d8:	a1 09       	sbc	r26, r1
    30da:	b1 09       	sbc	r27, r1
    30dc:	80 87       	std	Z+8, r24	; 0x08
    30de:	91 87       	std	Z+9, r25	; 0x09
    30e0:	a2 87       	std	Z+10, r26	; 0x0a
    30e2:	b3 87       	std	Z+11, r27	; 0x0b
    30e4:	0d c0       	rjmp	.+26     	; 0x3100 <__vector_11+0x376>
    else { sys_position[Z_AXIS]++; }
    30e6:	ec e9       	ldi	r30, 0x9C	; 156
    30e8:	f5 e0       	ldi	r31, 0x05	; 5
    30ea:	80 85       	ldd	r24, Z+8	; 0x08
    30ec:	91 85       	ldd	r25, Z+9	; 0x09
    30ee:	a2 85       	ldd	r26, Z+10	; 0x0a
    30f0:	b3 85       	ldd	r27, Z+11	; 0x0b
    30f2:	01 96       	adiw	r24, 0x01	; 1
    30f4:	a1 1d       	adc	r26, r1
    30f6:	b1 1d       	adc	r27, r1
    30f8:	80 87       	std	Z+8, r24	; 0x08
    30fa:	91 87       	std	Z+9, r25	; 0x09
    30fc:	a2 87       	std	Z+10, r26	; 0x0a
    30fe:	b3 87       	std	Z+11, r27	; 0x0b
  }

  // During a homing cycle, lock out and prevent desired axes from moving.
  if (sys.state == STATE_HOMING) { 
    3100:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    3104:	84 30       	cpi	r24, 0x04	; 4
    3106:	39 f4       	brne	.+14     	; 0x3116 <__vector_11+0x38c>
    st.step_outbits &= sys.homing_axis_lock;
    3108:	e4 e9       	ldi	r30, 0x94	; 148
    310a:	f1 e0       	ldi	r31, 0x01	; 1
    310c:	96 85       	ldd	r25, Z+14	; 0x0e
    310e:	80 91 82 05 	lds	r24, 0x0582	; 0x800582 <sys+0x6>
    3112:	89 23       	and	r24, r25
    3114:	86 87       	std	Z+14, r24	; 0x0e
    #ifdef ENABLE_DUAL_AXIS
      st.step_outbits_dual &= sys.homing_axis_lock_dual;
    #endif
  }

  st.step_count--; // Decrement step events count
    3116:	e4 e9       	ldi	r30, 0x94	; 148
    3118:	f1 e0       	ldi	r31, 0x01	; 1
    311a:	84 8d       	ldd	r24, Z+28	; 0x1c
    311c:	95 8d       	ldd	r25, Z+29	; 0x1d
    311e:	01 97       	sbiw	r24, 0x01	; 1
    3120:	95 8f       	std	Z+29, r25	; 0x1d
    3122:	84 8f       	std	Z+28, r24	; 0x1c
  if (st.step_count == 0) {
    3124:	89 2b       	or	r24, r25
    3126:	69 f4       	brne	.+26     	; 0x3142 <__vector_11+0x3b8>
    // Segment is complete. Discard current segment and advance segment indexing.
    st.exec_segment = NULL;
    3128:	10 92 b6 01 	sts	0x01B6, r1	; 0x8001b6 <st+0x22>
    312c:	10 92 b5 01 	sts	0x01B5, r1	; 0x8001b5 <st+0x21>
    if ( ++segment_buffer_tail == SEGMENT_BUFFER_SIZE) { segment_buffer_tail = 0; }
    3130:	80 91 93 01 	lds	r24, 0x0193	; 0x800193 <segment_buffer_tail>
    3134:	8f 5f       	subi	r24, 0xFF	; 255
    3136:	80 93 93 01 	sts	0x0193, r24	; 0x800193 <segment_buffer_tail>
    313a:	86 30       	cpi	r24, 0x06	; 6
    313c:	11 f4       	brne	.+4      	; 0x3142 <__vector_11+0x3b8>
    313e:	10 92 93 01 	sts	0x0193, r1	; 0x800193 <segment_buffer_tail>
  }

  st.step_outbits ^= step_port_invert_mask;  // Apply step port invert mask
    3142:	e4 e9       	ldi	r30, 0x94	; 148
    3144:	f1 e0       	ldi	r31, 0x01	; 1
    3146:	96 85       	ldd	r25, Z+14	; 0x0e
    3148:	80 91 90 01 	lds	r24, 0x0190	; 0x800190 <step_port_invert_mask>
    314c:	89 27       	eor	r24, r25
    314e:	86 87       	std	Z+14, r24	; 0x0e
  #ifdef ENABLE_DUAL_AXIS
    st.step_outbits_dual ^= step_port_invert_mask_dual;
  #endif
  busy = false;
    3150:	10 92 8e 01 	sts	0x018E, r1	; 0x80018e <busy>
}
    3154:	ff 91       	pop	r31
    3156:	ef 91       	pop	r30
    3158:	df 91       	pop	r29
    315a:	cf 91       	pop	r28
    315c:	bf 91       	pop	r27
    315e:	af 91       	pop	r26
    3160:	9f 91       	pop	r25
    3162:	8f 91       	pop	r24
    3164:	7f 91       	pop	r23
    3166:	6f 91       	pop	r22
    3168:	5f 91       	pop	r21
    316a:	4f 91       	pop	r20
    316c:	3f 91       	pop	r19
    316e:	2f 91       	pop	r18
    3170:	0f 90       	pop	r0
    3172:	0f be       	out	0x3f, r0	; 63
    3174:	0f 90       	pop	r0
    3176:	1f 90       	pop	r1
    3178:	18 95       	reti

0000317a <__vector_16>:
*/
// This interrupt is enabled by ISR_TIMER1_COMPAREA when it sets the motor port bits to execute
// a step. This ISR resets the motor port after a short period (settings.pulse_microseconds)
// completing one step cycle.
ISR(TIMER0_OVF_vect)
{
    317a:	1f 92       	push	r1
    317c:	0f 92       	push	r0
    317e:	0f b6       	in	r0, 0x3f	; 63
    3180:	0f 92       	push	r0
    3182:	11 24       	eor	r1, r1
    3184:	8f 93       	push	r24
    3186:	9f 93       	push	r25
  // Reset stepping pins (leave the direction pins)
  STEP_PORT = (STEP_PORT & ~STEP_MASK) | (step_port_invert_mask & STEP_MASK);
    3188:	8b b1       	in	r24, 0x0b	; 11
    318a:	90 91 90 01 	lds	r25, 0x0190	; 0x800190 <step_port_invert_mask>
    318e:	9c 71       	andi	r25, 0x1C	; 28
    3190:	83 7e       	andi	r24, 0xE3	; 227
    3192:	89 2b       	or	r24, r25
    3194:	8b b9       	out	0x0b, r24	; 11
  #ifdef ENABLE_DUAL_AXIS
    STEP_PORT_DUAL = (STEP_PORT_DUAL & ~STEP_MASK_DUAL) | (step_port_invert_mask_dual & STEP_MASK_DUAL);
  #endif
  TCCR0B = 0; // Disable Timer0 to prevent re-entering this interrupt when it's not needed.
    3196:	15 bc       	out	0x25, r1	; 37
}
    3198:	9f 91       	pop	r25
    319a:	8f 91       	pop	r24
    319c:	0f 90       	pop	r0
    319e:	0f be       	out	0x3f, r0	; 63
    31a0:	0f 90       	pop	r0
    31a2:	1f 90       	pop	r1
    31a4:	18 95       	reti

000031a6 <st_generate_step_dir_invert_masks>:
#endif


// Generates the step and direction port invert masks used in the Stepper Interrupt Driver.
void st_generate_step_dir_invert_masks()
{
    31a6:	ef 92       	push	r14
    31a8:	ff 92       	push	r15
    31aa:	0f 93       	push	r16
    31ac:	1f 93       	push	r17
    31ae:	cf 93       	push	r28
    31b0:	df 93       	push	r29
  uint8_t idx;
  step_port_invert_mask = 0;
    31b2:	10 92 90 01 	sts	0x0190, r1	; 0x800190 <step_port_invert_mask>
  dir_port_invert_mask = 0;
    31b6:	10 92 8f 01 	sts	0x018F, r1	; 0x80018f <dir_port_invert_mask>
    31ba:	c0 e0       	ldi	r28, 0x00	; 0
    31bc:	d0 e0       	ldi	r29, 0x00	; 0
  for (idx=0; idx<N_AXIS; idx++) {
    if (bit_istrue(settings.step_invert_mask,bit(idx))) { step_port_invert_mask |= get_step_pin_mask(idx); }
    31be:	0e e0       	ldi	r16, 0x0E	; 14
    31c0:	17 e0       	ldi	r17, 0x07	; 7
    31c2:	ec 2e       	mov	r14, r28
    31c4:	fc 2e       	mov	r15, r28
    31c6:	f8 01       	movw	r30, r16
    31c8:	81 a9       	ldd	r24, Z+49	; 0x31
    31ca:	90 e0       	ldi	r25, 0x00	; 0
    31cc:	0c 2e       	mov	r0, r28
    31ce:	02 c0       	rjmp	.+4      	; 0x31d4 <st_generate_step_dir_invert_masks+0x2e>
    31d0:	95 95       	asr	r25
    31d2:	87 95       	ror	r24
    31d4:	0a 94       	dec	r0
    31d6:	e2 f7       	brpl	.-8      	; 0x31d0 <st_generate_step_dir_invert_masks+0x2a>
    31d8:	80 ff       	sbrs	r24, 0
    31da:	08 c0       	rjmp	.+16     	; 0x31ec <st_generate_step_dir_invert_masks+0x46>
    31dc:	8c 2f       	mov	r24, r28
    31de:	0e 94 92 23 	call	0x4724	; 0x4724 <get_step_pin_mask>
    31e2:	90 91 90 01 	lds	r25, 0x0190	; 0x800190 <step_port_invert_mask>
    31e6:	89 2b       	or	r24, r25
    31e8:	80 93 90 01 	sts	0x0190, r24	; 0x800190 <step_port_invert_mask>
    if (bit_istrue(settings.dir_invert_mask,bit(idx))) { dir_port_invert_mask |= get_direction_pin_mask(idx); }
    31ec:	f8 01       	movw	r30, r16
    31ee:	82 a9       	ldd	r24, Z+50	; 0x32
    31f0:	90 e0       	ldi	r25, 0x00	; 0
    31f2:	02 c0       	rjmp	.+4      	; 0x31f8 <st_generate_step_dir_invert_masks+0x52>
    31f4:	95 95       	asr	r25
    31f6:	87 95       	ror	r24
    31f8:	fa 94       	dec	r15
    31fa:	e2 f7       	brpl	.-8      	; 0x31f4 <st_generate_step_dir_invert_masks+0x4e>
    31fc:	80 ff       	sbrs	r24, 0
    31fe:	08 c0       	rjmp	.+16     	; 0x3210 <st_generate_step_dir_invert_masks+0x6a>
    3200:	8e 2d       	mov	r24, r14
    3202:	0e 94 9c 23 	call	0x4738	; 0x4738 <get_direction_pin_mask>
    3206:	90 91 8f 01 	lds	r25, 0x018F	; 0x80018f <dir_port_invert_mask>
    320a:	89 2b       	or	r24, r25
    320c:	80 93 8f 01 	sts	0x018F, r24	; 0x80018f <dir_port_invert_mask>
    3210:	21 96       	adiw	r28, 0x01	; 1
void st_generate_step_dir_invert_masks()
{
  uint8_t idx;
  step_port_invert_mask = 0;
  dir_port_invert_mask = 0;
  for (idx=0; idx<N_AXIS; idx++) {
    3212:	c3 30       	cpi	r28, 0x03	; 3
    3214:	d1 05       	cpc	r29, r1
    3216:	a9 f6       	brne	.-86     	; 0x31c2 <st_generate_step_dir_invert_masks+0x1c>
    dir_port_invert_mask_dual = 0;
    // NOTE: Dual axis invert uses the N_AXIS bit to set step and direction invert pins.    
    if (bit_istrue(settings.step_invert_mask,bit(N_AXIS))) { step_port_invert_mask_dual = (1<<DUAL_STEP_BIT); }
    if (bit_istrue(settings.dir_invert_mask,bit(N_AXIS))) { dir_port_invert_mask_dual = (1<<DUAL_DIRECTION_BIT); }
  #endif
}
    3218:	df 91       	pop	r29
    321a:	cf 91       	pop	r28
    321c:	1f 91       	pop	r17
    321e:	0f 91       	pop	r16
    3220:	ff 90       	pop	r15
    3222:	ef 90       	pop	r14
    3224:	08 95       	ret

00003226 <st_reset>:


// Reset and clear stepper subsystem variables
void st_reset()
{
    3226:	cf 93       	push	r28
    3228:	df 93       	push	r29
  // Initialize stepper driver idle state.
  st_go_idle();
    322a:	0e 94 97 16 	call	0x2d2e	; 0x2d2e <st_go_idle>

  // Initialize stepper algorithm variables.
  memset(&prep, 0, sizeof(st_prep_t));
    322e:	80 e3       	ldi	r24, 0x30	; 48
    3230:	ea e5       	ldi	r30, 0x5A	; 90
    3232:	f1 e0       	ldi	r31, 0x01	; 1
    3234:	df 01       	movw	r26, r30
    3236:	1d 92       	st	X+, r1
    3238:	8a 95       	dec	r24
    323a:	e9 f7       	brne	.-6      	; 0x3236 <st_reset+0x10>
  memset(&st, 0, sizeof(stepper_t));
    323c:	c4 e9       	ldi	r28, 0x94	; 148
    323e:	d1 e0       	ldi	r29, 0x01	; 1
    3240:	83 e2       	ldi	r24, 0x23	; 35
    3242:	fe 01       	movw	r30, r28
    3244:	11 92       	st	Z+, r1
    3246:	8a 95       	dec	r24
    3248:	e9 f7       	brne	.-6      	; 0x3244 <st_reset+0x1e>
  st.exec_segment = NULL;
  pl_block = NULL;  // Planner block pointer used by segment buffer
    324a:	10 92 8d 01 	sts	0x018D, r1	; 0x80018d <pl_block+0x1>
    324e:	10 92 8c 01 	sts	0x018C, r1	; 0x80018c <pl_block>
  segment_buffer_tail = 0;
    3252:	10 92 93 01 	sts	0x0193, r1	; 0x800193 <segment_buffer_tail>
  segment_buffer_head = 0; // empty = tail
    3256:	10 92 92 01 	sts	0x0192, r1	; 0x800192 <segment_buffer_head>
  segment_next_head = 1;
    325a:	81 e0       	ldi	r24, 0x01	; 1
    325c:	80 93 91 01 	sts	0x0191, r24	; 0x800191 <segment_next_head>
  busy = false;
    3260:	10 92 8e 01 	sts	0x018E, r1	; 0x80018e <busy>

  st_generate_step_dir_invert_masks();
    3264:	0e 94 d3 18 	call	0x31a6	; 0x31a6 <st_generate_step_dir_invert_masks>
  st.dir_outbits = dir_port_invert_mask; // Initialize direction bits to default.
    3268:	80 91 8f 01 	lds	r24, 0x018F	; 0x80018f <dir_port_invert_mask>
    326c:	8f 87       	std	Y+15, r24	; 0x0f

  // Initialize step and direction port pins.
  STEP_PORT = (STEP_PORT & ~STEP_MASK) | step_port_invert_mask;
    326e:	8b b1       	in	r24, 0x0b	; 11
    3270:	83 7e       	andi	r24, 0xE3	; 227
    3272:	90 91 90 01 	lds	r25, 0x0190	; 0x800190 <step_port_invert_mask>
    3276:	89 2b       	or	r24, r25
    3278:	8b b9       	out	0x0b, r24	; 11
  DIRECTION_PORT = (DIRECTION_PORT & ~DIRECTION_MASK) | dir_port_invert_mask;
    327a:	8b b1       	in	r24, 0x0b	; 11
    327c:	8f 71       	andi	r24, 0x1F	; 31
    327e:	90 91 8f 01 	lds	r25, 0x018F	; 0x80018f <dir_port_invert_mask>
    3282:	89 2b       	or	r24, r25
    3284:	8b b9       	out	0x0b, r24	; 11
  #ifdef ENABLE_DUAL_AXIS
    st.dir_outbits_dual = dir_port_invert_mask_dual;
    STEP_PORT_DUAL = (STEP_PORT_DUAL & ~STEP_MASK_DUAL) | step_port_invert_mask_dual;
    DIRECTION_PORT_DUAL = (DIRECTION_PORT_DUAL & ~DIRECTION_MASK_DUAL) | dir_port_invert_mask_dual;
  #endif
}
    3286:	df 91       	pop	r29
    3288:	cf 91       	pop	r28
    328a:	08 95       	ret

0000328c <stepper_init>:

// Initialize and start the stepper motor subsystem
void stepper_init()
{
  // Configure step and direction interface pins
  STEP_DDR |= STEP_MASK;
    328c:	8a b1       	in	r24, 0x0a	; 10
    328e:	8c 61       	ori	r24, 0x1C	; 28
    3290:	8a b9       	out	0x0a, r24	; 10
  STEPPERS_DISABLE_DDR |= 1<<STEPPERS_DISABLE_BIT;
    3292:	20 9a       	sbi	0x04, 0	; 4
  DIRECTION_DDR |= DIRECTION_MASK;
    3294:	8a b1       	in	r24, 0x0a	; 10
    3296:	80 6e       	ori	r24, 0xE0	; 224
    3298:	8a b9       	out	0x0a, r24	; 10
    STEP_DDR_DUAL |= STEP_MASK_DUAL;
    DIRECTION_DDR_DUAL |= DIRECTION_MASK_DUAL;
  #endif

  // Configure Timer 1: Stepper Driver Interrupt
  TCCR1B &= ~(1<<WGM13); // waveform generation = 0100 = CTC
    329a:	e1 e8       	ldi	r30, 0x81	; 129
    329c:	f0 e0       	ldi	r31, 0x00	; 0
    329e:	80 81       	ld	r24, Z
    32a0:	8f 7e       	andi	r24, 0xEF	; 239
    32a2:	80 83       	st	Z, r24
  TCCR1B |=  (1<<WGM12);
    32a4:	80 81       	ld	r24, Z
    32a6:	88 60       	ori	r24, 0x08	; 8
    32a8:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<WGM11) | (1<<WGM10));
    32aa:	e0 e8       	ldi	r30, 0x80	; 128
    32ac:	f0 e0       	ldi	r31, 0x00	; 0
    32ae:	80 81       	ld	r24, Z
    32b0:	8c 7f       	andi	r24, 0xFC	; 252
    32b2:	80 83       	st	Z, r24
  TCCR1A &= ~((1<<COM1A1) | (1<<COM1A0) | (1<<COM1B1) | (1<<COM1B0)); // Disconnect OC1 output
    32b4:	80 81       	ld	r24, Z
    32b6:	8f 70       	andi	r24, 0x0F	; 15
    32b8:	80 83       	st	Z, r24
  // TCCR1B = (TCCR1B & ~((1<<CS12) | (1<<CS11))) | (1<<CS10); // Set in st_go_idle().
  // TIMSK1 &= ~(1<<OCIE1A);  // Set in st_go_idle().

  // Configure Timer 0: Stepper Port Reset Interrupt
  TIMSK0 &= ~((1<<OCIE0B) | (1<<OCIE0A) | (1<<TOIE0)); // Disconnect OC0 outputs and OVF interrupt.
    32ba:	ee e6       	ldi	r30, 0x6E	; 110
    32bc:	f0 e0       	ldi	r31, 0x00	; 0
    32be:	80 81       	ld	r24, Z
    32c0:	88 7f       	andi	r24, 0xF8	; 248
    32c2:	80 83       	st	Z, r24
  TCCR0A = 0; // Normal operation
    32c4:	14 bc       	out	0x24, r1	; 36
  TCCR0B = 0; // Disable Timer0 until needed
    32c6:	15 bc       	out	0x25, r1	; 37
  TIMSK0 |= (1<<TOIE0); // Enable Timer0 overflow interrupt
    32c8:	80 81       	ld	r24, Z
    32ca:	81 60       	ori	r24, 0x01	; 1
    32cc:	80 83       	st	Z, r24
    32ce:	08 95       	ret

000032d0 <st_update_plan_block_parameters>:
}


// Called by planner_recalculate() when the executing block is updated by the new plan.
void st_update_plan_block_parameters()
{
    32d0:	cf 93       	push	r28
    32d2:	df 93       	push	r29
  if (pl_block != NULL) { // Ignore if at start of a new block.
    32d4:	c0 91 8c 01 	lds	r28, 0x018C	; 0x80018c <pl_block>
    32d8:	d0 91 8d 01 	lds	r29, 0x018D	; 0x80018d <pl_block+0x1>
    32dc:	20 97       	sbiw	r28, 0x00	; 0
    32de:	a9 f0       	breq	.+42     	; 0x330a <st_update_plan_block_parameters+0x3a>
    prep.recalculate_flag |= PREP_FLAG_RECALCULATE;
    32e0:	ea e5       	ldi	r30, 0x5A	; 90
    32e2:	f1 e0       	ldi	r31, 0x01	; 1
    32e4:	81 81       	ldd	r24, Z+1	; 0x01
    32e6:	81 60       	ori	r24, 0x01	; 1
    32e8:	81 83       	std	Z+1, r24	; 0x01
    pl_block->entry_speed_sqr = prep.current_speed*prep.current_speed; // Update entry speed.
    32ea:	67 89       	ldd	r22, Z+23	; 0x17
    32ec:	70 8d       	ldd	r23, Z+24	; 0x18
    32ee:	81 8d       	ldd	r24, Z+25	; 0x19
    32f0:	92 8d       	ldd	r25, Z+26	; 0x1a
    32f2:	9b 01       	movw	r18, r22
    32f4:	ac 01       	movw	r20, r24
    32f6:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    32fa:	6a 8b       	std	Y+18, r22	; 0x12
    32fc:	7b 8b       	std	Y+19, r23	; 0x13
    32fe:	8c 8b       	std	Y+20, r24	; 0x14
    3300:	9d 8b       	std	Y+21, r25	; 0x15
    pl_block = NULL; // Flag st_prep_segment() to load and check active velocity profile.
    3302:	10 92 8d 01 	sts	0x018D, r1	; 0x80018d <pl_block+0x1>
    3306:	10 92 8c 01 	sts	0x018C, r1	; 0x80018c <pl_block>
  }
}
    330a:	df 91       	pop	r29
    330c:	cf 91       	pop	r28
    330e:	08 95       	ret

00003310 <st_prep_buffer>:
   longer than the time it takes the stepper algorithm to empty it before refilling it.
   Currently, the segment buffer conservatively holds roughly up to 40-50 msec of steps.
   NOTE: Computation units are in steps, millimeters, and minutes.
*/
void st_prep_buffer()
{
    3310:	2f 92       	push	r2
    3312:	3f 92       	push	r3
    3314:	4f 92       	push	r4
    3316:	5f 92       	push	r5
    3318:	6f 92       	push	r6
    331a:	7f 92       	push	r7
    331c:	8f 92       	push	r8
    331e:	9f 92       	push	r9
    3320:	af 92       	push	r10
    3322:	bf 92       	push	r11
    3324:	cf 92       	push	r12
    3326:	df 92       	push	r13
    3328:	ef 92       	push	r14
    332a:	ff 92       	push	r15
    332c:	0f 93       	push	r16
    332e:	1f 93       	push	r17
    3330:	cf 93       	push	r28
    3332:	df 93       	push	r29
    3334:	cd b7       	in	r28, 0x3d	; 61
    3336:	de b7       	in	r29, 0x3e	; 62
    3338:	ea 97       	sbiw	r28, 0x3a	; 58
    333a:	0f b6       	in	r0, 0x3f	; 63
    333c:	f8 94       	cli
    333e:	de bf       	out	0x3e, r29	; 62
    3340:	0f be       	out	0x3f, r0	; 63
    3342:	cd bf       	out	0x3d, r28	; 61
  // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }
    3344:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <sys+0x4>
    3348:	80 ff       	sbrs	r24, 0
    334a:	02 c0       	rjmp	.+4      	; 0x3350 <st_prep_buffer+0x40>
    334c:	0c 94 cf 21 	jmp	0x439e	; 0x439e <st_prep_buffer+0x108e>
          mm_var = mm_remaining - prep.maximum_speed*time_var;
          if (mm_var < prep.decelerate_after) { // End of cruise.
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
    3350:	22 e0       	ldi	r18, 0x02	; 2
    3352:	2a af       	std	Y+58, r18	; 0x3a
    3354:	29 af       	std	Y+57, r18	; 0x39
    3356:	e5 c7       	rjmp	.+4042   	; 0x4322 <st_prep_buffer+0x1012>
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }

  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.

    // Determine if we need to load a new planner block or if the block needs to be recomputed.
    if (pl_block == NULL) {
    3358:	80 91 8c 01 	lds	r24, 0x018C	; 0x80018c <pl_block>
    335c:	90 91 8d 01 	lds	r25, 0x018D	; 0x80018d <pl_block+0x1>
    3360:	89 2b       	or	r24, r25
    3362:	09 f0       	breq	.+2      	; 0x3366 <st_prep_buffer+0x56>
    3364:	3a c3       	rjmp	.+1652   	; 0x39da <st_prep_buffer+0x6ca>

      // Query planner for a queued block
      if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) { pl_block = plan_get_system_motion_block(); }
    3366:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <sys+0x4>
    336a:	82 ff       	sbrs	r24, 2
    336c:	07 c0       	rjmp	.+14     	; 0x337c <st_prep_buffer+0x6c>
    336e:	0e 94 3e 25 	call	0x4a7c	; 0x4a7c <plan_get_system_motion_block>
    3372:	90 93 8d 01 	sts	0x018D, r25	; 0x80018d <pl_block+0x1>
    3376:	80 93 8c 01 	sts	0x018C, r24	; 0x80018c <pl_block>
    337a:	06 c0       	rjmp	.+12     	; 0x3388 <st_prep_buffer+0x78>
      else { pl_block = plan_get_current_block(); }
    337c:	0e 94 47 25 	call	0x4a8e	; 0x4a8e <plan_get_current_block>
    3380:	90 93 8d 01 	sts	0x018D, r25	; 0x80018d <pl_block+0x1>
    3384:	80 93 8c 01 	sts	0x018C, r24	; 0x80018c <pl_block>
      if (pl_block == NULL) { return; } // No planner blocks. Exit.
    3388:	00 91 8c 01 	lds	r16, 0x018C	; 0x80018c <pl_block>
    338c:	10 91 8d 01 	lds	r17, 0x018D	; 0x80018d <pl_block+0x1>
    3390:	01 15       	cp	r16, r1
    3392:	11 05       	cpc	r17, r1
    3394:	11 f4       	brne	.+4      	; 0x339a <st_prep_buffer+0x8a>
    3396:	0c 94 cf 21 	jmp	0x439e	; 0x439e <st_prep_buffer+0x108e>

      // Check if we need to only recompute the velocity profile or load a new block.
      if (prep.recalculate_flag & PREP_FLAG_RECALCULATE) {
    339a:	f0 90 5b 01 	lds	r15, 0x015B	; 0x80015b <prep+0x1>
    339e:	8f 2d       	mov	r24, r15
    33a0:	81 70       	andi	r24, 0x01	; 1
    33a2:	f0 fe       	sbrs	r15, 0
    33a4:	03 c0       	rjmp	.+6      	; 0x33ac <st_prep_buffer+0x9c>

        #ifdef PARKING_ENABLE
          if (prep.recalculate_flag & PREP_FLAG_PARKING) { prep.recalculate_flag &= ~(PREP_FLAG_RECALCULATE); }
          else { prep.recalculate_flag = false; }
        #else
          prep.recalculate_flag = false;
    33a6:	10 92 5b 01 	sts	0x015B, r1	; 0x80015b <prep+0x1>
    33aa:	f6 c0       	rjmp	.+492    	; 0x3598 <st_prep_buffer+0x288>


// Increments the step segment buffer block data ring buffer.
static uint8_t st_next_block_index(uint8_t block_index)
{
  block_index++;
    33ac:	aa e5       	ldi	r26, 0x5A	; 90
    33ae:	b1 e0       	ldi	r27, 0x01	; 1
    33b0:	9c 91       	ld	r25, X
    33b2:	9f 5f       	subi	r25, 0xFF	; 255
  if ( block_index == (SEGMENT_BUFFER_SIZE-1) ) { return(0); }
    33b4:	95 30       	cpi	r25, 0x05	; 5
    33b6:	09 f0       	breq	.+2      	; 0x33ba <st_prep_buffer+0xaa>
  return(block_index);
    33b8:	89 2f       	mov	r24, r25
        #endif

      } else {

        // Load the Bresenham stepping data for the block.
        prep.st_block_index = st_next_block_index(prep.st_block_index);
    33ba:	ea e5       	ldi	r30, 0x5A	; 90
    33bc:	f1 e0       	ldi	r31, 0x01	; 1
    33be:	80 83       	st	Z, r24

        // Prepare and copy Bresenham algorithm segment data from the new planner block, so that
        // when the segment buffer completes the planner block, it may be discarded when the
        // segment buffer finishes the prepped block, but the stepper ISR is still executing it.
        st_prep_block = &st_block_buffer[prep.st_block_index];
    33c0:	90 e0       	ldi	r25, 0x00	; 0
    33c2:	fc 01       	movw	r30, r24
    33c4:	ee 0f       	add	r30, r30
    33c6:	ff 1f       	adc	r31, r31
    33c8:	9f 01       	movw	r18, r30
    33ca:	22 0f       	add	r18, r18
    33cc:	33 1f       	adc	r19, r19
    33ce:	22 0f       	add	r18, r18
    33d0:	33 1f       	adc	r19, r19
    33d2:	22 0f       	add	r18, r18
    33d4:	33 1f       	adc	r19, r19
    33d6:	e2 0f       	add	r30, r18
    33d8:	f3 1f       	adc	r31, r19
    33da:	ef 51       	subi	r30, 0x1F	; 31
    33dc:	fe 4f       	sbci	r31, 0xFE	; 254
    33de:	f0 93 8b 01 	sts	0x018B, r31	; 0x80018b <st_prep_block+0x1>
    33e2:	e0 93 8a 01 	sts	0x018A, r30	; 0x80018a <st_prep_block>
        st_prep_block->direction_bits = pl_block->direction_bits;
    33e6:	d8 01       	movw	r26, r16
    33e8:	50 96       	adiw	r26, 0x10	; 16
    33ea:	2c 91       	ld	r18, X
    33ec:	50 97       	sbiw	r26, 0x10	; 16
    33ee:	20 8b       	std	Z+16, r18	; 0x10
    33f0:	98 01       	movw	r18, r16
    33f2:	24 5f       	subi	r18, 0xF4	; 244
    33f4:	3f 4f       	sbci	r19, 0xFF	; 255
          st_prep_block->step_event_count = (pl_block->step_event_count << 1);
        #else
          // With AMASS enabled, simply bit-shift multiply all Bresenham data by the max AMASS
          // level, such that we never divide beyond the original data anywhere in the algorithm.
          // If the original data is divided, we can lose a step from integer roundoff.
          for (idx=0; idx<N_AXIS; idx++) { st_prep_block->steps[idx] = pl_block->steps[idx] << MAX_AMASS_LEVEL; }
    33f6:	4d 91       	ld	r20, X+
    33f8:	5d 91       	ld	r21, X+
    33fa:	6d 91       	ld	r22, X+
    33fc:	7d 91       	ld	r23, X+
    33fe:	44 0f       	add	r20, r20
    3400:	55 1f       	adc	r21, r21
    3402:	66 1f       	adc	r22, r22
    3404:	77 1f       	adc	r23, r23
    3406:	44 0f       	add	r20, r20
    3408:	55 1f       	adc	r21, r21
    340a:	66 1f       	adc	r22, r22
    340c:	77 1f       	adc	r23, r23
    340e:	44 0f       	add	r20, r20
    3410:	55 1f       	adc	r21, r21
    3412:	66 1f       	adc	r22, r22
    3414:	77 1f       	adc	r23, r23
    3416:	41 93       	st	Z+, r20
    3418:	51 93       	st	Z+, r21
    341a:	61 93       	st	Z+, r22
    341c:	71 93       	st	Z+, r23
    341e:	a2 17       	cp	r26, r18
    3420:	b3 07       	cpc	r27, r19
    3422:	49 f7       	brne	.-46     	; 0x33f6 <st_prep_buffer+0xe6>
          st_prep_block->step_event_count = pl_block->step_event_count << MAX_AMASS_LEVEL;
    3424:	88 0f       	add	r24, r24
    3426:	99 1f       	adc	r25, r25
    3428:	fc 01       	movw	r30, r24
    342a:	ee 0f       	add	r30, r30
    342c:	ff 1f       	adc	r31, r31
    342e:	ee 0f       	add	r30, r30
    3430:	ff 1f       	adc	r31, r31
    3432:	ee 0f       	add	r30, r30
    3434:	ff 1f       	adc	r31, r31
    3436:	8e 0f       	add	r24, r30
    3438:	9f 1f       	adc	r25, r31
    343a:	9c 01       	movw	r18, r24
    343c:	2f 51       	subi	r18, 0x1F	; 31
    343e:	3e 4f       	sbci	r19, 0xFE	; 254
    3440:	f8 01       	movw	r30, r16
    3442:	84 85       	ldd	r24, Z+12	; 0x0c
    3444:	95 85       	ldd	r25, Z+13	; 0x0d
    3446:	a6 85       	ldd	r26, Z+14	; 0x0e
    3448:	b7 85       	ldd	r27, Z+15	; 0x0f
    344a:	88 0f       	add	r24, r24
    344c:	99 1f       	adc	r25, r25
    344e:	aa 1f       	adc	r26, r26
    3450:	bb 1f       	adc	r27, r27
    3452:	88 0f       	add	r24, r24
    3454:	99 1f       	adc	r25, r25
    3456:	aa 1f       	adc	r26, r26
    3458:	bb 1f       	adc	r27, r27
    345a:	88 0f       	add	r24, r24
    345c:	99 1f       	adc	r25, r25
    345e:	aa 1f       	adc	r26, r26
    3460:	bb 1f       	adc	r27, r27
    3462:	f9 01       	movw	r30, r18
    3464:	84 87       	std	Z+12, r24	; 0x0c
    3466:	95 87       	std	Z+13, r25	; 0x0d
    3468:	a6 87       	std	Z+14, r26	; 0x0e
    346a:	b7 87       	std	Z+15, r27	; 0x0f
        #endif

        // Initialize segment buffer data for generating the segments.
        prep.steps_remaining = (float)pl_block->step_event_count;
    346c:	d8 01       	movw	r26, r16
    346e:	1c 96       	adiw	r26, 0x0c	; 12
    3470:	6d 91       	ld	r22, X+
    3472:	7d 91       	ld	r23, X+
    3474:	8d 91       	ld	r24, X+
    3476:	9c 91       	ld	r25, X
    3478:	1f 97       	sbiw	r26, 0x0f	; 15
    347a:	0e 94 16 30 	call	0x602c	; 0x602c <__floatunsisf>
    347e:	60 93 60 01 	sts	0x0160, r22	; 0x800160 <prep+0x6>
    3482:	70 93 61 01 	sts	0x0161, r23	; 0x800161 <prep+0x7>
    3486:	80 93 62 01 	sts	0x0162, r24	; 0x800162 <prep+0x8>
    348a:	90 93 63 01 	sts	0x0163, r25	; 0x800163 <prep+0x9>
        prep.step_per_mm = prep.steps_remaining/pl_block->millimeters;
    348e:	f8 01       	movw	r30, r16
    3490:	26 8d       	ldd	r18, Z+30	; 0x1e
    3492:	37 8d       	ldd	r19, Z+31	; 0x1f
    3494:	40 a1       	ldd	r20, Z+32	; 0x20
    3496:	51 a1       	ldd	r21, Z+33	; 0x21
    3498:	0e 94 6e 2f 	call	0x5edc	; 0x5edc <__divsf3>
    349c:	9b 01       	movw	r18, r22
    349e:	ac 01       	movw	r20, r24
    34a0:	60 93 64 01 	sts	0x0164, r22	; 0x800164 <prep+0xa>
    34a4:	70 93 65 01 	sts	0x0165, r23	; 0x800165 <prep+0xb>
    34a8:	80 93 66 01 	sts	0x0166, r24	; 0x800166 <prep+0xc>
    34ac:	90 93 67 01 	sts	0x0167, r25	; 0x800167 <prep+0xd>
        prep.req_mm_increment = REQ_MM_INCREMENT_SCALAR/prep.step_per_mm;
    34b0:	60 e0       	ldi	r22, 0x00	; 0
    34b2:	70 e0       	ldi	r23, 0x00	; 0
    34b4:	80 ea       	ldi	r24, 0xA0	; 160
    34b6:	9f e3       	ldi	r25, 0x3F	; 63
    34b8:	0e 94 6e 2f 	call	0x5edc	; 0x5edc <__divsf3>
    34bc:	60 93 68 01 	sts	0x0168, r22	; 0x800168 <prep+0xe>
    34c0:	70 93 69 01 	sts	0x0169, r23	; 0x800169 <prep+0xf>
    34c4:	80 93 6a 01 	sts	0x016A, r24	; 0x80016a <prep+0x10>
    34c8:	90 93 6b 01 	sts	0x016B, r25	; 0x80016b <prep+0x11>
        prep.dt_remainder = 0.0; // Reset for new segment block
    34cc:	10 92 5c 01 	sts	0x015C, r1	; 0x80015c <prep+0x2>
    34d0:	10 92 5d 01 	sts	0x015D, r1	; 0x80015d <prep+0x3>
    34d4:	10 92 5e 01 	sts	0x015E, r1	; 0x80015e <prep+0x4>
    34d8:	10 92 5f 01 	sts	0x015F, r1	; 0x80015f <prep+0x5>

        if ((sys.step_control & STEP_CONTROL_EXECUTE_HOLD) || (prep.recalculate_flag & PREP_FLAG_DECEL_OVERRIDE)) {
    34dc:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <sys+0x4>
    34e0:	81 fd       	sbrc	r24, 1
    34e2:	02 c0       	rjmp	.+4      	; 0x34e8 <st_prep_buffer+0x1d8>
    34e4:	f3 fe       	sbrs	r15, 3
    34e6:	20 c0       	rjmp	.+64     	; 0x3528 <st_prep_buffer+0x218>
          // New block loaded mid-hold. Override planner block entry speed to enforce deceleration.
          prep.current_speed = prep.exit_speed;
    34e8:	60 91 79 01 	lds	r22, 0x0179	; 0x800179 <prep+0x1f>
    34ec:	70 91 7a 01 	lds	r23, 0x017A	; 0x80017a <prep+0x20>
    34f0:	80 91 7b 01 	lds	r24, 0x017B	; 0x80017b <prep+0x21>
    34f4:	90 91 7c 01 	lds	r25, 0x017C	; 0x80017c <prep+0x22>
    34f8:	60 93 71 01 	sts	0x0171, r22	; 0x800171 <prep+0x17>
    34fc:	70 93 72 01 	sts	0x0172, r23	; 0x800172 <prep+0x18>
    3500:	80 93 73 01 	sts	0x0173, r24	; 0x800173 <prep+0x19>
    3504:	90 93 74 01 	sts	0x0174, r25	; 0x800174 <prep+0x1a>
          pl_block->entry_speed_sqr = prep.exit_speed*prep.exit_speed;
    3508:	9b 01       	movw	r18, r22
    350a:	ac 01       	movw	r20, r24
    350c:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    3510:	d8 01       	movw	r26, r16
    3512:	52 96       	adiw	r26, 0x12	; 18
    3514:	6d 93       	st	X+, r22
    3516:	7d 93       	st	X+, r23
    3518:	8d 93       	st	X+, r24
    351a:	9c 93       	st	X, r25
    351c:	55 97       	sbiw	r26, 0x15	; 21
          prep.recalculate_flag &= ~(PREP_FLAG_DECEL_OVERRIDE);
    351e:	8f 2d       	mov	r24, r15
    3520:	87 7f       	andi	r24, 0xF7	; 247
    3522:	80 93 5b 01 	sts	0x015B, r24	; 0x80015b <prep+0x1>
    3526:	0f c0       	rjmp	.+30     	; 0x3546 <st_prep_buffer+0x236>
        } else {
          prep.current_speed = sqrt(pl_block->entry_speed_sqr);
    3528:	f8 01       	movw	r30, r16
    352a:	62 89       	ldd	r22, Z+18	; 0x12
    352c:	73 89       	ldd	r23, Z+19	; 0x13
    352e:	84 89       	ldd	r24, Z+20	; 0x14
    3530:	95 89       	ldd	r25, Z+21	; 0x15
    3532:	0e 94 65 32 	call	0x64ca	; 0x64ca <sqrt>
    3536:	60 93 71 01 	sts	0x0171, r22	; 0x800171 <prep+0x17>
    353a:	70 93 72 01 	sts	0x0172, r23	; 0x800172 <prep+0x18>
    353e:	80 93 73 01 	sts	0x0173, r24	; 0x800173 <prep+0x19>
    3542:	90 93 74 01 	sts	0x0174, r25	; 0x800174 <prep+0x1a>
        }
        
        #ifdef VARIABLE_SPINDLE
          // Setup laser mode variables. PWM rate adjusted motions will always complete a motion with the
          // spindle off. 
          st_prep_block->is_pwm_rate_adjusted = false;
    3546:	00 91 8a 01 	lds	r16, 0x018A	; 0x80018a <st_prep_block>
    354a:	10 91 8b 01 	lds	r17, 0x018B	; 0x80018b <st_prep_block+0x1>
    354e:	d8 01       	movw	r26, r16
    3550:	51 96       	adiw	r26, 0x11	; 17
    3552:	1c 92       	st	X, r1
          if (settings.flags & BITFLAG_LASER_MODE) {
    3554:	e3 e5       	ldi	r30, 0x53	; 83
    3556:	f7 e0       	ldi	r31, 0x07	; 7
    3558:	80 81       	ld	r24, Z
    355a:	81 ff       	sbrs	r24, 1
    355c:	1d c0       	rjmp	.+58     	; 0x3598 <st_prep_buffer+0x288>
            if (pl_block->condition & PL_COND_FLAG_SPINDLE_CCW) { 
    355e:	e0 91 8c 01 	lds	r30, 0x018C	; 0x80018c <pl_block>
    3562:	f0 91 8d 01 	lds	r31, 0x018D	; 0x80018d <pl_block+0x1>
    3566:	81 89       	ldd	r24, Z+17	; 0x11
    3568:	85 ff       	sbrs	r24, 5
    356a:	16 c0       	rjmp	.+44     	; 0x3598 <st_prep_buffer+0x288>
              // Pre-compute inverse programmed rate to speed up PWM updating per step segment.
              prep.inv_rate = 1.0/pl_block->programmed_rate;
    356c:	22 a5       	ldd	r18, Z+42	; 0x2a
    356e:	33 a5       	ldd	r19, Z+43	; 0x2b
    3570:	44 a5       	ldd	r20, Z+44	; 0x2c
    3572:	55 a5       	ldd	r21, Z+45	; 0x2d
    3574:	60 e0       	ldi	r22, 0x00	; 0
    3576:	70 e0       	ldi	r23, 0x00	; 0
    3578:	80 e8       	ldi	r24, 0x80	; 128
    357a:	9f e3       	ldi	r25, 0x3F	; 63
    357c:	0e 94 6e 2f 	call	0x5edc	; 0x5edc <__divsf3>
    3580:	60 93 85 01 	sts	0x0185, r22	; 0x800185 <prep+0x2b>
    3584:	70 93 86 01 	sts	0x0186, r23	; 0x800186 <prep+0x2c>
    3588:	80 93 87 01 	sts	0x0187, r24	; 0x800187 <prep+0x2d>
    358c:	90 93 88 01 	sts	0x0188, r25	; 0x800188 <prep+0x2e>
              st_prep_block->is_pwm_rate_adjusted = true; 
    3590:	e1 e0       	ldi	r30, 0x01	; 1
    3592:	d8 01       	movw	r26, r16
    3594:	51 96       	adiw	r26, 0x11	; 17
    3596:	ec 93       	st	X, r30
			 Compute the velocity profile of a new planner block based on its entry and exit
			 speeds, or recompute the profile of a partially-completed planner block if the
			 planner has updated it. For a commanded forced-deceleration, such as from a feed
			 hold, override the planner velocities and decelerate to the target exit speed.
			*/
			prep.mm_complete = 0.0; // Default velocity profile complete at 0.0mm from end of block.
    3598:	10 92 6d 01 	sts	0x016D, r1	; 0x80016d <prep+0x13>
    359c:	10 92 6e 01 	sts	0x016E, r1	; 0x80016e <prep+0x14>
    35a0:	10 92 6f 01 	sts	0x016F, r1	; 0x80016f <prep+0x15>
    35a4:	10 92 70 01 	sts	0x0170, r1	; 0x800170 <prep+0x16>
			float inv_2_accel = 0.5/pl_block->acceleration;
    35a8:	00 91 8c 01 	lds	r16, 0x018C	; 0x80018c <pl_block>
    35ac:	10 91 8d 01 	lds	r17, 0x018D	; 0x80018d <pl_block+0x1>
    35b0:	d8 01       	movw	r26, r16
    35b2:	5a 96       	adiw	r26, 0x1a	; 26
    35b4:	8d 90       	ld	r8, X+
    35b6:	9d 90       	ld	r9, X+
    35b8:	ad 90       	ld	r10, X+
    35ba:	bc 90       	ld	r11, X
    35bc:	5d 97       	sbiw	r26, 0x1d	; 29
    35be:	a5 01       	movw	r20, r10
    35c0:	94 01       	movw	r18, r8
    35c2:	60 e0       	ldi	r22, 0x00	; 0
    35c4:	70 e0       	ldi	r23, 0x00	; 0
    35c6:	80 e0       	ldi	r24, 0x00	; 0
    35c8:	9f e3       	ldi	r25, 0x3F	; 63
    35ca:	0e 94 6e 2f 	call	0x5edc	; 0x5edc <__divsf3>
    35ce:	69 83       	std	Y+1, r22	; 0x01
    35d0:	7a 83       	std	Y+2, r23	; 0x02
    35d2:	8b 83       	std	Y+3, r24	; 0x03
    35d4:	9c 83       	std	Y+4, r25	; 0x04
			if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) { // [Forced Deceleration to Zero Velocity]
    35d6:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <sys+0x4>
    35da:	81 ff       	sbrs	r24, 1
    35dc:	55 c0       	rjmp	.+170    	; 0x3688 <st_prep_buffer+0x378>
				// Compute velocity profile parameters for a feed hold in-progress. This profile overrides
				// the planner block profile, enforcing a deceleration to zero speed.
				prep.ramp_type = RAMP_DECEL;
    35de:	b2 e0       	ldi	r27, 0x02	; 2
    35e0:	b0 93 6c 01 	sts	0x016C, r27	; 0x80016c <prep+0x12>
				// Compute decelerate distance relative to end of block.
				float decel_dist = pl_block->millimeters - inv_2_accel*pl_block->entry_speed_sqr;
    35e4:	f8 01       	movw	r30, r16
    35e6:	46 8c       	ldd	r4, Z+30	; 0x1e
    35e8:	57 8c       	ldd	r5, Z+31	; 0x1f
    35ea:	60 a0       	ldd	r6, Z+32	; 0x20
    35ec:	71 a0       	ldd	r7, Z+33	; 0x21
    35ee:	c2 88       	ldd	r12, Z+18	; 0x12
    35f0:	d3 88       	ldd	r13, Z+19	; 0x13
    35f2:	e4 88       	ldd	r14, Z+20	; 0x14
    35f4:	f5 88       	ldd	r15, Z+21	; 0x15
    35f6:	a7 01       	movw	r20, r14
    35f8:	96 01       	movw	r18, r12
    35fa:	69 81       	ldd	r22, Y+1	; 0x01
    35fc:	7a 81       	ldd	r23, Y+2	; 0x02
    35fe:	8b 81       	ldd	r24, Y+3	; 0x03
    3600:	9c 81       	ldd	r25, Y+4	; 0x04
    3602:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    3606:	9b 01       	movw	r18, r22
    3608:	ac 01       	movw	r20, r24
    360a:	c3 01       	movw	r24, r6
    360c:	b2 01       	movw	r22, r4
    360e:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    3612:	69 83       	std	Y+1, r22	; 0x01
    3614:	7a 83       	std	Y+2, r23	; 0x02
    3616:	8b 83       	std	Y+3, r24	; 0x03
    3618:	9c 83       	std	Y+4, r25	; 0x04
				if (decel_dist < 0.0) {
    361a:	20 e0       	ldi	r18, 0x00	; 0
    361c:	30 e0       	ldi	r19, 0x00	; 0
    361e:	a9 01       	movw	r20, r18
    3620:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    3624:	88 23       	and	r24, r24
    3626:	dc f4       	brge	.+54     	; 0x365e <st_prep_buffer+0x34e>
					// Deceleration through entire planner block. End of feed hold is not in this block.
					prep.exit_speed = sqrt(pl_block->entry_speed_sqr-2*pl_block->acceleration*pl_block->millimeters);
    3628:	a5 01       	movw	r20, r10
    362a:	94 01       	movw	r18, r8
    362c:	c5 01       	movw	r24, r10
    362e:	b4 01       	movw	r22, r8
    3630:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    3634:	a3 01       	movw	r20, r6
    3636:	92 01       	movw	r18, r4
    3638:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    363c:	9b 01       	movw	r18, r22
    363e:	ac 01       	movw	r20, r24
    3640:	c7 01       	movw	r24, r14
    3642:	b6 01       	movw	r22, r12
    3644:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    3648:	0e 94 65 32 	call	0x64ca	; 0x64ca <sqrt>
    364c:	60 93 79 01 	sts	0x0179, r22	; 0x800179 <prep+0x1f>
    3650:	70 93 7a 01 	sts	0x017A, r23	; 0x80017a <prep+0x20>
    3654:	80 93 7b 01 	sts	0x017B, r24	; 0x80017b <prep+0x21>
    3658:	90 93 7c 01 	sts	0x017C, r25	; 0x80017c <prep+0x22>
    365c:	b9 c1       	rjmp	.+882    	; 0x39d0 <st_prep_buffer+0x6c0>
				} else {
					prep.mm_complete = decel_dist; // End of feed hold.
    365e:	29 81       	ldd	r18, Y+1	; 0x01
    3660:	3a 81       	ldd	r19, Y+2	; 0x02
    3662:	4b 81       	ldd	r20, Y+3	; 0x03
    3664:	5c 81       	ldd	r21, Y+4	; 0x04
    3666:	20 93 6d 01 	sts	0x016D, r18	; 0x80016d <prep+0x13>
    366a:	30 93 6e 01 	sts	0x016E, r19	; 0x80016e <prep+0x14>
    366e:	40 93 6f 01 	sts	0x016F, r20	; 0x80016f <prep+0x15>
    3672:	50 93 70 01 	sts	0x0170, r21	; 0x800170 <prep+0x16>
					prep.exit_speed = 0.0;
    3676:	10 92 79 01 	sts	0x0179, r1	; 0x800179 <prep+0x1f>
    367a:	10 92 7a 01 	sts	0x017A, r1	; 0x80017a <prep+0x20>
    367e:	10 92 7b 01 	sts	0x017B, r1	; 0x80017b <prep+0x21>
    3682:	10 92 7c 01 	sts	0x017C, r1	; 0x80017c <prep+0x22>
    3686:	a4 c1       	rjmp	.+840    	; 0x39d0 <st_prep_buffer+0x6c0>
				}
			} else { // [Normal Operation]
				// Compute or recompute velocity profile parameters of the prepped planner block.
				prep.ramp_type = RAMP_ACCEL; // Initialize as acceleration ramp.
    3688:	10 92 6c 01 	sts	0x016C, r1	; 0x80016c <prep+0x12>
				prep.accelerate_until = pl_block->millimeters;
    368c:	d8 01       	movw	r26, r16
    368e:	5e 96       	adiw	r26, 0x1e	; 30
    3690:	4d 91       	ld	r20, X+
    3692:	5d 91       	ld	r21, X+
    3694:	6d 91       	ld	r22, X+
    3696:	7c 91       	ld	r23, X
    3698:	91 97       	sbiw	r26, 0x21	; 33
    369a:	40 93 7d 01 	sts	0x017D, r20	; 0x80017d <prep+0x23>
    369e:	50 93 7e 01 	sts	0x017E, r21	; 0x80017e <prep+0x24>
    36a2:	60 93 7f 01 	sts	0x017F, r22	; 0x80017f <prep+0x25>
    36a6:	70 93 80 01 	sts	0x0180, r23	; 0x800180 <prep+0x26>

				float exit_speed_sqr;
				float nominal_speed;
        if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
    36aa:	82 ff       	sbrs	r24, 2
    36ac:	0d c0       	rjmp	.+26     	; 0x36c8 <st_prep_buffer+0x3b8>
          prep.exit_speed = exit_speed_sqr = 0.0; // Enforce stop at end of system motion.
    36ae:	10 92 79 01 	sts	0x0179, r1	; 0x800179 <prep+0x1f>
    36b2:	10 92 7a 01 	sts	0x017A, r1	; 0x80017a <prep+0x20>
    36b6:	10 92 7b 01 	sts	0x017B, r1	; 0x80017b <prep+0x21>
    36ba:	10 92 7c 01 	sts	0x017C, r1	; 0x80017c <prep+0x22>
    36be:	19 86       	std	Y+9, r1	; 0x09
    36c0:	1a 86       	std	Y+10, r1	; 0x0a
    36c2:	1b 86       	std	Y+11, r1	; 0x0b
    36c4:	1c 86       	std	Y+12, r1	; 0x0c
    36c6:	10 c0       	rjmp	.+32     	; 0x36e8 <st_prep_buffer+0x3d8>
        } else {
          exit_speed_sqr = plan_get_exec_block_exit_speed_sqr();
    36c8:	0e 94 57 25 	call	0x4aae	; 0x4aae <plan_get_exec_block_exit_speed_sqr>
    36cc:	69 87       	std	Y+9, r22	; 0x09
    36ce:	7a 87       	std	Y+10, r23	; 0x0a
    36d0:	8b 87       	std	Y+11, r24	; 0x0b
    36d2:	9c 87       	std	Y+12, r25	; 0x0c
          prep.exit_speed = sqrt(exit_speed_sqr);
    36d4:	0e 94 65 32 	call	0x64ca	; 0x64ca <sqrt>
    36d8:	60 93 79 01 	sts	0x0179, r22	; 0x800179 <prep+0x1f>
    36dc:	70 93 7a 01 	sts	0x017A, r23	; 0x80017a <prep+0x20>
    36e0:	80 93 7b 01 	sts	0x017B, r24	; 0x80017b <prep+0x21>
    36e4:	90 93 7c 01 	sts	0x017C, r25	; 0x80017c <prep+0x22>
        }

        nominal_speed = plan_compute_profile_nominal_speed(pl_block);
    36e8:	80 91 8c 01 	lds	r24, 0x018C	; 0x80018c <pl_block>
    36ec:	90 91 8d 01 	lds	r25, 0x018D	; 0x80018d <pl_block+0x1>
    36f0:	0e 94 78 25 	call	0x4af0	; 0x4af0 <plan_compute_profile_nominal_speed>
    36f4:	4b 01       	movw	r8, r22
    36f6:	5c 01       	movw	r10, r24
				float nominal_speed_sqr = nominal_speed*nominal_speed;
    36f8:	9b 01       	movw	r18, r22
    36fa:	ac 01       	movw	r20, r24
    36fc:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    3700:	6d 83       	std	Y+5, r22	; 0x05
    3702:	7e 83       	std	Y+6, r23	; 0x06
    3704:	8f 83       	std	Y+7, r24	; 0x07
    3706:	98 87       	std	Y+8, r25	; 0x08
				float intersect_distance =
								0.5*(pl_block->millimeters+inv_2_accel*(pl_block->entry_speed_sqr-exit_speed_sqr));
    3708:	00 91 8c 01 	lds	r16, 0x018C	; 0x80018c <pl_block>
    370c:	10 91 8d 01 	lds	r17, 0x018D	; 0x80018d <pl_block+0x1>
    3710:	f8 01       	movw	r30, r16
    3712:	c6 8c       	ldd	r12, Z+30	; 0x1e
    3714:	d7 8c       	ldd	r13, Z+31	; 0x1f
    3716:	e0 a0       	ldd	r14, Z+32	; 0x20
    3718:	f1 a0       	ldd	r15, Z+33	; 0x21
    371a:	42 88       	ldd	r4, Z+18	; 0x12
    371c:	53 88       	ldd	r5, Z+19	; 0x13
    371e:	64 88       	ldd	r6, Z+20	; 0x14
    3720:	75 88       	ldd	r7, Z+21	; 0x15

        if (pl_block->entry_speed_sqr > nominal_speed_sqr) { // Only occurs during override reductions.
    3722:	a3 01       	movw	r20, r6
    3724:	92 01       	movw	r18, r4
    3726:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    372a:	88 23       	and	r24, r24
    372c:	0c f0       	brlt	.+2      	; 0x3730 <st_prep_buffer+0x420>
    372e:	79 c0       	rjmp	.+242    	; 0x3822 <st_prep_buffer+0x512>
          prep.accelerate_until = pl_block->millimeters - inv_2_accel*(pl_block->entry_speed_sqr-nominal_speed_sqr);
    3730:	2d 81       	ldd	r18, Y+5	; 0x05
    3732:	3e 81       	ldd	r19, Y+6	; 0x06
    3734:	4f 81       	ldd	r20, Y+7	; 0x07
    3736:	58 85       	ldd	r21, Y+8	; 0x08
    3738:	c3 01       	movw	r24, r6
    373a:	b2 01       	movw	r22, r4
    373c:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    3740:	29 81       	ldd	r18, Y+1	; 0x01
    3742:	3a 81       	ldd	r19, Y+2	; 0x02
    3744:	4b 81       	ldd	r20, Y+3	; 0x03
    3746:	5c 81       	ldd	r21, Y+4	; 0x04
    3748:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    374c:	9b 01       	movw	r18, r22
    374e:	ac 01       	movw	r20, r24
    3750:	c7 01       	movw	r24, r14
    3752:	b6 01       	movw	r22, r12
    3754:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    3758:	60 93 7d 01 	sts	0x017D, r22	; 0x80017d <prep+0x23>
    375c:	70 93 7e 01 	sts	0x017E, r23	; 0x80017e <prep+0x24>
    3760:	80 93 7f 01 	sts	0x017F, r24	; 0x80017f <prep+0x25>
    3764:	90 93 80 01 	sts	0x0180, r25	; 0x800180 <prep+0x26>
          if (prep.accelerate_until <= 0.0) { // Deceleration-only.
    3768:	20 e0       	ldi	r18, 0x00	; 0
    376a:	30 e0       	ldi	r19, 0x00	; 0
    376c:	a9 01       	movw	r20, r18
    376e:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    3772:	18 16       	cp	r1, r24
    3774:	94 f1       	brlt	.+100    	; 0x37da <st_prep_buffer+0x4ca>
            prep.ramp_type = RAMP_DECEL;
    3776:	f2 e0       	ldi	r31, 0x02	; 2
    3778:	f0 93 6c 01 	sts	0x016C, r31	; 0x80016c <prep+0x12>
            // prep.decelerate_after = pl_block->millimeters;
            // prep.maximum_speed = prep.current_speed;

            // Compute override block exit speed since it doesn't match the planner exit speed.
            prep.exit_speed = sqrt(pl_block->entry_speed_sqr - 2*pl_block->acceleration*pl_block->millimeters);
    377c:	d8 01       	movw	r26, r16
    377e:	5a 96       	adiw	r26, 0x1a	; 26
    3780:	cd 90       	ld	r12, X+
    3782:	dd 90       	ld	r13, X+
    3784:	ed 90       	ld	r14, X+
    3786:	fc 90       	ld	r15, X
    3788:	5d 97       	sbiw	r26, 0x1d	; 29
    378a:	a7 01       	movw	r20, r14
    378c:	96 01       	movw	r18, r12
    378e:	c7 01       	movw	r24, r14
    3790:	b6 01       	movw	r22, r12
    3792:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    3796:	f8 01       	movw	r30, r16
    3798:	26 8d       	ldd	r18, Z+30	; 0x1e
    379a:	37 8d       	ldd	r19, Z+31	; 0x1f
    379c:	40 a1       	ldd	r20, Z+32	; 0x20
    379e:	51 a1       	ldd	r21, Z+33	; 0x21
    37a0:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    37a4:	9b 01       	movw	r18, r22
    37a6:	ac 01       	movw	r20, r24
    37a8:	d8 01       	movw	r26, r16
    37aa:	52 96       	adiw	r26, 0x12	; 18
    37ac:	6d 91       	ld	r22, X+
    37ae:	7d 91       	ld	r23, X+
    37b0:	8d 91       	ld	r24, X+
    37b2:	9c 91       	ld	r25, X
    37b4:	55 97       	sbiw	r26, 0x15	; 21
    37b6:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    37ba:	0e 94 65 32 	call	0x64ca	; 0x64ca <sqrt>
    37be:	60 93 79 01 	sts	0x0179, r22	; 0x800179 <prep+0x1f>
    37c2:	70 93 7a 01 	sts	0x017A, r23	; 0x80017a <prep+0x20>
    37c6:	80 93 7b 01 	sts	0x017B, r24	; 0x80017b <prep+0x21>
    37ca:	90 93 7c 01 	sts	0x017C, r25	; 0x80017c <prep+0x22>
            prep.recalculate_flag |= PREP_FLAG_DECEL_OVERRIDE; // Flag to load next block as deceleration override.
    37ce:	80 91 5b 01 	lds	r24, 0x015B	; 0x80015b <prep+0x1>
    37d2:	88 60       	ori	r24, 0x08	; 8
    37d4:	80 93 5b 01 	sts	0x015B, r24	; 0x80015b <prep+0x1>
    37d8:	fb c0       	rjmp	.+502    	; 0x39d0 <st_prep_buffer+0x6c0>
            // Can be tricky since entry speed will be current speed, as in feed holds.
            // Also, look into near-zero speed handling issues with this.

          } else {
            // Decelerate to cruise or cruise-decelerate types. Guaranteed to intersect updated plan.
            prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr); // Should always be >= 0.0 due to planner reinit.
    37da:	29 85       	ldd	r18, Y+9	; 0x09
    37dc:	3a 85       	ldd	r19, Y+10	; 0x0a
    37de:	4b 85       	ldd	r20, Y+11	; 0x0b
    37e0:	5c 85       	ldd	r21, Y+12	; 0x0c
    37e2:	6d 81       	ldd	r22, Y+5	; 0x05
    37e4:	7e 81       	ldd	r23, Y+6	; 0x06
    37e6:	8f 81       	ldd	r24, Y+7	; 0x07
    37e8:	98 85       	ldd	r25, Y+8	; 0x08
    37ea:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    37ee:	29 81       	ldd	r18, Y+1	; 0x01
    37f0:	3a 81       	ldd	r19, Y+2	; 0x02
    37f2:	4b 81       	ldd	r20, Y+3	; 0x03
    37f4:	5c 81       	ldd	r21, Y+4	; 0x04
    37f6:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    37fa:	60 93 81 01 	sts	0x0181, r22	; 0x800181 <prep+0x27>
    37fe:	70 93 82 01 	sts	0x0182, r23	; 0x800182 <prep+0x28>
    3802:	80 93 83 01 	sts	0x0183, r24	; 0x800183 <prep+0x29>
    3806:	90 93 84 01 	sts	0x0184, r25	; 0x800184 <prep+0x2a>
            prep.maximum_speed = nominal_speed;
    380a:	80 92 75 01 	sts	0x0175, r8	; 0x800175 <prep+0x1b>
    380e:	90 92 76 01 	sts	0x0176, r9	; 0x800176 <prep+0x1c>
    3812:	a0 92 77 01 	sts	0x0177, r10	; 0x800177 <prep+0x1d>
    3816:	b0 92 78 01 	sts	0x0178, r11	; 0x800178 <prep+0x1e>
            prep.ramp_type = RAMP_DECEL_OVERRIDE;
    381a:	b3 e0       	ldi	r27, 0x03	; 3
    381c:	b0 93 6c 01 	sts	0x016C, r27	; 0x80016c <prep+0x12>
    3820:	d7 c0       	rjmp	.+430    	; 0x39d0 <st_prep_buffer+0x6c0>
          prep.exit_speed = sqrt(exit_speed_sqr);
        }

        nominal_speed = plan_compute_profile_nominal_speed(pl_block);
				float nominal_speed_sqr = nominal_speed*nominal_speed;
				float intersect_distance =
    3822:	29 85       	ldd	r18, Y+9	; 0x09
    3824:	3a 85       	ldd	r19, Y+10	; 0x0a
    3826:	4b 85       	ldd	r20, Y+11	; 0x0b
    3828:	5c 85       	ldd	r21, Y+12	; 0x0c
    382a:	c3 01       	movw	r24, r6
    382c:	b2 01       	movw	r22, r4
    382e:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    3832:	29 81       	ldd	r18, Y+1	; 0x01
    3834:	3a 81       	ldd	r19, Y+2	; 0x02
    3836:	4b 81       	ldd	r20, Y+3	; 0x03
    3838:	5c 81       	ldd	r21, Y+4	; 0x04
    383a:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    383e:	a7 01       	movw	r20, r14
    3840:	96 01       	movw	r18, r12
    3842:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    3846:	20 e0       	ldi	r18, 0x00	; 0
    3848:	30 e0       	ldi	r19, 0x00	; 0
    384a:	40 e0       	ldi	r20, 0x00	; 0
    384c:	5f e3       	ldi	r21, 0x3F	; 63
    384e:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    3852:	2b 01       	movw	r4, r22
    3854:	3c 01       	movw	r6, r24
            // Decelerate to cruise or cruise-decelerate types. Guaranteed to intersect updated plan.
            prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr); // Should always be >= 0.0 due to planner reinit.
            prep.maximum_speed = nominal_speed;
            prep.ramp_type = RAMP_DECEL_OVERRIDE;
          }
				} else if (intersect_distance > 0.0) {
    3856:	20 e0       	ldi	r18, 0x00	; 0
    3858:	30 e0       	ldi	r19, 0x00	; 0
    385a:	a9 01       	movw	r20, r18
    385c:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    3860:	18 16       	cp	r1, r24
    3862:	0c f0       	brlt	.+2      	; 0x3866 <st_prep_buffer+0x556>
    3864:	9d c0       	rjmp	.+314    	; 0x39a0 <st_prep_buffer+0x690>
					if (intersect_distance < pl_block->millimeters) { // Either trapezoid or triangle types
    3866:	a3 01       	movw	r20, r6
    3868:	92 01       	movw	r18, r4
    386a:	c7 01       	movw	r24, r14
    386c:	b6 01       	movw	r22, r12
    386e:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    3872:	18 16       	cp	r1, r24
    3874:	0c f0       	brlt	.+2      	; 0x3878 <st_prep_buffer+0x568>
    3876:	90 c0       	rjmp	.+288    	; 0x3998 <st_prep_buffer+0x688>
						// NOTE: For acceleration-cruise and cruise-only types, following calculation will be 0.0.
						prep.decelerate_after = inv_2_accel*(nominal_speed_sqr-exit_speed_sqr);
    3878:	29 85       	ldd	r18, Y+9	; 0x09
    387a:	3a 85       	ldd	r19, Y+10	; 0x0a
    387c:	4b 85       	ldd	r20, Y+11	; 0x0b
    387e:	5c 85       	ldd	r21, Y+12	; 0x0c
    3880:	6d 81       	ldd	r22, Y+5	; 0x05
    3882:	7e 81       	ldd	r23, Y+6	; 0x06
    3884:	8f 81       	ldd	r24, Y+7	; 0x07
    3886:	98 85       	ldd	r25, Y+8	; 0x08
    3888:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    388c:	29 81       	ldd	r18, Y+1	; 0x01
    388e:	3a 81       	ldd	r19, Y+2	; 0x02
    3890:	4b 81       	ldd	r20, Y+3	; 0x03
    3892:	5c 81       	ldd	r21, Y+4	; 0x04
    3894:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    3898:	9b 01       	movw	r18, r22
    389a:	ac 01       	movw	r20, r24
    389c:	60 93 81 01 	sts	0x0181, r22	; 0x800181 <prep+0x27>
    38a0:	70 93 82 01 	sts	0x0182, r23	; 0x800182 <prep+0x28>
    38a4:	80 93 83 01 	sts	0x0183, r24	; 0x800183 <prep+0x29>
    38a8:	90 93 84 01 	sts	0x0184, r25	; 0x800184 <prep+0x2a>
						if (prep.decelerate_after < intersect_distance) { // Trapezoid type
    38ac:	c3 01       	movw	r24, r6
    38ae:	b2 01       	movw	r22, r4
    38b0:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    38b4:	18 16       	cp	r1, r24
    38b6:	f4 f5       	brge	.+124    	; 0x3934 <st_prep_buffer+0x624>
							prep.maximum_speed = nominal_speed;
    38b8:	80 92 75 01 	sts	0x0175, r8	; 0x800175 <prep+0x1b>
    38bc:	90 92 76 01 	sts	0x0176, r9	; 0x800176 <prep+0x1c>
    38c0:	a0 92 77 01 	sts	0x0177, r10	; 0x800177 <prep+0x1d>
    38c4:	b0 92 78 01 	sts	0x0178, r11	; 0x800178 <prep+0x1e>
							if (pl_block->entry_speed_sqr == nominal_speed_sqr) {
    38c8:	f8 01       	movw	r30, r16
    38ca:	42 88       	ldd	r4, Z+18	; 0x12
    38cc:	53 88       	ldd	r5, Z+19	; 0x13
    38ce:	64 88       	ldd	r6, Z+20	; 0x14
    38d0:	75 88       	ldd	r7, Z+21	; 0x15
    38d2:	a3 01       	movw	r20, r6
    38d4:	92 01       	movw	r18, r4
    38d6:	6d 81       	ldd	r22, Y+5	; 0x05
    38d8:	7e 81       	ldd	r23, Y+6	; 0x06
    38da:	8f 81       	ldd	r24, Y+7	; 0x07
    38dc:	98 85       	ldd	r25, Y+8	; 0x08
    38de:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    38e2:	81 11       	cpse	r24, r1
    38e4:	04 c0       	rjmp	.+8      	; 0x38ee <st_prep_buffer+0x5de>
								// Cruise-deceleration or cruise-only type.
								prep.ramp_type = RAMP_CRUISE;
    38e6:	f1 e0       	ldi	r31, 0x01	; 1
    38e8:	f0 93 6c 01 	sts	0x016C, r31	; 0x80016c <prep+0x12>
    38ec:	71 c0       	rjmp	.+226    	; 0x39d0 <st_prep_buffer+0x6c0>
							} else {
								// Full-trapezoid or acceleration-cruise types
								prep.accelerate_until -= inv_2_accel*(nominal_speed_sqr-pl_block->entry_speed_sqr);
    38ee:	a3 01       	movw	r20, r6
    38f0:	92 01       	movw	r18, r4
    38f2:	6d 81       	ldd	r22, Y+5	; 0x05
    38f4:	7e 81       	ldd	r23, Y+6	; 0x06
    38f6:	8f 81       	ldd	r24, Y+7	; 0x07
    38f8:	98 85       	ldd	r25, Y+8	; 0x08
    38fa:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    38fe:	29 81       	ldd	r18, Y+1	; 0x01
    3900:	3a 81       	ldd	r19, Y+2	; 0x02
    3902:	4b 81       	ldd	r20, Y+3	; 0x03
    3904:	5c 81       	ldd	r21, Y+4	; 0x04
    3906:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    390a:	9b 01       	movw	r18, r22
    390c:	ac 01       	movw	r20, r24
    390e:	60 91 7d 01 	lds	r22, 0x017D	; 0x80017d <prep+0x23>
    3912:	70 91 7e 01 	lds	r23, 0x017E	; 0x80017e <prep+0x24>
    3916:	80 91 7f 01 	lds	r24, 0x017F	; 0x80017f <prep+0x25>
    391a:	90 91 80 01 	lds	r25, 0x0180	; 0x800180 <prep+0x26>
    391e:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    3922:	60 93 7d 01 	sts	0x017D, r22	; 0x80017d <prep+0x23>
    3926:	70 93 7e 01 	sts	0x017E, r23	; 0x80017e <prep+0x24>
    392a:	80 93 7f 01 	sts	0x017F, r24	; 0x80017f <prep+0x25>
    392e:	90 93 80 01 	sts	0x0180, r25	; 0x800180 <prep+0x26>
    3932:	4e c0       	rjmp	.+156    	; 0x39d0 <st_prep_buffer+0x6c0>
							}
						} else { // Triangle type
							prep.accelerate_until = intersect_distance;
    3934:	40 92 7d 01 	sts	0x017D, r4	; 0x80017d <prep+0x23>
    3938:	50 92 7e 01 	sts	0x017E, r5	; 0x80017e <prep+0x24>
    393c:	60 92 7f 01 	sts	0x017F, r6	; 0x80017f <prep+0x25>
    3940:	70 92 80 01 	sts	0x0180, r7	; 0x800180 <prep+0x26>
							prep.decelerate_after = intersect_distance;
    3944:	40 92 81 01 	sts	0x0181, r4	; 0x800181 <prep+0x27>
    3948:	50 92 82 01 	sts	0x0182, r5	; 0x800182 <prep+0x28>
    394c:	60 92 83 01 	sts	0x0183, r6	; 0x800183 <prep+0x29>
    3950:	70 92 84 01 	sts	0x0184, r7	; 0x800184 <prep+0x2a>
							prep.maximum_speed = sqrt(2.0*pl_block->acceleration*intersect_distance+exit_speed_sqr);
    3954:	d8 01       	movw	r26, r16
    3956:	5a 96       	adiw	r26, 0x1a	; 26
    3958:	cd 90       	ld	r12, X+
    395a:	dd 90       	ld	r13, X+
    395c:	ed 90       	ld	r14, X+
    395e:	fc 90       	ld	r15, X
    3960:	5d 97       	sbiw	r26, 0x1d	; 29
    3962:	a7 01       	movw	r20, r14
    3964:	96 01       	movw	r18, r12
    3966:	c7 01       	movw	r24, r14
    3968:	b6 01       	movw	r22, r12
    396a:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    396e:	a3 01       	movw	r20, r6
    3970:	92 01       	movw	r18, r4
    3972:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    3976:	29 85       	ldd	r18, Y+9	; 0x09
    3978:	3a 85       	ldd	r19, Y+10	; 0x0a
    397a:	4b 85       	ldd	r20, Y+11	; 0x0b
    397c:	5c 85       	ldd	r21, Y+12	; 0x0c
    397e:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    3982:	0e 94 65 32 	call	0x64ca	; 0x64ca <sqrt>
    3986:	60 93 75 01 	sts	0x0175, r22	; 0x800175 <prep+0x1b>
    398a:	70 93 76 01 	sts	0x0176, r23	; 0x800176 <prep+0x1c>
    398e:	80 93 77 01 	sts	0x0177, r24	; 0x800177 <prep+0x1d>
    3992:	90 93 78 01 	sts	0x0178, r25	; 0x800178 <prep+0x1e>
    3996:	1c c0       	rjmp	.+56     	; 0x39d0 <st_prep_buffer+0x6c0>
						}
					} else { // Deceleration-only type
            prep.ramp_type = RAMP_DECEL;
    3998:	b2 e0       	ldi	r27, 0x02	; 2
    399a:	b0 93 6c 01 	sts	0x016C, r27	; 0x80016c <prep+0x12>
    399e:	18 c0       	rjmp	.+48     	; 0x39d0 <st_prep_buffer+0x6c0>
            // prep.decelerate_after = pl_block->millimeters;
            // prep.maximum_speed = prep.current_speed;
					}
				} else { // Acceleration-only type
					prep.accelerate_until = 0.0;
    39a0:	10 92 7d 01 	sts	0x017D, r1	; 0x80017d <prep+0x23>
    39a4:	10 92 7e 01 	sts	0x017E, r1	; 0x80017e <prep+0x24>
    39a8:	10 92 7f 01 	sts	0x017F, r1	; 0x80017f <prep+0x25>
    39ac:	10 92 80 01 	sts	0x0180, r1	; 0x800180 <prep+0x26>
					// prep.decelerate_after = 0.0;
					prep.maximum_speed = prep.exit_speed;
    39b0:	80 91 79 01 	lds	r24, 0x0179	; 0x800179 <prep+0x1f>
    39b4:	90 91 7a 01 	lds	r25, 0x017A	; 0x80017a <prep+0x20>
    39b8:	a0 91 7b 01 	lds	r26, 0x017B	; 0x80017b <prep+0x21>
    39bc:	b0 91 7c 01 	lds	r27, 0x017C	; 0x80017c <prep+0x22>
    39c0:	80 93 75 01 	sts	0x0175, r24	; 0x800175 <prep+0x1b>
    39c4:	90 93 76 01 	sts	0x0176, r25	; 0x800176 <prep+0x1c>
    39c8:	a0 93 77 01 	sts	0x0177, r26	; 0x800177 <prep+0x1d>
    39cc:	b0 93 78 01 	sts	0x0178, r27	; 0x800178 <prep+0x1e>
				}
			}
      
      #ifdef VARIABLE_SPINDLE
        bit_true(sys.step_control, STEP_CONTROL_UPDATE_SPINDLE_PWM); // Force update whenever updating block.
    39d0:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <sys+0x4>
    39d4:	88 60       	ori	r24, 0x08	; 8
    39d6:	80 93 80 05 	sts	0x0580, r24	; 0x800580 <sys+0x4>
      #endif
    }
    
    // Initialize new segment
    segment_t *prep_segment = &segment_buffer[segment_buffer_head];
    39da:	e0 91 92 01 	lds	r30, 0x0192	; 0x800192 <segment_buffer_head>

    // Set new segment to point to the current segment data block.
    prep_segment->st_block_index = prep.st_block_index;
    39de:	2e 2f       	mov	r18, r30
    39e0:	30 e0       	ldi	r19, 0x00	; 0
    39e2:	3a a7       	std	Y+42, r19	; 0x2a
    39e4:	29 a7       	std	Y+41, r18	; 0x29
    39e6:	37 e0       	ldi	r19, 0x07	; 7
    39e8:	e3 9f       	mul	r30, r19
    39ea:	f0 01       	movw	r30, r0
    39ec:	11 24       	eor	r1, r1
    39ee:	e9 54       	subi	r30, 0x49	; 73
    39f0:	fe 4f       	sbci	r31, 0xFE	; 254
    39f2:	aa e5       	ldi	r26, 0x5A	; 90
    39f4:	b1 e0       	ldi	r27, 0x01	; 1
    39f6:	8c 91       	ld	r24, X
    39f8:	84 83       	std	Z+4, r24	; 0x04
    float dt_max = DT_SEGMENT; // Maximum segment time
    float dt = 0.0; // Initialize segment time
    float time_var = dt_max; // Time worker variable
    float mm_var; // mm-Distance worker variable
    float speed_var; // Speed worker variable
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    39fa:	e0 91 8c 01 	lds	r30, 0x018C	; 0x80018c <pl_block>
    39fe:	f0 91 8d 01 	lds	r31, 0x018D	; 0x80018d <pl_block+0x1>
    3a02:	fc 8f       	std	Y+28, r31	; 0x1c
    3a04:	eb 8f       	std	Y+27, r30	; 0x1b
    3a06:	f6 8d       	ldd	r31, Z+30	; 0x1e
    3a08:	fb a7       	std	Y+43, r31	; 0x2b
    3a0a:	ab 8d       	ldd	r26, Y+27	; 0x1b
    3a0c:	bc 8d       	ldd	r27, Y+28	; 0x1c
    3a0e:	5f 96       	adiw	r26, 0x1f	; 31
    3a10:	bc 91       	ld	r27, X
    3a12:	bc a7       	std	Y+44, r27	; 0x2c
    3a14:	eb 8d       	ldd	r30, Y+27	; 0x1b
    3a16:	fc 8d       	ldd	r31, Y+28	; 0x1c
    3a18:	f0 a1       	ldd	r31, Z+32	; 0x20
    3a1a:	fd a7       	std	Y+45, r31	; 0x2d
    3a1c:	ab 8d       	ldd	r26, Y+27	; 0x1b
    3a1e:	bc 8d       	ldd	r27, Y+28	; 0x1c
    3a20:	91 96       	adiw	r26, 0x21	; 33
    3a22:	bc 91       	ld	r27, X
    3a24:	be a7       	std	Y+46, r27	; 0x2e
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    3a26:	20 91 68 01 	lds	r18, 0x0168	; 0x800168 <prep+0xe>
    3a2a:	30 91 69 01 	lds	r19, 0x0169	; 0x800169 <prep+0xf>
    3a2e:	40 91 6a 01 	lds	r20, 0x016A	; 0x80016a <prep+0x10>
    3a32:	50 91 6b 01 	lds	r21, 0x016B	; 0x80016b <prep+0x11>
    3a36:	6b a5       	ldd	r22, Y+43	; 0x2b
    3a38:	7c a5       	ldd	r23, Y+44	; 0x2c
    3a3a:	8f 2f       	mov	r24, r31
    3a3c:	9b 2f       	mov	r25, r27
    3a3e:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    3a42:	69 a3       	std	Y+33, r22	; 0x21
    3a44:	7a a3       	std	Y+34, r23	; 0x22
    3a46:	8b a3       	std	Y+35, r24	; 0x23
    3a48:	9c a3       	std	Y+36, r25	; 0x24
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }
    3a4a:	20 e0       	ldi	r18, 0x00	; 0
    3a4c:	30 e0       	ldi	r19, 0x00	; 0
    3a4e:	a9 01       	movw	r20, r18
    3a50:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    3a54:	88 23       	and	r24, r24
    3a56:	24 f4       	brge	.+8      	; 0x3a60 <st_prep_buffer+0x750>
    3a58:	19 a2       	std	Y+33, r1	; 0x21
    3a5a:	1a a2       	std	Y+34, r1	; 0x22
    3a5c:	1b a2       	std	Y+35, r1	; 0x23
    3a5e:	1c a2       	std	Y+36, r1	; 0x24

    do {
      switch (prep.ramp_type) {
        case RAMP_DECEL_OVERRIDE:
          speed_var = pl_block->acceleration*time_var;
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
    3a60:	20 91 75 01 	lds	r18, 0x0175	; 0x800175 <prep+0x1b>
    3a64:	30 91 76 01 	lds	r19, 0x0176	; 0x800176 <prep+0x1c>
    3a68:	40 91 77 01 	lds	r20, 0x0177	; 0x800177 <prep+0x1d>
    3a6c:	50 91 78 01 	lds	r21, 0x0178	; 0x800178 <prep+0x1e>
    3a70:	2f 8b       	std	Y+23, r18	; 0x17
    3a72:	38 8f       	std	Y+24, r19	; 0x18
    3a74:	49 8f       	std	Y+25, r20	; 0x19
    3a76:	5a 8f       	std	Y+26, r21	; 0x1a
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
    3a78:	30 91 7d 01 	lds	r19, 0x017D	; 0x80017d <prep+0x23>
    3a7c:	3d 8f       	std	Y+29, r19	; 0x1d
    3a7e:	40 91 7e 01 	lds	r20, 0x017E	; 0x80017e <prep+0x24>
    3a82:	4e 8f       	std	Y+30, r20	; 0x1e
    3a84:	50 91 7f 01 	lds	r21, 0x017F	; 0x80017f <prep+0x25>
    3a88:	5f 8f       	std	Y+31, r21	; 0x1f
    3a8a:	80 91 80 01 	lds	r24, 0x0180	; 0x800180 <prep+0x26>
    3a8e:	88 a3       	std	Y+32, r24	; 0x20
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
    3a90:	90 91 81 01 	lds	r25, 0x0181	; 0x800181 <prep+0x27>
    3a94:	9d a3       	std	Y+37, r25	; 0x25
    3a96:	a0 91 82 01 	lds	r26, 0x0182	; 0x800182 <prep+0x28>
    3a9a:	ae a3       	std	Y+38, r26	; 0x26
    3a9c:	b0 91 83 01 	lds	r27, 0x0183	; 0x800183 <prep+0x29>
    3aa0:	bf a3       	std	Y+39, r27	; 0x27
    3aa2:	e0 91 84 01 	lds	r30, 0x0184	; 0x800184 <prep+0x2a>
    3aa6:	e8 a7       	std	Y+40, r30	; 0x28
    3aa8:	10 91 6c 01 	lds	r17, 0x016C	; 0x80016c <prep+0x12>
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
    3aac:	f0 91 6d 01 	lds	r31, 0x016D	; 0x80016d <prep+0x13>
    3ab0:	fb 8b       	std	Y+19, r31	; 0x13
    3ab2:	20 91 6e 01 	lds	r18, 0x016E	; 0x80016e <prep+0x14>
    3ab6:	2c 8b       	std	Y+20, r18	; 0x14
    3ab8:	30 91 6f 01 	lds	r19, 0x016F	; 0x80016f <prep+0x15>
    3abc:	3d 8b       	std	Y+21, r19	; 0x15
    3abe:	40 91 70 01 	lds	r20, 0x0170	; 0x800170 <prep+0x16>
    3ac2:	4e 8b       	std	Y+22, r20	; 0x16
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
            }
          }
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    3ac4:	80 91 79 01 	lds	r24, 0x0179	; 0x800179 <prep+0x1f>
    3ac8:	90 91 7a 01 	lds	r25, 0x017A	; 0x80017a <prep+0x20>
    3acc:	a0 91 7b 01 	lds	r26, 0x017B	; 0x80017b <prep+0x21>
    3ad0:	b0 91 7c 01 	lds	r27, 0x017C	; 0x80017c <prep+0x22>
    3ad4:	8f a7       	std	Y+47, r24	; 0x2f
    3ad6:	98 ab       	std	Y+48, r25	; 0x30
    3ad8:	a9 ab       	std	Y+49, r26	; 0x31
    3ada:	ba ab       	std	Y+50, r27	; 0x32
    3adc:	2d a1       	ldd	r18, Y+37	; 0x25
    3ade:	3e a1       	ldd	r19, Y+38	; 0x26
    3ae0:	4f a1       	ldd	r20, Y+39	; 0x27
    3ae2:	5e 2f       	mov	r21, r30
    3ae4:	6d 8d       	ldd	r22, Y+29	; 0x1d
    3ae6:	7e 8d       	ldd	r23, Y+30	; 0x1e
    3ae8:	8f 8d       	ldd	r24, Y+31	; 0x1f
    3aea:	98 a1       	ldd	r25, Y+32	; 0x20
    3aec:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    3af0:	81 11       	cpse	r24, r1
    3af2:	02 c0       	rjmp	.+4      	; 0x3af8 <st_prep_buffer+0x7e8>
    3af4:	8a ad       	ldd	r24, Y+58	; 0x3a
    3af6:	01 c0       	rjmp	.+2      	; 0x3afa <st_prep_buffer+0x7ea>
    3af8:	81 e0       	ldi	r24, 0x01	; 1
    3afa:	3b a4       	ldd	r3, Y+43	; 0x2b
    3afc:	2c a4       	ldd	r2, Y+44	; 0x2c
    3afe:	5d a4       	ldd	r5, Y+45	; 0x2d
    3b00:	4e a4       	ldd	r4, Y+46	; 0x2e
    3b02:	9e e3       	ldi	r25, 0x3E	; 62
    3b04:	99 83       	std	Y+1, r25	; 0x01
    3b06:	0f 2e       	mov	r0, r31
    3b08:	f3 ec       	ldi	r31, 0xC3	; 195
    3b0a:	6f 2e       	mov	r6, r31
    3b0c:	f0 2d       	mov	r31, r0
    3b0e:	0f 2e       	mov	r0, r31
    3b10:	fe e2       	ldi	r31, 0x2E	; 46
    3b12:	7f 2e       	mov	r7, r31
    3b14:	f0 2d       	mov	r31, r0
    3b16:	09 e3       	ldi	r16, 0x39	; 57
    3b18:	81 2c       	mov	r8, r1
    3b1a:	91 2c       	mov	r9, r1
    3b1c:	54 01       	movw	r10, r8
    3b1e:	ae e3       	ldi	r26, 0x3E	; 62
    3b20:	ad 83       	std	Y+5, r26	; 0x05
    3b22:	b3 ec       	ldi	r27, 0xC3	; 195
    3b24:	b9 87       	std	Y+9, r27	; 0x09
    3b26:	ee e2       	ldi	r30, 0x2E	; 46
    3b28:	ed 87       	std	Y+13, r30	; 0x0d
    3b2a:	f9 e3       	ldi	r31, 0x39	; 57
    3b2c:	fe 87       	std	Y+14, r31	; 0x0e
    3b2e:	8f ab       	std	Y+55, r24	; 0x37
    3b30:	f3 2c       	mov	r15, r3
    3b32:	37 2c       	mov	r3, r7
    3b34:	e2 2c       	mov	r14, r2
    3b36:	26 2c       	mov	r2, r6
    3b38:	d5 2c       	mov	r13, r5
    3b3a:	c4 2c       	mov	r12, r4
    float mm_remaining = pl_block->millimeters; // New segment distance from end of block.
    float minimum_mm = mm_remaining-prep.req_mm_increment; // Guarantee at least one step.
    if (minimum_mm < 0.0) { minimum_mm = 0.0; }

    do {
      switch (prep.ramp_type) {
    3b3c:	11 30       	cpi	r17, 0x01	; 1
    3b3e:	09 f4       	brne	.+2      	; 0x3b42 <st_prep_buffer+0x832>
    3b40:	1f c1       	rjmp	.+574    	; 0x3d80 <st_prep_buffer+0xa70>
    3b42:	08 f4       	brcc	.+2      	; 0x3b46 <st_prep_buffer+0x836>
    3b44:	96 c0       	rjmp	.+300    	; 0x3c72 <st_prep_buffer+0x962>
    3b46:	13 30       	cpi	r17, 0x03	; 3
    3b48:	09 f0       	breq	.+2      	; 0x3b4c <st_prep_buffer+0x83c>
    3b4a:	57 c1       	rjmp	.+686    	; 0x3dfa <st_prep_buffer+0xaea>
        case RAMP_DECEL_OVERRIDE:
          speed_var = pl_block->acceleration*time_var;
    3b4c:	ab 8d       	ldd	r26, Y+27	; 0x1b
    3b4e:	bc 8d       	ldd	r27, Y+28	; 0x1c
    3b50:	5a 96       	adiw	r26, 0x1a	; 26
    3b52:	2d 91       	ld	r18, X+
    3b54:	3d 91       	ld	r19, X+
    3b56:	4d 91       	ld	r20, X+
    3b58:	5c 91       	ld	r21, X
    3b5a:	5d 97       	sbiw	r26, 0x1d	; 29
    3b5c:	69 81       	ldd	r22, Y+1	; 0x01
    3b5e:	72 2d       	mov	r23, r2
    3b60:	83 2d       	mov	r24, r3
    3b62:	90 2f       	mov	r25, r16
    3b64:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    3b68:	6f 87       	std	Y+15, r22	; 0x0f
    3b6a:	78 8b       	std	Y+16, r23	; 0x10
    3b6c:	89 8b       	std	Y+17, r24	; 0x11
    3b6e:	9a 8b       	std	Y+18, r25	; 0x12
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
    3b70:	40 90 71 01 	lds	r4, 0x0171	; 0x800171 <prep+0x17>
    3b74:	50 90 72 01 	lds	r5, 0x0172	; 0x800172 <prep+0x18>
    3b78:	60 90 73 01 	lds	r6, 0x0173	; 0x800173 <prep+0x19>
    3b7c:	70 90 74 01 	lds	r7, 0x0174	; 0x800174 <prep+0x1a>
    3b80:	2f 89       	ldd	r18, Y+23	; 0x17
    3b82:	38 8d       	ldd	r19, Y+24	; 0x18
    3b84:	49 8d       	ldd	r20, Y+25	; 0x19
    3b86:	5a 8d       	ldd	r21, Y+26	; 0x1a
    3b88:	c3 01       	movw	r24, r6
    3b8a:	b2 01       	movw	r22, r4
    3b8c:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    3b90:	9b 01       	movw	r18, r22
    3b92:	ac 01       	movw	r20, r24
    3b94:	6f 85       	ldd	r22, Y+15	; 0x0f
    3b96:	78 89       	ldd	r23, Y+16	; 0x10
    3b98:	89 89       	ldd	r24, Y+17	; 0x11
    3b9a:	9a 89       	ldd	r25, Y+18	; 0x12
    3b9c:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    3ba0:	88 23       	and	r24, r24
    3ba2:	a4 f1       	brlt	.+104    	; 0x3c0c <st_prep_buffer+0x8fc>
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    3ba4:	2d 8d       	ldd	r18, Y+29	; 0x1d
    3ba6:	3e 8d       	ldd	r19, Y+30	; 0x1e
    3ba8:	4f 8d       	ldd	r20, Y+31	; 0x1f
    3baa:	58 a1       	ldd	r21, Y+32	; 0x20
    3bac:	6b a5       	ldd	r22, Y+43	; 0x2b
    3bae:	7c a5       	ldd	r23, Y+44	; 0x2c
    3bb0:	8d a5       	ldd	r24, Y+45	; 0x2d
    3bb2:	9e a5       	ldd	r25, Y+46	; 0x2e
    3bb4:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    3bb8:	9b 01       	movw	r18, r22
    3bba:	ac 01       	movw	r20, r24
    3bbc:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    3bc0:	6b 01       	movw	r12, r22
    3bc2:	7c 01       	movw	r14, r24
    3bc4:	2f 89       	ldd	r18, Y+23	; 0x17
    3bc6:	38 8d       	ldd	r19, Y+24	; 0x18
    3bc8:	49 8d       	ldd	r20, Y+25	; 0x19
    3bca:	5a 8d       	ldd	r21, Y+26	; 0x1a
    3bcc:	c3 01       	movw	r24, r6
    3bce:	b2 01       	movw	r22, r4
    3bd0:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    3bd4:	9b 01       	movw	r18, r22
    3bd6:	ac 01       	movw	r20, r24
    3bd8:	c7 01       	movw	r24, r14
    3bda:	b6 01       	movw	r22, r12
    3bdc:	0e 94 6e 2f 	call	0x5edc	; 0x5edc <__divsf3>
    3be0:	69 83       	std	Y+1, r22	; 0x01
    3be2:	27 2e       	mov	r2, r23
    3be4:	38 2e       	mov	r3, r24
    3be6:	09 2f       	mov	r16, r25
            prep.ramp_type = RAMP_CRUISE;
            prep.current_speed = prep.maximum_speed;
    3be8:	2f 89       	ldd	r18, Y+23	; 0x17
    3bea:	38 8d       	ldd	r19, Y+24	; 0x18
    3bec:	49 8d       	ldd	r20, Y+25	; 0x19
    3bee:	5a 8d       	ldd	r21, Y+26	; 0x1a
    3bf0:	20 93 71 01 	sts	0x0171, r18	; 0x800171 <prep+0x17>
    3bf4:	30 93 72 01 	sts	0x0172, r19	; 0x800172 <prep+0x18>
    3bf8:	40 93 73 01 	sts	0x0173, r20	; 0x800173 <prep+0x19>
    3bfc:	50 93 74 01 	sts	0x0174, r21	; 0x800174 <prep+0x1a>
      switch (prep.ramp_type) {
        case RAMP_DECEL_OVERRIDE:
          speed_var = pl_block->acceleration*time_var;
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
    3c00:	fd 8c       	ldd	r15, Y+29	; 0x1d
    3c02:	ee 8c       	ldd	r14, Y+30	; 0x1e
    3c04:	df 8c       	ldd	r13, Y+31	; 0x1f
    3c06:	c8 a0       	ldd	r12, Y+32	; 0x20
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            prep.ramp_type = RAMP_CRUISE;
    3c08:	18 ad       	ldd	r17, Y+56	; 0x38
    3c0a:	8e c1       	rjmp	.+796    	; 0x3f28 <st_prep_buffer+0xc18>
            prep.current_speed = prep.maximum_speed;
          } else { // Mid-deceleration override ramp.
            mm_remaining -= time_var*(prep.current_speed - 0.5*speed_var);
    3c0c:	20 e0       	ldi	r18, 0x00	; 0
    3c0e:	30 e0       	ldi	r19, 0x00	; 0
    3c10:	40 e0       	ldi	r20, 0x00	; 0
    3c12:	5f e3       	ldi	r21, 0x3F	; 63
    3c14:	6f 85       	ldd	r22, Y+15	; 0x0f
    3c16:	78 89       	ldd	r23, Y+16	; 0x10
    3c18:	89 89       	ldd	r24, Y+17	; 0x11
    3c1a:	9a 89       	ldd	r25, Y+18	; 0x12
    3c1c:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    3c20:	9b 01       	movw	r18, r22
    3c22:	ac 01       	movw	r20, r24
    3c24:	c3 01       	movw	r24, r6
    3c26:	b2 01       	movw	r22, r4
    3c28:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    3c2c:	29 81       	ldd	r18, Y+1	; 0x01
    3c2e:	32 2d       	mov	r19, r2
    3c30:	43 2d       	mov	r20, r3
    3c32:	50 2f       	mov	r21, r16
    3c34:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    3c38:	9b 01       	movw	r18, r22
    3c3a:	ac 01       	movw	r20, r24
    3c3c:	6f 2d       	mov	r22, r15
    3c3e:	7e 2d       	mov	r23, r14
    3c40:	8d 2d       	mov	r24, r13
    3c42:	9c 2d       	mov	r25, r12
    3c44:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    3c48:	f6 2e       	mov	r15, r22
    3c4a:	e7 2e       	mov	r14, r23
    3c4c:	d8 2e       	mov	r13, r24
    3c4e:	c9 2e       	mov	r12, r25
            prep.current_speed -= speed_var;
    3c50:	2f 85       	ldd	r18, Y+15	; 0x0f
    3c52:	38 89       	ldd	r19, Y+16	; 0x10
    3c54:	49 89       	ldd	r20, Y+17	; 0x11
    3c56:	5a 89       	ldd	r21, Y+18	; 0x12
    3c58:	c3 01       	movw	r24, r6
    3c5a:	b2 01       	movw	r22, r4
    3c5c:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    3c60:	60 93 71 01 	sts	0x0171, r22	; 0x800171 <prep+0x17>
    3c64:	70 93 72 01 	sts	0x0172, r23	; 0x800172 <prep+0x18>
    3c68:	80 93 73 01 	sts	0x0173, r24	; 0x800173 <prep+0x19>
    3c6c:	90 93 74 01 	sts	0x0174, r25	; 0x800174 <prep+0x1a>
    3c70:	5b c1       	rjmp	.+694    	; 0x3f28 <st_prep_buffer+0xc18>
          }
          break;
        case RAMP_ACCEL:
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
    3c72:	ab 8d       	ldd	r26, Y+27	; 0x1b
    3c74:	bc 8d       	ldd	r27, Y+28	; 0x1c
    3c76:	5a 96       	adiw	r26, 0x1a	; 26
    3c78:	2d 91       	ld	r18, X+
    3c7a:	3d 91       	ld	r19, X+
    3c7c:	4d 91       	ld	r20, X+
    3c7e:	5c 91       	ld	r21, X
    3c80:	5d 97       	sbiw	r26, 0x1d	; 29
    3c82:	69 81       	ldd	r22, Y+1	; 0x01
    3c84:	72 2d       	mov	r23, r2
    3c86:	83 2d       	mov	r24, r3
    3c88:	90 2f       	mov	r25, r16
    3c8a:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    3c8e:	6f 87       	std	Y+15, r22	; 0x0f
    3c90:	78 8b       	std	Y+16, r23	; 0x10
    3c92:	89 8b       	std	Y+17, r24	; 0x11
    3c94:	9a 8b       	std	Y+18, r25	; 0x12
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
    3c96:	40 90 71 01 	lds	r4, 0x0171	; 0x800171 <prep+0x17>
    3c9a:	50 90 72 01 	lds	r5, 0x0172	; 0x800172 <prep+0x18>
    3c9e:	60 90 73 01 	lds	r6, 0x0173	; 0x800173 <prep+0x19>
    3ca2:	70 90 74 01 	lds	r7, 0x0174	; 0x800174 <prep+0x1a>
    3ca6:	20 e0       	ldi	r18, 0x00	; 0
    3ca8:	30 e0       	ldi	r19, 0x00	; 0
    3caa:	40 e0       	ldi	r20, 0x00	; 0
    3cac:	5f e3       	ldi	r21, 0x3F	; 63
    3cae:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    3cb2:	a3 01       	movw	r20, r6
    3cb4:	92 01       	movw	r18, r4
    3cb6:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    3cba:	29 81       	ldd	r18, Y+1	; 0x01
    3cbc:	32 2d       	mov	r19, r2
    3cbe:	43 2d       	mov	r20, r3
    3cc0:	50 2f       	mov	r21, r16
    3cc2:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    3cc6:	9b 01       	movw	r18, r22
    3cc8:	ac 01       	movw	r20, r24
    3cca:	6f 2d       	mov	r22, r15
    3ccc:	7e 2d       	mov	r23, r14
    3cce:	8d 2d       	mov	r24, r13
    3cd0:	9c 2d       	mov	r25, r12
    3cd2:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    3cd6:	f6 2e       	mov	r15, r22
    3cd8:	e7 2e       	mov	r14, r23
    3cda:	d8 2e       	mov	r13, r24
    3cdc:	c9 2e       	mov	r12, r25
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
    3cde:	26 2f       	mov	r18, r22
    3ce0:	37 2f       	mov	r19, r23
    3ce2:	48 2f       	mov	r20, r24
    3ce4:	59 2f       	mov	r21, r25
    3ce6:	6d 8d       	ldd	r22, Y+29	; 0x1d
    3ce8:	7e 8d       	ldd	r23, Y+30	; 0x1e
    3cea:	8f 8d       	ldd	r24, Y+31	; 0x1f
    3cec:	98 a1       	ldd	r25, Y+32	; 0x20
    3cee:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    3cf2:	18 16       	cp	r1, r24
    3cf4:	a4 f5       	brge	.+104    	; 0x3d5e <st_prep_buffer+0xa4e>
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
    3cf6:	2d 8d       	ldd	r18, Y+29	; 0x1d
    3cf8:	3e 8d       	ldd	r19, Y+30	; 0x1e
    3cfa:	4f 8d       	ldd	r20, Y+31	; 0x1f
    3cfc:	58 a1       	ldd	r21, Y+32	; 0x20
    3cfe:	6b a5       	ldd	r22, Y+43	; 0x2b
    3d00:	7c a5       	ldd	r23, Y+44	; 0x2c
    3d02:	8d a5       	ldd	r24, Y+45	; 0x2d
    3d04:	9e a5       	ldd	r25, Y+46	; 0x2e
    3d06:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    3d0a:	9b 01       	movw	r18, r22
    3d0c:	ac 01       	movw	r20, r24
    3d0e:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    3d12:	6b 01       	movw	r12, r22
    3d14:	7c 01       	movw	r14, r24
    3d16:	a3 01       	movw	r20, r6
    3d18:	92 01       	movw	r18, r4
    3d1a:	6f 89       	ldd	r22, Y+23	; 0x17
    3d1c:	78 8d       	ldd	r23, Y+24	; 0x18
    3d1e:	89 8d       	ldd	r24, Y+25	; 0x19
    3d20:	9a 8d       	ldd	r25, Y+26	; 0x1a
    3d22:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    3d26:	9b 01       	movw	r18, r22
    3d28:	ac 01       	movw	r20, r24
    3d2a:	c7 01       	movw	r24, r14
    3d2c:	b6 01       	movw	r22, r12
    3d2e:	0e 94 6e 2f 	call	0x5edc	; 0x5edc <__divsf3>
    3d32:	69 83       	std	Y+1, r22	; 0x01
    3d34:	27 2e       	mov	r2, r23
    3d36:	38 2e       	mov	r3, r24
    3d38:	09 2f       	mov	r16, r25
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
    3d3a:	2f 89       	ldd	r18, Y+23	; 0x17
    3d3c:	38 8d       	ldd	r19, Y+24	; 0x18
    3d3e:	49 8d       	ldd	r20, Y+25	; 0x19
    3d40:	5a 8d       	ldd	r21, Y+26	; 0x1a
    3d42:	20 93 71 01 	sts	0x0171, r18	; 0x800171 <prep+0x17>
    3d46:	30 93 72 01 	sts	0x0172, r19	; 0x800172 <prep+0x18>
    3d4a:	40 93 73 01 	sts	0x0173, r20	; 0x800173 <prep+0x19>
    3d4e:	50 93 74 01 	sts	0x0174, r21	; 0x800174 <prep+0x1a>
    3d52:	1f a9       	ldd	r17, Y+55	; 0x37
          // NOTE: Acceleration ramp only computes during first do-while loop.
          speed_var = pl_block->acceleration*time_var;
          mm_remaining -= time_var*(prep.current_speed + 0.5*speed_var);
          if (mm_remaining < prep.accelerate_until) { // End of acceleration ramp.
            // Acceleration-cruise, acceleration-deceleration ramp junction, or end of block.
            mm_remaining = prep.accelerate_until; // NOTE: 0.0 at EOB
    3d54:	fd 8c       	ldd	r15, Y+29	; 0x1d
    3d56:	ee 8c       	ldd	r14, Y+30	; 0x1e
    3d58:	df 8c       	ldd	r13, Y+31	; 0x1f
    3d5a:	c8 a0       	ldd	r12, Y+32	; 0x20
    3d5c:	e5 c0       	rjmp	.+458    	; 0x3f28 <st_prep_buffer+0xc18>
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            if (mm_remaining == prep.decelerate_after) { prep.ramp_type = RAMP_DECEL; }
            else { prep.ramp_type = RAMP_CRUISE; }
            prep.current_speed = prep.maximum_speed;
          } else { // Acceleration only.
            prep.current_speed += speed_var;
    3d5e:	a3 01       	movw	r20, r6
    3d60:	92 01       	movw	r18, r4
    3d62:	6f 85       	ldd	r22, Y+15	; 0x0f
    3d64:	78 89       	ldd	r23, Y+16	; 0x10
    3d66:	89 89       	ldd	r24, Y+17	; 0x11
    3d68:	9a 89       	ldd	r25, Y+18	; 0x12
    3d6a:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    3d6e:	60 93 71 01 	sts	0x0171, r22	; 0x800171 <prep+0x17>
    3d72:	70 93 72 01 	sts	0x0172, r23	; 0x800172 <prep+0x18>
    3d76:	80 93 73 01 	sts	0x0173, r24	; 0x800173 <prep+0x19>
    3d7a:	90 93 74 01 	sts	0x0174, r25	; 0x800174 <prep+0x1a>
    3d7e:	d4 c0       	rjmp	.+424    	; 0x3f28 <st_prep_buffer+0xc18>
          break;
        case RAMP_CRUISE:
          // NOTE: mm_var used to retain the last mm_remaining for incomplete segment time_var calculations.
          // NOTE: If maximum_speed*time_var value is too low, round-off can cause mm_var to not change. To
          //   prevent this, simply enforce a minimum speed threshold in the planner.
          mm_var = mm_remaining - prep.maximum_speed*time_var;
    3d80:	2f 89       	ldd	r18, Y+23	; 0x17
    3d82:	38 8d       	ldd	r19, Y+24	; 0x18
    3d84:	49 8d       	ldd	r20, Y+25	; 0x19
    3d86:	5a 8d       	ldd	r21, Y+26	; 0x1a
    3d88:	69 81       	ldd	r22, Y+1	; 0x01
    3d8a:	72 2d       	mov	r23, r2
    3d8c:	83 2d       	mov	r24, r3
    3d8e:	90 2f       	mov	r25, r16
    3d90:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    3d94:	9b 01       	movw	r18, r22
    3d96:	ac 01       	movw	r20, r24
    3d98:	6f 2d       	mov	r22, r15
    3d9a:	7e 2d       	mov	r23, r14
    3d9c:	8d 2d       	mov	r24, r13
    3d9e:	9c 2d       	mov	r25, r12
    3da0:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    3da4:	46 2e       	mov	r4, r22
    3da6:	57 2e       	mov	r5, r23
    3da8:	68 2e       	mov	r6, r24
    3daa:	79 2e       	mov	r7, r25
          if (mm_var < prep.decelerate_after) { // End of cruise.
    3dac:	26 2f       	mov	r18, r22
    3dae:	37 2f       	mov	r19, r23
    3db0:	48 2f       	mov	r20, r24
    3db2:	59 2f       	mov	r21, r25
    3db4:	6d a1       	ldd	r22, Y+37	; 0x25
    3db6:	7e a1       	ldd	r23, Y+38	; 0x26
    3db8:	8f a1       	ldd	r24, Y+39	; 0x27
    3dba:	98 a5       	ldd	r25, Y+40	; 0x28
    3dbc:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    3dc0:	18 16       	cp	r1, r24
    3dc2:	0c f0       	brlt	.+2      	; 0x3dc6 <st_prep_buffer+0xab6>
    3dc4:	ad c0       	rjmp	.+346    	; 0x3f20 <st_prep_buffer+0xc10>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
    3dc6:	2d a1       	ldd	r18, Y+37	; 0x25
    3dc8:	3e a1       	ldd	r19, Y+38	; 0x26
    3dca:	4f a1       	ldd	r20, Y+39	; 0x27
    3dcc:	58 a5       	ldd	r21, Y+40	; 0x28
    3dce:	6f 2d       	mov	r22, r15
    3dd0:	7e 2d       	mov	r23, r14
    3dd2:	8d 2d       	mov	r24, r13
    3dd4:	9c 2d       	mov	r25, r12
    3dd6:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    3dda:	2f 89       	ldd	r18, Y+23	; 0x17
    3ddc:	38 8d       	ldd	r19, Y+24	; 0x18
    3dde:	49 8d       	ldd	r20, Y+25	; 0x19
    3de0:	5a 8d       	ldd	r21, Y+26	; 0x1a
    3de2:	0e 94 6e 2f 	call	0x5edc	; 0x5edc <__divsf3>
    3de6:	69 83       	std	Y+1, r22	; 0x01
    3de8:	27 2e       	mov	r2, r23
    3dea:	38 2e       	mov	r3, r24
    3dec:	09 2f       	mov	r16, r25
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
    3dee:	fd a0       	ldd	r15, Y+37	; 0x25
    3df0:	ee a0       	ldd	r14, Y+38	; 0x26
    3df2:	df a0       	ldd	r13, Y+39	; 0x27
    3df4:	c8 a4       	ldd	r12, Y+40	; 0x28
            prep.ramp_type = RAMP_DECEL;
    3df6:	19 ad       	ldd	r17, Y+57	; 0x39
    3df8:	97 c0       	rjmp	.+302    	; 0x3f28 <st_prep_buffer+0xc18>
            mm_remaining = mm_var;
          }
          break;
        default: // case RAMP_DECEL:
          // NOTE: mm_var used as a misc worker variable to prevent errors when near zero speed.
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
    3dfa:	ab 8d       	ldd	r26, Y+27	; 0x1b
    3dfc:	bc 8d       	ldd	r27, Y+28	; 0x1c
    3dfe:	5a 96       	adiw	r26, 0x1a	; 26
    3e00:	2d 91       	ld	r18, X+
    3e02:	3d 91       	ld	r19, X+
    3e04:	4d 91       	ld	r20, X+
    3e06:	5c 91       	ld	r21, X
    3e08:	5d 97       	sbiw	r26, 0x1d	; 29
    3e0a:	69 81       	ldd	r22, Y+1	; 0x01
    3e0c:	72 2d       	mov	r23, r2
    3e0e:	83 2d       	mov	r24, r3
    3e10:	90 2f       	mov	r25, r16
    3e12:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    3e16:	6f 87       	std	Y+15, r22	; 0x0f
    3e18:	78 8b       	std	Y+16, r23	; 0x10
    3e1a:	89 8b       	std	Y+17, r24	; 0x11
    3e1c:	9a 8b       	std	Y+18, r25	; 0x12
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
    3e1e:	40 90 71 01 	lds	r4, 0x0171	; 0x800171 <prep+0x17>
    3e22:	50 90 72 01 	lds	r5, 0x0172	; 0x800172 <prep+0x18>
    3e26:	60 90 73 01 	lds	r6, 0x0173	; 0x800173 <prep+0x19>
    3e2a:	70 90 74 01 	lds	r7, 0x0174	; 0x800174 <prep+0x1a>
    3e2e:	a3 01       	movw	r20, r6
    3e30:	92 01       	movw	r18, r4
    3e32:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    3e36:	88 23       	and	r24, r24
    3e38:	0c f0       	brlt	.+2      	; 0x3e3c <st_prep_buffer+0xb2c>
    3e3a:	3f c0       	rjmp	.+126    	; 0x3eba <st_prep_buffer+0xbaa>
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
    3e3c:	20 e0       	ldi	r18, 0x00	; 0
    3e3e:	30 e0       	ldi	r19, 0x00	; 0
    3e40:	40 e0       	ldi	r20, 0x00	; 0
    3e42:	5f e3       	ldi	r21, 0x3F	; 63
    3e44:	6f 85       	ldd	r22, Y+15	; 0x0f
    3e46:	78 89       	ldd	r23, Y+16	; 0x10
    3e48:	89 89       	ldd	r24, Y+17	; 0x11
    3e4a:	9a 89       	ldd	r25, Y+18	; 0x12
    3e4c:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    3e50:	9b 01       	movw	r18, r22
    3e52:	ac 01       	movw	r20, r24
    3e54:	c3 01       	movw	r24, r6
    3e56:	b2 01       	movw	r22, r4
    3e58:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    3e5c:	29 81       	ldd	r18, Y+1	; 0x01
    3e5e:	32 2d       	mov	r19, r2
    3e60:	43 2d       	mov	r20, r3
    3e62:	50 2f       	mov	r21, r16
    3e64:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    3e68:	9b 01       	movw	r18, r22
    3e6a:	ac 01       	movw	r20, r24
    3e6c:	6f 2d       	mov	r22, r15
    3e6e:	7e 2d       	mov	r23, r14
    3e70:	8d 2d       	mov	r24, r13
    3e72:	9c 2d       	mov	r25, r12
    3e74:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    3e78:	6b ab       	std	Y+51, r22	; 0x33
    3e7a:	7c ab       	std	Y+52, r23	; 0x34
    3e7c:	8d ab       	std	Y+53, r24	; 0x35
    3e7e:	9e ab       	std	Y+54, r25	; 0x36
            if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
    3e80:	2b 89       	ldd	r18, Y+19	; 0x13
    3e82:	3c 89       	ldd	r19, Y+20	; 0x14
    3e84:	4d 89       	ldd	r20, Y+21	; 0x15
    3e86:	5e 89       	ldd	r21, Y+22	; 0x16
    3e88:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    3e8c:	18 16       	cp	r1, r24
    3e8e:	ac f4       	brge	.+42     	; 0x3eba <st_prep_buffer+0xbaa>
              mm_remaining = mm_var;
              prep.current_speed -= speed_var;
    3e90:	2f 85       	ldd	r18, Y+15	; 0x0f
    3e92:	38 89       	ldd	r19, Y+16	; 0x10
    3e94:	49 89       	ldd	r20, Y+17	; 0x11
    3e96:	5a 89       	ldd	r21, Y+18	; 0x12
    3e98:	c3 01       	movw	r24, r6
    3e9a:	b2 01       	movw	r22, r4
    3e9c:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    3ea0:	60 93 71 01 	sts	0x0171, r22	; 0x800171 <prep+0x17>
    3ea4:	70 93 72 01 	sts	0x0172, r23	; 0x800172 <prep+0x18>
    3ea8:	80 93 73 01 	sts	0x0173, r24	; 0x800173 <prep+0x19>
    3eac:	90 93 74 01 	sts	0x0174, r25	; 0x800174 <prep+0x1a>
          speed_var = pl_block->acceleration*time_var; // Used as delta speed (mm/min)
          if (prep.current_speed > speed_var) { // Check if at or below zero speed.
            // Compute distance from end of segment to end of block.
            mm_var = mm_remaining - time_var*(prep.current_speed - 0.5*speed_var); // (mm)
            if (mm_var > prep.mm_complete) { // Typical case. In deceleration ramp.
              mm_remaining = mm_var;
    3eb0:	fb a8       	ldd	r15, Y+51	; 0x33
    3eb2:	ec a8       	ldd	r14, Y+52	; 0x34
    3eb4:	dd a8       	ldd	r13, Y+53	; 0x35
    3eb6:	ce a8       	ldd	r12, Y+54	; 0x36
              prep.current_speed -= speed_var;
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
    3eb8:	37 c0       	rjmp	.+110    	; 0x3f28 <st_prep_buffer+0xc18>
            }
          }
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
    3eba:	2b 89       	ldd	r18, Y+19	; 0x13
    3ebc:	3c 89       	ldd	r19, Y+20	; 0x14
    3ebe:	4d 89       	ldd	r20, Y+21	; 0x15
    3ec0:	5e 89       	ldd	r21, Y+22	; 0x16
    3ec2:	6f 2d       	mov	r22, r15
    3ec4:	7e 2d       	mov	r23, r14
    3ec6:	8d 2d       	mov	r24, r13
    3ec8:	9c 2d       	mov	r25, r12
    3eca:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    3ece:	9b 01       	movw	r18, r22
    3ed0:	ac 01       	movw	r20, r24
    3ed2:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    3ed6:	6b 01       	movw	r12, r22
    3ed8:	7c 01       	movw	r14, r24
    3eda:	2f a5       	ldd	r18, Y+47	; 0x2f
    3edc:	38 a9       	ldd	r19, Y+48	; 0x30
    3ede:	49 a9       	ldd	r20, Y+49	; 0x31
    3ee0:	5a a9       	ldd	r21, Y+50	; 0x32
    3ee2:	c3 01       	movw	r24, r6
    3ee4:	b2 01       	movw	r22, r4
    3ee6:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    3eea:	9b 01       	movw	r18, r22
    3eec:	ac 01       	movw	r20, r24
    3eee:	c7 01       	movw	r24, r14
    3ef0:	b6 01       	movw	r22, r12
    3ef2:	0e 94 6e 2f 	call	0x5edc	; 0x5edc <__divsf3>
    3ef6:	69 83       	std	Y+1, r22	; 0x01
    3ef8:	27 2e       	mov	r2, r23
    3efa:	38 2e       	mov	r3, r24
    3efc:	09 2f       	mov	r16, r25
          mm_remaining = prep.mm_complete;
          prep.current_speed = prep.exit_speed;
    3efe:	2f a5       	ldd	r18, Y+47	; 0x2f
    3f00:	38 a9       	ldd	r19, Y+48	; 0x30
    3f02:	49 a9       	ldd	r20, Y+49	; 0x31
    3f04:	5a a9       	ldd	r21, Y+50	; 0x32
    3f06:	20 93 71 01 	sts	0x0171, r18	; 0x800171 <prep+0x17>
    3f0a:	30 93 72 01 	sts	0x0172, r19	; 0x800172 <prep+0x18>
    3f0e:	40 93 73 01 	sts	0x0173, r20	; 0x800173 <prep+0x19>
    3f12:	50 93 74 01 	sts	0x0174, r21	; 0x800174 <prep+0x1a>
              break; // Segment complete. Exit switch-case statement. Continue do-while loop.
            }
          }
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
          mm_remaining = prep.mm_complete;
    3f16:	fb 88       	ldd	r15, Y+19	; 0x13
    3f18:	ec 88       	ldd	r14, Y+20	; 0x14
    3f1a:	dd 88       	ldd	r13, Y+21	; 0x15
    3f1c:	ce 88       	ldd	r12, Y+22	; 0x16
    3f1e:	04 c0       	rjmp	.+8      	; 0x3f28 <st_prep_buffer+0xc18>
            // Cruise-deceleration junction or end of block.
            time_var = (mm_remaining - prep.decelerate_after)/prep.maximum_speed;
            mm_remaining = prep.decelerate_after; // NOTE: 0.0 at EOB
            prep.ramp_type = RAMP_DECEL;
          } else { // Cruising only.
            mm_remaining = mm_var;
    3f20:	f4 2c       	mov	r15, r4
    3f22:	e5 2c       	mov	r14, r5
    3f24:	d6 2c       	mov	r13, r6
    3f26:	c7 2c       	mov	r12, r7
          // Otherwise, at end of block or end of forced-deceleration.
          time_var = 2.0*(mm_remaining-prep.mm_complete)/(prep.current_speed+prep.exit_speed);
          mm_remaining = prep.mm_complete;
          prep.current_speed = prep.exit_speed;
      }
      dt += time_var; // Add computed ramp time to total segment time.
    3f28:	29 81       	ldd	r18, Y+1	; 0x01
    3f2a:	32 2d       	mov	r19, r2
    3f2c:	43 2d       	mov	r20, r3
    3f2e:	50 2f       	mov	r21, r16
    3f30:	c5 01       	movw	r24, r10
    3f32:	b4 01       	movw	r22, r8
    3f34:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    3f38:	4b 01       	movw	r8, r22
    3f3a:	5c 01       	movw	r10, r24
      if (dt < dt_max) { time_var = dt_max - dt; } // **Incomplete** At ramp junction.
    3f3c:	9b 01       	movw	r18, r22
    3f3e:	ac 01       	movw	r20, r24
    3f40:	6d 81       	ldd	r22, Y+5	; 0x05
    3f42:	79 85       	ldd	r23, Y+9	; 0x09
    3f44:	8d 85       	ldd	r24, Y+13	; 0x0d
    3f46:	9e 85       	ldd	r25, Y+14	; 0x0e
    3f48:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    3f4c:	18 16       	cp	r1, r24
    3f4e:	6c f4       	brge	.+26     	; 0x3f6a <st_prep_buffer+0xc5a>
    3f50:	a5 01       	movw	r20, r10
    3f52:	94 01       	movw	r18, r8
    3f54:	6d 81       	ldd	r22, Y+5	; 0x05
    3f56:	79 85       	ldd	r23, Y+9	; 0x09
    3f58:	8d 85       	ldd	r24, Y+13	; 0x0d
    3f5a:	9e 85       	ldd	r25, Y+14	; 0x0e
    3f5c:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    3f60:	69 83       	std	Y+1, r22	; 0x01
    3f62:	27 2e       	mov	r2, r23
    3f64:	38 2e       	mov	r3, r24
    3f66:	09 2f       	mov	r16, r25
    3f68:	29 c0       	rjmp	.+82     	; 0x3fbc <st_prep_buffer+0xcac>
      else {
        if (mm_remaining > minimum_mm) { // Check for very slow segments with zero steps.
    3f6a:	29 a1       	ldd	r18, Y+33	; 0x21
    3f6c:	3a a1       	ldd	r19, Y+34	; 0x22
    3f6e:	4b a1       	ldd	r20, Y+35	; 0x23
    3f70:	5c a1       	ldd	r21, Y+36	; 0x24
    3f72:	6f 2d       	mov	r22, r15
    3f74:	7e 2d       	mov	r23, r14
    3f76:	8d 2d       	mov	r24, r13
    3f78:	9c 2d       	mov	r25, r12
    3f7a:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    3f7e:	18 16       	cp	r1, r24
    3f80:	3c f0       	brlt	.+14     	; 0x3f90 <st_prep_buffer+0xc80>
    3f82:	3f 2c       	mov	r3, r15
    3f84:	2e 2c       	mov	r2, r14
    3f86:	5d 2c       	mov	r5, r13
    3f88:	4c 2c       	mov	r4, r12
    3f8a:	10 93 6c 01 	sts	0x016C, r17	; 0x80016c <prep+0x12>
    3f8e:	29 c0       	rjmp	.+82     	; 0x3fe2 <st_prep_buffer+0xcd2>
          // Increase segment time to ensure at least one step in segment. Override and loop
          // through distance calculations until minimum_mm or mm_complete.
          dt_max += DT_SEGMENT;
    3f90:	2e e3       	ldi	r18, 0x3E	; 62
    3f92:	33 ec       	ldi	r19, 0xC3	; 195
    3f94:	4e e2       	ldi	r20, 0x2E	; 46
    3f96:	59 e3       	ldi	r21, 0x39	; 57
    3f98:	6d 81       	ldd	r22, Y+5	; 0x05
    3f9a:	79 85       	ldd	r23, Y+9	; 0x09
    3f9c:	8d 85       	ldd	r24, Y+13	; 0x0d
    3f9e:	9e 85       	ldd	r25, Y+14	; 0x0e
    3fa0:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    3fa4:	6d 83       	std	Y+5, r22	; 0x05
    3fa6:	79 87       	std	Y+9, r23	; 0x09
    3fa8:	8d 87       	std	Y+13, r24	; 0x0d
    3faa:	9e 87       	std	Y+14, r25	; 0x0e
          time_var = dt_max - dt;
    3fac:	a5 01       	movw	r20, r10
    3fae:	94 01       	movw	r18, r8
    3fb0:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    3fb4:	69 83       	std	Y+1, r22	; 0x01
    3fb6:	27 2e       	mov	r2, r23
    3fb8:	38 2e       	mov	r3, r24
    3fba:	09 2f       	mov	r16, r25
        } else {
          break; // **Complete** Exit loop. Segment execution time maxed.
        }
      }
    } while (mm_remaining > prep.mm_complete); // **Complete** Exit loop. Profile complete.
    3fbc:	2b 89       	ldd	r18, Y+19	; 0x13
    3fbe:	3c 89       	ldd	r19, Y+20	; 0x14
    3fc0:	4d 89       	ldd	r20, Y+21	; 0x15
    3fc2:	5e 89       	ldd	r21, Y+22	; 0x16
    3fc4:	6f 2d       	mov	r22, r15
    3fc6:	7e 2d       	mov	r23, r14
    3fc8:	8d 2d       	mov	r24, r13
    3fca:	9c 2d       	mov	r25, r12
    3fcc:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    3fd0:	18 16       	cp	r1, r24
    3fd2:	0c f4       	brge	.+2      	; 0x3fd6 <st_prep_buffer+0xcc6>
    3fd4:	b3 cd       	rjmp	.-1178   	; 0x3b3c <st_prep_buffer+0x82c>
    3fd6:	3f 2c       	mov	r3, r15
    3fd8:	2e 2c       	mov	r2, r14
    3fda:	5d 2c       	mov	r5, r13
    3fdc:	4c 2c       	mov	r4, r12
    3fde:	10 93 6c 01 	sts	0x016C, r17	; 0x80016c <prep+0x12>
    #ifdef VARIABLE_SPINDLE
      /* -----------------------------------------------------------------------------------
        Compute spindle speed PWM output for step segment
      */
      
      if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
    3fe2:	e0 91 8a 01 	lds	r30, 0x018A	; 0x80018a <st_prep_block>
    3fe6:	f0 91 8b 01 	lds	r31, 0x018B	; 0x80018b <st_prep_block+0x1>
    3fea:	81 89       	ldd	r24, Z+17	; 0x11
    3fec:	81 11       	cpse	r24, r1
    3fee:	c1 c1       	rjmp	.+898    	; 0x4372 <st_prep_buffer+0x1062>
    3ff0:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <sys+0x4>
    3ff4:	83 fd       	sbrc	r24, 3
    3ff6:	cd c1       	rjmp	.+922    	; 0x4392 <st_prep_buffer+0x1082>
    3ff8:	14 c0       	rjmp	.+40     	; 0x4022 <st_prep_buffer+0xd12>
          float rpm = pl_block->spindle_speed;
          // NOTE: Feed and rapid overrides are independent of PWM value and do not alter laser power/rate.        
          if (st_prep_block->is_pwm_rate_adjusted) { rpm *= (prep.current_speed * prep.inv_rate); }
          // If current_speed is zero, then may need to be rpm_min*(100/MAX_SPINDLE_SPEED_OVERRIDE)
          // but this would be instantaneous only and during a motion. May not matter at all.
          prep.current_spindle_pwm = spindle_compute_pwm_value(rpm);
    3ffa:	0e 94 d4 10 	call	0x21a8	; 0x21a8 <spindle_compute_pwm_value>
    3ffe:	80 93 89 01 	sts	0x0189, r24	; 0x800189 <prep+0x2f>
    4002:	0a c0       	rjmp	.+20     	; 0x4018 <st_prep_buffer+0xd08>
        } else { 
          sys.spindle_speed = 0.0;
    4004:	10 92 89 05 	sts	0x0589, r1	; 0x800589 <sys+0xd>
    4008:	10 92 8a 05 	sts	0x058A, r1	; 0x80058a <sys+0xe>
    400c:	10 92 8b 05 	sts	0x058B, r1	; 0x80058b <sys+0xf>
    4010:	10 92 8c 05 	sts	0x058C, r1	; 0x80058c <sys+0x10>
          prep.current_spindle_pwm = SPINDLE_PWM_OFF_VALUE;
    4014:	10 92 89 01 	sts	0x0189, r1	; 0x800189 <prep+0x2f>
        }
        bit_false(sys.step_control,STEP_CONTROL_UPDATE_SPINDLE_PWM);
    4018:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <sys+0x4>
    401c:	87 7f       	andi	r24, 0xF7	; 247
    401e:	80 93 80 05 	sts	0x0580, r24	; 0x800580 <sys+0x4>
      }
      prep_segment->spindle_pwm = prep.current_spindle_pwm; // Reload segment PWM value
    4022:	09 a5       	ldd	r16, Y+41	; 0x29
    4024:	1a a5       	ldd	r17, Y+42	; 0x2a
    4026:	00 0f       	add	r16, r16
    4028:	11 1f       	adc	r17, r17
    402a:	00 0f       	add	r16, r16
    402c:	11 1f       	adc	r17, r17
    402e:	00 0f       	add	r16, r16
    4030:	11 1f       	adc	r17, r17
    4032:	49 a5       	ldd	r20, Y+41	; 0x29
    4034:	5a a5       	ldd	r21, Y+42	; 0x2a
    4036:	04 1b       	sub	r16, r20
    4038:	15 0b       	sbc	r17, r21
    403a:	09 54       	subi	r16, 0x49	; 73
    403c:	1e 4f       	sbci	r17, 0xFE	; 254
    403e:	80 91 89 01 	lds	r24, 0x0189	; 0x800189 <prep+0x2f>
    4042:	d8 01       	movw	r26, r16
    4044:	16 96       	adiw	r26, 0x06	; 6
    4046:	8c 93       	st	X, r24
       However, since floats have only 7.2 significant digits, long moves with extremely
       high step counts can exceed the precision of floats, which can lead to lost steps.
       Fortunately, this scenario is highly unlikely and unrealistic in CNC machines
       supported by Grbl (i.e. exceeding 10 meters axis travel at 200 step/mm).
    */
    float step_dist_remaining = prep.step_per_mm*mm_remaining; // Convert mm_remaining to steps
    4048:	20 91 64 01 	lds	r18, 0x0164	; 0x800164 <prep+0xa>
    404c:	30 91 65 01 	lds	r19, 0x0165	; 0x800165 <prep+0xb>
    4050:	40 91 66 01 	lds	r20, 0x0166	; 0x800166 <prep+0xc>
    4054:	50 91 67 01 	lds	r21, 0x0167	; 0x800167 <prep+0xd>
    4058:	63 2d       	mov	r22, r3
    405a:	72 2d       	mov	r23, r2
    405c:	85 2d       	mov	r24, r5
    405e:	94 2d       	mov	r25, r4
    4060:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    4064:	69 83       	std	Y+1, r22	; 0x01
    4066:	7a 83       	std	Y+2, r23	; 0x02
    4068:	8b 83       	std	Y+3, r24	; 0x03
    406a:	9c 83       	std	Y+4, r25	; 0x04
    float n_steps_remaining = ceil(step_dist_remaining); // Round-up current steps remaining
    406c:	0e 94 4d 2f 	call	0x5e9a	; 0x5e9a <ceil>
    4070:	6d 83       	std	Y+5, r22	; 0x05
    4072:	7e 83       	std	Y+6, r23	; 0x06
    4074:	8f 83       	std	Y+7, r24	; 0x07
    4076:	98 87       	std	Y+8, r25	; 0x08
    float last_n_steps_remaining = ceil(prep.steps_remaining); // Round-up last steps remaining
    4078:	60 91 60 01 	lds	r22, 0x0160	; 0x800160 <prep+0x6>
    407c:	70 91 61 01 	lds	r23, 0x0161	; 0x800161 <prep+0x7>
    4080:	80 91 62 01 	lds	r24, 0x0162	; 0x800162 <prep+0x8>
    4084:	90 91 63 01 	lds	r25, 0x0163	; 0x800163 <prep+0x9>
    4088:	0e 94 4d 2f 	call	0x5e9a	; 0x5e9a <ceil>
    408c:	69 87       	std	Y+9, r22	; 0x09
    408e:	7a 87       	std	Y+10, r23	; 0x0a
    4090:	8b 87       	std	Y+11, r24	; 0x0b
    4092:	9c 87       	std	Y+12, r25	; 0x0c
    prep_segment->n_step = last_n_steps_remaining-n_steps_remaining; // Compute number of steps to execute.
    4094:	2d 81       	ldd	r18, Y+5	; 0x05
    4096:	3e 81       	ldd	r19, Y+6	; 0x06
    4098:	4f 81       	ldd	r20, Y+7	; 0x07
    409a:	58 85       	ldd	r21, Y+8	; 0x08
    409c:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    40a0:	0e 94 e7 2f 	call	0x5fce	; 0x5fce <__fixunssfsi>
    40a4:	6b 01       	movw	r12, r22
    40a6:	7c 01       	movw	r14, r24
    40a8:	f8 01       	movw	r30, r16
    40aa:	71 83       	std	Z+1, r23	; 0x01
    40ac:	60 83       	st	Z, r22

    // Bail if we are at the end of a feed hold and don't have a step to execute.
    if (prep_segment->n_step == 0) {
    40ae:	67 2b       	or	r22, r23
    40b0:	41 f4       	brne	.+16     	; 0x40c2 <st_prep_buffer+0xdb2>
      if (sys.step_control & STEP_CONTROL_EXECUTE_HOLD) {
    40b2:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <sys+0x4>
    40b6:	81 ff       	sbrs	r24, 1
    40b8:	04 c0       	rjmp	.+8      	; 0x40c2 <st_prep_buffer+0xdb2>
        // Less than one step to decelerate to zero speed, but already very close. AMASS
        // requires full steps to execute. So, just bail.
        bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    40ba:	81 60       	ori	r24, 0x01	; 1
    40bc:	80 93 80 05 	sts	0x0580, r24	; 0x800580 <sys+0x4>
        #ifdef PARKING_ENABLE
          if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
        #endif
        return; // Segment not generated, but current step data still retained.
    40c0:	6e c1       	rjmp	.+732    	; 0x439e <st_prep_buffer+0x108e>
    // apply it with the partial step distance to the current segment, so that it minutely
    // adjusts the whole segment rate to keep step output exact. These rate adjustments are
    // typically very small and do not adversely effect performance, but ensures that Grbl
    // outputs the exact acceleration and velocity profiles as computed by the planner.
    dt += prep.dt_remainder; // Apply previous segment partial step execute time
    float inv_rate = dt/(last_n_steps_remaining - step_dist_remaining); // Compute adjusted step rate inverse
    40c2:	20 91 5c 01 	lds	r18, 0x015C	; 0x80015c <prep+0x2>
    40c6:	30 91 5d 01 	lds	r19, 0x015D	; 0x80015d <prep+0x3>
    40ca:	40 91 5e 01 	lds	r20, 0x015E	; 0x80015e <prep+0x4>
    40ce:	50 91 5f 01 	lds	r21, 0x015F	; 0x80015f <prep+0x5>
    40d2:	c5 01       	movw	r24, r10
    40d4:	b4 01       	movw	r22, r8
    40d6:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    40da:	4b 01       	movw	r8, r22
    40dc:	5c 01       	movw	r10, r24
    40de:	29 81       	ldd	r18, Y+1	; 0x01
    40e0:	3a 81       	ldd	r19, Y+2	; 0x02
    40e2:	4b 81       	ldd	r20, Y+3	; 0x03
    40e4:	5c 81       	ldd	r21, Y+4	; 0x04
    40e6:	69 85       	ldd	r22, Y+9	; 0x09
    40e8:	7a 85       	ldd	r23, Y+10	; 0x0a
    40ea:	8b 85       	ldd	r24, Y+11	; 0x0b
    40ec:	9c 85       	ldd	r25, Y+12	; 0x0c
    40ee:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    40f2:	9b 01       	movw	r18, r22
    40f4:	ac 01       	movw	r20, r24
    40f6:	c5 01       	movw	r24, r10
    40f8:	b4 01       	movw	r22, r8
    40fa:	0e 94 6e 2f 	call	0x5edc	; 0x5edc <__divsf3>
    40fe:	4b 01       	movw	r8, r22
    4100:	5c 01       	movw	r10, r24

    // Compute CPU cycles per step for the prepped segment.
    uint32_t cycles = ceil( (TICKS_PER_MICROSECOND*1000000*60)*inv_rate ); // (cycles/step)
    4102:	20 ec       	ldi	r18, 0xC0	; 192
    4104:	31 ee       	ldi	r19, 0xE1	; 225
    4106:	44 e6       	ldi	r20, 0x64	; 100
    4108:	5e e4       	ldi	r21, 0x4E	; 78
    410a:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    410e:	0e 94 4d 2f 	call	0x5e9a	; 0x5e9a <ceil>
    4112:	0e 94 e7 2f 	call	0x5fce	; 0x5fce <__fixunssfsi>

    #ifdef ADAPTIVE_MULTI_AXIS_STEP_SMOOTHING
      // Compute step timing and multi-axis smoothing level.
      // NOTE: AMASS overdrives the timer with each level, so only one prescalar is required.
      if (cycles < AMASS_LEVEL1) { prep_segment->amass_level = 0; }
    4116:	60 3d       	cpi	r22, 0xD0	; 208
    4118:	f7 e0       	ldi	r31, 0x07	; 7
    411a:	7f 07       	cpc	r23, r31
    411c:	81 05       	cpc	r24, r1
    411e:	91 05       	cpc	r25, r1
    4120:	80 f4       	brcc	.+32     	; 0x4142 <st_prep_buffer+0xe32>
    4122:	e9 a5       	ldd	r30, Y+41	; 0x29
    4124:	fa a5       	ldd	r31, Y+42	; 0x2a
    4126:	ee 0f       	add	r30, r30
    4128:	ff 1f       	adc	r31, r31
    412a:	ee 0f       	add	r30, r30
    412c:	ff 1f       	adc	r31, r31
    412e:	ee 0f       	add	r30, r30
    4130:	ff 1f       	adc	r31, r31
    4132:	29 a5       	ldd	r18, Y+41	; 0x29
    4134:	3a a5       	ldd	r19, Y+42	; 0x2a
    4136:	e2 1b       	sub	r30, r18
    4138:	f3 0b       	sbc	r31, r19
    413a:	e9 54       	subi	r30, 0x49	; 73
    413c:	fe 4f       	sbci	r31, 0xFE	; 254
    413e:	15 82       	std	Z+5, r1	; 0x05
    4140:	5d c0       	rjmp	.+186    	; 0x41fc <st_prep_buffer+0xeec>
      else {
        if (cycles < AMASS_LEVEL2) { prep_segment->amass_level = 1; }
    4142:	60 3a       	cpi	r22, 0xA0	; 160
    4144:	3f e0       	ldi	r19, 0x0F	; 15
    4146:	73 07       	cpc	r23, r19
    4148:	81 05       	cpc	r24, r1
    414a:	91 05       	cpc	r25, r1
    414c:	88 f4       	brcc	.+34     	; 0x4170 <st_prep_buffer+0xe60>
    414e:	e9 a5       	ldd	r30, Y+41	; 0x29
    4150:	fa a5       	ldd	r31, Y+42	; 0x2a
    4152:	ee 0f       	add	r30, r30
    4154:	ff 1f       	adc	r31, r31
    4156:	ee 0f       	add	r30, r30
    4158:	ff 1f       	adc	r31, r31
    415a:	ee 0f       	add	r30, r30
    415c:	ff 1f       	adc	r31, r31
    415e:	49 a5       	ldd	r20, Y+41	; 0x29
    4160:	5a a5       	ldd	r21, Y+42	; 0x2a
    4162:	e4 1b       	sub	r30, r20
    4164:	f5 0b       	sbc	r31, r21
    4166:	e9 54       	subi	r30, 0x49	; 73
    4168:	fe 4f       	sbci	r31, 0xFE	; 254
    416a:	51 e0       	ldi	r21, 0x01	; 1
    416c:	55 83       	std	Z+5, r21	; 0x05
    416e:	27 c0       	rjmp	.+78     	; 0x41be <st_prep_buffer+0xeae>
        else if (cycles < AMASS_LEVEL3) { prep_segment->amass_level = 2; }
    4170:	60 34       	cpi	r22, 0x40	; 64
    4172:	af e1       	ldi	r26, 0x1F	; 31
    4174:	7a 07       	cpc	r23, r26
    4176:	81 05       	cpc	r24, r1
    4178:	91 05       	cpc	r25, r1
    417a:	88 f4       	brcc	.+34     	; 0x419e <st_prep_buffer+0xe8e>
    417c:	e9 a5       	ldd	r30, Y+41	; 0x29
    417e:	fa a5       	ldd	r31, Y+42	; 0x2a
    4180:	ee 0f       	add	r30, r30
    4182:	ff 1f       	adc	r31, r31
    4184:	ee 0f       	add	r30, r30
    4186:	ff 1f       	adc	r31, r31
    4188:	ee 0f       	add	r30, r30
    418a:	ff 1f       	adc	r31, r31
    418c:	29 a5       	ldd	r18, Y+41	; 0x29
    418e:	3a a5       	ldd	r19, Y+42	; 0x2a
    4190:	e2 1b       	sub	r30, r18
    4192:	f3 0b       	sbc	r31, r19
    4194:	e9 54       	subi	r30, 0x49	; 73
    4196:	fe 4f       	sbci	r31, 0xFE	; 254
    4198:	32 e0       	ldi	r19, 0x02	; 2
    419a:	35 83       	std	Z+5, r19	; 0x05
    419c:	10 c0       	rjmp	.+32     	; 0x41be <st_prep_buffer+0xeae>
        else { prep_segment->amass_level = 3; }
    419e:	e9 a5       	ldd	r30, Y+41	; 0x29
    41a0:	fa a5       	ldd	r31, Y+42	; 0x2a
    41a2:	ee 0f       	add	r30, r30
    41a4:	ff 1f       	adc	r31, r31
    41a6:	ee 0f       	add	r30, r30
    41a8:	ff 1f       	adc	r31, r31
    41aa:	ee 0f       	add	r30, r30
    41ac:	ff 1f       	adc	r31, r31
    41ae:	49 a5       	ldd	r20, Y+41	; 0x29
    41b0:	5a a5       	ldd	r21, Y+42	; 0x2a
    41b2:	e4 1b       	sub	r30, r20
    41b4:	f5 0b       	sbc	r31, r21
    41b6:	e9 54       	subi	r30, 0x49	; 73
    41b8:	fe 4f       	sbci	r31, 0xFE	; 254
    41ba:	53 e0       	ldi	r21, 0x03	; 3
    41bc:	55 83       	std	Z+5, r21	; 0x05
        cycles >>= prep_segment->amass_level;
    41be:	e9 a5       	ldd	r30, Y+41	; 0x29
    41c0:	fa a5       	ldd	r31, Y+42	; 0x2a
    41c2:	ee 0f       	add	r30, r30
    41c4:	ff 1f       	adc	r31, r31
    41c6:	ee 0f       	add	r30, r30
    41c8:	ff 1f       	adc	r31, r31
    41ca:	ee 0f       	add	r30, r30
    41cc:	ff 1f       	adc	r31, r31
    41ce:	a9 a5       	ldd	r26, Y+41	; 0x29
    41d0:	ba a5       	ldd	r27, Y+42	; 0x2a
    41d2:	ea 1b       	sub	r30, r26
    41d4:	fb 0b       	sbc	r31, r27
    41d6:	e9 54       	subi	r30, 0x49	; 73
    41d8:	fe 4f       	sbci	r31, 0xFE	; 254
    41da:	25 81       	ldd	r18, Z+5	; 0x05
    41dc:	02 2e       	mov	r0, r18
    41de:	04 c0       	rjmp	.+8      	; 0x41e8 <st_prep_buffer+0xed8>
    41e0:	96 95       	lsr	r25
    41e2:	87 95       	ror	r24
    41e4:	77 95       	ror	r23
    41e6:	67 95       	ror	r22
    41e8:	0a 94       	dec	r0
    41ea:	d2 f7       	brpl	.-12     	; 0x41e0 <st_prep_buffer+0xed0>
        prep_segment->n_step <<= prep_segment->amass_level;
    41ec:	a6 01       	movw	r20, r12
    41ee:	02 c0       	rjmp	.+4      	; 0x41f4 <st_prep_buffer+0xee4>
    41f0:	44 0f       	add	r20, r20
    41f2:	55 1f       	adc	r21, r21
    41f4:	2a 95       	dec	r18
    41f6:	e2 f7       	brpl	.-8      	; 0x41f0 <st_prep_buffer+0xee0>
    41f8:	51 83       	std	Z+1, r21	; 0x01
    41fa:	40 83       	st	Z, r20
      }
      if (cycles < (1UL << 16)) { prep_segment->cycles_per_tick = cycles; } // < 65536 (4.1ms @ 16MHz)
    41fc:	61 15       	cp	r22, r1
    41fe:	71 05       	cpc	r23, r1
    4200:	51 e0       	ldi	r21, 0x01	; 1
    4202:	85 07       	cpc	r24, r21
    4204:	91 05       	cpc	r25, r1
    4206:	88 f4       	brcc	.+34     	; 0x422a <st_prep_buffer+0xf1a>
    4208:	e9 a5       	ldd	r30, Y+41	; 0x29
    420a:	fa a5       	ldd	r31, Y+42	; 0x2a
    420c:	ee 0f       	add	r30, r30
    420e:	ff 1f       	adc	r31, r31
    4210:	ee 0f       	add	r30, r30
    4212:	ff 1f       	adc	r31, r31
    4214:	ee 0f       	add	r30, r30
    4216:	ff 1f       	adc	r31, r31
    4218:	a9 a5       	ldd	r26, Y+41	; 0x29
    421a:	ba a5       	ldd	r27, Y+42	; 0x2a
    421c:	ea 1b       	sub	r30, r26
    421e:	fb 0b       	sbc	r31, r27
    4220:	e9 54       	subi	r30, 0x49	; 73
    4222:	fe 4f       	sbci	r31, 0xFE	; 254
    4224:	73 83       	std	Z+3, r23	; 0x03
    4226:	62 83       	std	Z+2, r22	; 0x02
    4228:	13 c0       	rjmp	.+38     	; 0x4250 <st_prep_buffer+0xf40>
      else { prep_segment->cycles_per_tick = 0xffff; } // Just set the slowest speed possible.
    422a:	89 a5       	ldd	r24, Y+41	; 0x29
    422c:	9a a5       	ldd	r25, Y+42	; 0x2a
    422e:	88 0f       	add	r24, r24
    4230:	99 1f       	adc	r25, r25
    4232:	88 0f       	add	r24, r24
    4234:	99 1f       	adc	r25, r25
    4236:	88 0f       	add	r24, r24
    4238:	99 1f       	adc	r25, r25
    423a:	e9 a5       	ldd	r30, Y+41	; 0x29
    423c:	fa a5       	ldd	r31, Y+42	; 0x2a
    423e:	8e 1b       	sub	r24, r30
    4240:	9f 0b       	sbc	r25, r31
    4242:	fc 01       	movw	r30, r24
    4244:	e9 54       	subi	r30, 0x49	; 73
    4246:	fe 4f       	sbci	r31, 0xFE	; 254
    4248:	2f ef       	ldi	r18, 0xFF	; 255
    424a:	3f ef       	ldi	r19, 0xFF	; 255
    424c:	33 83       	std	Z+3, r19	; 0x03
    424e:	22 83       	std	Z+2, r18	; 0x02
        }
      }
    #endif

    // Segment complete! Increment segment buffer indices, so stepper ISR can immediately execute it.
    segment_buffer_head = segment_next_head;
    4250:	80 91 91 01 	lds	r24, 0x0191	; 0x800191 <segment_next_head>
    4254:	80 93 92 01 	sts	0x0192, r24	; 0x800192 <segment_buffer_head>
    if ( ++segment_next_head == SEGMENT_BUFFER_SIZE ) { segment_next_head = 0; }
    4258:	8f 5f       	subi	r24, 0xFF	; 255
    425a:	86 30       	cpi	r24, 0x06	; 6
    425c:	19 f0       	breq	.+6      	; 0x4264 <st_prep_buffer+0xf54>
    425e:	80 93 91 01 	sts	0x0191, r24	; 0x800191 <segment_next_head>
    4262:	02 c0       	rjmp	.+4      	; 0x4268 <st_prep_buffer+0xf58>
    4264:	10 92 91 01 	sts	0x0191, r1	; 0x800191 <segment_next_head>

    // Update the appropriate planner and segment data.
    pl_block->millimeters = mm_remaining;
    4268:	e0 91 8c 01 	lds	r30, 0x018C	; 0x80018c <pl_block>
    426c:	f0 91 8d 01 	lds	r31, 0x018D	; 0x80018d <pl_block+0x1>
    4270:	83 2d       	mov	r24, r3
    4272:	92 2d       	mov	r25, r2
    4274:	a5 2d       	mov	r26, r5
    4276:	b4 2d       	mov	r27, r4
    4278:	86 8f       	std	Z+30, r24	; 0x1e
    427a:	97 8f       	std	Z+31, r25	; 0x1f
    427c:	a0 a3       	std	Z+32, r26	; 0x20
    427e:	b1 a3       	std	Z+33, r27	; 0x21
    prep.steps_remaining = n_steps_remaining;
    4280:	8d 81       	ldd	r24, Y+5	; 0x05
    4282:	9e 81       	ldd	r25, Y+6	; 0x06
    4284:	af 81       	ldd	r26, Y+7	; 0x07
    4286:	b8 85       	ldd	r27, Y+8	; 0x08
    4288:	80 93 60 01 	sts	0x0160, r24	; 0x800160 <prep+0x6>
    428c:	90 93 61 01 	sts	0x0161, r25	; 0x800161 <prep+0x7>
    4290:	a0 93 62 01 	sts	0x0162, r26	; 0x800162 <prep+0x8>
    4294:	b0 93 63 01 	sts	0x0163, r27	; 0x800163 <prep+0x9>
    prep.dt_remainder = (n_steps_remaining - step_dist_remaining)*inv_rate;
    4298:	29 81       	ldd	r18, Y+1	; 0x01
    429a:	3a 81       	ldd	r19, Y+2	; 0x02
    429c:	4b 81       	ldd	r20, Y+3	; 0x03
    429e:	5c 81       	ldd	r21, Y+4	; 0x04
    42a0:	bc 01       	movw	r22, r24
    42a2:	cd 01       	movw	r24, r26
    42a4:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    42a8:	a5 01       	movw	r20, r10
    42aa:	94 01       	movw	r18, r8
    42ac:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    42b0:	60 93 5c 01 	sts	0x015C, r22	; 0x80015c <prep+0x2>
    42b4:	70 93 5d 01 	sts	0x015D, r23	; 0x80015d <prep+0x3>
    42b8:	80 93 5e 01 	sts	0x015E, r24	; 0x80015e <prep+0x4>
    42bc:	90 93 5f 01 	sts	0x015F, r25	; 0x80015f <prep+0x5>

    // Check for exit conditions and flag to load next planner block.
    if (mm_remaining == prep.mm_complete) {
    42c0:	20 91 6d 01 	lds	r18, 0x016D	; 0x80016d <prep+0x13>
    42c4:	30 91 6e 01 	lds	r19, 0x016E	; 0x80016e <prep+0x14>
    42c8:	40 91 6f 01 	lds	r20, 0x016F	; 0x80016f <prep+0x15>
    42cc:	50 91 70 01 	lds	r21, 0x0170	; 0x800170 <prep+0x16>
    42d0:	63 2d       	mov	r22, r3
    42d2:	72 2d       	mov	r23, r2
    42d4:	85 2d       	mov	r24, r5
    42d6:	94 2d       	mov	r25, r4
    42d8:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    42dc:	81 11       	cpse	r24, r1
    42de:	23 c0       	rjmp	.+70     	; 0x4326 <st_prep_buffer+0x1016>
    42e0:	75 2c       	mov	r7, r5
    42e2:	53 2c       	mov	r5, r3
      // End of planner block or forced-termination. No more distance to be executed.
      if (mm_remaining > 0.0) { // At end of forced-termination.
    42e4:	20 e0       	ldi	r18, 0x00	; 0
    42e6:	30 e0       	ldi	r19, 0x00	; 0
    42e8:	a9 01       	movw	r20, r18
    42ea:	65 2d       	mov	r22, r5
    42ec:	72 2d       	mov	r23, r2
    42ee:	87 2d       	mov	r24, r7
    42f0:	94 2d       	mov	r25, r4
    42f2:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    42f6:	18 16       	cp	r1, r24
    42f8:	34 f4       	brge	.+12     	; 0x4306 <st_prep_buffer+0xff6>
        // Reset prep parameters for resuming and then bail. Allow the stepper ISR to complete
        // the segment queue, where realtime protocol will set new state upon receiving the
        // cycle stop flag from the ISR. Prep_segment is blocked until then.
        bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    42fa:	ec e7       	ldi	r30, 0x7C	; 124
    42fc:	f5 e0       	ldi	r31, 0x05	; 5
    42fe:	84 81       	ldd	r24, Z+4	; 0x04
    4300:	81 60       	ori	r24, 0x01	; 1
    4302:	84 83       	std	Z+4, r24	; 0x04
        #ifdef PARKING_ENABLE
          if (!(prep.recalculate_flag & PREP_FLAG_PARKING)) { prep.recalculate_flag |= PREP_FLAG_HOLD_PARTIAL_BLOCK; }
        #endif
        return; // Bail!
    4304:	4c c0       	rjmp	.+152    	; 0x439e <st_prep_buffer+0x108e>
      } else { // End of planner block
        // The planner block is complete. All steps are set to be executed in the segment buffer.
        if (sys.step_control & STEP_CONTROL_EXECUTE_SYS_MOTION) {
    4306:	80 91 80 05 	lds	r24, 0x0580	; 0x800580 <sys+0x4>
    430a:	82 ff       	sbrs	r24, 2
    430c:	04 c0       	rjmp	.+8      	; 0x4316 <st_prep_buffer+0x1006>
          bit_true(sys.step_control,STEP_CONTROL_END_MOTION);
    430e:	81 60       	ori	r24, 0x01	; 1
    4310:	80 93 80 05 	sts	0x0580, r24	; 0x800580 <sys+0x4>
          return;
    4314:	44 c0       	rjmp	.+136    	; 0x439e <st_prep_buffer+0x108e>
        }
        pl_block = NULL; // Set pointer to indicate check and load next planner block.
    4316:	10 92 8d 01 	sts	0x018D, r1	; 0x80018d <pl_block+0x1>
    431a:	10 92 8c 01 	sts	0x018C, r1	; 0x80018c <pl_block>
        plan_discard_current_block();
    431e:	0e 94 2a 25 	call	0x4a54	; 0x4a54 <plan_discard_current_block>
          speed_var = pl_block->acceleration*time_var;
          if (prep.current_speed-prep.maximum_speed <= speed_var) {
            // Cruise or cruise-deceleration types only for deceleration override.
            mm_remaining = prep.accelerate_until;
            time_var = 2.0*(pl_block->millimeters-mm_remaining)/(prep.current_speed+prep.maximum_speed);
            prep.ramp_type = RAMP_CRUISE;
    4322:	91 e0       	ldi	r25, 0x01	; 1
    4324:	98 af       	std	Y+56, r25	; 0x38
void st_prep_buffer()
{
  // Block step prep buffer, while in a suspend state and there is no suspend motion to execute.
  if (bit_istrue(sys.step_control,STEP_CONTROL_END_MOTION)) { return; }

  while (segment_buffer_tail != segment_next_head) { // Check if we need to fill the buffer.
    4326:	90 91 93 01 	lds	r25, 0x0193	; 0x800193 <segment_buffer_tail>
    432a:	80 91 91 01 	lds	r24, 0x0191	; 0x800191 <segment_next_head>
    432e:	98 13       	cpse	r25, r24
    4330:	13 c8       	rjmp	.-4058   	; 0x3358 <st_prep_buffer+0x48>
    4332:	35 c0       	rjmp	.+106    	; 0x439e <st_prep_buffer+0x108e>
        Compute spindle speed PWM output for step segment
      */
      
      if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
        if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
          float rpm = pl_block->spindle_speed;
    4334:	ab 8d       	ldd	r26, Y+27	; 0x1b
    4336:	bc 8d       	ldd	r27, Y+28	; 0x1c
    4338:	9e 96       	adiw	r26, 0x2e	; 46
    433a:	cd 90       	ld	r12, X+
    433c:	dd 90       	ld	r13, X+
    433e:	ed 90       	ld	r14, X+
    4340:	fc 90       	ld	r15, X
    4342:	d1 97       	sbiw	r26, 0x31	; 49
          // NOTE: Feed and rapid overrides are independent of PWM value and do not alter laser power/rate.        
          if (st_prep_block->is_pwm_rate_adjusted) { rpm *= (prep.current_speed * prep.inv_rate); }
    4344:	20 91 85 01 	lds	r18, 0x0185	; 0x800185 <prep+0x2b>
    4348:	30 91 86 01 	lds	r19, 0x0186	; 0x800186 <prep+0x2c>
    434c:	40 91 87 01 	lds	r20, 0x0187	; 0x800187 <prep+0x2d>
    4350:	50 91 88 01 	lds	r21, 0x0188	; 0x800188 <prep+0x2e>
    4354:	60 91 71 01 	lds	r22, 0x0171	; 0x800171 <prep+0x17>
    4358:	70 91 72 01 	lds	r23, 0x0172	; 0x800172 <prep+0x18>
    435c:	80 91 73 01 	lds	r24, 0x0173	; 0x800173 <prep+0x19>
    4360:	90 91 74 01 	lds	r25, 0x0174	; 0x800174 <prep+0x1a>
    4364:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    4368:	a7 01       	movw	r20, r14
    436a:	96 01       	movw	r18, r12
    436c:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    4370:	44 ce       	rjmp	.-888    	; 0x3ffa <st_prep_buffer+0xcea>
      /* -----------------------------------------------------------------------------------
        Compute spindle speed PWM output for step segment
      */
      
      if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
        if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
    4372:	eb 8d       	ldd	r30, Y+27	; 0x1b
    4374:	fc 8d       	ldd	r31, Y+28	; 0x1c
    4376:	81 89       	ldd	r24, Z+17	; 0x11
    4378:	80 73       	andi	r24, 0x30	; 48
    437a:	09 f4       	brne	.+2      	; 0x437e <st_prep_buffer+0x106e>
    437c:	43 ce       	rjmp	.-890    	; 0x4004 <st_prep_buffer+0xcf4>
    437e:	da cf       	rjmp	.-76     	; 0x4334 <st_prep_buffer+0x1024>
          float rpm = pl_block->spindle_speed;
    4380:	ab 8d       	ldd	r26, Y+27	; 0x1b
    4382:	bc 8d       	ldd	r27, Y+28	; 0x1c
    4384:	9e 96       	adiw	r26, 0x2e	; 46
    4386:	6d 91       	ld	r22, X+
    4388:	7d 91       	ld	r23, X+
    438a:	8d 91       	ld	r24, X+
    438c:	9c 91       	ld	r25, X
    438e:	d1 97       	sbiw	r26, 0x31	; 49
    4390:	34 ce       	rjmp	.-920    	; 0x3ffa <st_prep_buffer+0xcea>
      /* -----------------------------------------------------------------------------------
        Compute spindle speed PWM output for step segment
      */
      
      if (st_prep_block->is_pwm_rate_adjusted || (sys.step_control & STEP_CONTROL_UPDATE_SPINDLE_PWM)) {
        if (pl_block->condition & (PL_COND_FLAG_SPINDLE_CW | PL_COND_FLAG_SPINDLE_CCW)) {
    4392:	eb 8d       	ldd	r30, Y+27	; 0x1b
    4394:	fc 8d       	ldd	r31, Y+28	; 0x1c
    4396:	81 89       	ldd	r24, Z+17	; 0x11
    4398:	80 73       	andi	r24, 0x30	; 48
    439a:	91 f7       	brne	.-28     	; 0x4380 <st_prep_buffer+0x1070>
    439c:	33 ce       	rjmp	.-922    	; 0x4004 <st_prep_buffer+0xcf4>
        plan_discard_current_block();
      }
    }

  }
}
    439e:	ea 96       	adiw	r28, 0x3a	; 58
    43a0:	0f b6       	in	r0, 0x3f	; 63
    43a2:	f8 94       	cli
    43a4:	de bf       	out	0x3e, r29	; 62
    43a6:	0f be       	out	0x3f, r0	; 63
    43a8:	cd bf       	out	0x3d, r28	; 61
    43aa:	df 91       	pop	r29
    43ac:	cf 91       	pop	r28
    43ae:	1f 91       	pop	r17
    43b0:	0f 91       	pop	r16
    43b2:	ff 90       	pop	r15
    43b4:	ef 90       	pop	r14
    43b6:	df 90       	pop	r13
    43b8:	cf 90       	pop	r12
    43ba:	bf 90       	pop	r11
    43bc:	af 90       	pop	r10
    43be:	9f 90       	pop	r9
    43c0:	8f 90       	pop	r8
    43c2:	7f 90       	pop	r7
    43c4:	6f 90       	pop	r6
    43c6:	5f 90       	pop	r5
    43c8:	4f 90       	pop	r4
    43ca:	3f 90       	pop	r3
    43cc:	2f 90       	pop	r2
    43ce:	08 95       	ret

000043d0 <eeprom_get_char>:
 *  \param  addr  EEPROM address to read from.
 *  \return  The byte read from the EEPROM address.
 */
unsigned char eeprom_get_char( unsigned int addr )
{
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
    43d0:	f9 99       	sbic	0x1f, 1	; 31
    43d2:	fe cf       	rjmp	.-4      	; 0x43d0 <eeprom_get_char>
	EEAR = addr; // Set EEPROM address register.
    43d4:	92 bd       	out	0x22, r25	; 34
    43d6:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
    43d8:	81 e0       	ldi	r24, 0x01	; 1
    43da:	8f bb       	out	0x1f, r24	; 31
	return EEDR; // Return the byte read from EEPROM.
    43dc:	80 b5       	in	r24, 0x20	; 32
}
    43de:	08 95       	ret

000043e0 <eeprom_put_char>:
void eeprom_put_char( unsigned int addr, unsigned char new_value )
{
	char old_value; // Old EEPROM value.
	char diff_mask; // Difference mask, i.e. old value XOR new value.

	cli(); // Ensure atomic operation for the write operation.
    43e0:	f8 94       	cli
	
	do {} while( EECR & (1<<EEPE) ); // Wait for completion of previous write.
    43e2:	f9 99       	sbic	0x1f, 1	; 31
    43e4:	fe cf       	rjmp	.-4      	; 0x43e2 <eeprom_put_char+0x2>
	#ifndef EEPROM_IGNORE_SELFPROG
	do {} while( SPMCSR & (1<<SELFPRGEN) ); // Wait for completion of SPM.
	#endif
	
	EEAR = addr; // Set EEPROM address register.
    43e6:	92 bd       	out	0x22, r25	; 34
    43e8:	81 bd       	out	0x21, r24	; 33
	EECR = (1<<EERE); // Start EEPROM read operation.
    43ea:	81 e0       	ldi	r24, 0x01	; 1
    43ec:	8f bb       	out	0x1f, r24	; 31
	old_value = EEDR; // Get old EEPROM value.
    43ee:	80 b5       	in	r24, 0x20	; 32
	diff_mask = old_value ^ new_value; // Get bit differences.
    43f0:	86 27       	eor	r24, r22
	
	// Check if any bits are changed to '1' in the new value.
	if( diff_mask & new_value ) {
    43f2:	96 2f       	mov	r25, r22
    43f4:	98 23       	and	r25, r24
    43f6:	59 f0       	breq	.+22     	; 0x440e <eeprom_put_char+0x2e>
		// Now we know that _some_ bits need to be erased to '1'.
		
		// Check if any bits in the new value are '0'.
		if( new_value != 0xff ) {
    43f8:	6f 3f       	cpi	r22, 0xFF	; 255
    43fa:	29 f0       	breq	.+10     	; 0x4406 <eeprom_put_char+0x26>
			// Now we know that some bits need to be programmed to '0' also.
			
			EEDR = new_value; // Set EEPROM data register.
    43fc:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    43fe:	84 e0       	ldi	r24, 0x04	; 4
    4400:	8f bb       	out	0x1f, r24	; 31
			       (0<<EEPM1) | (0<<EEPM0); // ...and Erase+Write mode.
			EECR |= (1<<EEPE);  // Start Erase+Write operation.
    4402:	f9 9a       	sbi	0x1f, 1	; 31
    4404:	0a c0       	rjmp	.+20     	; 0x441a <eeprom_put_char+0x3a>
		} else {
			// Now we know that all bits should be erased.

			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    4406:	84 e1       	ldi	r24, 0x14	; 20
    4408:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM0);  // ...and Erase-only mode.
			EECR |= (1<<EEPE);  // Start Erase-only operation.
    440a:	f9 9a       	sbi	0x1f, 1	; 31
    440c:	06 c0       	rjmp	.+12     	; 0x441a <eeprom_put_char+0x3a>
		}
	} else {
		// Now we know that _no_ bits need to be erased to '1'.
		
		// Check if any bits are changed from '1' in the old value.
		if( diff_mask ) {
    440e:	88 23       	and	r24, r24
    4410:	21 f0       	breq	.+8      	; 0x441a <eeprom_put_char+0x3a>
			// Now we know that _some_ bits need to the programmed to '0'.
			
			EEDR = new_value;   // Set EEPROM data register.
    4412:	60 bd       	out	0x20, r22	; 32
			EECR = (1<<EEMPE) | // Set Master Write Enable bit...
    4414:	84 e2       	ldi	r24, 0x24	; 36
    4416:	8f bb       	out	0x1f, r24	; 31
			       (1<<EEPM1);  // ...and Write-only mode.
			EECR |= (1<<EEPE);  // Start Write-only operation.
    4418:	f9 9a       	sbi	0x1f, 1	; 31
		}
	}
	
	sei(); // Restore interrupt flag state.
    441a:	78 94       	sei
    441c:	08 95       	ret

0000441e <memcpy_to_eeprom_with_checksum>:
}

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
    441e:	8f 92       	push	r8
    4420:	9f 92       	push	r9
    4422:	af 92       	push	r10
    4424:	bf 92       	push	r11
    4426:	cf 92       	push	r12
    4428:	df 92       	push	r13
    442a:	ef 92       	push	r14
    442c:	ff 92       	push	r15
    442e:	0f 93       	push	r16
    4430:	1f 93       	push	r17
    4432:	cf 93       	push	r28
    4434:	df 93       	push	r29
    4436:	7c 01       	movw	r14, r24
    4438:	8b 01       	movw	r16, r22
    443a:	6a 01       	movw	r12, r20
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    443c:	41 15       	cp	r20, r1
    443e:	51 05       	cpc	r21, r1
    4440:	09 f1       	breq	.+66     	; 0x4484 <memcpy_to_eeprom_with_checksum+0x66>
    4442:	5a 01       	movw	r10, r20
    4444:	c0 e0       	ldi	r28, 0x00	; 0
    checksum = (checksum << 1) || (checksum >> 7);
    4446:	d1 e0       	ldi	r29, 0x01	; 1
    4448:	01 c0       	rjmp	.+2      	; 0x444c <memcpy_to_eeprom_with_checksum+0x2e>
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
    444a:	c4 01       	movw	r24, r8


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
    444c:	c1 11       	cpse	r28, r1
    444e:	08 c0       	rjmp	.+16     	; 0x4460 <memcpy_to_eeprom_with_checksum+0x42>
    4450:	6c 2f       	mov	r22, r28
    4452:	cc 0f       	add	r28, r28
    4454:	77 0b       	sbc	r23, r23
    4456:	c7 2f       	mov	r28, r23
    4458:	cc 1f       	adc	r28, r28
    445a:	cc 27       	eor	r28, r28
    445c:	cc 1f       	adc	r28, r28
    445e:	01 c0       	rjmp	.+2      	; 0x4462 <memcpy_to_eeprom_with_checksum+0x44>
    4460:	cd 2f       	mov	r28, r29
    checksum += *source;
    4462:	f8 01       	movw	r30, r16
    4464:	61 91       	ld	r22, Z+
    4466:	8f 01       	movw	r16, r30
    4468:	c6 0f       	add	r28, r22
    eeprom_put_char(destination++, *(source++)); 
    446a:	4c 01       	movw	r8, r24
    446c:	ff ef       	ldi	r31, 0xFF	; 255
    446e:	8f 1a       	sub	r8, r31
    4470:	9f 0a       	sbc	r9, r31
    4472:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <eeprom_put_char>
// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
  for(; size > 0; size--) { 
    4476:	21 e0       	ldi	r18, 0x01	; 1
    4478:	a2 1a       	sub	r10, r18
    447a:	b1 08       	sbc	r11, r1
    447c:	31 f7       	brne	.-52     	; 0x444a <memcpy_to_eeprom_with_checksum+0x2c>
    447e:	ec 0c       	add	r14, r12
    4480:	fd 1c       	adc	r15, r13
    4482:	01 c0       	rjmp	.+2      	; 0x4486 <memcpy_to_eeprom_with_checksum+0x68>

// Extensions added as part of Grbl 


void memcpy_to_eeprom_with_checksum(unsigned int destination, char *source, unsigned int size) {
  unsigned char checksum = 0;
    4484:	c0 e0       	ldi	r28, 0x00	; 0
  for(; size > 0; size--) { 
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += *source;
    eeprom_put_char(destination++, *(source++)); 
  }
  eeprom_put_char(destination, checksum);
    4486:	6c 2f       	mov	r22, r28
    4488:	c7 01       	movw	r24, r14
    448a:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <eeprom_put_char>
}
    448e:	df 91       	pop	r29
    4490:	cf 91       	pop	r28
    4492:	1f 91       	pop	r17
    4494:	0f 91       	pop	r16
    4496:	ff 90       	pop	r15
    4498:	ef 90       	pop	r14
    449a:	df 90       	pop	r13
    449c:	cf 90       	pop	r12
    449e:	bf 90       	pop	r11
    44a0:	af 90       	pop	r10
    44a2:	9f 90       	pop	r9
    44a4:	8f 90       	pop	r8
    44a6:	08 95       	ret

000044a8 <memcpy_from_eeprom_with_checksum>:

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
    44a8:	8f 92       	push	r8
    44aa:	9f 92       	push	r9
    44ac:	af 92       	push	r10
    44ae:	bf 92       	push	r11
    44b0:	cf 92       	push	r12
    44b2:	df 92       	push	r13
    44b4:	ef 92       	push	r14
    44b6:	ff 92       	push	r15
    44b8:	0f 93       	push	r16
    44ba:	1f 93       	push	r17
    44bc:	cf 93       	push	r28
    44be:	df 93       	push	r29
    44c0:	7b 01       	movw	r14, r22
    44c2:	6a 01       	movw	r12, r20
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    44c4:	41 15       	cp	r20, r1
    44c6:	51 05       	cpc	r21, r1
    44c8:	11 f1       	breq	.+68     	; 0x450e <memcpy_from_eeprom_with_checksum+0x66>
    44ca:	c8 2f       	mov	r28, r24
    44cc:	d9 2f       	mov	r29, r25
    44ce:	5a 01       	movw	r10, r20
    44d0:	cb 01       	movw	r24, r22
    44d2:	91 2c       	mov	r9, r1
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    44d4:	88 24       	eor	r8, r8
    44d6:	83 94       	inc	r8
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    data = eeprom_get_char(source++);
    44d8:	8c 01       	movw	r16, r24
    44da:	0f 5f       	subi	r16, 0xFF	; 255
    44dc:	1f 4f       	sbci	r17, 0xFF	; 255
    44de:	0e 94 e8 21 	call	0x43d0	; 0x43d0 <eeprom_get_char>
    checksum = (checksum << 1) || (checksum >> 7);
    44e2:	91 10       	cpse	r9, r1
    44e4:	08 c0       	rjmp	.+16     	; 0x44f6 <memcpy_from_eeprom_with_checksum+0x4e>
    44e6:	29 2d       	mov	r18, r9
    44e8:	99 0c       	add	r9, r9
    44ea:	33 0b       	sbc	r19, r19
    44ec:	23 2f       	mov	r18, r19
    44ee:	22 1f       	adc	r18, r18
    44f0:	22 27       	eor	r18, r18
    44f2:	22 1f       	adc	r18, r18
    44f4:	01 c0       	rjmp	.+2      	; 0x44f8 <memcpy_from_eeprom_with_checksum+0x50>
    44f6:	28 2d       	mov	r18, r8
    checksum += data;    
    44f8:	98 2e       	mov	r9, r24
    44fa:	92 0e       	add	r9, r18
    *(destination++) = data; 
    44fc:	89 93       	st	Y+, r24
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    44fe:	81 e0       	ldi	r24, 0x01	; 1
    4500:	a8 1a       	sub	r10, r24
    4502:	b1 08       	sbc	r11, r1
    data = eeprom_get_char(source++);
    4504:	c8 01       	movw	r24, r16
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
  for(; size > 0; size--) { 
    4506:	41 f7       	brne	.-48     	; 0x44d8 <memcpy_from_eeprom_with_checksum+0x30>
    4508:	ec 0c       	add	r14, r12
    450a:	fd 1c       	adc	r15, r13
    450c:	01 c0       	rjmp	.+2      	; 0x4510 <memcpy_from_eeprom_with_checksum+0x68>
  }
  eeprom_put_char(destination, checksum);
}

int memcpy_from_eeprom_with_checksum(char *destination, unsigned int source, unsigned int size) {
  unsigned char data, checksum = 0;
    450e:	91 2c       	mov	r9, r1
    data = eeprom_get_char(source++);
    checksum = (checksum << 1) || (checksum >> 7);
    checksum += data;    
    *(destination++) = data; 
  }
  return(checksum == eeprom_get_char(source));
    4510:	c7 01       	movw	r24, r14
    4512:	0e 94 e8 21 	call	0x43d0	; 0x43d0 <eeprom_get_char>
    4516:	21 e0       	ldi	r18, 0x01	; 1
    4518:	30 e0       	ldi	r19, 0x00	; 0
    451a:	89 15       	cp	r24, r9
    451c:	11 f0       	breq	.+4      	; 0x4522 <memcpy_from_eeprom_with_checksum+0x7a>
    451e:	20 e0       	ldi	r18, 0x00	; 0
    4520:	30 e0       	ldi	r19, 0x00	; 0
}
    4522:	c9 01       	movw	r24, r18
    4524:	df 91       	pop	r29
    4526:	cf 91       	pop	r28
    4528:	1f 91       	pop	r17
    452a:	0f 91       	pop	r16
    452c:	ff 90       	pop	r15
    452e:	ef 90       	pop	r14
    4530:	df 90       	pop	r13
    4532:	cf 90       	pop	r12
    4534:	bf 90       	pop	r11
    4536:	af 90       	pop	r10
    4538:	9f 90       	pop	r9
    453a:	8f 90       	pop	r8
    453c:	08 95       	ret

0000453e <settings_store_startup_line>:
        return(STATUS_INVALID_STATEMENT);
    }
  }
  write_global_settings();
  return(STATUS_OK);
}
    453e:	0f 93       	push	r16
    4540:	1f 93       	push	r17
    4542:	cf 93       	push	r28
    4544:	c8 2f       	mov	r28, r24
    4546:	8b 01       	movw	r16, r22
    4548:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <protocol_buffer_synchronize>
    454c:	21 e5       	ldi	r18, 0x51	; 81
    454e:	c2 9f       	mul	r28, r18
    4550:	c0 01       	movw	r24, r0
    4552:	11 24       	eor	r1, r1
    4554:	40 e5       	ldi	r20, 0x50	; 80
    4556:	50 e0       	ldi	r21, 0x00	; 0
    4558:	b8 01       	movw	r22, r16
    455a:	9d 5f       	subi	r25, 0xFD	; 253
    455c:	0e 94 0f 22 	call	0x441e	; 0x441e <memcpy_to_eeprom_with_checksum>
    4560:	cf 91       	pop	r28
    4562:	1f 91       	pop	r17
    4564:	0f 91       	pop	r16
    4566:	08 95       	ret

00004568 <settings_write_coord_data>:
    4568:	0f 93       	push	r16
    456a:	1f 93       	push	r17
    456c:	cf 93       	push	r28
    456e:	c8 2f       	mov	r28, r24
    4570:	8b 01       	movw	r16, r22
    4572:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <protocol_buffer_synchronize>
    4576:	2d e0       	ldi	r18, 0x0D	; 13
    4578:	c2 9f       	mul	r28, r18
    457a:	c0 01       	movw	r24, r0
    457c:	11 24       	eor	r1, r1
    457e:	4c e0       	ldi	r20, 0x0C	; 12
    4580:	50 e0       	ldi	r21, 0x00	; 0
    4582:	b8 01       	movw	r22, r16
    4584:	9e 5f       	subi	r25, 0xFE	; 254
    4586:	0e 94 0f 22 	call	0x441e	; 0x441e <memcpy_to_eeprom_with_checksum>
    458a:	cf 91       	pop	r28
    458c:	1f 91       	pop	r17
    458e:	0f 91       	pop	r16
    4590:	08 95       	ret

00004592 <write_global_settings>:
    4592:	6a e0       	ldi	r22, 0x0A	; 10
    4594:	80 e0       	ldi	r24, 0x00	; 0
    4596:	90 e0       	ldi	r25, 0x00	; 0
    4598:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <eeprom_put_char>
    459c:	45 e5       	ldi	r20, 0x55	; 85
    459e:	50 e0       	ldi	r21, 0x00	; 0
    45a0:	6e e0       	ldi	r22, 0x0E	; 14
    45a2:	77 e0       	ldi	r23, 0x07	; 7
    45a4:	81 e0       	ldi	r24, 0x01	; 1
    45a6:	90 e0       	ldi	r25, 0x00	; 0
    45a8:	0e 94 0f 22 	call	0x441e	; 0x441e <memcpy_to_eeprom_with_checksum>
    45ac:	08 95       	ret

000045ae <settings_restore>:
    45ae:	0f 93       	push	r16
    45b0:	1f 93       	push	r17
    45b2:	cf 93       	push	r28
    45b4:	df 93       	push	r29
    45b6:	cd b7       	in	r28, 0x3d	; 61
    45b8:	de b7       	in	r29, 0x3e	; 62
    45ba:	2c 97       	sbiw	r28, 0x0c	; 12
    45bc:	0f b6       	in	r0, 0x3f	; 63
    45be:	f8 94       	cli
    45c0:	de bf       	out	0x3e, r29	; 62
    45c2:	0f be       	out	0x3f, r0	; 63
    45c4:	cd bf       	out	0x3d, r28	; 61
    45c6:	08 2f       	mov	r16, r24
    45c8:	80 ff       	sbrs	r24, 0
    45ca:	0b c0       	rjmp	.+22     	; 0x45e2 <settings_restore+0x34>
    45cc:	85 e5       	ldi	r24, 0x55	; 85
    45ce:	e4 e1       	ldi	r30, 0x14	; 20
    45d0:	f2 e0       	ldi	r31, 0x02	; 2
    45d2:	ae e0       	ldi	r26, 0x0E	; 14
    45d4:	b7 e0       	ldi	r27, 0x07	; 7
    45d6:	05 90       	lpm	r0, Z+
    45d8:	0d 92       	st	X+, r0
    45da:	8a 95       	dec	r24
    45dc:	e1 f7       	brne	.-8      	; 0x45d6 <settings_restore+0x28>
    45de:	0e 94 c9 22 	call	0x4592	; 0x4592 <write_global_settings>
    45e2:	01 ff       	sbrs	r16, 1
    45e4:	11 c0       	rjmp	.+34     	; 0x4608 <settings_restore+0x5a>
    45e6:	fe 01       	movw	r30, r28
    45e8:	31 96       	adiw	r30, 0x01	; 1
    45ea:	8c e0       	ldi	r24, 0x0C	; 12
    45ec:	df 01       	movw	r26, r30
    45ee:	1d 92       	st	X+, r1
    45f0:	8a 95       	dec	r24
    45f2:	e9 f7       	brne	.-6      	; 0x45ee <settings_restore+0x40>
    45f4:	10 e0       	ldi	r17, 0x00	; 0
    45f6:	be 01       	movw	r22, r28
    45f8:	6f 5f       	subi	r22, 0xFF	; 255
    45fa:	7f 4f       	sbci	r23, 0xFF	; 255
    45fc:	81 2f       	mov	r24, r17
    45fe:	0e 94 b4 22 	call	0x4568	; 0x4568 <settings_write_coord_data>
    4602:	1f 5f       	subi	r17, 0xFF	; 255
    4604:	18 30       	cpi	r17, 0x08	; 8
    4606:	b9 f7       	brne	.-18     	; 0x45f6 <settings_restore+0x48>
    4608:	02 ff       	sbrs	r16, 2
    460a:	14 c0       	rjmp	.+40     	; 0x4634 <settings_restore+0x86>
    460c:	60 e0       	ldi	r22, 0x00	; 0
    460e:	80 e0       	ldi	r24, 0x00	; 0
    4610:	93 e0       	ldi	r25, 0x03	; 3
    4612:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <eeprom_put_char>
    4616:	60 e0       	ldi	r22, 0x00	; 0
    4618:	81 e0       	ldi	r24, 0x01	; 1
    461a:	93 e0       	ldi	r25, 0x03	; 3
    461c:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <eeprom_put_char>
    4620:	60 e0       	ldi	r22, 0x00	; 0
    4622:	81 e5       	ldi	r24, 0x51	; 81
    4624:	93 e0       	ldi	r25, 0x03	; 3
    4626:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <eeprom_put_char>
    462a:	60 e0       	ldi	r22, 0x00	; 0
    462c:	82 e5       	ldi	r24, 0x52	; 82
    462e:	93 e0       	ldi	r25, 0x03	; 3
    4630:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <eeprom_put_char>
    4634:	03 ff       	sbrs	r16, 3
    4636:	0a c0       	rjmp	.+20     	; 0x464c <settings_restore+0x9e>
    4638:	60 e0       	ldi	r22, 0x00	; 0
    463a:	8e ea       	ldi	r24, 0xAE	; 174
    463c:	93 e0       	ldi	r25, 0x03	; 3
    463e:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <eeprom_put_char>
    4642:	60 e0       	ldi	r22, 0x00	; 0
    4644:	8f ea       	ldi	r24, 0xAF	; 175
    4646:	93 e0       	ldi	r25, 0x03	; 3
    4648:	0e 94 f0 21 	call	0x43e0	; 0x43e0 <eeprom_put_char>
    464c:	2c 96       	adiw	r28, 0x0c	; 12
    464e:	0f b6       	in	r0, 0x3f	; 63
    4650:	f8 94       	cli
    4652:	de bf       	out	0x3e, r29	; 62
    4654:	0f be       	out	0x3f, r0	; 63
    4656:	cd bf       	out	0x3d, r28	; 61
    4658:	df 91       	pop	r29
    465a:	cf 91       	pop	r28
    465c:	1f 91       	pop	r17
    465e:	0f 91       	pop	r16
    4660:	08 95       	ret

00004662 <settings_read_startup_line>:
    4662:	1f 93       	push	r17
    4664:	cf 93       	push	r28
    4666:	df 93       	push	r29
    4668:	18 2f       	mov	r17, r24
    466a:	eb 01       	movw	r28, r22
    466c:	81 e5       	ldi	r24, 0x51	; 81
    466e:	18 9f       	mul	r17, r24
    4670:	b0 01       	movw	r22, r0
    4672:	11 24       	eor	r1, r1
    4674:	7d 5f       	subi	r23, 0xFD	; 253
    4676:	40 e5       	ldi	r20, 0x50	; 80
    4678:	50 e0       	ldi	r21, 0x00	; 0
    467a:	ce 01       	movw	r24, r28
    467c:	0e 94 54 22 	call	0x44a8	; 0x44a8 <memcpy_from_eeprom_with_checksum>
    4680:	89 2b       	or	r24, r25
    4682:	39 f4       	brne	.+14     	; 0x4692 <settings_read_startup_line+0x30>
    4684:	18 82       	st	Y, r1
    4686:	be 01       	movw	r22, r28
    4688:	81 2f       	mov	r24, r17
    468a:	0e 94 9f 22 	call	0x453e	; 0x453e <settings_store_startup_line>
    468e:	80 e0       	ldi	r24, 0x00	; 0
    4690:	01 c0       	rjmp	.+2      	; 0x4694 <settings_read_startup_line+0x32>
    4692:	81 e0       	ldi	r24, 0x01	; 1
    4694:	df 91       	pop	r29
    4696:	cf 91       	pop	r28
    4698:	1f 91       	pop	r17
    469a:	08 95       	ret

0000469c <settings_read_coord_data>:
    469c:	1f 93       	push	r17
    469e:	cf 93       	push	r28
    46a0:	df 93       	push	r29
    46a2:	18 2f       	mov	r17, r24
    46a4:	eb 01       	movw	r28, r22
    46a6:	8d e0       	ldi	r24, 0x0D	; 13
    46a8:	18 9f       	mul	r17, r24
    46aa:	b0 01       	movw	r22, r0
    46ac:	11 24       	eor	r1, r1
    46ae:	7e 5f       	subi	r23, 0xFE	; 254
    46b0:	4c e0       	ldi	r20, 0x0C	; 12
    46b2:	50 e0       	ldi	r21, 0x00	; 0
    46b4:	ce 01       	movw	r24, r28
    46b6:	0e 94 54 22 	call	0x44a8	; 0x44a8 <memcpy_from_eeprom_with_checksum>
    46ba:	89 2b       	or	r24, r25
    46bc:	59 f4       	brne	.+22     	; 0x46d4 <settings_read_coord_data+0x38>
    46be:	8c e0       	ldi	r24, 0x0C	; 12
    46c0:	fe 01       	movw	r30, r28
    46c2:	11 92       	st	Z+, r1
    46c4:	8a 95       	dec	r24
    46c6:	e9 f7       	brne	.-6      	; 0x46c2 <settings_read_coord_data+0x26>
    46c8:	be 01       	movw	r22, r28
    46ca:	81 2f       	mov	r24, r17
    46cc:	0e 94 b4 22 	call	0x4568	; 0x4568 <settings_write_coord_data>
    46d0:	80 e0       	ldi	r24, 0x00	; 0
    46d2:	01 c0       	rjmp	.+2      	; 0x46d6 <settings_read_coord_data+0x3a>
    46d4:	81 e0       	ldi	r24, 0x01	; 1
    46d6:	df 91       	pop	r29
    46d8:	cf 91       	pop	r28
    46da:	1f 91       	pop	r17
    46dc:	08 95       	ret

000046de <read_global_settings>:
    46de:	80 e0       	ldi	r24, 0x00	; 0
    46e0:	90 e0       	ldi	r25, 0x00	; 0
    46e2:	0e 94 e8 21 	call	0x43d0	; 0x43d0 <eeprom_get_char>
    46e6:	8a 30       	cpi	r24, 0x0A	; 10
    46e8:	69 f4       	brne	.+26     	; 0x4704 <read_global_settings+0x26>
    46ea:	45 e5       	ldi	r20, 0x55	; 85
    46ec:	50 e0       	ldi	r21, 0x00	; 0
    46ee:	61 e0       	ldi	r22, 0x01	; 1
    46f0:	70 e0       	ldi	r23, 0x00	; 0
    46f2:	8e e0       	ldi	r24, 0x0E	; 14
    46f4:	97 e0       	ldi	r25, 0x07	; 7
    46f6:	0e 94 54 22 	call	0x44a8	; 0x44a8 <memcpy_from_eeprom_with_checksum>
    46fa:	21 e0       	ldi	r18, 0x01	; 1
    46fc:	89 2b       	or	r24, r25
    46fe:	19 f4       	brne	.+6      	; 0x4706 <read_global_settings+0x28>
    4700:	20 e0       	ldi	r18, 0x00	; 0
    4702:	01 c0       	rjmp	.+2      	; 0x4706 <read_global_settings+0x28>
    4704:	20 e0       	ldi	r18, 0x00	; 0
    4706:	82 2f       	mov	r24, r18
    4708:	08 95       	ret

0000470a <settings_init>:


// Initialize the config subsystem
void settings_init() {
  if(!read_global_settings()) {
    470a:	0e 94 6f 23 	call	0x46de	; 0x46de <read_global_settings>
    470e:	81 11       	cpse	r24, r1
    4710:	08 c0       	rjmp	.+16     	; 0x4722 <settings_init+0x18>
    report_status_message(STATUS_SETTING_READ_FAIL);
    4712:	87 e0       	ldi	r24, 0x07	; 7
    4714:	0e 94 fd 2c 	call	0x59fa	; 0x59fa <report_status_message>
    settings_restore(SETTINGS_RESTORE_ALL); // Force restore all EEPROM data.
    4718:	8f ef       	ldi	r24, 0xFF	; 255
    471a:	0e 94 d7 22 	call	0x45ae	; 0x45ae <settings_restore>
    report_grbl_settings();
    471e:	0e 94 01 2d 	call	0x5a02	; 0x5a02 <report_grbl_settings>
    4722:	08 95       	ret

00004724 <get_step_pin_mask>:


// Returns step pin mask according to Grbl internal axis indexing.
uint8_t get_step_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    4724:	88 23       	and	r24, r24
    4726:	21 f0       	breq	.+8      	; 0x4730 <get_step_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
    4728:	81 30       	cpi	r24, 0x01	; 1
    472a:	21 f0       	breq	.+8      	; 0x4734 <get_step_pin_mask+0x10>
  return((1<<Z_STEP_BIT));
    472c:	80 e1       	ldi	r24, 0x10	; 16
    472e:	08 95       	ret


// Returns step pin mask according to Grbl internal axis indexing.
uint8_t get_step_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_STEP_BIT)); }
    4730:	84 e0       	ldi	r24, 0x04	; 4
    4732:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_STEP_BIT)); }
    4734:	88 e0       	ldi	r24, 0x08	; 8
  return((1<<Z_STEP_BIT));
}
    4736:	08 95       	ret

00004738 <get_direction_pin_mask>:


// Returns direction pin mask according to Grbl internal axis indexing.
uint8_t get_direction_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    4738:	88 23       	and	r24, r24
    473a:	21 f0       	breq	.+8      	; 0x4744 <get_direction_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
    473c:	81 30       	cpi	r24, 0x01	; 1
    473e:	21 f0       	breq	.+8      	; 0x4748 <get_direction_pin_mask+0x10>
  return((1<<Z_DIRECTION_BIT));
    4740:	80 e8       	ldi	r24, 0x80	; 128
    4742:	08 95       	ret


// Returns direction pin mask according to Grbl internal axis indexing.
uint8_t get_direction_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_DIRECTION_BIT)); }
    4744:	80 e2       	ldi	r24, 0x20	; 32
    4746:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_DIRECTION_BIT)); }
    4748:	80 e4       	ldi	r24, 0x40	; 64
  return((1<<Z_DIRECTION_BIT));
}
    474a:	08 95       	ret

0000474c <get_limit_pin_mask>:


// Returns limit pin mask according to Grbl internal axis indexing.
uint8_t get_limit_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    474c:	88 23       	and	r24, r24
    474e:	21 f0       	breq	.+8      	; 0x4758 <get_limit_pin_mask+0xc>
  if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
    4750:	81 30       	cpi	r24, 0x01	; 1
    4752:	21 f0       	breq	.+8      	; 0x475c <get_limit_pin_mask+0x10>
  return((1<<Z_LIMIT_BIT));
    4754:	80 e1       	ldi	r24, 0x10	; 16
    4756:	08 95       	ret


// Returns limit pin mask according to Grbl internal axis indexing.
uint8_t get_limit_pin_mask(uint8_t axis_idx)
{
  if ( axis_idx == X_AXIS ) { return((1<<X_LIMIT_BIT)); }
    4758:	82 e0       	ldi	r24, 0x02	; 2
    475a:	08 95       	ret
  if ( axis_idx == Y_AXIS ) { return((1<<Y_LIMIT_BIT)); }
    475c:	84 e0       	ldi	r24, 0x04	; 4
  return((1<<Z_LIMIT_BIT));
}
    475e:	08 95       	ret

00004760 <planner_recalculate>:
// NOTE: Deprecated. Not used unless classic status reports are enabled in config.h
uint8_t plan_get_block_buffer_count()
{
  if (block_buffer_head >= block_buffer_tail) { return(block_buffer_head-block_buffer_tail); }
  return(BLOCK_BUFFER_SIZE - (block_buffer_tail-block_buffer_head));
}
    4760:	2f 92       	push	r2
    4762:	3f 92       	push	r3
    4764:	4f 92       	push	r4
    4766:	5f 92       	push	r5
    4768:	6f 92       	push	r6
    476a:	7f 92       	push	r7
    476c:	8f 92       	push	r8
    476e:	9f 92       	push	r9
    4770:	af 92       	push	r10
    4772:	bf 92       	push	r11
    4774:	cf 92       	push	r12
    4776:	df 92       	push	r13
    4778:	ef 92       	push	r14
    477a:	ff 92       	push	r15
    477c:	0f 93       	push	r16
    477e:	1f 93       	push	r17
    4780:	cf 93       	push	r28
    4782:	df 93       	push	r29
    4784:	c0 91 59 02 	lds	r28, 0x0259	; 0x800259 <block_buffer_head>
    4788:	c1 11       	cpse	r28, r1
    478a:	01 c0       	rjmp	.+2      	; 0x478e <planner_recalculate+0x2e>
    478c:	c0 e1       	ldi	r28, 0x10	; 16
    478e:	c1 50       	subi	r28, 0x01	; 1
    4790:	d0 91 57 02 	lds	r29, 0x0257	; 0x800257 <block_buffer_planned>
    4794:	dc 17       	cp	r29, r28
    4796:	09 f4       	brne	.+2      	; 0x479a <planner_recalculate+0x3a>
    4798:	36 c1       	rjmp	.+620    	; 0x4a06 <planner_recalculate+0x2a6>
    479a:	0c 2f       	mov	r16, r28
    479c:	10 e0       	ldi	r17, 0x00	; 0
    479e:	22 e3       	ldi	r18, 0x32	; 50
    47a0:	c2 9f       	mul	r28, r18
    47a2:	c0 01       	movw	r24, r0
    47a4:	11 24       	eor	r1, r1
    47a6:	fc 01       	movw	r30, r24
    47a8:	e5 5a       	subi	r30, 0xA5	; 165
    47aa:	fd 4f       	sbci	r31, 0xFD	; 253
    47ac:	6f 01       	movw	r12, r30
    47ae:	e6 88       	ldd	r14, Z+22	; 0x16
    47b0:	f7 88       	ldd	r15, Z+23	; 0x17
    47b2:	90 8c       	ldd	r9, Z+24	; 0x18
    47b4:	81 8c       	ldd	r8, Z+25	; 0x19
    47b6:	62 8d       	ldd	r22, Z+26	; 0x1a
    47b8:	73 8d       	ldd	r23, Z+27	; 0x1b
    47ba:	84 8d       	ldd	r24, Z+28	; 0x1c
    47bc:	95 8d       	ldd	r25, Z+29	; 0x1d
    47be:	9b 01       	movw	r18, r22
    47c0:	ac 01       	movw	r20, r24
    47c2:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    47c6:	f6 01       	movw	r30, r12
    47c8:	26 8d       	ldd	r18, Z+30	; 0x1e
    47ca:	37 8d       	ldd	r19, Z+31	; 0x1f
    47cc:	40 a1       	ldd	r20, Z+32	; 0x20
    47ce:	51 a1       	ldd	r21, Z+33	; 0x21
    47d0:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    47d4:	a6 2e       	mov	r10, r22
    47d6:	b7 2e       	mov	r11, r23
    47d8:	c8 2e       	mov	r12, r24
    47da:	d9 2e       	mov	r13, r25
    47dc:	26 2f       	mov	r18, r22
    47de:	37 2f       	mov	r19, r23
    47e0:	48 2f       	mov	r20, r24
    47e2:	59 2f       	mov	r21, r25
    47e4:	6e 2d       	mov	r22, r14
    47e6:	7f 2d       	mov	r23, r15
    47e8:	89 2d       	mov	r24, r9
    47ea:	98 2d       	mov	r25, r8
    47ec:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    47f0:	88 23       	and	r24, r24
    47f2:	24 f0       	brlt	.+8      	; 0x47fc <planner_recalculate+0x9c>
    47f4:	ea 2c       	mov	r14, r10
    47f6:	fb 2c       	mov	r15, r11
    47f8:	9c 2c       	mov	r9, r12
    47fa:	8d 2c       	mov	r8, r13
    47fc:	82 e3       	ldi	r24, 0x32	; 50
    47fe:	80 9f       	mul	r24, r16
    4800:	f0 01       	movw	r30, r0
    4802:	81 9f       	mul	r24, r17
    4804:	f0 0d       	add	r31, r0
    4806:	11 24       	eor	r1, r1
    4808:	e5 5a       	subi	r30, 0xA5	; 165
    480a:	fd 4f       	sbci	r31, 0xFD	; 253
    480c:	8e 2d       	mov	r24, r14
    480e:	9f 2d       	mov	r25, r15
    4810:	a9 2d       	mov	r26, r9
    4812:	b8 2d       	mov	r27, r8
    4814:	82 8b       	std	Z+18, r24	; 0x12
    4816:	93 8b       	std	Z+19, r25	; 0x13
    4818:	a4 8b       	std	Z+20, r26	; 0x14
    481a:	b5 8b       	std	Z+21, r27	; 0x15
    481c:	c1 11       	cpse	r28, r1
    481e:	01 c0       	rjmp	.+2      	; 0x4822 <planner_recalculate+0xc2>
    4820:	c0 e1       	ldi	r28, 0x10	; 16
    4822:	c1 50       	subi	r28, 0x01	; 1
    4824:	dc 13       	cpse	r29, r28
    4826:	07 c0       	rjmp	.+14     	; 0x4836 <planner_recalculate+0xd6>
    4828:	80 91 5a 02 	lds	r24, 0x025A	; 0x80025a <block_buffer_tail>
    482c:	d8 13       	cpse	r29, r24
    482e:	7c c0       	rjmp	.+248    	; 0x4928 <planner_recalculate+0x1c8>
    4830:	0e 94 68 19 	call	0x32d0	; 0x32d0 <st_update_plan_block_parameters>
    4834:	79 c0       	rjmp	.+242    	; 0x4928 <planner_recalculate+0x1c8>
    4836:	22 e3       	ldi	r18, 0x32	; 50
    4838:	20 9f       	mul	r18, r16
    483a:	c0 01       	movw	r24, r0
    483c:	21 9f       	mul	r18, r17
    483e:	90 0d       	add	r25, r0
    4840:	11 24       	eor	r1, r1
    4842:	9c 01       	movw	r18, r24
    4844:	25 5a       	subi	r18, 0xA5	; 165
    4846:	3d 4f       	sbci	r19, 0xFD	; 253
    4848:	69 01       	movw	r12, r18
    484a:	d2 e3       	ldi	r29, 0x32	; 50
    484c:	ec 2e       	mov	r14, r28
    484e:	f1 2c       	mov	r15, r1
    4850:	de 9d       	mul	r29, r14
    4852:	80 01       	movw	r16, r0
    4854:	df 9d       	mul	r29, r15
    4856:	10 0d       	add	r17, r0
    4858:	11 24       	eor	r1, r1
    485a:	05 5a       	subi	r16, 0xA5	; 165
    485c:	1d 4f       	sbci	r17, 0xFD	; 253
    485e:	c1 11       	cpse	r28, r1
    4860:	01 c0       	rjmp	.+2      	; 0x4864 <planner_recalculate+0x104>
    4862:	c0 e1       	ldi	r28, 0x10	; 16
    4864:	c1 50       	subi	r28, 0x01	; 1
    4866:	80 91 5a 02 	lds	r24, 0x025A	; 0x80025a <block_buffer_tail>
    486a:	8c 13       	cpse	r24, r28
    486c:	02 c0       	rjmp	.+4      	; 0x4872 <planner_recalculate+0x112>
    486e:	0e 94 68 19 	call	0x32d0	; 0x32d0 <st_update_plan_block_parameters>
    4872:	de 9d       	mul	r29, r14
    4874:	f0 01       	movw	r30, r0
    4876:	df 9d       	mul	r29, r15
    4878:	f0 0d       	add	r31, r0
    487a:	11 24       	eor	r1, r1
    487c:	e5 5a       	subi	r30, 0xA5	; 165
    487e:	fd 4f       	sbci	r31, 0xFD	; 253
    4880:	46 88       	ldd	r4, Z+22	; 0x16
    4882:	57 88       	ldd	r5, Z+23	; 0x17
    4884:	60 8c       	ldd	r6, Z+24	; 0x18
    4886:	71 8c       	ldd	r7, Z+25	; 0x19
    4888:	a3 01       	movw	r20, r6
    488a:	92 01       	movw	r18, r4
    488c:	62 89       	ldd	r22, Z+18	; 0x12
    488e:	73 89       	ldd	r23, Z+19	; 0x13
    4890:	84 89       	ldd	r24, Z+20	; 0x14
    4892:	95 89       	ldd	r25, Z+21	; 0x15
    4894:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    4898:	88 23       	and	r24, r24
    489a:	09 f4       	brne	.+2      	; 0x489e <planner_recalculate+0x13e>
    489c:	40 c0       	rjmp	.+128    	; 0x491e <planner_recalculate+0x1be>
    489e:	de 9d       	mul	r29, r14
    48a0:	c0 01       	movw	r24, r0
    48a2:	df 9d       	mul	r29, r15
    48a4:	90 0d       	add	r25, r0
    48a6:	11 24       	eor	r1, r1
    48a8:	fc 01       	movw	r30, r24
    48aa:	e5 5a       	subi	r30, 0xA5	; 165
    48ac:	fd 4f       	sbci	r31, 0xFD	; 253
    48ae:	5f 01       	movw	r10, r30
    48b0:	62 8d       	ldd	r22, Z+26	; 0x1a
    48b2:	73 8d       	ldd	r23, Z+27	; 0x1b
    48b4:	84 8d       	ldd	r24, Z+28	; 0x1c
    48b6:	95 8d       	ldd	r25, Z+29	; 0x1d
    48b8:	9b 01       	movw	r18, r22
    48ba:	ac 01       	movw	r20, r24
    48bc:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    48c0:	f5 01       	movw	r30, r10
    48c2:	26 8d       	ldd	r18, Z+30	; 0x1e
    48c4:	37 8d       	ldd	r19, Z+31	; 0x1f
    48c6:	40 a1       	ldd	r20, Z+32	; 0x20
    48c8:	51 a1       	ldd	r21, Z+33	; 0x21
    48ca:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    48ce:	f6 01       	movw	r30, r12
    48d0:	22 89       	ldd	r18, Z+18	; 0x12
    48d2:	33 89       	ldd	r19, Z+19	; 0x13
    48d4:	44 89       	ldd	r20, Z+20	; 0x14
    48d6:	55 89       	ldd	r21, Z+21	; 0x15
    48d8:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    48dc:	4b 01       	movw	r8, r22
    48de:	5c 01       	movw	r10, r24
    48e0:	9b 01       	movw	r18, r22
    48e2:	ac 01       	movw	r20, r24
    48e4:	c3 01       	movw	r24, r6
    48e6:	b2 01       	movw	r22, r4
    48e8:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    48ec:	18 16       	cp	r1, r24
    48ee:	64 f4       	brge	.+24     	; 0x4908 <planner_recalculate+0x1a8>
    48f0:	de 9d       	mul	r29, r14
    48f2:	f0 01       	movw	r30, r0
    48f4:	df 9d       	mul	r29, r15
    48f6:	f0 0d       	add	r31, r0
    48f8:	11 24       	eor	r1, r1
    48fa:	e5 5a       	subi	r30, 0xA5	; 165
    48fc:	fd 4f       	sbci	r31, 0xFD	; 253
    48fe:	82 8a       	std	Z+18, r8	; 0x12
    4900:	93 8a       	std	Z+19, r9	; 0x13
    4902:	a4 8a       	std	Z+20, r10	; 0x14
    4904:	b5 8a       	std	Z+21, r11	; 0x15
    4906:	0b c0       	rjmp	.+22     	; 0x491e <planner_recalculate+0x1be>
    4908:	de 9d       	mul	r29, r14
    490a:	f0 01       	movw	r30, r0
    490c:	df 9d       	mul	r29, r15
    490e:	f0 0d       	add	r31, r0
    4910:	11 24       	eor	r1, r1
    4912:	e5 5a       	subi	r30, 0xA5	; 165
    4914:	fd 4f       	sbci	r31, 0xFD	; 253
    4916:	42 8a       	std	Z+18, r4	; 0x12
    4918:	53 8a       	std	Z+19, r5	; 0x13
    491a:	64 8a       	std	Z+20, r6	; 0x14
    491c:	75 8a       	std	Z+21, r7	; 0x15
    491e:	68 01       	movw	r12, r16
    4920:	80 91 57 02 	lds	r24, 0x0257	; 0x800257 <block_buffer_planned>
    4924:	8c 13       	cpse	r24, r28
    4926:	92 cf       	rjmp	.-220    	; 0x484c <planner_recalculate+0xec>
    4928:	20 90 57 02 	lds	r2, 0x0257	; 0x800257 <block_buffer_planned>
    492c:	f2 e3       	ldi	r31, 0x32	; 50
    492e:	2f 9e       	mul	r2, r31
    4930:	c0 01       	movw	r24, r0
    4932:	11 24       	eor	r1, r1
    4934:	9c 01       	movw	r18, r24
    4936:	25 5a       	subi	r18, 0xA5	; 165
    4938:	3d 4f       	sbci	r19, 0xFD	; 253
    493a:	79 01       	movw	r14, r18
    493c:	c1 e0       	ldi	r28, 0x01	; 1
    493e:	c2 0d       	add	r28, r2
    4940:	c0 31       	cpi	r28, 0x10	; 16
    4942:	09 f4       	brne	.+2      	; 0x4946 <planner_recalculate+0x1e6>
    4944:	c0 e0       	ldi	r28, 0x00	; 0
    4946:	30 90 59 02 	lds	r3, 0x0259	; 0x800259 <block_buffer_head>
    494a:	d2 e3       	ldi	r29, 0x32	; 50
    494c:	58 c0       	rjmp	.+176    	; 0x49fe <planner_recalculate+0x29e>
    494e:	cc 2e       	mov	r12, r28
    4950:	d1 2c       	mov	r13, r1
    4952:	dc 9d       	mul	r29, r12
    4954:	80 01       	movw	r16, r0
    4956:	dd 9d       	mul	r29, r13
    4958:	10 0d       	add	r17, r0
    495a:	11 24       	eor	r1, r1
    495c:	05 5a       	subi	r16, 0xA5	; 165
    495e:	1d 4f       	sbci	r17, 0xFD	; 253
    4960:	f7 01       	movw	r30, r14
    4962:	42 88       	ldd	r4, Z+18	; 0x12
    4964:	53 88       	ldd	r5, Z+19	; 0x13
    4966:	64 88       	ldd	r6, Z+20	; 0x14
    4968:	75 88       	ldd	r7, Z+21	; 0x15
    496a:	f8 01       	movw	r30, r16
    496c:	82 88       	ldd	r8, Z+18	; 0x12
    496e:	93 88       	ldd	r9, Z+19	; 0x13
    4970:	a4 88       	ldd	r10, Z+20	; 0x14
    4972:	b5 88       	ldd	r11, Z+21	; 0x15
    4974:	a5 01       	movw	r20, r10
    4976:	94 01       	movw	r18, r8
    4978:	c3 01       	movw	r24, r6
    497a:	b2 01       	movw	r22, r4
    497c:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    4980:	88 23       	and	r24, r24
    4982:	24 f5       	brge	.+72     	; 0x49cc <planner_recalculate+0x26c>
    4984:	f7 01       	movw	r30, r14
    4986:	62 8d       	ldd	r22, Z+26	; 0x1a
    4988:	73 8d       	ldd	r23, Z+27	; 0x1b
    498a:	84 8d       	ldd	r24, Z+28	; 0x1c
    498c:	95 8d       	ldd	r25, Z+29	; 0x1d
    498e:	9b 01       	movw	r18, r22
    4990:	ac 01       	movw	r20, r24
    4992:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    4996:	f7 01       	movw	r30, r14
    4998:	26 8d       	ldd	r18, Z+30	; 0x1e
    499a:	37 8d       	ldd	r19, Z+31	; 0x1f
    499c:	40 a1       	ldd	r20, Z+32	; 0x20
    499e:	51 a1       	ldd	r21, Z+33	; 0x21
    49a0:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    49a4:	a3 01       	movw	r20, r6
    49a6:	92 01       	movw	r18, r4
    49a8:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    49ac:	2b 01       	movw	r4, r22
    49ae:	3c 01       	movw	r6, r24
    49b0:	9b 01       	movw	r18, r22
    49b2:	ac 01       	movw	r20, r24
    49b4:	c5 01       	movw	r24, r10
    49b6:	b4 01       	movw	r22, r8
    49b8:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    49bc:	18 16       	cp	r1, r24
    49be:	34 f4       	brge	.+12     	; 0x49cc <planner_recalculate+0x26c>
    49c0:	f8 01       	movw	r30, r16
    49c2:	42 8a       	std	Z+18, r4	; 0x12
    49c4:	53 8a       	std	Z+19, r5	; 0x13
    49c6:	64 8a       	std	Z+20, r6	; 0x14
    49c8:	75 8a       	std	Z+21, r7	; 0x15
    49ca:	2c 2e       	mov	r2, r28
    49cc:	dc 9d       	mul	r29, r12
    49ce:	f0 01       	movw	r30, r0
    49d0:	dd 9d       	mul	r29, r13
    49d2:	f0 0d       	add	r31, r0
    49d4:	11 24       	eor	r1, r1
    49d6:	e5 5a       	subi	r30, 0xA5	; 165
    49d8:	fd 4f       	sbci	r31, 0xFD	; 253
    49da:	26 89       	ldd	r18, Z+22	; 0x16
    49dc:	37 89       	ldd	r19, Z+23	; 0x17
    49de:	40 8d       	ldd	r20, Z+24	; 0x18
    49e0:	51 8d       	ldd	r21, Z+25	; 0x19
    49e2:	62 89       	ldd	r22, Z+18	; 0x12
    49e4:	73 89       	ldd	r23, Z+19	; 0x13
    49e6:	84 89       	ldd	r24, Z+20	; 0x14
    49e8:	95 89       	ldd	r25, Z+21	; 0x15
    49ea:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    49ee:	81 11       	cpse	r24, r1
    49f0:	01 c0       	rjmp	.+2      	; 0x49f4 <planner_recalculate+0x294>
    49f2:	2c 2e       	mov	r2, r28
    49f4:	cf 5f       	subi	r28, 0xFF	; 255
    49f6:	c0 31       	cpi	r28, 0x10	; 16
    49f8:	09 f4       	brne	.+2      	; 0x49fc <planner_recalculate+0x29c>
    49fa:	c0 e0       	ldi	r28, 0x00	; 0
    49fc:	78 01       	movw	r14, r16
    49fe:	c3 11       	cpse	r28, r3
    4a00:	a6 cf       	rjmp	.-180    	; 0x494e <planner_recalculate+0x1ee>
    4a02:	20 92 57 02 	sts	0x0257, r2	; 0x800257 <block_buffer_planned>
    4a06:	df 91       	pop	r29
    4a08:	cf 91       	pop	r28
    4a0a:	1f 91       	pop	r17
    4a0c:	0f 91       	pop	r16
    4a0e:	ff 90       	pop	r15
    4a10:	ef 90       	pop	r14
    4a12:	df 90       	pop	r13
    4a14:	cf 90       	pop	r12
    4a16:	bf 90       	pop	r11
    4a18:	af 90       	pop	r10
    4a1a:	9f 90       	pop	r9
    4a1c:	8f 90       	pop	r8
    4a1e:	7f 90       	pop	r7
    4a20:	6f 90       	pop	r6
    4a22:	5f 90       	pop	r5
    4a24:	4f 90       	pop	r4
    4a26:	3f 90       	pop	r3
    4a28:	2f 90       	pop	r2
    4a2a:	08 95       	ret

00004a2c <plan_reset_buffer>:
    4a2c:	10 92 5a 02 	sts	0x025A, r1	; 0x80025a <block_buffer_tail>
    4a30:	10 92 59 02 	sts	0x0259, r1	; 0x800259 <block_buffer_head>
    4a34:	81 e0       	ldi	r24, 0x01	; 1
    4a36:	80 93 58 02 	sts	0x0258, r24	; 0x800258 <next_buffer_head>
    4a3a:	10 92 57 02 	sts	0x0257, r1	; 0x800257 <block_buffer_planned>
    4a3e:	08 95       	ret

00004a40 <plan_reset>:
    4a40:	8c e1       	ldi	r24, 0x1C	; 28
    4a42:	eb e3       	ldi	r30, 0x3B	; 59
    4a44:	f2 e0       	ldi	r31, 0x02	; 2
    4a46:	df 01       	movw	r26, r30
    4a48:	1d 92       	st	X+, r1
    4a4a:	8a 95       	dec	r24
    4a4c:	e9 f7       	brne	.-6      	; 0x4a48 <plan_reset+0x8>
    4a4e:	0e 94 16 25 	call	0x4a2c	; 0x4a2c <plan_reset_buffer>
    4a52:	08 95       	ret

00004a54 <plan_discard_current_block>:
    4a54:	80 91 5a 02 	lds	r24, 0x025A	; 0x80025a <block_buffer_tail>
    4a58:	90 91 59 02 	lds	r25, 0x0259	; 0x800259 <block_buffer_head>
    4a5c:	98 17       	cp	r25, r24
    4a5e:	69 f0       	breq	.+26     	; 0x4a7a <plan_discard_current_block+0x26>
    4a60:	91 e0       	ldi	r25, 0x01	; 1
    4a62:	98 0f       	add	r25, r24
    4a64:	90 31       	cpi	r25, 0x10	; 16
    4a66:	09 f4       	brne	.+2      	; 0x4a6a <plan_discard_current_block+0x16>
    4a68:	90 e0       	ldi	r25, 0x00	; 0
    4a6a:	20 91 57 02 	lds	r18, 0x0257	; 0x800257 <block_buffer_planned>
    4a6e:	82 13       	cpse	r24, r18
    4a70:	02 c0       	rjmp	.+4      	; 0x4a76 <plan_discard_current_block+0x22>
    4a72:	90 93 57 02 	sts	0x0257, r25	; 0x800257 <block_buffer_planned>
    4a76:	90 93 5a 02 	sts	0x025A, r25	; 0x80025a <block_buffer_tail>
    4a7a:	08 95       	ret

00004a7c <plan_get_system_motion_block>:
    4a7c:	80 91 59 02 	lds	r24, 0x0259	; 0x800259 <block_buffer_head>
    4a80:	22 e3       	ldi	r18, 0x32	; 50
    4a82:	82 9f       	mul	r24, r18
    4a84:	c0 01       	movw	r24, r0
    4a86:	11 24       	eor	r1, r1
    4a88:	85 5a       	subi	r24, 0xA5	; 165
    4a8a:	9d 4f       	sbci	r25, 0xFD	; 253
    4a8c:	08 95       	ret

00004a8e <plan_get_current_block>:
    4a8e:	80 91 5a 02 	lds	r24, 0x025A	; 0x80025a <block_buffer_tail>
    4a92:	90 91 59 02 	lds	r25, 0x0259	; 0x800259 <block_buffer_head>
    4a96:	98 17       	cp	r25, r24
    4a98:	39 f0       	breq	.+14     	; 0x4aa8 <plan_get_current_block+0x1a>
    4a9a:	22 e3       	ldi	r18, 0x32	; 50
    4a9c:	82 9f       	mul	r24, r18
    4a9e:	c0 01       	movw	r24, r0
    4aa0:	11 24       	eor	r1, r1
    4aa2:	85 5a       	subi	r24, 0xA5	; 165
    4aa4:	9d 4f       	sbci	r25, 0xFD	; 253
    4aa6:	08 95       	ret
    4aa8:	80 e0       	ldi	r24, 0x00	; 0
    4aaa:	90 e0       	ldi	r25, 0x00	; 0
    4aac:	08 95       	ret

00004aae <plan_get_exec_block_exit_speed_sqr>:
    4aae:	e0 91 5a 02 	lds	r30, 0x025A	; 0x80025a <block_buffer_tail>
    4ab2:	ef 5f       	subi	r30, 0xFF	; 255
    4ab4:	e0 31       	cpi	r30, 0x10	; 16
    4ab6:	09 f4       	brne	.+2      	; 0x4aba <plan_get_exec_block_exit_speed_sqr+0xc>
    4ab8:	e0 e0       	ldi	r30, 0x00	; 0
    4aba:	80 91 59 02 	lds	r24, 0x0259	; 0x800259 <block_buffer_head>
    4abe:	8e 17       	cp	r24, r30
    4ac0:	59 f0       	breq	.+22     	; 0x4ad8 <plan_get_exec_block_exit_speed_sqr+0x2a>
    4ac2:	82 e3       	ldi	r24, 0x32	; 50
    4ac4:	e8 9f       	mul	r30, r24
    4ac6:	f0 01       	movw	r30, r0
    4ac8:	11 24       	eor	r1, r1
    4aca:	e5 5a       	subi	r30, 0xA5	; 165
    4acc:	fd 4f       	sbci	r31, 0xFD	; 253
    4ace:	62 89       	ldd	r22, Z+18	; 0x12
    4ad0:	73 89       	ldd	r23, Z+19	; 0x13
    4ad2:	84 89       	ldd	r24, Z+20	; 0x14
    4ad4:	95 89       	ldd	r25, Z+21	; 0x15
    4ad6:	08 95       	ret
    4ad8:	60 e0       	ldi	r22, 0x00	; 0
    4ada:	70 e0       	ldi	r23, 0x00	; 0
    4adc:	cb 01       	movw	r24, r22
    4ade:	08 95       	ret

00004ae0 <plan_check_full_buffer>:
    4ae0:	81 e0       	ldi	r24, 0x01	; 1
    4ae2:	20 91 5a 02 	lds	r18, 0x025A	; 0x80025a <block_buffer_tail>
    4ae6:	90 91 58 02 	lds	r25, 0x0258	; 0x800258 <next_buffer_head>
    4aea:	29 13       	cpse	r18, r25
    4aec:	80 e0       	ldi	r24, 0x00	; 0
    4aee:	08 95       	ret

00004af0 <plan_compute_profile_nominal_speed>:
    4af0:	af 92       	push	r10
    4af2:	bf 92       	push	r11
    4af4:	cf 92       	push	r12
    4af6:	df 92       	push	r13
    4af8:	ef 92       	push	r14
    4afa:	ff 92       	push	r15
    4afc:	0f 93       	push	r16
    4afe:	1f 93       	push	r17
    4b00:	cf 93       	push	r28
    4b02:	df 93       	push	r29
    4b04:	ec 01       	movw	r28, r24
    4b06:	1a a5       	ldd	r17, Y+42	; 0x2a
    4b08:	ab a4       	ldd	r10, Y+43	; 0x2b
    4b0a:	ec a4       	ldd	r14, Y+44	; 0x2c
    4b0c:	0d a5       	ldd	r16, Y+45	; 0x2d
    4b0e:	89 89       	ldd	r24, Y+17	; 0x11
    4b10:	80 ff       	sbrs	r24, 0
    4b12:	1a c0       	rjmp	.+52     	; 0x4b48 <plan_compute_profile_nominal_speed+0x58>
    4b14:	60 91 84 05 	lds	r22, 0x0584	; 0x800584 <sys+0x8>
    4b18:	70 e0       	ldi	r23, 0x00	; 0
    4b1a:	80 e0       	ldi	r24, 0x00	; 0
    4b1c:	90 e0       	ldi	r25, 0x00	; 0
    4b1e:	0e 94 18 30 	call	0x6030	; 0x6030 <__floatsisf>
    4b22:	2a e0       	ldi	r18, 0x0A	; 10
    4b24:	37 ed       	ldi	r19, 0xD7	; 215
    4b26:	43 e2       	ldi	r20, 0x23	; 35
    4b28:	5c e3       	ldi	r21, 0x3C	; 60
    4b2a:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    4b2e:	9b 01       	movw	r18, r22
    4b30:	ac 01       	movw	r20, r24
    4b32:	61 2f       	mov	r22, r17
    4b34:	7a 2d       	mov	r23, r10
    4b36:	8e 2d       	mov	r24, r14
    4b38:	90 2f       	mov	r25, r16
    4b3a:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    4b3e:	16 2f       	mov	r17, r22
    4b40:	a7 2e       	mov	r10, r23
    4b42:	e8 2e       	mov	r14, r24
    4b44:	09 2f       	mov	r16, r25
    4b46:	2f c0       	rjmp	.+94     	; 0x4ba6 <plan_compute_profile_nominal_speed+0xb6>
    4b48:	82 fd       	sbrc	r24, 2
    4b4a:	19 c0       	rjmp	.+50     	; 0x4b7e <plan_compute_profile_nominal_speed+0x8e>
    4b4c:	60 91 83 05 	lds	r22, 0x0583	; 0x800583 <sys+0x7>
    4b50:	70 e0       	ldi	r23, 0x00	; 0
    4b52:	80 e0       	ldi	r24, 0x00	; 0
    4b54:	90 e0       	ldi	r25, 0x00	; 0
    4b56:	0e 94 18 30 	call	0x6030	; 0x6030 <__floatsisf>
    4b5a:	2a e0       	ldi	r18, 0x0A	; 10
    4b5c:	37 ed       	ldi	r19, 0xD7	; 215
    4b5e:	43 e2       	ldi	r20, 0x23	; 35
    4b60:	5c e3       	ldi	r21, 0x3C	; 60
    4b62:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    4b66:	9b 01       	movw	r18, r22
    4b68:	ac 01       	movw	r20, r24
    4b6a:	61 2f       	mov	r22, r17
    4b6c:	7a 2d       	mov	r23, r10
    4b6e:	8e 2d       	mov	r24, r14
    4b70:	90 2f       	mov	r25, r16
    4b72:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    4b76:	16 2f       	mov	r17, r22
    4b78:	a7 2e       	mov	r10, r23
    4b7a:	e8 2e       	mov	r14, r24
    4b7c:	09 2f       	mov	r16, r25
    4b7e:	be a0       	ldd	r11, Y+38	; 0x26
    4b80:	cf a0       	ldd	r12, Y+39	; 0x27
    4b82:	d8 a4       	ldd	r13, Y+40	; 0x28
    4b84:	f9 a4       	ldd	r15, Y+41	; 0x29
    4b86:	2b 2d       	mov	r18, r11
    4b88:	3c 2d       	mov	r19, r12
    4b8a:	4d 2d       	mov	r20, r13
    4b8c:	5f 2d       	mov	r21, r15
    4b8e:	61 2f       	mov	r22, r17
    4b90:	7a 2d       	mov	r23, r10
    4b92:	8e 2d       	mov	r24, r14
    4b94:	90 2f       	mov	r25, r16
    4b96:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    4b9a:	18 16       	cp	r1, r24
    4b9c:	24 f4       	brge	.+8      	; 0x4ba6 <plan_compute_profile_nominal_speed+0xb6>
    4b9e:	1b 2d       	mov	r17, r11
    4ba0:	ac 2c       	mov	r10, r12
    4ba2:	ed 2c       	mov	r14, r13
    4ba4:	0f 2d       	mov	r16, r15
    4ba6:	20 e0       	ldi	r18, 0x00	; 0
    4ba8:	30 e0       	ldi	r19, 0x00	; 0
    4baa:	40 e8       	ldi	r20, 0x80	; 128
    4bac:	5f e3       	ldi	r21, 0x3F	; 63
    4bae:	61 2f       	mov	r22, r17
    4bb0:	7a 2d       	mov	r23, r10
    4bb2:	8e 2d       	mov	r24, r14
    4bb4:	90 2f       	mov	r25, r16
    4bb6:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    4bba:	18 16       	cp	r1, r24
    4bbc:	1c f4       	brge	.+6      	; 0x4bc4 <plan_compute_profile_nominal_speed+0xd4>
    4bbe:	da 2d       	mov	r29, r10
    4bc0:	ce 2d       	mov	r28, r14
    4bc2:	04 c0       	rjmp	.+8      	; 0x4bcc <plan_compute_profile_nominal_speed+0xdc>
    4bc4:	10 e0       	ldi	r17, 0x00	; 0
    4bc6:	d0 e0       	ldi	r29, 0x00	; 0
    4bc8:	c0 e8       	ldi	r28, 0x80	; 128
    4bca:	0f e3       	ldi	r16, 0x3F	; 63
    4bcc:	61 2f       	mov	r22, r17
    4bce:	7d 2f       	mov	r23, r29
    4bd0:	8c 2f       	mov	r24, r28
    4bd2:	90 2f       	mov	r25, r16
    4bd4:	df 91       	pop	r29
    4bd6:	cf 91       	pop	r28
    4bd8:	1f 91       	pop	r17
    4bda:	0f 91       	pop	r16
    4bdc:	ff 90       	pop	r15
    4bde:	ef 90       	pop	r14
    4be0:	df 90       	pop	r13
    4be2:	cf 90       	pop	r12
    4be4:	bf 90       	pop	r11
    4be6:	af 90       	pop	r10
    4be8:	08 95       	ret

00004bea <plan_update_velocity_profile_parameters>:
    4bea:	5f 92       	push	r5
    4bec:	6f 92       	push	r6
    4bee:	7f 92       	push	r7
    4bf0:	8f 92       	push	r8
    4bf2:	9f 92       	push	r9
    4bf4:	af 92       	push	r10
    4bf6:	bf 92       	push	r11
    4bf8:	cf 92       	push	r12
    4bfa:	df 92       	push	r13
    4bfc:	ef 92       	push	r14
    4bfe:	ff 92       	push	r15
    4c00:	0f 93       	push	r16
    4c02:	1f 93       	push	r17
    4c04:	cf 93       	push	r28
    4c06:	df 93       	push	r29
    4c08:	10 91 5a 02 	lds	r17, 0x025A	; 0x80025a <block_buffer_tail>
    4c0c:	50 90 59 02 	lds	r5, 0x0259	; 0x800259 <block_buffer_head>
    4c10:	0f 2e       	mov	r0, r31
    4c12:	f9 e9       	ldi	r31, 0x99	; 153
    4c14:	9f 2e       	mov	r9, r31
    4c16:	f0 2d       	mov	r31, r0
    4c18:	0f 2e       	mov	r0, r31
    4c1a:	f6 e7       	ldi	r31, 0x76	; 118
    4c1c:	8f 2e       	mov	r8, r31
    4c1e:	f0 2d       	mov	r31, r0
    4c20:	0f 2e       	mov	r0, r31
    4c22:	f6 e9       	ldi	r31, 0x96	; 150
    4c24:	7f 2e       	mov	r7, r31
    4c26:	f0 2d       	mov	r31, r0
    4c28:	0f 2e       	mov	r0, r31
    4c2a:	fe e7       	ldi	r31, 0x7E	; 126
    4c2c:	6f 2e       	mov	r6, r31
    4c2e:	f0 2d       	mov	r31, r0
    4c30:	0f 2e       	mov	r0, r31
    4c32:	f2 e3       	ldi	r31, 0x32	; 50
    4c34:	cf 2e       	mov	r12, r31
    4c36:	f0 2d       	mov	r31, r0
    4c38:	74 c0       	rjmp	.+232    	; 0x4d22 <plan_update_velocity_profile_parameters+0x138>
    4c3a:	c1 2f       	mov	r28, r17
    4c3c:	d0 e0       	ldi	r29, 0x00	; 0
    4c3e:	cc 9e       	mul	r12, r28
    4c40:	c0 01       	movw	r24, r0
    4c42:	cd 9e       	mul	r12, r29
    4c44:	90 0d       	add	r25, r0
    4c46:	11 24       	eor	r1, r1
    4c48:	85 5a       	subi	r24, 0xA5	; 165
    4c4a:	9d 4f       	sbci	r25, 0xFD	; 253
    4c4c:	0e 94 78 25 	call	0x4af0	; 0x4af0 <plan_compute_profile_nominal_speed>
    4c50:	06 2f       	mov	r16, r22
    4c52:	f7 2e       	mov	r15, r23
    4c54:	e8 2e       	mov	r14, r24
    4c56:	d9 2e       	mov	r13, r25
    4c58:	26 2f       	mov	r18, r22
    4c5a:	37 2f       	mov	r19, r23
    4c5c:	48 2f       	mov	r20, r24
    4c5e:	59 2f       	mov	r21, r25
    4c60:	69 2d       	mov	r22, r9
    4c62:	78 2d       	mov	r23, r8
    4c64:	87 2d       	mov	r24, r7
    4c66:	96 2d       	mov	r25, r6
    4c68:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    4c6c:	88 23       	and	r24, r24
    4c6e:	cc f4       	brge	.+50     	; 0x4ca2 <plan_update_velocity_profile_parameters+0xb8>
    4c70:	cc 9e       	mul	r12, r28
    4c72:	c0 01       	movw	r24, r0
    4c74:	cd 9e       	mul	r12, r29
    4c76:	90 0d       	add	r25, r0
    4c78:	11 24       	eor	r1, r1
    4c7a:	9c 01       	movw	r18, r24
    4c7c:	25 5a       	subi	r18, 0xA5	; 165
    4c7e:	3d 4f       	sbci	r19, 0xFD	; 253
    4c80:	59 01       	movw	r10, r18
    4c82:	29 2d       	mov	r18, r9
    4c84:	38 2d       	mov	r19, r8
    4c86:	47 2d       	mov	r20, r7
    4c88:	56 2d       	mov	r21, r6
    4c8a:	69 2d       	mov	r22, r9
    4c8c:	78 2d       	mov	r23, r8
    4c8e:	87 2d       	mov	r24, r7
    4c90:	96 2d       	mov	r25, r6
    4c92:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    4c96:	f5 01       	movw	r30, r10
    4c98:	66 8b       	std	Z+22, r22	; 0x16
    4c9a:	77 8b       	std	Z+23, r23	; 0x17
    4c9c:	80 8f       	std	Z+24, r24	; 0x18
    4c9e:	91 8f       	std	Z+25, r25	; 0x19
    4ca0:	18 c0       	rjmp	.+48     	; 0x4cd2 <plan_update_velocity_profile_parameters+0xe8>
    4ca2:	cc 9e       	mul	r12, r28
    4ca4:	c0 01       	movw	r24, r0
    4ca6:	cd 9e       	mul	r12, r29
    4ca8:	90 0d       	add	r25, r0
    4caa:	11 24       	eor	r1, r1
    4cac:	9c 01       	movw	r18, r24
    4cae:	25 5a       	subi	r18, 0xA5	; 165
    4cb0:	3d 4f       	sbci	r19, 0xFD	; 253
    4cb2:	59 01       	movw	r10, r18
    4cb4:	20 2f       	mov	r18, r16
    4cb6:	3f 2d       	mov	r19, r15
    4cb8:	4e 2d       	mov	r20, r14
    4cba:	5d 2d       	mov	r21, r13
    4cbc:	60 2f       	mov	r22, r16
    4cbe:	7f 2d       	mov	r23, r15
    4cc0:	8e 2d       	mov	r24, r14
    4cc2:	9d 2d       	mov	r25, r13
    4cc4:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    4cc8:	f5 01       	movw	r30, r10
    4cca:	66 8b       	std	Z+22, r22	; 0x16
    4ccc:	77 8b       	std	Z+23, r23	; 0x17
    4cce:	80 8f       	std	Z+24, r24	; 0x18
    4cd0:	91 8f       	std	Z+25, r25	; 0x19
    4cd2:	cc 9e       	mul	r12, r28
    4cd4:	f0 01       	movw	r30, r0
    4cd6:	cd 9e       	mul	r12, r29
    4cd8:	f0 0d       	add	r31, r0
    4cda:	11 24       	eor	r1, r1
    4cdc:	e5 5a       	subi	r30, 0xA5	; 165
    4cde:	fd 4f       	sbci	r31, 0xFD	; 253
    4ce0:	82 a0       	ldd	r8, Z+34	; 0x22
    4ce2:	93 a0       	ldd	r9, Z+35	; 0x23
    4ce4:	a4 a0       	ldd	r10, Z+36	; 0x24
    4ce6:	b5 a0       	ldd	r11, Z+37	; 0x25
    4ce8:	a5 01       	movw	r20, r10
    4cea:	94 01       	movw	r18, r8
    4cec:	66 89       	ldd	r22, Z+22	; 0x16
    4cee:	77 89       	ldd	r23, Z+23	; 0x17
    4cf0:	80 8d       	ldd	r24, Z+24	; 0x18
    4cf2:	91 8d       	ldd	r25, Z+25	; 0x19
    4cf4:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    4cf8:	18 16       	cp	r1, r24
    4cfa:	5c f4       	brge	.+22     	; 0x4d12 <plan_update_velocity_profile_parameters+0x128>
    4cfc:	cc 9e       	mul	r12, r28
    4cfe:	f0 01       	movw	r30, r0
    4d00:	cd 9e       	mul	r12, r29
    4d02:	f0 0d       	add	r31, r0
    4d04:	11 24       	eor	r1, r1
    4d06:	e5 5a       	subi	r30, 0xA5	; 165
    4d08:	fd 4f       	sbci	r31, 0xFD	; 253
    4d0a:	86 8a       	std	Z+22, r8	; 0x16
    4d0c:	97 8a       	std	Z+23, r9	; 0x17
    4d0e:	a0 8e       	std	Z+24, r10	; 0x18
    4d10:	b1 8e       	std	Z+25, r11	; 0x19
    4d12:	1f 5f       	subi	r17, 0xFF	; 255
    4d14:	10 31       	cpi	r17, 0x10	; 16
    4d16:	09 f4       	brne	.+2      	; 0x4d1a <plan_update_velocity_profile_parameters+0x130>
    4d18:	10 e0       	ldi	r17, 0x00	; 0
    4d1a:	90 2e       	mov	r9, r16
    4d1c:	8f 2c       	mov	r8, r15
    4d1e:	7e 2c       	mov	r7, r14
    4d20:	6d 2c       	mov	r6, r13
    4d22:	15 11       	cpse	r17, r5
    4d24:	8a cf       	rjmp	.-236    	; 0x4c3a <plan_update_velocity_profile_parameters+0x50>
    4d26:	89 2d       	mov	r24, r9
    4d28:	98 2d       	mov	r25, r8
    4d2a:	a7 2d       	mov	r26, r7
    4d2c:	b6 2d       	mov	r27, r6
    4d2e:	80 93 53 02 	sts	0x0253, r24	; 0x800253 <pl+0x18>
    4d32:	90 93 54 02 	sts	0x0254, r25	; 0x800254 <pl+0x19>
    4d36:	a0 93 55 02 	sts	0x0255, r26	; 0x800255 <pl+0x1a>
    4d3a:	b0 93 56 02 	sts	0x0256, r27	; 0x800256 <pl+0x1b>
    4d3e:	df 91       	pop	r29
    4d40:	cf 91       	pop	r28
    4d42:	1f 91       	pop	r17
    4d44:	0f 91       	pop	r16
    4d46:	ff 90       	pop	r15
    4d48:	ef 90       	pop	r14
    4d4a:	df 90       	pop	r13
    4d4c:	cf 90       	pop	r12
    4d4e:	bf 90       	pop	r11
    4d50:	af 90       	pop	r10
    4d52:	9f 90       	pop	r9
    4d54:	8f 90       	pop	r8
    4d56:	7f 90       	pop	r7
    4d58:	6f 90       	pop	r6
    4d5a:	5f 90       	pop	r5
    4d5c:	08 95       	ret

00004d5e <plan_buffer_line>:
    4d5e:	2f 92       	push	r2
    4d60:	3f 92       	push	r3
    4d62:	4f 92       	push	r4
    4d64:	5f 92       	push	r5
    4d66:	6f 92       	push	r6
    4d68:	7f 92       	push	r7
    4d6a:	8f 92       	push	r8
    4d6c:	9f 92       	push	r9
    4d6e:	af 92       	push	r10
    4d70:	bf 92       	push	r11
    4d72:	cf 92       	push	r12
    4d74:	df 92       	push	r13
    4d76:	ef 92       	push	r14
    4d78:	ff 92       	push	r15
    4d7a:	0f 93       	push	r16
    4d7c:	1f 93       	push	r17
    4d7e:	cf 93       	push	r28
    4d80:	df 93       	push	r29
    4d82:	cd b7       	in	r28, 0x3d	; 61
    4d84:	de b7       	in	r29, 0x3e	; 62
    4d86:	c6 54       	subi	r28, 0x46	; 70
    4d88:	d1 09       	sbc	r29, r1
    4d8a:	0f b6       	in	r0, 0x3f	; 63
    4d8c:	f8 94       	cli
    4d8e:	de bf       	out	0x3e, r29	; 62
    4d90:	0f be       	out	0x3f, r0	; 63
    4d92:	cd bf       	out	0x3d, r28	; 61
    4d94:	25 96       	adiw	r28, 0x05	; 5
    4d96:	7f af       	std	Y+63, r23	; 0x3f
    4d98:	6e af       	std	Y+62, r22	; 0x3e
    4d9a:	25 97       	sbiw	r28, 0x05	; 5
    4d9c:	20 90 59 02 	lds	r2, 0x0259	; 0x800259 <block_buffer_head>
    4da0:	a2 2c       	mov	r10, r2
    4da2:	b1 2c       	mov	r11, r1
    4da4:	22 e3       	ldi	r18, 0x32	; 50
    4da6:	2a 9d       	mul	r18, r10
    4da8:	a0 01       	movw	r20, r0
    4daa:	2b 9d       	mul	r18, r11
    4dac:	50 0d       	add	r21, r0
    4dae:	11 24       	eor	r1, r1
    4db0:	ba 01       	movw	r22, r20
    4db2:	65 5a       	subi	r22, 0xA5	; 165
    4db4:	7d 4f       	sbci	r23, 0xFD	; 253
    4db6:	21 96       	adiw	r28, 0x01	; 1
    4db8:	7f af       	std	Y+63, r23	; 0x3f
    4dba:	6e af       	std	Y+62, r22	; 0x3e
    4dbc:	21 97       	sbiw	r28, 0x01	; 1
    4dbe:	fb 01       	movw	r30, r22
    4dc0:	11 92       	st	Z+, r1
    4dc2:	2a 95       	dec	r18
    4dc4:	e9 f7       	brne	.-6      	; 0x4dc0 <plan_buffer_line+0x62>
    4dc6:	25 96       	adiw	r28, 0x05	; 5
    4dc8:	ee ad       	ldd	r30, Y+62	; 0x3e
    4dca:	ff ad       	ldd	r31, Y+63	; 0x3f
    4dcc:	25 97       	sbiw	r28, 0x05	; 5
    4dce:	20 85       	ldd	r18, Z+8	; 0x08
    4dd0:	fb 01       	movw	r30, r22
    4dd2:	21 8b       	std	Z+17, r18	; 0x11
    4dd4:	25 96       	adiw	r28, 0x05	; 5
    4dd6:	ee ad       	ldd	r30, Y+62	; 0x3e
    4dd8:	ff ad       	ldd	r31, Y+63	; 0x3f
    4dda:	25 97       	sbiw	r28, 0x05	; 5
    4ddc:	44 81       	ldd	r20, Z+4	; 0x04
    4dde:	55 81       	ldd	r21, Z+5	; 0x05
    4de0:	66 81       	ldd	r22, Z+6	; 0x06
    4de2:	77 81       	ldd	r23, Z+7	; 0x07
    4de4:	21 96       	adiw	r28, 0x01	; 1
    4de6:	ee ad       	ldd	r30, Y+62	; 0x3e
    4de8:	ff ad       	ldd	r31, Y+63	; 0x3f
    4dea:	21 97       	sbiw	r28, 0x01	; 1
    4dec:	46 a7       	std	Z+46, r20	; 0x2e
    4dee:	57 a7       	std	Z+47, r21	; 0x2f
    4df0:	60 ab       	std	Z+48, r22	; 0x30
    4df2:	71 ab       	std	Z+49, r23	; 0x31
    4df4:	21 ff       	sbrs	r18, 1
    4df6:	0a c0       	rjmp	.+20     	; 0x4e0c <plan_buffer_line+0xae>
    4df8:	2c e0       	ldi	r18, 0x0C	; 12
    4dfa:	ec e9       	ldi	r30, 0x9C	; 156
    4dfc:	f5 e0       	ldi	r31, 0x05	; 5
    4dfe:	de 01       	movw	r26, r28
    4e00:	1d 96       	adiw	r26, 0x0d	; 13
    4e02:	01 90       	ld	r0, Z+
    4e04:	0d 92       	st	X+, r0
    4e06:	2a 95       	dec	r18
    4e08:	e1 f7       	brne	.-8      	; 0x4e02 <plan_buffer_line+0xa4>
    4e0a:	6d c2       	rjmp	.+1242   	; 0x52e6 <plan_buffer_line+0x588>
    4e0c:	2c e0       	ldi	r18, 0x0C	; 12
    4e0e:	eb e3       	ldi	r30, 0x3B	; 59
    4e10:	f2 e0       	ldi	r31, 0x02	; 2
    4e12:	de 01       	movw	r26, r28
    4e14:	1d 96       	adiw	r26, 0x0d	; 13
    4e16:	01 90       	ld	r0, Z+
    4e18:	0d 92       	st	X+, r0
    4e1a:	2a 95       	dec	r18
    4e1c:	e1 f7       	brne	.-8      	; 0x4e16 <plan_buffer_line+0xb8>
    4e1e:	63 c2       	rjmp	.+1222   	; 0x52e6 <plan_buffer_line+0x588>
    4e20:	e9 ad       	ldd	r30, Y+57	; 0x39
    4e22:	fa ad       	ldd	r31, Y+58	; 0x3a
    4e24:	61 91       	ld	r22, Z+
    4e26:	71 91       	ld	r23, Z+
    4e28:	81 91       	ld	r24, Z+
    4e2a:	91 91       	ld	r25, Z+
    4e2c:	fa af       	std	Y+58, r31	; 0x3a
    4e2e:	e9 af       	std	Y+57, r30	; 0x39
    4e30:	eb ad       	ldd	r30, Y+59	; 0x3b
    4e32:	fc ad       	ldd	r31, Y+60	; 0x3c
    4e34:	21 91       	ld	r18, Z+
    4e36:	31 91       	ld	r19, Z+
    4e38:	41 91       	ld	r20, Z+
    4e3a:	51 91       	ld	r21, Z+
    4e3c:	fc af       	std	Y+60, r31	; 0x3c
    4e3e:	eb af       	std	Y+59, r30	; 0x3b
    4e40:	2d ab       	std	Y+53, r18	; 0x35
    4e42:	3e ab       	std	Y+54, r19	; 0x36
    4e44:	4f ab       	std	Y+55, r20	; 0x37
    4e46:	58 af       	std	Y+56, r21	; 0x38
    4e48:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    4e4c:	0e 94 93 31 	call	0x6326	; 0x6326 <lround>
    4e50:	f4 01       	movw	r30, r8
    4e52:	61 93       	st	Z+, r22
    4e54:	71 93       	st	Z+, r23
    4e56:	81 93       	st	Z+, r24
    4e58:	91 93       	st	Z+, r25
    4e5a:	4f 01       	movw	r8, r30
    4e5c:	f6 01       	movw	r30, r12
    4e5e:	01 91       	ld	r16, Z+
    4e60:	11 91       	ld	r17, Z+
    4e62:	21 91       	ld	r18, Z+
    4e64:	31 91       	ld	r19, Z+
    4e66:	6f 01       	movw	r12, r30
    4e68:	60 1b       	sub	r22, r16
    4e6a:	71 0b       	sbc	r23, r17
    4e6c:	82 0b       	sbc	r24, r18
    4e6e:	93 0b       	sbc	r25, r19
    4e70:	8b 01       	movw	r16, r22
    4e72:	9c 01       	movw	r18, r24
    4e74:	3a f4       	brpl	.+14     	; 0x4e84 <plan_buffer_line+0x126>
    4e76:	00 27       	eor	r16, r16
    4e78:	11 27       	eor	r17, r17
    4e7a:	98 01       	movw	r18, r16
    4e7c:	06 1b       	sub	r16, r22
    4e7e:	17 0b       	sbc	r17, r23
    4e80:	28 0b       	sbc	r18, r24
    4e82:	39 0b       	sbc	r19, r25
    4e84:	f1 01       	movw	r30, r2
    4e86:	01 93       	st	Z+, r16
    4e88:	11 93       	st	Z+, r17
    4e8a:	21 93       	st	Z+, r18
    4e8c:	31 93       	st	Z+, r19
    4e8e:	1f 01       	movw	r2, r30
    4e90:	f7 01       	movw	r30, r14
    4e92:	40 80       	ld	r4, Z
    4e94:	51 80       	ldd	r5, Z+1	; 0x01
    4e96:	62 80       	ldd	r6, Z+2	; 0x02
    4e98:	73 80       	ldd	r7, Z+3	; 0x03
    4e9a:	40 16       	cp	r4, r16
    4e9c:	51 06       	cpc	r5, r17
    4e9e:	62 06       	cpc	r6, r18
    4ea0:	73 06       	cpc	r7, r19
    4ea2:	10 f4       	brcc	.+4      	; 0x4ea8 <plan_buffer_line+0x14a>
    4ea4:	28 01       	movw	r4, r16
    4ea6:	39 01       	movw	r6, r18
    4ea8:	f7 01       	movw	r30, r14
    4eaa:	40 82       	st	Z, r4
    4eac:	51 82       	std	Z+1, r5	; 0x01
    4eae:	62 82       	std	Z+2, r6	; 0x02
    4eb0:	73 82       	std	Z+3, r7	; 0x03
    4eb2:	0e 94 18 30 	call	0x6030	; 0x6030 <__floatsisf>
    4eb6:	2d a9       	ldd	r18, Y+53	; 0x35
    4eb8:	3e a9       	ldd	r19, Y+54	; 0x36
    4eba:	4f a9       	ldd	r20, Y+55	; 0x37
    4ebc:	58 ad       	ldd	r21, Y+56	; 0x38
    4ebe:	0e 94 6e 2f 	call	0x5edc	; 0x5edc <__divsf3>
    4ec2:	ed ad       	ldd	r30, Y+61	; 0x3d
    4ec4:	fe ad       	ldd	r31, Y+62	; 0x3e
    4ec6:	61 93       	st	Z+, r22
    4ec8:	71 93       	st	Z+, r23
    4eca:	81 93       	st	Z+, r24
    4ecc:	91 93       	st	Z+, r25
    4ece:	fe af       	std	Y+62, r31	; 0x3e
    4ed0:	ed af       	std	Y+61, r30	; 0x3d
    4ed2:	20 e0       	ldi	r18, 0x00	; 0
    4ed4:	30 e0       	ldi	r19, 0x00	; 0
    4ed6:	a9 01       	movw	r20, r18
    4ed8:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    4edc:	88 23       	and	r24, r24
    4ede:	54 f4       	brge	.+20     	; 0x4ef4 <plan_buffer_line+0x196>
    4ee0:	89 a9       	ldd	r24, Y+49	; 0x31
    4ee2:	0e 94 9c 23 	call	0x4738	; 0x4738 <get_direction_pin_mask>
    4ee6:	27 96       	adiw	r28, 0x07	; 7
    4ee8:	ee ad       	ldd	r30, Y+62	; 0x3e
    4eea:	ff ad       	ldd	r31, Y+63	; 0x3f
    4eec:	27 97       	sbiw	r28, 0x07	; 7
    4eee:	90 81       	ld	r25, Z
    4ef0:	89 2b       	or	r24, r25
    4ef2:	80 83       	st	Z, r24
    4ef4:	f9 a9       	ldd	r31, Y+49	; 0x31
    4ef6:	ff 5f       	subi	r31, 0xFF	; 255
    4ef8:	f9 ab       	std	Y+49, r31	; 0x31
    4efa:	f3 30       	cpi	r31, 0x03	; 3
    4efc:	09 f0       	breq	.+2      	; 0x4f00 <plan_buffer_line+0x1a2>
    4efe:	90 cf       	rjmp	.-224    	; 0x4e20 <plan_buffer_line+0xc2>
    4f00:	82 e3       	ldi	r24, 0x32	; 50
    4f02:	8a 9d       	mul	r24, r10
    4f04:	f0 01       	movw	r30, r0
    4f06:	8b 9d       	mul	r24, r11
    4f08:	f0 0d       	add	r31, r0
    4f0a:	11 24       	eor	r1, r1
    4f0c:	e5 5a       	subi	r30, 0xA5	; 165
    4f0e:	fd 4f       	sbci	r31, 0xFD	; 253
    4f10:	84 85       	ldd	r24, Z+12	; 0x0c
    4f12:	95 85       	ldd	r25, Z+13	; 0x0d
    4f14:	a6 85       	ldd	r26, Z+14	; 0x0e
    4f16:	b7 85       	ldd	r27, Z+15	; 0x0f
    4f18:	89 2b       	or	r24, r25
    4f1a:	8a 2b       	or	r24, r26
    4f1c:	8b 2b       	or	r24, r27
    4f1e:	09 f4       	brne	.+2      	; 0x4f22 <plan_buffer_line+0x1c4>
    4f20:	de c1       	rjmp	.+956    	; 0x52de <plan_buffer_line+0x580>
    4f22:	ce 01       	movw	r24, r28
    4f24:	49 96       	adiw	r24, 0x19	; 25
    4f26:	0e 94 1e 2b 	call	0x563c	; 0x563c <convert_delta_vector_to_unit_vector>
    4f2a:	22 e3       	ldi	r18, 0x32	; 50
    4f2c:	2a 9d       	mul	r18, r10
    4f2e:	80 01       	movw	r16, r0
    4f30:	2b 9d       	mul	r18, r11
    4f32:	10 0d       	add	r17, r0
    4f34:	11 24       	eor	r1, r1
    4f36:	05 5a       	subi	r16, 0xA5	; 165
    4f38:	1d 4f       	sbci	r17, 0xFD	; 253
    4f3a:	f8 01       	movw	r30, r16
    4f3c:	66 8f       	std	Z+30, r22	; 0x1e
    4f3e:	77 8f       	std	Z+31, r23	; 0x1f
    4f40:	80 a3       	std	Z+32, r24	; 0x20
    4f42:	91 a3       	std	Z+33, r25	; 0x21
    4f44:	be 01       	movw	r22, r28
    4f46:	67 5e       	subi	r22, 0xE7	; 231
    4f48:	7f 4f       	sbci	r23, 0xFF	; 255
    4f4a:	86 e2       	ldi	r24, 0x26	; 38
    4f4c:	97 e0       	ldi	r25, 0x07	; 7
    4f4e:	0e 94 85 2b 	call	0x570a	; 0x570a <limit_value_by_axis_maximum>
    4f52:	f8 01       	movw	r30, r16
    4f54:	62 8f       	std	Z+26, r22	; 0x1a
    4f56:	73 8f       	std	Z+27, r23	; 0x1b
    4f58:	84 8f       	std	Z+28, r24	; 0x1c
    4f5a:	95 8f       	std	Z+29, r25	; 0x1d
    4f5c:	be 01       	movw	r22, r28
    4f5e:	67 5e       	subi	r22, 0xE7	; 231
    4f60:	7f 4f       	sbci	r23, 0xFF	; 255
    4f62:	8a e1       	ldi	r24, 0x1A	; 26
    4f64:	97 e0       	ldi	r25, 0x07	; 7
    4f66:	0e 94 85 2b 	call	0x570a	; 0x570a <limit_value_by_axis_maximum>
    4f6a:	f8 01       	movw	r30, r16
    4f6c:	66 a3       	std	Z+38, r22	; 0x26
    4f6e:	77 a3       	std	Z+39, r23	; 0x27
    4f70:	80 a7       	std	Z+40, r24	; 0x28
    4f72:	91 a7       	std	Z+41, r25	; 0x29
    4f74:	11 89       	ldd	r17, Z+17	; 0x11
    4f76:	10 ff       	sbrs	r17, 0
    4f78:	0d c0       	rjmp	.+26     	; 0x4f94 <plan_buffer_line+0x236>
    4f7a:	22 e3       	ldi	r18, 0x32	; 50
    4f7c:	2a 9d       	mul	r18, r10
    4f7e:	f0 01       	movw	r30, r0
    4f80:	2b 9d       	mul	r18, r11
    4f82:	f0 0d       	add	r31, r0
    4f84:	11 24       	eor	r1, r1
    4f86:	e5 5a       	subi	r30, 0xA5	; 165
    4f88:	fd 4f       	sbci	r31, 0xFD	; 253
    4f8a:	62 a7       	std	Z+42, r22	; 0x2a
    4f8c:	73 a7       	std	Z+43, r23	; 0x2b
    4f8e:	84 a7       	std	Z+44, r24	; 0x2c
    4f90:	95 a7       	std	Z+45, r25	; 0x2d
    4f92:	22 c0       	rjmp	.+68     	; 0x4fd8 <plan_buffer_line+0x27a>
    4f94:	25 96       	adiw	r28, 0x05	; 5
    4f96:	ee ad       	ldd	r30, Y+62	; 0x3e
    4f98:	ff ad       	ldd	r31, Y+63	; 0x3f
    4f9a:	25 97       	sbiw	r28, 0x05	; 5
    4f9c:	20 81       	ld	r18, Z
    4f9e:	31 81       	ldd	r19, Z+1	; 0x01
    4fa0:	42 81       	ldd	r20, Z+2	; 0x02
    4fa2:	53 81       	ldd	r21, Z+3	; 0x03
    4fa4:	82 e3       	ldi	r24, 0x32	; 50
    4fa6:	8a 9d       	mul	r24, r10
    4fa8:	f0 01       	movw	r30, r0
    4faa:	8b 9d       	mul	r24, r11
    4fac:	f0 0d       	add	r31, r0
    4fae:	11 24       	eor	r1, r1
    4fb0:	e5 5a       	subi	r30, 0xA5	; 165
    4fb2:	fd 4f       	sbci	r31, 0xFD	; 253
    4fb4:	22 a7       	std	Z+42, r18	; 0x2a
    4fb6:	33 a7       	std	Z+43, r19	; 0x2b
    4fb8:	44 a7       	std	Z+44, r20	; 0x2c
    4fba:	55 a7       	std	Z+45, r21	; 0x2d
    4fbc:	13 ff       	sbrs	r17, 3
    4fbe:	0c c0       	rjmp	.+24     	; 0x4fd8 <plan_buffer_line+0x27a>
    4fc0:	7f 01       	movw	r14, r30
    4fc2:	66 8d       	ldd	r22, Z+30	; 0x1e
    4fc4:	77 8d       	ldd	r23, Z+31	; 0x1f
    4fc6:	80 a1       	ldd	r24, Z+32	; 0x20
    4fc8:	91 a1       	ldd	r25, Z+33	; 0x21
    4fca:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    4fce:	f7 01       	movw	r30, r14
    4fd0:	62 a7       	std	Z+42, r22	; 0x2a
    4fd2:	73 a7       	std	Z+43, r23	; 0x2b
    4fd4:	84 a7       	std	Z+44, r24	; 0x2c
    4fd6:	95 a7       	std	Z+45, r25	; 0x2d
    4fd8:	90 91 59 02 	lds	r25, 0x0259	; 0x800259 <block_buffer_head>
    4fdc:	80 91 5a 02 	lds	r24, 0x025A	; 0x80025a <block_buffer_tail>
    4fe0:	98 17       	cp	r25, r24
    4fe2:	11 f0       	breq	.+4      	; 0x4fe8 <plan_buffer_line+0x28a>
    4fe4:	11 ff       	sbrs	r17, 1
    4fe6:	11 c0       	rjmp	.+34     	; 0x500a <plan_buffer_line+0x2ac>
    4fe8:	82 e3       	ldi	r24, 0x32	; 50
    4fea:	8a 9d       	mul	r24, r10
    4fec:	f0 01       	movw	r30, r0
    4fee:	8b 9d       	mul	r24, r11
    4ff0:	f0 0d       	add	r31, r0
    4ff2:	11 24       	eor	r1, r1
    4ff4:	e5 5a       	subi	r30, 0xA5	; 165
    4ff6:	fd 4f       	sbci	r31, 0xFD	; 253
    4ff8:	12 8a       	std	Z+18, r1	; 0x12
    4ffa:	13 8a       	std	Z+19, r1	; 0x13
    4ffc:	14 8a       	std	Z+20, r1	; 0x14
    4ffe:	15 8a       	std	Z+21, r1	; 0x15
    5000:	12 a2       	std	Z+34, r1	; 0x22
    5002:	13 a2       	std	Z+35, r1	; 0x23
    5004:	14 a2       	std	Z+36, r1	; 0x24
    5006:	15 a2       	std	Z+37, r1	; 0x25
    5008:	d8 c0       	rjmp	.+432    	; 0x51ba <plan_buffer_line+0x45c>
    500a:	07 e4       	ldi	r16, 0x47	; 71
    500c:	12 e0       	ldi	r17, 0x02	; 2
    500e:	1e 01       	movw	r2, r28
    5010:	f5 e2       	ldi	r31, 0x25	; 37
    5012:	2f 0e       	add	r2, r31
    5014:	31 1c       	adc	r3, r1
    5016:	41 01       	movw	r8, r2
    5018:	19 aa       	std	Y+49, r1	; 0x31
    501a:	1a aa       	std	Y+50, r1	; 0x32
    501c:	1b aa       	std	Y+51, r1	; 0x33
    501e:	1c aa       	std	Y+52, r1	; 0x34
    5020:	f8 01       	movw	r30, r16
    5022:	c1 90       	ld	r12, Z+
    5024:	d1 90       	ld	r13, Z+
    5026:	e1 90       	ld	r14, Z+
    5028:	f1 90       	ld	r15, Z+
    502a:	8f 01       	movw	r16, r30
    502c:	23 96       	adiw	r28, 0x03	; 3
    502e:	ee ad       	ldd	r30, Y+62	; 0x3e
    5030:	ff ad       	ldd	r31, Y+63	; 0x3f
    5032:	23 97       	sbiw	r28, 0x03	; 3
    5034:	41 90       	ld	r4, Z+
    5036:	51 90       	ld	r5, Z+
    5038:	61 90       	ld	r6, Z+
    503a:	71 90       	ld	r7, Z+
    503c:	23 96       	adiw	r28, 0x03	; 3
    503e:	ff af       	std	Y+63, r31	; 0x3f
    5040:	ee af       	std	Y+62, r30	; 0x3e
    5042:	23 97       	sbiw	r28, 0x03	; 3
    5044:	a3 01       	movw	r20, r6
    5046:	92 01       	movw	r18, r4
    5048:	c7 01       	movw	r24, r14
    504a:	b6 01       	movw	r22, r12
    504c:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    5050:	9b 01       	movw	r18, r22
    5052:	ac 01       	movw	r20, r24
    5054:	69 a9       	ldd	r22, Y+49	; 0x31
    5056:	7a a9       	ldd	r23, Y+50	; 0x32
    5058:	8b a9       	ldd	r24, Y+51	; 0x33
    505a:	9c a9       	ldd	r25, Y+52	; 0x34
    505c:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    5060:	69 ab       	std	Y+49, r22	; 0x31
    5062:	7a ab       	std	Y+50, r23	; 0x32
    5064:	8b ab       	std	Y+51, r24	; 0x33
    5066:	9c ab       	std	Y+52, r25	; 0x34
    5068:	a7 01       	movw	r20, r14
    506a:	96 01       	movw	r18, r12
    506c:	c3 01       	movw	r24, r6
    506e:	b2 01       	movw	r22, r4
    5070:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    5074:	f1 01       	movw	r30, r2
    5076:	61 93       	st	Z+, r22
    5078:	71 93       	st	Z+, r23
    507a:	81 93       	st	Z+, r24
    507c:	91 93       	st	Z+, r25
    507e:	1f 01       	movw	r2, r30
    5080:	23 96       	adiw	r28, 0x03	; 3
    5082:	2e ad       	ldd	r18, Y+62	; 0x3e
    5084:	3f ad       	ldd	r19, Y+63	; 0x3f
    5086:	23 97       	sbiw	r28, 0x03	; 3
    5088:	28 15       	cp	r18, r8
    508a:	39 05       	cpc	r19, r9
    508c:	49 f6       	brne	.-110    	; 0x5020 <plan_buffer_line+0x2c2>
    508e:	2f ee       	ldi	r18, 0xEF	; 239
    5090:	3f ef       	ldi	r19, 0xFF	; 255
    5092:	4f e7       	ldi	r20, 0x7F	; 127
    5094:	5f e3       	ldi	r21, 0x3F	; 63
    5096:	69 a9       	ldd	r22, Y+49	; 0x31
    5098:	7a a9       	ldd	r23, Y+50	; 0x32
    509a:	8b a9       	ldd	r24, Y+51	; 0x33
    509c:	9c a9       	ldd	r25, Y+52	; 0x34
    509e:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    50a2:	18 16       	cp	r1, r24
    50a4:	6c f4       	brge	.+26     	; 0x50c0 <plan_buffer_line+0x362>
    50a6:	82 e3       	ldi	r24, 0x32	; 50
    50a8:	8a 9d       	mul	r24, r10
    50aa:	f0 01       	movw	r30, r0
    50ac:	8b 9d       	mul	r24, r11
    50ae:	f0 0d       	add	r31, r0
    50b0:	11 24       	eor	r1, r1
    50b2:	e5 5a       	subi	r30, 0xA5	; 165
    50b4:	fd 4f       	sbci	r31, 0xFD	; 253
    50b6:	12 a2       	std	Z+34, r1	; 0x22
    50b8:	13 a2       	std	Z+35, r1	; 0x23
    50ba:	14 a2       	std	Z+36, r1	; 0x24
    50bc:	15 a2       	std	Z+37, r1	; 0x25
    50be:	7d c0       	rjmp	.+250    	; 0x51ba <plan_buffer_line+0x45c>
    50c0:	2f ee       	ldi	r18, 0xEF	; 239
    50c2:	3f ef       	ldi	r19, 0xFF	; 255
    50c4:	4f e7       	ldi	r20, 0x7F	; 127
    50c6:	5f eb       	ldi	r21, 0xBF	; 191
    50c8:	69 a9       	ldd	r22, Y+49	; 0x31
    50ca:	7a a9       	ldd	r23, Y+50	; 0x32
    50cc:	8b a9       	ldd	r24, Y+51	; 0x33
    50ce:	9c a9       	ldd	r25, Y+52	; 0x34
    50d0:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    50d4:	88 23       	and	r24, r24
    50d6:	8c f4       	brge	.+34     	; 0x50fa <plan_buffer_line+0x39c>
    50d8:	82 e3       	ldi	r24, 0x32	; 50
    50da:	8a 9d       	mul	r24, r10
    50dc:	f0 01       	movw	r30, r0
    50de:	8b 9d       	mul	r24, r11
    50e0:	f0 0d       	add	r31, r0
    50e2:	11 24       	eor	r1, r1
    50e4:	e5 5a       	subi	r30, 0xA5	; 165
    50e6:	fd 4f       	sbci	r31, 0xFD	; 253
    50e8:	89 e9       	ldi	r24, 0x99	; 153
    50ea:	96 e7       	ldi	r25, 0x76	; 118
    50ec:	a6 e9       	ldi	r26, 0x96	; 150
    50ee:	be e7       	ldi	r27, 0x7E	; 126
    50f0:	82 a3       	std	Z+34, r24	; 0x22
    50f2:	93 a3       	std	Z+35, r25	; 0x23
    50f4:	a4 a3       	std	Z+36, r26	; 0x24
    50f6:	b5 a3       	std	Z+37, r27	; 0x25
    50f8:	60 c0       	rjmp	.+192    	; 0x51ba <plan_buffer_line+0x45c>
    50fa:	ce 01       	movw	r24, r28
    50fc:	85 96       	adiw	r24, 0x25	; 37
    50fe:	0e 94 1e 2b 	call	0x563c	; 0x563c <convert_delta_vector_to_unit_vector>
    5102:	be 01       	movw	r22, r28
    5104:	6b 5d       	subi	r22, 0xDB	; 219
    5106:	7f 4f       	sbci	r23, 0xFF	; 255
    5108:	86 e2       	ldi	r24, 0x26	; 38
    510a:	97 e0       	ldi	r25, 0x07	; 7
    510c:	0e 94 85 2b 	call	0x570a	; 0x570a <limit_value_by_axis_maximum>
    5110:	6b 01       	movw	r12, r22
    5112:	7c 01       	movw	r14, r24
    5114:	29 a9       	ldd	r18, Y+49	; 0x31
    5116:	3a a9       	ldd	r19, Y+50	; 0x32
    5118:	4b a9       	ldd	r20, Y+51	; 0x33
    511a:	5c a9       	ldd	r21, Y+52	; 0x34
    511c:	60 e0       	ldi	r22, 0x00	; 0
    511e:	70 e0       	ldi	r23, 0x00	; 0
    5120:	80 e8       	ldi	r24, 0x80	; 128
    5122:	9f e3       	ldi	r25, 0x3F	; 63
    5124:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    5128:	20 e0       	ldi	r18, 0x00	; 0
    512a:	30 e0       	ldi	r19, 0x00	; 0
    512c:	40 e0       	ldi	r20, 0x00	; 0
    512e:	5f e3       	ldi	r21, 0x3F	; 63
    5130:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    5134:	0e 94 65 32 	call	0x64ca	; 0x64ca <sqrt>
    5138:	2b 01       	movw	r4, r22
    513a:	3c 01       	movw	r6, r24
    513c:	20 91 43 07 	lds	r18, 0x0743	; 0x800743 <settings+0x35>
    5140:	30 91 44 07 	lds	r19, 0x0744	; 0x800744 <settings+0x36>
    5144:	40 91 45 07 	lds	r20, 0x0745	; 0x800745 <settings+0x37>
    5148:	50 91 46 07 	lds	r21, 0x0746	; 0x800746 <settings+0x38>
    514c:	c7 01       	movw	r24, r14
    514e:	b6 01       	movw	r22, r12
    5150:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    5154:	a3 01       	movw	r20, r6
    5156:	92 01       	movw	r18, r4
    5158:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    515c:	6b 01       	movw	r12, r22
    515e:	7c 01       	movw	r14, r24
    5160:	a3 01       	movw	r20, r6
    5162:	92 01       	movw	r18, r4
    5164:	60 e0       	ldi	r22, 0x00	; 0
    5166:	70 e0       	ldi	r23, 0x00	; 0
    5168:	80 e8       	ldi	r24, 0x80	; 128
    516a:	9f e3       	ldi	r25, 0x3F	; 63
    516c:	0e 94 6e 2e 	call	0x5cdc	; 0x5cdc <__subsf3>
    5170:	9b 01       	movw	r18, r22
    5172:	ac 01       	movw	r20, r24
    5174:	c7 01       	movw	r24, r14
    5176:	b6 01       	movw	r22, r12
    5178:	0e 94 6e 2f 	call	0x5edc	; 0x5edc <__divsf3>
    517c:	e6 2e       	mov	r14, r22
    517e:	f7 2e       	mov	r15, r23
    5180:	08 2f       	mov	r16, r24
    5182:	19 2f       	mov	r17, r25
    5184:	20 e0       	ldi	r18, 0x00	; 0
    5186:	30 e0       	ldi	r19, 0x00	; 0
    5188:	a9 01       	movw	r20, r18
    518a:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    518e:	88 23       	and	r24, r24
    5190:	24 f4       	brge	.+8      	; 0x519a <plan_buffer_line+0x43c>
    5192:	e1 2c       	mov	r14, r1
    5194:	f1 2c       	mov	r15, r1
    5196:	00 e0       	ldi	r16, 0x00	; 0
    5198:	10 e0       	ldi	r17, 0x00	; 0
    519a:	82 e3       	ldi	r24, 0x32	; 50
    519c:	8a 9d       	mul	r24, r10
    519e:	f0 01       	movw	r30, r0
    51a0:	8b 9d       	mul	r24, r11
    51a2:	f0 0d       	add	r31, r0
    51a4:	11 24       	eor	r1, r1
    51a6:	e5 5a       	subi	r30, 0xA5	; 165
    51a8:	fd 4f       	sbci	r31, 0xFD	; 253
    51aa:	4e 2d       	mov	r20, r14
    51ac:	5f 2d       	mov	r21, r15
    51ae:	60 2f       	mov	r22, r16
    51b0:	71 2f       	mov	r23, r17
    51b2:	42 a3       	std	Z+34, r20	; 0x22
    51b4:	53 a3       	std	Z+35, r21	; 0x23
    51b6:	64 a3       	std	Z+36, r22	; 0x24
    51b8:	75 a3       	std	Z+37, r23	; 0x25
    51ba:	82 e3       	ldi	r24, 0x32	; 50
    51bc:	8a 9d       	mul	r24, r10
    51be:	f0 01       	movw	r30, r0
    51c0:	8b 9d       	mul	r24, r11
    51c2:	f0 0d       	add	r31, r0
    51c4:	11 24       	eor	r1, r1
    51c6:	e5 5a       	subi	r30, 0xA5	; 165
    51c8:	fd 4f       	sbci	r31, 0xFD	; 253
    51ca:	81 89       	ldd	r24, Z+17	; 0x11
    51cc:	81 fd       	sbrc	r24, 1
    51ce:	89 c0       	rjmp	.+274    	; 0x52e2 <plan_buffer_line+0x584>
    51d0:	21 96       	adiw	r28, 0x01	; 1
    51d2:	8e ad       	ldd	r24, Y+62	; 0x3e
    51d4:	9f ad       	ldd	r25, Y+63	; 0x3f
    51d6:	21 97       	sbiw	r28, 0x01	; 1
    51d8:	0e 94 78 25 	call	0x4af0	; 0x4af0 <plan_compute_profile_nominal_speed>
    51dc:	6b 01       	movw	r12, r22
    51de:	7c 01       	movw	r14, r24
    51e0:	40 90 53 02 	lds	r4, 0x0253	; 0x800253 <pl+0x18>
    51e4:	50 90 54 02 	lds	r5, 0x0254	; 0x800254 <pl+0x19>
    51e8:	60 90 55 02 	lds	r6, 0x0255	; 0x800255 <pl+0x1a>
    51ec:	70 90 56 02 	lds	r7, 0x0256	; 0x800256 <pl+0x1b>
    51f0:	a3 01       	movw	r20, r6
    51f2:	92 01       	movw	r18, r4
    51f4:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    51f8:	18 16       	cp	r1, r24
    51fa:	a4 f4       	brge	.+40     	; 0x5224 <plan_buffer_line+0x4c6>
    51fc:	82 e3       	ldi	r24, 0x32	; 50
    51fe:	8a 9d       	mul	r24, r10
    5200:	80 01       	movw	r16, r0
    5202:	8b 9d       	mul	r24, r11
    5204:	10 0d       	add	r17, r0
    5206:	11 24       	eor	r1, r1
    5208:	05 5a       	subi	r16, 0xA5	; 165
    520a:	1d 4f       	sbci	r17, 0xFD	; 253
    520c:	a3 01       	movw	r20, r6
    520e:	92 01       	movw	r18, r4
    5210:	c3 01       	movw	r24, r6
    5212:	b2 01       	movw	r22, r4
    5214:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    5218:	f8 01       	movw	r30, r16
    521a:	66 8b       	std	Z+22, r22	; 0x16
    521c:	77 8b       	std	Z+23, r23	; 0x17
    521e:	80 8f       	std	Z+24, r24	; 0x18
    5220:	91 8f       	std	Z+25, r25	; 0x19
    5222:	13 c0       	rjmp	.+38     	; 0x524a <plan_buffer_line+0x4ec>
    5224:	82 e3       	ldi	r24, 0x32	; 50
    5226:	8a 9d       	mul	r24, r10
    5228:	80 01       	movw	r16, r0
    522a:	8b 9d       	mul	r24, r11
    522c:	10 0d       	add	r17, r0
    522e:	11 24       	eor	r1, r1
    5230:	05 5a       	subi	r16, 0xA5	; 165
    5232:	1d 4f       	sbci	r17, 0xFD	; 253
    5234:	a7 01       	movw	r20, r14
    5236:	96 01       	movw	r18, r12
    5238:	c7 01       	movw	r24, r14
    523a:	b6 01       	movw	r22, r12
    523c:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    5240:	f8 01       	movw	r30, r16
    5242:	66 8b       	std	Z+22, r22	; 0x16
    5244:	77 8b       	std	Z+23, r23	; 0x17
    5246:	80 8f       	std	Z+24, r24	; 0x18
    5248:	91 8f       	std	Z+25, r25	; 0x19
    524a:	82 e3       	ldi	r24, 0x32	; 50
    524c:	8a 9d       	mul	r24, r10
    524e:	f0 01       	movw	r30, r0
    5250:	8b 9d       	mul	r24, r11
    5252:	f0 0d       	add	r31, r0
    5254:	11 24       	eor	r1, r1
    5256:	e5 5a       	subi	r30, 0xA5	; 165
    5258:	fd 4f       	sbci	r31, 0xFD	; 253
    525a:	42 a0       	ldd	r4, Z+34	; 0x22
    525c:	53 a0       	ldd	r5, Z+35	; 0x23
    525e:	64 a0       	ldd	r6, Z+36	; 0x24
    5260:	75 a0       	ldd	r7, Z+37	; 0x25
    5262:	a3 01       	movw	r20, r6
    5264:	92 01       	movw	r18, r4
    5266:	66 89       	ldd	r22, Z+22	; 0x16
    5268:	77 89       	ldd	r23, Z+23	; 0x17
    526a:	80 8d       	ldd	r24, Z+24	; 0x18
    526c:	91 8d       	ldd	r25, Z+25	; 0x19
    526e:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    5272:	18 16       	cp	r1, r24
    5274:	64 f4       	brge	.+24     	; 0x528e <plan_buffer_line+0x530>
    5276:	82 e3       	ldi	r24, 0x32	; 50
    5278:	8a 9d       	mul	r24, r10
    527a:	f0 01       	movw	r30, r0
    527c:	8b 9d       	mul	r24, r11
    527e:	f0 0d       	add	r31, r0
    5280:	11 24       	eor	r1, r1
    5282:	e5 5a       	subi	r30, 0xA5	; 165
    5284:	fd 4f       	sbci	r31, 0xFD	; 253
    5286:	46 8a       	std	Z+22, r4	; 0x16
    5288:	57 8a       	std	Z+23, r5	; 0x17
    528a:	60 8e       	std	Z+24, r6	; 0x18
    528c:	71 8e       	std	Z+25, r7	; 0x19
    528e:	c0 92 53 02 	sts	0x0253, r12	; 0x800253 <pl+0x18>
    5292:	d0 92 54 02 	sts	0x0254, r13	; 0x800254 <pl+0x19>
    5296:	e0 92 55 02 	sts	0x0255, r14	; 0x800255 <pl+0x1a>
    529a:	f0 92 56 02 	sts	0x0256, r15	; 0x800256 <pl+0x1b>
    529e:	8c e0       	ldi	r24, 0x0C	; 12
    52a0:	fe 01       	movw	r30, r28
    52a2:	79 96       	adiw	r30, 0x19	; 25
    52a4:	a7 e4       	ldi	r26, 0x47	; 71
    52a6:	b2 e0       	ldi	r27, 0x02	; 2
    52a8:	01 90       	ld	r0, Z+
    52aa:	0d 92       	st	X+, r0
    52ac:	8a 95       	dec	r24
    52ae:	e1 f7       	brne	.-8      	; 0x52a8 <plan_buffer_line+0x54a>
    52b0:	8c e0       	ldi	r24, 0x0C	; 12
    52b2:	fe 01       	movw	r30, r28
    52b4:	31 96       	adiw	r30, 0x01	; 1
    52b6:	ab e3       	ldi	r26, 0x3B	; 59
    52b8:	b2 e0       	ldi	r27, 0x02	; 2
    52ba:	01 90       	ld	r0, Z+
    52bc:	0d 92       	st	X+, r0
    52be:	8a 95       	dec	r24
    52c0:	e1 f7       	brne	.-8      	; 0x52ba <plan_buffer_line+0x55c>
    52c2:	80 91 58 02 	lds	r24, 0x0258	; 0x800258 <next_buffer_head>
    52c6:	80 93 59 02 	sts	0x0259, r24	; 0x800259 <block_buffer_head>
    52ca:	8f 5f       	subi	r24, 0xFF	; 255
    52cc:	80 31       	cpi	r24, 0x10	; 16
    52ce:	09 f4       	brne	.+2      	; 0x52d2 <plan_buffer_line+0x574>
    52d0:	80 e0       	ldi	r24, 0x00	; 0
    52d2:	80 93 58 02 	sts	0x0258, r24	; 0x800258 <next_buffer_head>
    52d6:	0e 94 b0 23 	call	0x4760	; 0x4760 <planner_recalculate>
    52da:	81 e0       	ldi	r24, 0x01	; 1
    52dc:	39 c0       	rjmp	.+114    	; 0x5350 <plan_buffer_line+0x5f2>
    52de:	80 e0       	ldi	r24, 0x00	; 0
    52e0:	37 c0       	rjmp	.+110    	; 0x5350 <plan_buffer_line+0x5f2>
    52e2:	81 e0       	ldi	r24, 0x01	; 1
    52e4:	35 c0       	rjmp	.+106    	; 0x5350 <plan_buffer_line+0x5f2>
    52e6:	89 af       	std	Y+57, r24	; 0x39
    52e8:	9a af       	std	Y+58, r25	; 0x3a
    52ea:	2e e0       	ldi	r18, 0x0E	; 14
    52ec:	37 e0       	ldi	r19, 0x07	; 7
    52ee:	3c af       	std	Y+60, r19	; 0x3c
    52f0:	2b af       	std	Y+59, r18	; 0x3b
    52f2:	ae 01       	movw	r20, r28
    52f4:	4f 5f       	subi	r20, 0xFF	; 255
    52f6:	5f 4f       	sbci	r21, 0xFF	; 255
    52f8:	4a 01       	movw	r8, r20
    52fa:	6e 01       	movw	r12, r28
    52fc:	5d e0       	ldi	r21, 0x0D	; 13
    52fe:	c5 0e       	add	r12, r21
    5300:	d1 1c       	adc	r13, r1
    5302:	62 e3       	ldi	r22, 0x32	; 50
    5304:	26 9e       	mul	r2, r22
    5306:	c0 01       	movw	r24, r0
    5308:	11 24       	eor	r1, r1
    530a:	fc 01       	movw	r30, r24
    530c:	e5 5a       	subi	r30, 0xA5	; 165
    530e:	fd 4f       	sbci	r31, 0xFD	; 253
    5310:	1f 01       	movw	r2, r30
    5312:	9e 01       	movw	r18, r28
    5314:	27 5e       	subi	r18, 0xE7	; 231
    5316:	3f 4f       	sbci	r19, 0xFF	; 255
    5318:	23 96       	adiw	r28, 0x03	; 3
    531a:	3f af       	std	Y+63, r19	; 0x3f
    531c:	2e af       	std	Y+62, r18	; 0x3e
    531e:	23 97       	sbiw	r28, 0x03	; 3
    5320:	3e af       	std	Y+62, r19	; 0x3e
    5322:	2d af       	std	Y+61, r18	; 0x3d
    5324:	10 e0       	ldi	r17, 0x00	; 0
    5326:	22 e3       	ldi	r18, 0x32	; 50
    5328:	2a 9d       	mul	r18, r10
    532a:	c0 01       	movw	r24, r0
    532c:	2b 9d       	mul	r18, r11
    532e:	90 0d       	add	r25, r0
    5330:	11 24       	eor	r1, r1
    5332:	85 5a       	subi	r24, 0xA5	; 165
    5334:	9d 4f       	sbci	r25, 0xFD	; 253
    5336:	7c 01       	movw	r14, r24
    5338:	3c e0       	ldi	r19, 0x0C	; 12
    533a:	e3 0e       	add	r14, r19
    533c:	f1 1c       	adc	r15, r1
    533e:	ac 01       	movw	r20, r24
    5340:	40 5f       	subi	r20, 0xF0	; 240
    5342:	5f 4f       	sbci	r21, 0xFF	; 255
    5344:	27 96       	adiw	r28, 0x07	; 7
    5346:	5f af       	std	Y+63, r21	; 0x3f
    5348:	4e af       	std	Y+62, r20	; 0x3e
    534a:	27 97       	sbiw	r28, 0x07	; 7
    534c:	19 ab       	std	Y+49, r17	; 0x31
    534e:	68 cd       	rjmp	.-1328   	; 0x4e20 <plan_buffer_line+0xc2>
    5350:	ca 5b       	subi	r28, 0xBA	; 186
    5352:	df 4f       	sbci	r29, 0xFF	; 255
    5354:	0f b6       	in	r0, 0x3f	; 63
    5356:	f8 94       	cli
    5358:	de bf       	out	0x3e, r29	; 62
    535a:	0f be       	out	0x3f, r0	; 63
    535c:	cd bf       	out	0x3d, r28	; 61
    535e:	df 91       	pop	r29
    5360:	cf 91       	pop	r28
    5362:	1f 91       	pop	r17
    5364:	0f 91       	pop	r16
    5366:	ff 90       	pop	r15
    5368:	ef 90       	pop	r14
    536a:	df 90       	pop	r13
    536c:	cf 90       	pop	r12
    536e:	bf 90       	pop	r11
    5370:	af 90       	pop	r10
    5372:	9f 90       	pop	r9
    5374:	8f 90       	pop	r8
    5376:	7f 90       	pop	r7
    5378:	6f 90       	pop	r6
    537a:	5f 90       	pop	r5
    537c:	4f 90       	pop	r4
    537e:	3f 90       	pop	r3
    5380:	2f 90       	pop	r2
    5382:	08 95       	ret

00005384 <plan_sync_position>:
    5384:	ec e9       	ldi	r30, 0x9C	; 156
    5386:	f5 e0       	ldi	r31, 0x05	; 5
    5388:	ab e3       	ldi	r26, 0x3B	; 59
    538a:	b2 e0       	ldi	r27, 0x02	; 2
    538c:	88 ea       	ldi	r24, 0xA8	; 168
    538e:	95 e0       	ldi	r25, 0x05	; 5
    5390:	41 91       	ld	r20, Z+
    5392:	51 91       	ld	r21, Z+
    5394:	61 91       	ld	r22, Z+
    5396:	71 91       	ld	r23, Z+
    5398:	4d 93       	st	X+, r20
    539a:	5d 93       	st	X+, r21
    539c:	6d 93       	st	X+, r22
    539e:	7d 93       	st	X+, r23
    53a0:	e8 17       	cp	r30, r24
    53a2:	f9 07       	cpc	r31, r25
    53a4:	a9 f7       	brne	.-22     	; 0x5390 <plan_sync_position+0xc>
    53a6:	08 95       	ret

000053a8 <plan_cycle_reinitialize>:
// Re-initialize buffer plan with a partially completed block, assumed to exist at the buffer tail.
// Called after a steppers have come to a complete stop for a feed hold and the cycle is stopped.
void plan_cycle_reinitialize()
{
  // Re-plan from a complete stop. Reset planner entry speeds and buffer planned pointer.
  st_update_plan_block_parameters();
    53a8:	0e 94 68 19 	call	0x32d0	; 0x32d0 <st_update_plan_block_parameters>
  block_buffer_planned = block_buffer_tail;
    53ac:	80 91 5a 02 	lds	r24, 0x025A	; 0x80025a <block_buffer_tail>
    53b0:	80 93 57 02 	sts	0x0257, r24	; 0x800257 <block_buffer_planned>
  planner_recalculate();
    53b4:	0e 94 b0 23 	call	0x4760	; 0x4760 <planner_recalculate>
    53b8:	08 95       	ret

000053ba <read_float>:
// Delays variable defined microseconds. Compiler compatibility fix for _delay_us(),
// which only accepts constants in future compiler releases. Written to perform more
// efficiently with larger delays, as the counter adds parasitic time in each iteration.
void delay_us(uint32_t us)
{
  while (us) {
    53ba:	4f 92       	push	r4
    53bc:	5f 92       	push	r5
    53be:	6f 92       	push	r6
    53c0:	7f 92       	push	r7
    53c2:	8f 92       	push	r8
    53c4:	9f 92       	push	r9
    53c6:	af 92       	push	r10
    53c8:	bf 92       	push	r11
    53ca:	cf 92       	push	r12
    53cc:	df 92       	push	r13
    53ce:	ef 92       	push	r14
    53d0:	ff 92       	push	r15
    53d2:	0f 93       	push	r16
    53d4:	1f 93       	push	r17
    53d6:	cf 93       	push	r28
    53d8:	df 93       	push	r29
    53da:	dc 01       	movw	r26, r24
    53dc:	fb 01       	movw	r30, r22
    53de:	c0 81       	ld	r28, Z
    53e0:	d0 e0       	ldi	r29, 0x00	; 0
    53e2:	fc 01       	movw	r30, r24
    53e4:	ec 0f       	add	r30, r28
    53e6:	fd 1f       	adc	r31, r29
    53e8:	90 81       	ld	r25, Z
    53ea:	9d 32       	cpi	r25, 0x2D	; 45
    53ec:	29 f4       	brne	.+10     	; 0x53f8 <read_float+0x3e>
    53ee:	ef 01       	movw	r28, r30
    53f0:	22 96       	adiw	r28, 0x02	; 2
    53f2:	91 81       	ldd	r25, Z+1	; 0x01
    53f4:	01 e0       	ldi	r16, 0x01	; 1
    53f6:	0b c0       	rjmp	.+22     	; 0x540e <read_float+0x54>
    53f8:	9b 32       	cpi	r25, 0x2B	; 43
    53fa:	29 f0       	breq	.+10     	; 0x5406 <read_float+0x4c>
    53fc:	21 96       	adiw	r28, 0x01	; 1
    53fe:	ca 0f       	add	r28, r26
    5400:	db 1f       	adc	r29, r27
    5402:	00 e0       	ldi	r16, 0x00	; 0
    5404:	04 c0       	rjmp	.+8      	; 0x540e <read_float+0x54>
    5406:	ef 01       	movw	r28, r30
    5408:	22 96       	adiw	r28, 0x02	; 2
    540a:	91 81       	ldd	r25, Z+1	; 0x01
    540c:	00 e0       	ldi	r16, 0x00	; 0
    540e:	80 e0       	ldi	r24, 0x00	; 0
    5410:	20 e0       	ldi	r18, 0x00	; 0
    5412:	10 e0       	ldi	r17, 0x00	; 0
    5414:	41 2c       	mov	r4, r1
    5416:	51 2c       	mov	r5, r1
    5418:	32 01       	movw	r6, r4
    541a:	31 e0       	ldi	r19, 0x01	; 1
    541c:	fe 01       	movw	r30, r28
    541e:	90 53       	subi	r25, 0x30	; 48
    5420:	9a 30       	cpi	r25, 0x0A	; 10
    5422:	10 f5       	brcc	.+68     	; 0x5468 <read_float+0xae>
    5424:	2f 5f       	subi	r18, 0xFF	; 255
    5426:	29 30       	cpi	r18, 0x09	; 9
    5428:	d8 f4       	brcc	.+54     	; 0x5460 <read_float+0xa6>
    542a:	81 11       	cpse	r24, r1
    542c:	11 50       	subi	r17, 0x01	; 1
    542e:	53 01       	movw	r10, r6
    5430:	42 01       	movw	r8, r4
    5432:	88 0c       	add	r8, r8
    5434:	99 1c       	adc	r9, r9
    5436:	aa 1c       	adc	r10, r10
    5438:	bb 1c       	adc	r11, r11
    543a:	88 0c       	add	r8, r8
    543c:	99 1c       	adc	r9, r9
    543e:	aa 1c       	adc	r10, r10
    5440:	bb 1c       	adc	r11, r11
    5442:	84 0c       	add	r8, r4
    5444:	95 1c       	adc	r9, r5
    5446:	a6 1c       	adc	r10, r6
    5448:	b7 1c       	adc	r11, r7
    544a:	88 0c       	add	r8, r8
    544c:	99 1c       	adc	r9, r9
    544e:	aa 1c       	adc	r10, r10
    5450:	bb 1c       	adc	r11, r11
    5452:	24 01       	movw	r4, r8
    5454:	35 01       	movw	r6, r10
    5456:	49 0e       	add	r4, r25
    5458:	51 1c       	adc	r5, r1
    545a:	61 1c       	adc	r6, r1
    545c:	71 1c       	adc	r7, r1
    545e:	09 c0       	rjmp	.+18     	; 0x5472 <read_float+0xb8>
    5460:	81 11       	cpse	r24, r1
    5462:	07 c0       	rjmp	.+14     	; 0x5472 <read_float+0xb8>
    5464:	1f 5f       	subi	r17, 0xFF	; 255
    5466:	05 c0       	rjmp	.+10     	; 0x5472 <read_float+0xb8>
    5468:	9e 3f       	cpi	r25, 0xFE	; 254
    546a:	31 f4       	brne	.+12     	; 0x5478 <read_float+0xbe>
    546c:	81 11       	cpse	r24, r1
    546e:	04 c0       	rjmp	.+8      	; 0x5478 <read_float+0xbe>
    5470:	83 2f       	mov	r24, r19
    5472:	90 81       	ld	r25, Z
    5474:	21 96       	adiw	r28, 0x01	; 1
    5476:	d2 cf       	rjmp	.-92     	; 0x541c <read_float+0x62>
    5478:	22 23       	and	r18, r18
    547a:	09 f4       	brne	.+2      	; 0x547e <read_float+0xc4>
    547c:	52 c0       	rjmp	.+164    	; 0x5522 <read_float+0x168>
    547e:	6a 01       	movw	r12, r20
    5480:	7b 01       	movw	r14, r22
    5482:	5d 01       	movw	r10, r26
    5484:	c3 01       	movw	r24, r6
    5486:	b2 01       	movw	r22, r4
    5488:	0e 94 16 30 	call	0x602c	; 0x602c <__floatunsisf>
    548c:	2b 01       	movw	r4, r22
    548e:	3c 01       	movw	r6, r24
    5490:	20 e0       	ldi	r18, 0x00	; 0
    5492:	30 e0       	ldi	r19, 0x00	; 0
    5494:	a9 01       	movw	r20, r18
    5496:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    549a:	88 23       	and	r24, r24
    549c:	51 f1       	breq	.+84     	; 0x54f2 <read_float+0x138>
    549e:	1f 3f       	cpi	r17, 0xFF	; 255
    54a0:	6c f4       	brge	.+26     	; 0x54bc <read_float+0x102>
    54a2:	2a e0       	ldi	r18, 0x0A	; 10
    54a4:	37 ed       	ldi	r19, 0xD7	; 215
    54a6:	43 e2       	ldi	r20, 0x23	; 35
    54a8:	5c e3       	ldi	r21, 0x3C	; 60
    54aa:	c3 01       	movw	r24, r6
    54ac:	b2 01       	movw	r22, r4
    54ae:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    54b2:	2b 01       	movw	r4, r22
    54b4:	3c 01       	movw	r6, r24
    54b6:	1e 5f       	subi	r17, 0xFE	; 254
    54b8:	1f 3f       	cpi	r17, 0xFF	; 255
    54ba:	9c f3       	brlt	.-26     	; 0x54a2 <read_float+0xe8>
    54bc:	11 23       	and	r17, r17
    54be:	5c f4       	brge	.+22     	; 0x54d6 <read_float+0x11c>
    54c0:	2d ec       	ldi	r18, 0xCD	; 205
    54c2:	3c ec       	ldi	r19, 0xCC	; 204
    54c4:	4c ec       	ldi	r20, 0xCC	; 204
    54c6:	5d e3       	ldi	r21, 0x3D	; 61
    54c8:	c3 01       	movw	r24, r6
    54ca:	b2 01       	movw	r22, r4
    54cc:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    54d0:	2b 01       	movw	r4, r22
    54d2:	3c 01       	movw	r6, r24
    54d4:	0e c0       	rjmp	.+28     	; 0x54f2 <read_float+0x138>
    54d6:	11 16       	cp	r1, r17
    54d8:	64 f4       	brge	.+24     	; 0x54f2 <read_float+0x138>
    54da:	20 e0       	ldi	r18, 0x00	; 0
    54dc:	30 e0       	ldi	r19, 0x00	; 0
    54de:	40 e2       	ldi	r20, 0x20	; 32
    54e0:	51 e4       	ldi	r21, 0x41	; 65
    54e2:	c3 01       	movw	r24, r6
    54e4:	b2 01       	movw	r22, r4
    54e6:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    54ea:	2b 01       	movw	r4, r22
    54ec:	3c 01       	movw	r6, r24
    54ee:	11 50       	subi	r17, 0x01	; 1
    54f0:	a1 f7       	brne	.-24     	; 0x54da <read_float+0x120>
    54f2:	00 23       	and	r16, r16
    54f4:	51 f0       	breq	.+20     	; 0x550a <read_float+0x150>
    54f6:	77 fa       	bst	r7, 7
    54f8:	70 94       	com	r7
    54fa:	77 f8       	bld	r7, 7
    54fc:	70 94       	com	r7
    54fe:	f6 01       	movw	r30, r12
    5500:	40 82       	st	Z, r4
    5502:	51 82       	std	Z+1, r5	; 0x01
    5504:	62 82       	std	Z+2, r6	; 0x02
    5506:	73 82       	std	Z+3, r7	; 0x03
    5508:	05 c0       	rjmp	.+10     	; 0x5514 <read_float+0x15a>
    550a:	f6 01       	movw	r30, r12
    550c:	40 82       	st	Z, r4
    550e:	51 82       	std	Z+1, r5	; 0x01
    5510:	62 82       	std	Z+2, r6	; 0x02
    5512:	73 82       	std	Z+3, r7	; 0x03
    5514:	ca 19       	sub	r28, r10
    5516:	db 09       	sbc	r29, r11
    5518:	c1 50       	subi	r28, 0x01	; 1
    551a:	f7 01       	movw	r30, r14
    551c:	c0 83       	st	Z, r28
    551e:	81 e0       	ldi	r24, 0x01	; 1
    5520:	01 c0       	rjmp	.+2      	; 0x5524 <read_float+0x16a>
    5522:	80 e0       	ldi	r24, 0x00	; 0
    5524:	df 91       	pop	r29
    5526:	cf 91       	pop	r28
    5528:	1f 91       	pop	r17
    552a:	0f 91       	pop	r16
    552c:	ff 90       	pop	r15
    552e:	ef 90       	pop	r14
    5530:	df 90       	pop	r13
    5532:	cf 90       	pop	r12
    5534:	bf 90       	pop	r11
    5536:	af 90       	pop	r10
    5538:	9f 90       	pop	r9
    553a:	8f 90       	pop	r8
    553c:	7f 90       	pop	r7
    553e:	6f 90       	pop	r6
    5540:	5f 90       	pop	r5
    5542:	4f 90       	pop	r4
    5544:	08 95       	ret

00005546 <delay_sec>:
    5546:	ff 92       	push	r15
    5548:	0f 93       	push	r16
    554a:	1f 93       	push	r17
    554c:	cf 93       	push	r28
    554e:	df 93       	push	r29
    5550:	f4 2e       	mov	r15, r20
    5552:	20 e0       	ldi	r18, 0x00	; 0
    5554:	30 e0       	ldi	r19, 0x00	; 0
    5556:	40 ea       	ldi	r20, 0xA0	; 160
    5558:	51 e4       	ldi	r21, 0x41	; 65
    555a:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    555e:	0e 94 4d 2f 	call	0x5e9a	; 0x5e9a <ceil>
    5562:	0e 94 e7 2f 	call	0x5fce	; 0x5fce <__fixunssfsi>
    5566:	61 15       	cp	r22, r1
    5568:	71 05       	cpc	r23, r1
    556a:	21 f1       	breq	.+72     	; 0x55b4 <delay_sec+0x6e>
    556c:	20 91 7d 05 	lds	r18, 0x057D	; 0x80057d <sys+0x1>
    5570:	21 11       	cpse	r18, r1
    5572:	20 c0       	rjmp	.+64     	; 0x55b4 <delay_sec+0x6e>
    5574:	eb 01       	movw	r28, r22
    5576:	0c e7       	ldi	r16, 0x7C	; 124
    5578:	15 e0       	ldi	r17, 0x05	; 5
    557a:	05 c0       	rjmp	.+10     	; 0x5586 <delay_sec+0x40>
    557c:	21 97       	sbiw	r28, 0x01	; 1
    557e:	f8 01       	movw	r30, r16
    5580:	81 81       	ldd	r24, Z+1	; 0x01
    5582:	81 11       	cpse	r24, r1
    5584:	17 c0       	rjmp	.+46     	; 0x55b4 <delay_sec+0x6e>
    5586:	f1 10       	cpse	r15, r1
    5588:	03 c0       	rjmp	.+6      	; 0x5590 <delay_sec+0x4a>
    558a:	0e 94 9e 14 	call	0x293c	; 0x293c <protocol_execute_realtime>
    558e:	06 c0       	rjmp	.+12     	; 0x559c <delay_sec+0x56>
    5590:	0e 94 da 12 	call	0x25b4	; 0x25b4 <protocol_exec_rt_system>
    5594:	f8 01       	movw	r30, r16
    5596:	82 81       	ldd	r24, Z+2	; 0x02
    5598:	81 fd       	sbrc	r24, 1
    559a:	0c c0       	rjmp	.+24     	; 0x55b4 <delay_sec+0x6e>
    559c:	ff ef       	ldi	r31, 0xFF	; 255
    559e:	20 e7       	ldi	r18, 0x70	; 112
    55a0:	82 e0       	ldi	r24, 0x02	; 2
    55a2:	f1 50       	subi	r31, 0x01	; 1
    55a4:	20 40       	sbci	r18, 0x00	; 0
    55a6:	80 40       	sbci	r24, 0x00	; 0
    55a8:	e1 f7       	brne	.-8      	; 0x55a2 <delay_sec+0x5c>
    55aa:	00 c0       	rjmp	.+0      	; 0x55ac <delay_sec+0x66>
    55ac:	00 00       	nop
    55ae:	c1 30       	cpi	r28, 0x01	; 1
    55b0:	d1 05       	cpc	r29, r1
    55b2:	21 f7       	brne	.-56     	; 0x557c <delay_sec+0x36>
    55b4:	df 91       	pop	r29
    55b6:	cf 91       	pop	r28
    55b8:	1f 91       	pop	r17
    55ba:	0f 91       	pop	r16
    55bc:	ff 90       	pop	r15
    55be:	08 95       	ret

000055c0 <delay_ms>:
    55c0:	00 97       	sbiw	r24, 0x00	; 0
    55c2:	41 f0       	breq	.+16     	; 0x55d4 <delay_ms+0x14>
    55c4:	ef e9       	ldi	r30, 0x9F	; 159
    55c6:	ff e0       	ldi	r31, 0x0F	; 15
    55c8:	31 97       	sbiw	r30, 0x01	; 1
    55ca:	f1 f7       	brne	.-4      	; 0x55c8 <delay_ms+0x8>
    55cc:	00 c0       	rjmp	.+0      	; 0x55ce <delay_ms+0xe>
    55ce:	00 00       	nop
    55d0:	01 97       	sbiw	r24, 0x01	; 1
    55d2:	c1 f7       	brne	.-16     	; 0x55c4 <delay_ms+0x4>
    55d4:	08 95       	ret

000055d6 <hypot_f>:
  }
}


// Simple hypotenuse computation function.
float hypot_f(float x, float y) { return(sqrt(x*x + y*y)); }
    55d6:	4f 92       	push	r4
    55d8:	5f 92       	push	r5
    55da:	6f 92       	push	r6
    55dc:	7f 92       	push	r7
    55de:	8f 92       	push	r8
    55e0:	9f 92       	push	r9
    55e2:	af 92       	push	r10
    55e4:	bf 92       	push	r11
    55e6:	cf 92       	push	r12
    55e8:	df 92       	push	r13
    55ea:	ef 92       	push	r14
    55ec:	ff 92       	push	r15
    55ee:	4b 01       	movw	r8, r22
    55f0:	5c 01       	movw	r10, r24
    55f2:	69 01       	movw	r12, r18
    55f4:	7a 01       	movw	r14, r20
    55f6:	a5 01       	movw	r20, r10
    55f8:	94 01       	movw	r18, r8
    55fa:	c5 01       	movw	r24, r10
    55fc:	b4 01       	movw	r22, r8
    55fe:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    5602:	4b 01       	movw	r8, r22
    5604:	5c 01       	movw	r10, r24
    5606:	a7 01       	movw	r20, r14
    5608:	96 01       	movw	r18, r12
    560a:	c7 01       	movw	r24, r14
    560c:	b6 01       	movw	r22, r12
    560e:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    5612:	9b 01       	movw	r18, r22
    5614:	ac 01       	movw	r20, r24
    5616:	c5 01       	movw	r24, r10
    5618:	b4 01       	movw	r22, r8
    561a:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    561e:	0e 94 65 32 	call	0x64ca	; 0x64ca <sqrt>
    5622:	ff 90       	pop	r15
    5624:	ef 90       	pop	r14
    5626:	df 90       	pop	r13
    5628:	cf 90       	pop	r12
    562a:	bf 90       	pop	r11
    562c:	af 90       	pop	r10
    562e:	9f 90       	pop	r9
    5630:	8f 90       	pop	r8
    5632:	7f 90       	pop	r7
    5634:	6f 90       	pop	r6
    5636:	5f 90       	pop	r5
    5638:	4f 90       	pop	r4
    563a:	08 95       	ret

0000563c <convert_delta_vector_to_unit_vector>:


float convert_delta_vector_to_unit_vector(float *vector)
{
    563c:	4f 92       	push	r4
    563e:	5f 92       	push	r5
    5640:	6f 92       	push	r6
    5642:	7f 92       	push	r7
    5644:	af 92       	push	r10
    5646:	bf 92       	push	r11
    5648:	cf 92       	push	r12
    564a:	df 92       	push	r13
    564c:	ef 92       	push	r14
    564e:	ff 92       	push	r15
    5650:	0f 93       	push	r16
    5652:	1f 93       	push	r17
    5654:	cf 93       	push	r28
    5656:	df 93       	push	r29
    5658:	ec 01       	movw	r28, r24
    565a:	5c 01       	movw	r10, r24
    565c:	8c e0       	ldi	r24, 0x0C	; 12
    565e:	a8 0e       	add	r10, r24
    5660:	b1 1c       	adc	r11, r1
    5662:	8e 01       	movw	r16, r28
  uint8_t idx;
  float magnitude = 0.0;
    5664:	41 2c       	mov	r4, r1
    5666:	51 2c       	mov	r5, r1
    5668:	32 01       	movw	r6, r4
  for (idx=0; idx<N_AXIS; idx++) {
    if (vector[idx] != 0.0) {
    566a:	f8 01       	movw	r30, r16
    566c:	c1 90       	ld	r12, Z+
    566e:	d1 90       	ld	r13, Z+
    5670:	e1 90       	ld	r14, Z+
    5672:	f1 90       	ld	r15, Z+
    5674:	8f 01       	movw	r16, r30
    5676:	20 e0       	ldi	r18, 0x00	; 0
    5678:	30 e0       	ldi	r19, 0x00	; 0
    567a:	a9 01       	movw	r20, r18
    567c:	c7 01       	movw	r24, r14
    567e:	b6 01       	movw	r22, r12
    5680:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    5684:	88 23       	and	r24, r24
    5686:	71 f0       	breq	.+28     	; 0x56a4 <convert_delta_vector_to_unit_vector+0x68>
      magnitude += vector[idx]*vector[idx];
    5688:	a7 01       	movw	r20, r14
    568a:	96 01       	movw	r18, r12
    568c:	c7 01       	movw	r24, r14
    568e:	b6 01       	movw	r22, r12
    5690:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    5694:	9b 01       	movw	r18, r22
    5696:	ac 01       	movw	r20, r24
    5698:	c3 01       	movw	r24, r6
    569a:	b2 01       	movw	r22, r4
    569c:	0e 94 6f 2e 	call	0x5cde	; 0x5cde <__addsf3>
    56a0:	2b 01       	movw	r4, r22
    56a2:	3c 01       	movw	r6, r24

float convert_delta_vector_to_unit_vector(float *vector)
{
  uint8_t idx;
  float magnitude = 0.0;
  for (idx=0; idx<N_AXIS; idx++) {
    56a4:	0a 15       	cp	r16, r10
    56a6:	1b 05       	cpc	r17, r11
    56a8:	01 f7       	brne	.-64     	; 0x566a <convert_delta_vector_to_unit_vector+0x2e>
    if (vector[idx] != 0.0) {
      magnitude += vector[idx]*vector[idx];
    }
  }
  magnitude = sqrt(magnitude);
    56aa:	c3 01       	movw	r24, r6
    56ac:	b2 01       	movw	r22, r4
    56ae:	0e 94 65 32 	call	0x64ca	; 0x64ca <sqrt>
    56b2:	2b 01       	movw	r4, r22
    56b4:	3c 01       	movw	r6, r24
  float inv_magnitude = 1.0/magnitude;
    56b6:	9b 01       	movw	r18, r22
    56b8:	ac 01       	movw	r20, r24
    56ba:	60 e0       	ldi	r22, 0x00	; 0
    56bc:	70 e0       	ldi	r23, 0x00	; 0
    56be:	80 e8       	ldi	r24, 0x80	; 128
    56c0:	9f e3       	ldi	r25, 0x3F	; 63
    56c2:	0e 94 6e 2f 	call	0x5edc	; 0x5edc <__divsf3>
    56c6:	6b 01       	movw	r12, r22
    56c8:	7c 01       	movw	r14, r24
  for (idx=0; idx<N_AXIS; idx++) { vector[idx] *= inv_magnitude; }
    56ca:	a7 01       	movw	r20, r14
    56cc:	96 01       	movw	r18, r12
    56ce:	68 81       	ld	r22, Y
    56d0:	79 81       	ldd	r23, Y+1	; 0x01
    56d2:	8a 81       	ldd	r24, Y+2	; 0x02
    56d4:	9b 81       	ldd	r25, Y+3	; 0x03
    56d6:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    56da:	69 93       	st	Y+, r22
    56dc:	79 93       	st	Y+, r23
    56de:	89 93       	st	Y+, r24
    56e0:	99 93       	st	Y+, r25
    56e2:	ca 15       	cp	r28, r10
    56e4:	db 05       	cpc	r29, r11
    56e6:	89 f7       	brne	.-30     	; 0x56ca <convert_delta_vector_to_unit_vector+0x8e>
  return(magnitude);
}
    56e8:	c3 01       	movw	r24, r6
    56ea:	b2 01       	movw	r22, r4
    56ec:	df 91       	pop	r29
    56ee:	cf 91       	pop	r28
    56f0:	1f 91       	pop	r17
    56f2:	0f 91       	pop	r16
    56f4:	ff 90       	pop	r15
    56f6:	ef 90       	pop	r14
    56f8:	df 90       	pop	r13
    56fa:	cf 90       	pop	r12
    56fc:	bf 90       	pop	r11
    56fe:	af 90       	pop	r10
    5700:	7f 90       	pop	r7
    5702:	6f 90       	pop	r6
    5704:	5f 90       	pop	r5
    5706:	4f 90       	pop	r4
    5708:	08 95       	ret

0000570a <limit_value_by_axis_maximum>:


float limit_value_by_axis_maximum(float *max_value, float *unit_vec)
{
    570a:	6f 92       	push	r6
    570c:	7f 92       	push	r7
    570e:	8f 92       	push	r8
    5710:	9f 92       	push	r9
    5712:	af 92       	push	r10
    5714:	bf 92       	push	r11
    5716:	cf 92       	push	r12
    5718:	df 92       	push	r13
    571a:	ef 92       	push	r14
    571c:	ff 92       	push	r15
    571e:	0f 93       	push	r16
    5720:	1f 93       	push	r17
    5722:	cf 93       	push	r28
    5724:	df 93       	push	r29
    5726:	eb 01       	movw	r28, r22
    5728:	8c 01       	movw	r16, r24
    572a:	7b 01       	movw	r14, r22
    572c:	8c e0       	ldi	r24, 0x0C	; 12
    572e:	e8 0e       	add	r14, r24
    5730:	f1 1c       	adc	r15, r1
  uint8_t idx;
  float limit_value = SOME_LARGE_VALUE;
    5732:	0f 2e       	mov	r0, r31
    5734:	f9 e9       	ldi	r31, 0x99	; 153
    5736:	7f 2e       	mov	r7, r31
    5738:	f0 2d       	mov	r31, r0
    573a:	0f 2e       	mov	r0, r31
    573c:	f6 e7       	ldi	r31, 0x76	; 118
    573e:	cf 2e       	mov	r12, r31
    5740:	f0 2d       	mov	r31, r0
    5742:	0f 2e       	mov	r0, r31
    5744:	f6 e9       	ldi	r31, 0x96	; 150
    5746:	df 2e       	mov	r13, r31
    5748:	f0 2d       	mov	r31, r0
    574a:	0f 2e       	mov	r0, r31
    574c:	fe e7       	ldi	r31, 0x7E	; 126
    574e:	6f 2e       	mov	r6, r31
    5750:	f0 2d       	mov	r31, r0
  for (idx=0; idx<N_AXIS; idx++) {
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
    5752:	89 90       	ld	r8, Y+
    5754:	99 90       	ld	r9, Y+
    5756:	a9 90       	ld	r10, Y+
    5758:	b9 90       	ld	r11, Y+
    575a:	20 e0       	ldi	r18, 0x00	; 0
    575c:	30 e0       	ldi	r19, 0x00	; 0
    575e:	a9 01       	movw	r20, r18
    5760:	c5 01       	movw	r24, r10
    5762:	b4 01       	movw	r22, r8
    5764:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    5768:	88 23       	and	r24, r24
    576a:	d9 f0       	breq	.+54     	; 0x57a2 <limit_value_by_axis_maximum+0x98>
      limit_value = min(limit_value,fabs(max_value[idx]/unit_vec[idx]));
    576c:	a5 01       	movw	r20, r10
    576e:	94 01       	movw	r18, r8
    5770:	f8 01       	movw	r30, r16
    5772:	60 81       	ld	r22, Z
    5774:	71 81       	ldd	r23, Z+1	; 0x01
    5776:	82 81       	ldd	r24, Z+2	; 0x02
    5778:	93 81       	ldd	r25, Z+3	; 0x03
    577a:	0e 94 6e 2f 	call	0x5edc	; 0x5edc <__divsf3>
    577e:	4b 01       	movw	r8, r22
    5780:	5c 01       	movw	r10, r24
    5782:	e8 94       	clt
    5784:	b7 f8       	bld	r11, 7
    5786:	27 2d       	mov	r18, r7
    5788:	3c 2d       	mov	r19, r12
    578a:	4d 2d       	mov	r20, r13
    578c:	56 2d       	mov	r21, r6
    578e:	c5 01       	movw	r24, r10
    5790:	b4 01       	movw	r22, r8
    5792:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    5796:	18 16       	cp	r1, r24
    5798:	24 f0       	brlt	.+8      	; 0x57a2 <limit_value_by_axis_maximum+0x98>
    579a:	78 2c       	mov	r7, r8
    579c:	c9 2c       	mov	r12, r9
    579e:	da 2c       	mov	r13, r10
    57a0:	6b 2c       	mov	r6, r11
    57a2:	0c 5f       	subi	r16, 0xFC	; 252
    57a4:	1f 4f       	sbci	r17, 0xFF	; 255

float limit_value_by_axis_maximum(float *max_value, float *unit_vec)
{
  uint8_t idx;
  float limit_value = SOME_LARGE_VALUE;
  for (idx=0; idx<N_AXIS; idx++) {
    57a6:	ce 15       	cp	r28, r14
    57a8:	df 05       	cpc	r29, r15
    57aa:	99 f6       	brne	.-90     	; 0x5752 <limit_value_by_axis_maximum+0x48>
    if (unit_vec[idx] != 0) {  // Avoid divide by zero.
      limit_value = min(limit_value,fabs(max_value[idx]/unit_vec[idx]));
    }
  }
  return(limit_value);
}
    57ac:	67 2d       	mov	r22, r7
    57ae:	7c 2d       	mov	r23, r12
    57b0:	8d 2d       	mov	r24, r13
    57b2:	96 2d       	mov	r25, r6
    57b4:	df 91       	pop	r29
    57b6:	cf 91       	pop	r28
    57b8:	1f 91       	pop	r17
    57ba:	0f 91       	pop	r16
    57bc:	ff 90       	pop	r15
    57be:	ef 90       	pop	r14
    57c0:	df 90       	pop	r13
    57c2:	cf 90       	pop	r12
    57c4:	bf 90       	pop	r11
    57c6:	af 90       	pop	r10
    57c8:	9f 90       	pop	r9
    57ca:	8f 90       	pop	r8
    57cc:	7f 90       	pop	r7
    57ce:	6f 90       	pop	r6
    57d0:	08 95       	ret

000057d2 <limits_disable>:
      #endif

    }
  }
  sys.step_control = STEP_CONTROL_NORMAL_OP; // Return step control to normal operation.
}
    57d2:	eb e6       	ldi	r30, 0x6B	; 107
    57d4:	f0 e0       	ldi	r31, 0x00	; 0
    57d6:	80 81       	ld	r24, Z
    57d8:	89 7e       	andi	r24, 0xE9	; 233
    57da:	80 83       	st	Z, r24
    57dc:	e8 e6       	ldi	r30, 0x68	; 104
    57de:	f0 e0       	ldi	r31, 0x00	; 0
    57e0:	80 81       	ld	r24, Z
    57e2:	8e 7f       	andi	r24, 0xFE	; 254
    57e4:	80 83       	st	Z, r24
    57e6:	08 95       	ret

000057e8 <limits_init>:
    57e8:	84 b1       	in	r24, 0x04	; 4
    57ea:	89 7e       	andi	r24, 0xE9	; 233
    57ec:	84 b9       	out	0x04, r24	; 4
    57ee:	85 b1       	in	r24, 0x05	; 5
    57f0:	86 61       	ori	r24, 0x16	; 22
    57f2:	85 b9       	out	0x05, r24	; 5
    57f4:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <settings+0x45>
    57f8:	83 ff       	sbrs	r24, 3
    57fa:	0b c0       	rjmp	.+22     	; 0x5812 <limits_init+0x2a>
    57fc:	eb e6       	ldi	r30, 0x6B	; 107
    57fe:	f0 e0       	ldi	r31, 0x00	; 0
    5800:	80 81       	ld	r24, Z
    5802:	86 61       	ori	r24, 0x16	; 22
    5804:	80 83       	st	Z, r24
    5806:	e8 e6       	ldi	r30, 0x68	; 104
    5808:	f0 e0       	ldi	r31, 0x00	; 0
    580a:	80 81       	ld	r24, Z
    580c:	81 60       	ori	r24, 0x01	; 1
    580e:	80 83       	st	Z, r24
    5810:	08 95       	ret
    5812:	0e 94 e9 2b 	call	0x57d2	; 0x57d2 <limits_disable>
    5816:	08 95       	ret

00005818 <limits_get_state>:
    5818:	ef 92       	push	r14
    581a:	ff 92       	push	r15
    581c:	0f 93       	push	r16
    581e:	1f 93       	push	r17
    5820:	cf 93       	push	r28
    5822:	df 93       	push	r29
    5824:	13 b1       	in	r17, 0x03	; 3
    5826:	16 71       	andi	r17, 0x16	; 22
    5828:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <settings+0x45>
    582c:	86 fd       	sbrc	r24, 6
    582e:	1b c0       	rjmp	.+54     	; 0x5866 <limits_get_state+0x4e>
    5830:	86 e1       	ldi	r24, 0x16	; 22
    5832:	18 27       	eor	r17, r24
    5834:	18 c0       	rjmp	.+48     	; 0x5866 <limits_get_state+0x4e>
    5836:	c0 e0       	ldi	r28, 0x00	; 0
    5838:	d0 e0       	ldi	r29, 0x00	; 0
    583a:	00 e0       	ldi	r16, 0x00	; 0
    583c:	ee 24       	eor	r14, r14
    583e:	e3 94       	inc	r14
    5840:	f1 2c       	mov	r15, r1
    5842:	8c 2f       	mov	r24, r28
    5844:	0e 94 a6 23 	call	0x474c	; 0x474c <get_limit_pin_mask>
    5848:	81 23       	and	r24, r17
    584a:	41 f0       	breq	.+16     	; 0x585c <limits_get_state+0x44>
    584c:	c7 01       	movw	r24, r14
    584e:	0c 2e       	mov	r0, r28
    5850:	02 c0       	rjmp	.+4      	; 0x5856 <limits_get_state+0x3e>
    5852:	88 0f       	add	r24, r24
    5854:	99 1f       	adc	r25, r25
    5856:	0a 94       	dec	r0
    5858:	e2 f7       	brpl	.-8      	; 0x5852 <limits_get_state+0x3a>
    585a:	08 2b       	or	r16, r24
    585c:	21 96       	adiw	r28, 0x01	; 1
    585e:	c3 30       	cpi	r28, 0x03	; 3
    5860:	d1 05       	cpc	r29, r1
    5862:	79 f7       	brne	.-34     	; 0x5842 <limits_get_state+0x2a>
    5864:	03 c0       	rjmp	.+6      	; 0x586c <limits_get_state+0x54>
    5866:	11 11       	cpse	r17, r1
    5868:	e6 cf       	rjmp	.-52     	; 0x5836 <limits_get_state+0x1e>
    586a:	00 e0       	ldi	r16, 0x00	; 0
    586c:	80 2f       	mov	r24, r16
    586e:	df 91       	pop	r29
    5870:	cf 91       	pop	r28
    5872:	1f 91       	pop	r17
    5874:	0f 91       	pop	r16
    5876:	ff 90       	pop	r15
    5878:	ef 90       	pop	r14
    587a:	08 95       	ret

0000587c <__vector_3>:
    587c:	1f 92       	push	r1
    587e:	0f 92       	push	r0
    5880:	0f b6       	in	r0, 0x3f	; 63
    5882:	0f 92       	push	r0
    5884:	11 24       	eor	r1, r1
    5886:	2f 93       	push	r18
    5888:	3f 93       	push	r19
    588a:	4f 93       	push	r20
    588c:	5f 93       	push	r21
    588e:	6f 93       	push	r22
    5890:	7f 93       	push	r23
    5892:	8f 93       	push	r24
    5894:	9f 93       	push	r25
    5896:	af 93       	push	r26
    5898:	bf 93       	push	r27
    589a:	ef 93       	push	r30
    589c:	ff 93       	push	r31
    589e:	80 91 7c 05 	lds	r24, 0x057C	; 0x80057c <sys>
    58a2:	81 30       	cpi	r24, 0x01	; 1
    58a4:	49 f0       	breq	.+18     	; 0x58b8 <__vector_3+0x3c>
    58a6:	80 91 a8 05 	lds	r24, 0x05A8	; 0x8005a8 <sys_rt_exec_alarm>
    58aa:	81 11       	cpse	r24, r1
    58ac:	05 c0       	rjmp	.+10     	; 0x58b8 <__vector_3+0x3c>
    58ae:	0e 94 5d 05 	call	0xaba	; 0xaba <mc_reset>
    58b2:	81 e0       	ldi	r24, 0x01	; 1
    58b4:	0e 94 44 2e 	call	0x5c88	; 0x5c88 <system_set_exec_alarm>
    58b8:	ff 91       	pop	r31
    58ba:	ef 91       	pop	r30
    58bc:	bf 91       	pop	r27
    58be:	af 91       	pop	r26
    58c0:	9f 91       	pop	r25
    58c2:	8f 91       	pop	r24
    58c4:	7f 91       	pop	r23
    58c6:	6f 91       	pop	r22
    58c8:	5f 91       	pop	r21
    58ca:	4f 91       	pop	r20
    58cc:	3f 91       	pop	r19
    58ce:	2f 91       	pop	r18
    58d0:	0f 90       	pop	r0
    58d2:	0f be       	out	0x3f, r0	; 63
    58d4:	0f 90       	pop	r0
    58d6:	1f 90       	pop	r1
    58d8:	18 95       	reti

000058da <limits_soft_check>:

// Performs a soft limit check. Called from mc_line() only. Assumes the machine has been homed,
// the workspace volume is in all negative space, and the system is in normal operation.
// NOTE: Used by jogging to limit travel within soft-limit volume.
void limits_soft_check(float *target)
{
    58da:	cf 93       	push	r28
    58dc:	df 93       	push	r29
  if (system_check_travel_limits(target)) {
    58de:	0e 94 c6 2d 	call	0x5b8c	; 0x5b8c <system_check_travel_limits>
    58e2:	88 23       	and	r24, r24
    58e4:	d1 f0       	breq	.+52     	; 0x591a <limits_soft_check+0x40>
    sys.soft_limit = true;
    58e6:	ec e7       	ldi	r30, 0x7C	; 124
    58e8:	f5 e0       	ldi	r31, 0x05	; 5
    58ea:	81 e0       	ldi	r24, 0x01	; 1
    58ec:	83 83       	std	Z+3, r24	; 0x03
    // Force feed hold if cycle is active. All buffered blocks are guaranteed to be within
    // workspace volume so just come to a controlled stop so position is not lost. When complete
    // enter alarm mode.
    if (sys.state == STATE_CYCLE) {
    58ee:	80 81       	ld	r24, Z
    58f0:	88 30       	cpi	r24, 0x08	; 8
    58f2:	61 f4       	brne	.+24     	; 0x590c <limits_soft_check+0x32>
      system_set_exec_state_flag(EXEC_FEED_HOLD);
    58f4:	0e 94 31 2e 	call	0x5c62	; 0x5c62 <system_set_exec_state_flag>
      do {
        protocol_execute_realtime();
        if (sys.abort) { return; }
    58f8:	cc e7       	ldi	r28, 0x7C	; 124
    58fa:	d5 e0       	ldi	r29, 0x05	; 5
    // workspace volume so just come to a controlled stop so position is not lost. When complete
    // enter alarm mode.
    if (sys.state == STATE_CYCLE) {
      system_set_exec_state_flag(EXEC_FEED_HOLD);
      do {
        protocol_execute_realtime();
    58fc:	0e 94 9e 14 	call	0x293c	; 0x293c <protocol_execute_realtime>
        if (sys.abort) { return; }
    5900:	89 81       	ldd	r24, Y+1	; 0x01
    5902:	81 11       	cpse	r24, r1
    5904:	0a c0       	rjmp	.+20     	; 0x591a <limits_soft_check+0x40>
      } while ( sys.state != STATE_IDLE );
    5906:	88 81       	ld	r24, Y
    5908:	81 11       	cpse	r24, r1
    590a:	f8 cf       	rjmp	.-16     	; 0x58fc <limits_soft_check+0x22>
    }
    mc_reset(); // Issue system reset and ensure spindle and coolant are shutdown.
    590c:	0e 94 5d 05 	call	0xaba	; 0xaba <mc_reset>
    system_set_exec_alarm(EXEC_ALARM_SOFT_LIMIT); // Indicate soft limit critical event
    5910:	82 e0       	ldi	r24, 0x02	; 2
    5912:	0e 94 44 2e 	call	0x5c88	; 0x5c88 <system_set_exec_alarm>
    protocol_execute_realtime(); // Execute to enter critical event loop and system abort
    5916:	0e 94 9e 14 	call	0x293c	; 0x293c <protocol_execute_realtime>
    return;
  }
}
    591a:	df 91       	pop	r29
    591c:	cf 91       	pop	r28
    591e:	08 95       	ret

00005920 <jog_execute>:
#include "grbl.h"


// Sets up valid jog motion received from g-code parser, checks for soft-limits, and executes the jog.
uint8_t jog_execute(plan_line_data_t *pl_data, parser_block_t *gc_block)
{
    5920:	0f 93       	push	r16
    5922:	1f 93       	push	r17
    5924:	cf 93       	push	r28
    5926:	df 93       	push	r29
    5928:	ec 01       	movw	r28, r24
    592a:	8b 01       	movw	r16, r22
  // Initialize planner data struct for jogging motions.
  // NOTE: Spindle and coolant are allowed to fully function with overrides during a jog.
  pl_data->feed_rate = gc_block->values.f;
    592c:	fb 01       	movw	r30, r22
    592e:	84 85       	ldd	r24, Z+12	; 0x0c
    5930:	95 85       	ldd	r25, Z+13	; 0x0d
    5932:	a6 85       	ldd	r26, Z+14	; 0x0e
    5934:	b7 85       	ldd	r27, Z+15	; 0x0f
    5936:	88 83       	st	Y, r24
    5938:	99 83       	std	Y+1, r25	; 0x01
    593a:	aa 83       	std	Y+2, r26	; 0x02
    593c:	bb 83       	std	Y+3, r27	; 0x03
  pl_data->condition |= PL_COND_FLAG_NO_FEED_OVERRIDE;
    593e:	88 85       	ldd	r24, Y+8	; 0x08
    5940:	84 60       	ori	r24, 0x04	; 4
    5942:	88 87       	std	Y+8, r24	; 0x08
  #ifdef USE_LINE_NUMBERS
    pl_data->line_number = gc_block->values.n;
  #endif

  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) {
    5944:	80 91 53 07 	lds	r24, 0x0753	; 0x800753 <settings+0x45>
    5948:	85 ff       	sbrs	r24, 5
    594a:	06 c0       	rjmp	.+12     	; 0x5958 <jog_execute+0x38>
    if (system_check_travel_limits(gc_block->values.xyz)) { return(STATUS_TRAVEL_EXCEEDED); }
    594c:	cb 01       	movw	r24, r22
    594e:	8e 96       	adiw	r24, 0x2e	; 46
    5950:	0e 94 c6 2d 	call	0x5b8c	; 0x5b8c <system_check_travel_limits>
    5954:	81 11       	cpse	r24, r1
    5956:	15 c0       	rjmp	.+42     	; 0x5982 <jog_execute+0x62>
  }

  // Valid jog command. Plan, set state, and execute.
  mc_line(gc_block->values.xyz,pl_data);
    5958:	be 01       	movw	r22, r28
    595a:	c8 01       	movw	r24, r16
    595c:	8e 96       	adiw	r24, 0x2e	; 46
    595e:	0e 94 ad 01 	call	0x35a	; 0x35a <mc_line>
  if (sys.state == STATE_IDLE) {
    5962:	c0 91 7c 05 	lds	r28, 0x057C	; 0x80057c <sys>
    5966:	c1 11       	cpse	r28, r1
    5968:	0e c0       	rjmp	.+28     	; 0x5986 <jog_execute+0x66>
    if (plan_get_current_block() != NULL) { // Check if there is a block to execute.
    596a:	0e 94 47 25 	call	0x4a8e	; 0x4a8e <plan_get_current_block>
    596e:	89 2b       	or	r24, r25
    5970:	59 f0       	breq	.+22     	; 0x5988 <jog_execute+0x68>
      sys.state = STATE_JOG;
    5972:	80 e2       	ldi	r24, 0x20	; 32
    5974:	80 93 7c 05 	sts	0x057C, r24	; 0x80057c <sys>
      st_prep_buffer();
    5978:	0e 94 88 19 	call	0x3310	; 0x3310 <st_prep_buffer>
      st_wake_up();  // NOTE: Manual start. No state machine required.
    597c:	0e 94 7f 16 	call	0x2cfe	; 0x2cfe <st_wake_up>
    5980:	03 c0       	rjmp	.+6      	; 0x5988 <jog_execute+0x68>
  #ifdef USE_LINE_NUMBERS
    pl_data->line_number = gc_block->values.n;
  #endif

  if (bit_istrue(settings.flags,BITFLAG_SOFT_LIMIT_ENABLE)) {
    if (system_check_travel_limits(gc_block->values.xyz)) { return(STATUS_TRAVEL_EXCEEDED); }
    5982:	cf e0       	ldi	r28, 0x0F	; 15
    5984:	01 c0       	rjmp	.+2      	; 0x5988 <jog_execute+0x68>
      st_prep_buffer();
      st_wake_up();  // NOTE: Manual start. No state machine required.
    }
  }

  return(STATUS_OK);
    5986:	c0 e0       	ldi	r28, 0x00	; 0
}
    5988:	8c 2f       	mov	r24, r28
    598a:	df 91       	pop	r29
    598c:	cf 91       	pop	r28
    598e:	1f 91       	pop	r17
    5990:	0f 91       	pop	r16
    5992:	08 95       	ret

00005994 <probe_configure_invert_mask>:
// Called by probe_init() and the mc_probe() routines. Sets up the probe pin invert mask to
// appropriately set the pin logic according to setting for normal-high/normal-low operation
// and the probing cycle modes for toward-workpiece/away-from-workpiece.
void probe_configure_invert_mask(uint8_t is_probe_away)
{
  probe_invert_mask = 0; // Initialize as zero.
    5994:	10 92 63 07 	sts	0x0763, r1	; 0x800763 <probe_invert_mask>
  if (bit_isfalse(settings.flags,BITFLAG_INVERT_PROBE_PIN)) { probe_invert_mask ^= PROBE_MASK; }
    5998:	90 91 53 07 	lds	r25, 0x0753	; 0x800753 <settings+0x45>
    599c:	99 23       	and	r25, r25
    599e:	1c f0       	brlt	.+6      	; 0x59a6 <probe_configure_invert_mask+0x12>
    59a0:	90 e2       	ldi	r25, 0x20	; 32
    59a2:	90 93 63 07 	sts	0x0763, r25	; 0x800763 <probe_invert_mask>
  if (is_probe_away) { probe_invert_mask ^= PROBE_MASK; }
    59a6:	88 23       	and	r24, r24
    59a8:	31 f0       	breq	.+12     	; 0x59b6 <probe_configure_invert_mask+0x22>
    59aa:	90 91 63 07 	lds	r25, 0x0763	; 0x800763 <probe_invert_mask>
    59ae:	80 e2       	ldi	r24, 0x20	; 32
    59b0:	89 27       	eor	r24, r25
    59b2:	80 93 63 07 	sts	0x0763, r24	; 0x800763 <probe_invert_mask>
    59b6:	08 95       	ret

000059b8 <probe_init>:


// Probe pin initialization routine.
void probe_init()
{
  PROBE_DDR &= ~(PROBE_MASK); // Configure as input pins
    59b8:	3d 98       	cbi	0x07, 5	; 7
  #ifdef DISABLE_PROBE_PIN_PULL_UP
    PROBE_PORT &= ~(PROBE_MASK); // Normal low operation. Requires external pull-down.
  #else
    PROBE_PORT |= PROBE_MASK;    // Enable internal pull-up resistors. Normal high operation.
    59ba:	45 9a       	sbi	0x08, 5	; 8
  #endif
  probe_configure_invert_mask(false); // Initialize invert mask.
    59bc:	80 e0       	ldi	r24, 0x00	; 0
    59be:	0e 94 ca 2c 	call	0x5994	; 0x5994 <probe_configure_invert_mask>
    59c2:	08 95       	ret

000059c4 <probe_get_state>:
  if (is_probe_away) { probe_invert_mask ^= PROBE_MASK; }
}


// Returns the probe pin state. Triggered = true. Called by gcode parser and probe state monitor.
uint8_t probe_get_state() { return((PROBE_PIN & PROBE_MASK) ^ probe_invert_mask); }
    59c4:	86 b1       	in	r24, 0x06	; 6
    59c6:	80 72       	andi	r24, 0x20	; 32
    59c8:	90 91 63 07 	lds	r25, 0x0763	; 0x800763 <probe_invert_mask>
    59cc:	89 27       	eor	r24, r25
    59ce:	08 95       	ret

000059d0 <probe_state_monitor>:
// Monitors probe pin state and records the system position when detected. Called by the
// stepper ISR per ISR tick.
// NOTE: This function must be extremely efficient as to not bog down the stepper ISR.
void probe_state_monitor()
{
  if (probe_get_state()) {
    59d0:	0e 94 e2 2c 	call	0x59c4	; 0x59c4 <probe_get_state>
    59d4:	88 23       	and	r24, r24
    59d6:	81 f0       	breq	.+32     	; 0x59f8 <probe_state_monitor+0x28>
    sys_probe_state = PROBE_OFF;
    59d8:	10 92 8f 05 	sts	0x058F, r1	; 0x80058f <sys_probe_state>
    memcpy(sys_probe_position, sys_position, sizeof(sys_position));
    59dc:	8c e0       	ldi	r24, 0x0C	; 12
    59de:	ec e9       	ldi	r30, 0x9C	; 156
    59e0:	f5 e0       	ldi	r31, 0x05	; 5
    59e2:	a0 e9       	ldi	r26, 0x90	; 144
    59e4:	b5 e0       	ldi	r27, 0x05	; 5
    59e6:	01 90       	ld	r0, Z+
    59e8:	0d 92       	st	X+, r0
    59ea:	8a 95       	dec	r24
    59ec:	e1 f7       	brne	.-8      	; 0x59e6 <probe_state_monitor+0x16>
    bit_true(sys_rt_exec_state, EXEC_MOTION_CANCEL);
    59ee:	80 91 8e 05 	lds	r24, 0x058E	; 0x80058e <sys_rt_exec_state>
    59f2:	80 64       	ori	r24, 0x40	; 64
    59f4:	80 93 8e 05 	sts	0x058E, r24	; 0x80058e <sys_rt_exec_state>
    59f8:	08 95       	ret

000059fa <report_status_message>:
#endif
}

// Prints build info line
void report_build_info(char *line)
{
    59fa:	08 95       	ret

000059fc <report_alarm_message>:
    59fc:	08 95       	ret

000059fe <report_feedback_message>:
    59fe:	08 95       	ret

00005a00 <report_init_message>:
    5a00:	08 95       	ret

00005a02 <report_grbl_settings>:
    5a02:	08 95       	ret

00005a04 <report_probe_parameters>:
    5a04:	08 95       	ret

00005a06 <report_execute_startup_message>:
    5a06:	08 95       	ret

00005a08 <report_echo_line_received>:


// Prints the character string line Grbl has received from the user, which has been pre-parsed,
// and has been sent into protocol_execute_line() routine to be executed by Grbl.
void report_echo_line_received(char *line)
{
    5a08:	08 95       	ret

00005a0a <report_realtime_status>:
 // and the actual location of the CNC machine. Users may change the following function to their
 // specific needs, but the desired real-time data report must be as short as possible. This is
 // requires as it minimizes the computational overhead and allows grbl to keep running smoothly,
 // especially during g-code programs with fast, short line segments and high frequency reports (5-20Hz).
void report_realtime_status()
{
    5a0a:	08 95       	ret

00005a0c <report_realtime_debug>:
}


#ifdef DEBUG
  void report_realtime_debug()
  {
    5a0c:	08 95       	ret

00005a0e <system_init>:
            return(settings_store_global_setting((uint8_t)parameter, value));
          }
      }
  }
  return(STATUS_OK); // If '$' command makes it to here, then everything's ok.
}
    5a0e:	87 b1       	in	r24, 0x07	; 7
    5a10:	88 7f       	andi	r24, 0xF8	; 248
    5a12:	87 b9       	out	0x07, r24	; 7
    5a14:	88 b1       	in	r24, 0x08	; 8
    5a16:	87 60       	ori	r24, 0x07	; 7
    5a18:	88 b9       	out	0x08, r24	; 8
    5a1a:	ec e6       	ldi	r30, 0x6C	; 108
    5a1c:	f0 e0       	ldi	r31, 0x00	; 0
    5a1e:	80 81       	ld	r24, Z
    5a20:	87 60       	ori	r24, 0x07	; 7
    5a22:	80 83       	st	Z, r24
    5a24:	e8 e6       	ldi	r30, 0x68	; 104
    5a26:	f0 e0       	ldi	r31, 0x00	; 0
    5a28:	80 81       	ld	r24, Z
    5a2a:	82 60       	ori	r24, 0x02	; 2
    5a2c:	80 83       	st	Z, r24
    5a2e:	08 95       	ret

00005a30 <system_control_get_state>:
    5a30:	96 b1       	in	r25, 0x06	; 6
    5a32:	90 95       	com	r25
    5a34:	89 2f       	mov	r24, r25
    5a36:	87 70       	andi	r24, 0x07	; 7
    5a38:	59 f0       	breq	.+22     	; 0x5a50 <system_control_get_state+0x20>
    5a3a:	91 ff       	sbrs	r25, 1
    5a3c:	02 c0       	rjmp	.+4      	; 0x5a42 <system_control_get_state+0x12>
    5a3e:	82 e0       	ldi	r24, 0x02	; 2
    5a40:	01 c0       	rjmp	.+2      	; 0x5a44 <system_control_get_state+0x14>
    5a42:	80 e0       	ldi	r24, 0x00	; 0
    5a44:	90 fd       	sbrc	r25, 0
    5a46:	81 60       	ori	r24, 0x01	; 1
    5a48:	92 ff       	sbrs	r25, 2
    5a4a:	03 c0       	rjmp	.+6      	; 0x5a52 <system_control_get_state+0x22>
    5a4c:	84 60       	ori	r24, 0x04	; 4
    5a4e:	08 95       	ret
    5a50:	80 e0       	ldi	r24, 0x00	; 0
    5a52:	08 95       	ret

00005a54 <__vector_4>:
    5a54:	1f 92       	push	r1
    5a56:	0f 92       	push	r0
    5a58:	0f b6       	in	r0, 0x3f	; 63
    5a5a:	0f 92       	push	r0
    5a5c:	11 24       	eor	r1, r1
    5a5e:	2f 93       	push	r18
    5a60:	3f 93       	push	r19
    5a62:	4f 93       	push	r20
    5a64:	5f 93       	push	r21
    5a66:	6f 93       	push	r22
    5a68:	7f 93       	push	r23
    5a6a:	8f 93       	push	r24
    5a6c:	9f 93       	push	r25
    5a6e:	af 93       	push	r26
    5a70:	bf 93       	push	r27
    5a72:	cf 93       	push	r28
    5a74:	ef 93       	push	r30
    5a76:	ff 93       	push	r31
    5a78:	0e 94 18 2d 	call	0x5a30	; 0x5a30 <system_control_get_state>
    5a7c:	c8 2f       	mov	r28, r24
    5a7e:	88 23       	and	r24, r24
    5a80:	89 f0       	breq	.+34     	; 0x5aa4 <__vector_4+0x50>
    5a82:	80 fd       	sbrc	r24, 0
    5a84:	0e 94 5d 05 	call	0xaba	; 0xaba <mc_reset>
    5a88:	c2 ff       	sbrs	r28, 2
    5a8a:	05 c0       	rjmp	.+10     	; 0x5a96 <__vector_4+0x42>
    5a8c:	80 91 8e 05 	lds	r24, 0x058E	; 0x80058e <sys_rt_exec_state>
    5a90:	82 60       	ori	r24, 0x02	; 2
    5a92:	80 93 8e 05 	sts	0x058E, r24	; 0x80058e <sys_rt_exec_state>
    5a96:	c1 ff       	sbrs	r28, 1
    5a98:	05 c0       	rjmp	.+10     	; 0x5aa4 <__vector_4+0x50>
    5a9a:	80 91 8e 05 	lds	r24, 0x058E	; 0x80058e <sys_rt_exec_state>
    5a9e:	88 60       	ori	r24, 0x08	; 8
    5aa0:	80 93 8e 05 	sts	0x058E, r24	; 0x80058e <sys_rt_exec_state>
    5aa4:	ff 91       	pop	r31
    5aa6:	ef 91       	pop	r30
    5aa8:	cf 91       	pop	r28
    5aaa:	bf 91       	pop	r27
    5aac:	af 91       	pop	r26
    5aae:	9f 91       	pop	r25
    5ab0:	8f 91       	pop	r24
    5ab2:	7f 91       	pop	r23
    5ab4:	6f 91       	pop	r22
    5ab6:	5f 91       	pop	r21
    5ab8:	4f 91       	pop	r20
    5aba:	3f 91       	pop	r19
    5abc:	2f 91       	pop	r18
    5abe:	0f 90       	pop	r0
    5ac0:	0f be       	out	0x3f, r0	; 63
    5ac2:	0f 90       	pop	r0
    5ac4:	1f 90       	pop	r1
    5ac6:	18 95       	reti

00005ac8 <system_check_safety_door_ajar>:
    5ac8:	80 e0       	ldi	r24, 0x00	; 0
    5aca:	08 95       	ret

00005acc <system_execute_startup>:
    5acc:	0f 93       	push	r16
    5ace:	1f 93       	push	r17
    5ad0:	cf 93       	push	r28
    5ad2:	8c 01       	movw	r16, r24
    5ad4:	c0 e0       	ldi	r28, 0x00	; 0
    5ad6:	b8 01       	movw	r22, r16
    5ad8:	8c 2f       	mov	r24, r28
    5ada:	0e 94 31 23 	call	0x4662	; 0x4662 <settings_read_startup_line>
    5ade:	81 11       	cpse	r24, r1
    5ae0:	07 c0       	rjmp	.+14     	; 0x5af0 <system_execute_startup+0x24>
    5ae2:	f8 01       	movw	r30, r16
    5ae4:	10 82       	st	Z, r1
    5ae6:	67 e0       	ldi	r22, 0x07	; 7
    5ae8:	c8 01       	movw	r24, r16
    5aea:	0e 94 03 2d 	call	0x5a06	; 0x5a06 <report_execute_startup_message>
    5aee:	0b c0       	rjmp	.+22     	; 0x5b06 <system_execute_startup+0x3a>
    5af0:	f8 01       	movw	r30, r16
    5af2:	80 81       	ld	r24, Z
    5af4:	88 23       	and	r24, r24
    5af6:	39 f0       	breq	.+14     	; 0x5b06 <system_execute_startup+0x3a>
    5af8:	c8 01       	movw	r24, r16
    5afa:	0e 94 9a 05 	call	0xb34	; 0xb34 <gc_execute_line>
    5afe:	68 2f       	mov	r22, r24
    5b00:	c8 01       	movw	r24, r16
    5b02:	0e 94 03 2d 	call	0x5a06	; 0x5a06 <report_execute_startup_message>
    5b06:	cf 5f       	subi	r28, 0xFF	; 255
    5b08:	c2 30       	cpi	r28, 0x02	; 2
    5b0a:	29 f7       	brne	.-54     	; 0x5ad6 <system_execute_startup+0xa>
    5b0c:	cf 91       	pop	r28
    5b0e:	1f 91       	pop	r17
    5b10:	0f 91       	pop	r16
    5b12:	08 95       	ret

00005b14 <system_flag_wco_change>:
    5b14:	0e 94 6a 16 	call	0x2cd4	; 0x2cd4 <protocol_buffer_synchronize>
    5b18:	10 92 88 05 	sts	0x0588, r1	; 0x800588 <sys+0xc>
    5b1c:	08 95       	ret

00005b1e <system_convert_axis_steps_to_mpos>:
    5b1e:	cf 93       	push	r28
    5b20:	df 93       	push	r29
    5b22:	c6 2f       	mov	r28, r22
    5b24:	d0 e0       	ldi	r29, 0x00	; 0
    5b26:	cc 0f       	add	r28, r28
    5b28:	dd 1f       	adc	r29, r29
    5b2a:	cc 0f       	add	r28, r28
    5b2c:	dd 1f       	adc	r29, r29
    5b2e:	8c 0f       	add	r24, r28
    5b30:	9d 1f       	adc	r25, r29
    5b32:	fc 01       	movw	r30, r24
    5b34:	60 81       	ld	r22, Z
    5b36:	71 81       	ldd	r23, Z+1	; 0x01
    5b38:	82 81       	ldd	r24, Z+2	; 0x02
    5b3a:	93 81       	ldd	r25, Z+3	; 0x03
    5b3c:	0e 94 18 30 	call	0x6030	; 0x6030 <__floatsisf>
    5b40:	c2 5f       	subi	r28, 0xF2	; 242
    5b42:	d8 4f       	sbci	r29, 0xF8	; 248
    5b44:	28 81       	ld	r18, Y
    5b46:	39 81       	ldd	r19, Y+1	; 0x01
    5b48:	4a 81       	ldd	r20, Y+2	; 0x02
    5b4a:	5b 81       	ldd	r21, Y+3	; 0x03
    5b4c:	0e 94 6e 2f 	call	0x5edc	; 0x5edc <__divsf3>
    5b50:	df 91       	pop	r29
    5b52:	cf 91       	pop	r28
    5b54:	08 95       	ret

00005b56 <system_convert_array_steps_to_mpos>:
    5b56:	ef 92       	push	r14
    5b58:	ff 92       	push	r15
    5b5a:	0f 93       	push	r16
    5b5c:	1f 93       	push	r17
    5b5e:	cf 93       	push	r28
    5b60:	7b 01       	movw	r14, r22
    5b62:	8c 01       	movw	r16, r24
    5b64:	c0 e0       	ldi	r28, 0x00	; 0
    5b66:	6c 2f       	mov	r22, r28
    5b68:	c7 01       	movw	r24, r14
    5b6a:	0e 94 8f 2d 	call	0x5b1e	; 0x5b1e <system_convert_axis_steps_to_mpos>
    5b6e:	f8 01       	movw	r30, r16
    5b70:	61 93       	st	Z+, r22
    5b72:	71 93       	st	Z+, r23
    5b74:	81 93       	st	Z+, r24
    5b76:	91 93       	st	Z+, r25
    5b78:	8f 01       	movw	r16, r30
    5b7a:	cf 5f       	subi	r28, 0xFF	; 255
    5b7c:	c3 30       	cpi	r28, 0x03	; 3
    5b7e:	99 f7       	brne	.-26     	; 0x5b66 <system_convert_array_steps_to_mpos+0x10>
    5b80:	cf 91       	pop	r28
    5b82:	1f 91       	pop	r17
    5b84:	0f 91       	pop	r16
    5b86:	ff 90       	pop	r15
    5b88:	ef 90       	pop	r14
    5b8a:	08 95       	ret

00005b8c <system_check_travel_limits>:
    5b8c:	cf 92       	push	r12
    5b8e:	df 92       	push	r13
    5b90:	ef 92       	push	r14
    5b92:	ff 92       	push	r15
    5b94:	cf 93       	push	r28
    5b96:	df 93       	push	r29
    5b98:	ec 01       	movw	r28, r24
    5b9a:	c8 80       	ld	r12, Y
    5b9c:	d9 80       	ldd	r13, Y+1	; 0x01
    5b9e:	ea 80       	ldd	r14, Y+2	; 0x02
    5ba0:	fb 80       	ldd	r15, Y+3	; 0x03
    5ba2:	20 e0       	ldi	r18, 0x00	; 0
    5ba4:	30 e0       	ldi	r19, 0x00	; 0
    5ba6:	a9 01       	movw	r20, r18
    5ba8:	c7 01       	movw	r24, r14
    5baa:	b6 01       	movw	r22, r12
    5bac:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    5bb0:	18 16       	cp	r1, r24
    5bb2:	0c f4       	brge	.+2      	; 0x5bb6 <system_check_travel_limits+0x2a>
    5bb4:	46 c0       	rjmp	.+140    	; 0x5c42 <system_check_travel_limits+0xb6>
    5bb6:	20 91 32 07 	lds	r18, 0x0732	; 0x800732 <settings+0x24>
    5bba:	30 91 33 07 	lds	r19, 0x0733	; 0x800733 <settings+0x25>
    5bbe:	40 91 34 07 	lds	r20, 0x0734	; 0x800734 <settings+0x26>
    5bc2:	50 91 35 07 	lds	r21, 0x0735	; 0x800735 <settings+0x27>
    5bc6:	c7 01       	movw	r24, r14
    5bc8:	b6 01       	movw	r22, r12
    5bca:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    5bce:	88 23       	and	r24, r24
    5bd0:	d4 f1       	brlt	.+116    	; 0x5c46 <system_check_travel_limits+0xba>
    5bd2:	cc 80       	ldd	r12, Y+4	; 0x04
    5bd4:	dd 80       	ldd	r13, Y+5	; 0x05
    5bd6:	ee 80       	ldd	r14, Y+6	; 0x06
    5bd8:	ff 80       	ldd	r15, Y+7	; 0x07
    5bda:	20 e0       	ldi	r18, 0x00	; 0
    5bdc:	30 e0       	ldi	r19, 0x00	; 0
    5bde:	a9 01       	movw	r20, r18
    5be0:	c7 01       	movw	r24, r14
    5be2:	b6 01       	movw	r22, r12
    5be4:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    5be8:	18 16       	cp	r1, r24
    5bea:	7c f1       	brlt	.+94     	; 0x5c4a <system_check_travel_limits+0xbe>
    5bec:	20 91 36 07 	lds	r18, 0x0736	; 0x800736 <settings+0x28>
    5bf0:	30 91 37 07 	lds	r19, 0x0737	; 0x800737 <settings+0x29>
    5bf4:	40 91 38 07 	lds	r20, 0x0738	; 0x800738 <settings+0x2a>
    5bf8:	50 91 39 07 	lds	r21, 0x0739	; 0x800739 <settings+0x2b>
    5bfc:	c7 01       	movw	r24, r14
    5bfe:	b6 01       	movw	r22, r12
    5c00:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    5c04:	88 23       	and	r24, r24
    5c06:	1c f1       	brlt	.+70     	; 0x5c4e <system_check_travel_limits+0xc2>
    5c08:	c8 84       	ldd	r12, Y+8	; 0x08
    5c0a:	d9 84       	ldd	r13, Y+9	; 0x09
    5c0c:	ea 84       	ldd	r14, Y+10	; 0x0a
    5c0e:	fb 84       	ldd	r15, Y+11	; 0x0b
    5c10:	20 e0       	ldi	r18, 0x00	; 0
    5c12:	30 e0       	ldi	r19, 0x00	; 0
    5c14:	a9 01       	movw	r20, r18
    5c16:	c7 01       	movw	r24, r14
    5c18:	b6 01       	movw	r22, r12
    5c1a:	0e 94 86 31 	call	0x630c	; 0x630c <__gesf2>
    5c1e:	18 16       	cp	r1, r24
    5c20:	c4 f0       	brlt	.+48     	; 0x5c52 <system_check_travel_limits+0xc6>
    5c22:	20 91 3a 07 	lds	r18, 0x073A	; 0x80073a <settings+0x2c>
    5c26:	30 91 3b 07 	lds	r19, 0x073B	; 0x80073b <settings+0x2d>
    5c2a:	40 91 3c 07 	lds	r20, 0x073C	; 0x80073c <settings+0x2e>
    5c2e:	50 91 3d 07 	lds	r21, 0x073D	; 0x80073d <settings+0x2f>
    5c32:	c7 01       	movw	r24, r14
    5c34:	b6 01       	movw	r22, r12
    5c36:	0e 94 64 2f 	call	0x5ec8	; 0x5ec8 <__cmpsf2>
    5c3a:	88 1f       	adc	r24, r24
    5c3c:	88 27       	eor	r24, r24
    5c3e:	88 1f       	adc	r24, r24
    5c40:	09 c0       	rjmp	.+18     	; 0x5c54 <system_check_travel_limits+0xc8>
    5c42:	81 e0       	ldi	r24, 0x01	; 1
    5c44:	07 c0       	rjmp	.+14     	; 0x5c54 <system_check_travel_limits+0xc8>
    5c46:	81 e0       	ldi	r24, 0x01	; 1
    5c48:	05 c0       	rjmp	.+10     	; 0x5c54 <system_check_travel_limits+0xc8>
    5c4a:	81 e0       	ldi	r24, 0x01	; 1
    5c4c:	03 c0       	rjmp	.+6      	; 0x5c54 <system_check_travel_limits+0xc8>
    5c4e:	81 e0       	ldi	r24, 0x01	; 1
    5c50:	01 c0       	rjmp	.+2      	; 0x5c54 <system_check_travel_limits+0xc8>
    5c52:	81 e0       	ldi	r24, 0x01	; 1
    5c54:	df 91       	pop	r29
    5c56:	cf 91       	pop	r28
    5c58:	ff 90       	pop	r15
    5c5a:	ef 90       	pop	r14
    5c5c:	df 90       	pop	r13
    5c5e:	cf 90       	pop	r12
    5c60:	08 95       	ret

00005c62 <system_set_exec_state_flag>:
    5c62:	9f b7       	in	r25, 0x3f	; 63
    5c64:	f8 94       	cli
    5c66:	20 91 8e 05 	lds	r18, 0x058E	; 0x80058e <sys_rt_exec_state>
    5c6a:	82 2b       	or	r24, r18
    5c6c:	80 93 8e 05 	sts	0x058E, r24	; 0x80058e <sys_rt_exec_state>
    5c70:	9f bf       	out	0x3f, r25	; 63
    5c72:	08 95       	ret

00005c74 <system_clear_exec_state_flag>:
  sys_rt_exec_state |= (mask);
  SREG = sreg;
}

void system_clear_exec_state_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    5c74:	2f b7       	in	r18, 0x3f	; 63
  cli();
    5c76:	f8 94       	cli
  sys_rt_exec_state &= ~(mask);
    5c78:	90 91 8e 05 	lds	r25, 0x058E	; 0x80058e <sys_rt_exec_state>
    5c7c:	80 95       	com	r24
    5c7e:	89 23       	and	r24, r25
    5c80:	80 93 8e 05 	sts	0x058E, r24	; 0x80058e <sys_rt_exec_state>
  SREG = sreg;
    5c84:	2f bf       	out	0x3f, r18	; 63
    5c86:	08 95       	ret

00005c88 <system_set_exec_alarm>:
}

void system_set_exec_alarm(uint8_t code) {
  uint8_t sreg = SREG;
    5c88:	9f b7       	in	r25, 0x3f	; 63
  cli();
    5c8a:	f8 94       	cli
  sys_rt_exec_alarm = code;
    5c8c:	80 93 a8 05 	sts	0x05A8, r24	; 0x8005a8 <sys_rt_exec_alarm>
  SREG = sreg;
    5c90:	9f bf       	out	0x3f, r25	; 63
    5c92:	08 95       	ret

00005c94 <system_clear_exec_alarm>:
}

void system_clear_exec_alarm() {
  uint8_t sreg = SREG;
    5c94:	8f b7       	in	r24, 0x3f	; 63
  cli();
    5c96:	f8 94       	cli
  sys_rt_exec_alarm = 0;
    5c98:	10 92 a8 05 	sts	0x05A8, r1	; 0x8005a8 <sys_rt_exec_alarm>
  SREG = sreg;
    5c9c:	8f bf       	out	0x3f, r24	; 63
    5c9e:	08 95       	ret

00005ca0 <system_set_exec_motion_override_flag>:
}

void system_set_exec_motion_override_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    5ca0:	9f b7       	in	r25, 0x3f	; 63
  cli();
    5ca2:	f8 94       	cli
  sys_rt_exec_motion_override |= (mask);
    5ca4:	20 91 7b 05 	lds	r18, 0x057B	; 0x80057b <sys_rt_exec_motion_override>
    5ca8:	82 2b       	or	r24, r18
    5caa:	80 93 7b 05 	sts	0x057B, r24	; 0x80057b <sys_rt_exec_motion_override>
  SREG = sreg;
    5cae:	9f bf       	out	0x3f, r25	; 63
    5cb0:	08 95       	ret

00005cb2 <system_set_exec_accessory_override_flag>:
}

void system_set_exec_accessory_override_flag(uint8_t mask) {
  uint8_t sreg = SREG;
    5cb2:	9f b7       	in	r25, 0x3f	; 63
  cli();
    5cb4:	f8 94       	cli
  sys_rt_exec_accessory_override |= (mask);
    5cb6:	20 91 8d 05 	lds	r18, 0x058D	; 0x80058d <sys_rt_exec_accessory_override>
    5cba:	82 2b       	or	r24, r18
    5cbc:	80 93 8d 05 	sts	0x058D, r24	; 0x80058d <sys_rt_exec_accessory_override>
  SREG = sreg;
    5cc0:	9f bf       	out	0x3f, r25	; 63
    5cc2:	08 95       	ret

00005cc4 <system_clear_exec_motion_overrides>:
}

void system_clear_exec_motion_overrides() {
  uint8_t sreg = SREG;
    5cc4:	8f b7       	in	r24, 0x3f	; 63
  cli();
    5cc6:	f8 94       	cli
  sys_rt_exec_motion_override = 0;
    5cc8:	10 92 7b 05 	sts	0x057B, r1	; 0x80057b <sys_rt_exec_motion_override>
  SREG = sreg;
    5ccc:	8f bf       	out	0x3f, r24	; 63
    5cce:	08 95       	ret

00005cd0 <system_clear_exec_accessory_overrides>:
}

void system_clear_exec_accessory_overrides() {
  uint8_t sreg = SREG;
    5cd0:	8f b7       	in	r24, 0x3f	; 63
  cli();
    5cd2:	f8 94       	cli
  sys_rt_exec_accessory_override = 0;
    5cd4:	10 92 8d 05 	sts	0x058D, r1	; 0x80058d <sys_rt_exec_accessory_override>
  SREG = sreg;
    5cd8:	8f bf       	out	0x3f, r24	; 63
    5cda:	08 95       	ret

00005cdc <__subsf3>:
    5cdc:	50 58       	subi	r21, 0x80	; 128

00005cde <__addsf3>:
    5cde:	bb 27       	eor	r27, r27
    5ce0:	aa 27       	eor	r26, r26
    5ce2:	0e 94 86 2e 	call	0x5d0c	; 0x5d0c <__addsf3x>
    5ce6:	0c 94 20 31 	jmp	0x6240	; 0x6240 <__fp_round>
    5cea:	0e 94 e7 30 	call	0x61ce	; 0x61ce <__fp_pscA>
    5cee:	38 f0       	brcs	.+14     	; 0x5cfe <__addsf3+0x20>
    5cf0:	0e 94 ee 30 	call	0x61dc	; 0x61dc <__fp_pscB>
    5cf4:	20 f0       	brcs	.+8      	; 0x5cfe <__addsf3+0x20>
    5cf6:	39 f4       	brne	.+14     	; 0x5d06 <__addsf3+0x28>
    5cf8:	9f 3f       	cpi	r25, 0xFF	; 255
    5cfa:	19 f4       	brne	.+6      	; 0x5d02 <__addsf3+0x24>
    5cfc:	26 f4       	brtc	.+8      	; 0x5d06 <__addsf3+0x28>
    5cfe:	0c 94 bd 30 	jmp	0x617a	; 0x617a <__fp_nan>
    5d02:	0e f4       	brtc	.+2      	; 0x5d06 <__addsf3+0x28>
    5d04:	e0 95       	com	r30
    5d06:	e7 fb       	bst	r30, 7
    5d08:	0c 94 8e 30 	jmp	0x611c	; 0x611c <__fp_inf>

00005d0c <__addsf3x>:
    5d0c:	e9 2f       	mov	r30, r25
    5d0e:	0e 94 45 31 	call	0x628a	; 0x628a <__fp_split3>
    5d12:	58 f3       	brcs	.-42     	; 0x5cea <__addsf3+0xc>
    5d14:	ba 17       	cp	r27, r26
    5d16:	62 07       	cpc	r22, r18
    5d18:	73 07       	cpc	r23, r19
    5d1a:	84 07       	cpc	r24, r20
    5d1c:	95 07       	cpc	r25, r21
    5d1e:	20 f0       	brcs	.+8      	; 0x5d28 <__addsf3x+0x1c>
    5d20:	79 f4       	brne	.+30     	; 0x5d40 <__addsf3x+0x34>
    5d22:	a6 f5       	brtc	.+104    	; 0x5d8c <__addsf3x+0x80>
    5d24:	0c 94 7f 31 	jmp	0x62fe	; 0x62fe <__fp_zero>
    5d28:	0e f4       	brtc	.+2      	; 0x5d2c <__addsf3x+0x20>
    5d2a:	e0 95       	com	r30
    5d2c:	0b 2e       	mov	r0, r27
    5d2e:	ba 2f       	mov	r27, r26
    5d30:	a0 2d       	mov	r26, r0
    5d32:	0b 01       	movw	r0, r22
    5d34:	b9 01       	movw	r22, r18
    5d36:	90 01       	movw	r18, r0
    5d38:	0c 01       	movw	r0, r24
    5d3a:	ca 01       	movw	r24, r20
    5d3c:	a0 01       	movw	r20, r0
    5d3e:	11 24       	eor	r1, r1
    5d40:	ff 27       	eor	r31, r31
    5d42:	59 1b       	sub	r21, r25
    5d44:	99 f0       	breq	.+38     	; 0x5d6c <__addsf3x+0x60>
    5d46:	59 3f       	cpi	r21, 0xF9	; 249
    5d48:	50 f4       	brcc	.+20     	; 0x5d5e <__addsf3x+0x52>
    5d4a:	50 3e       	cpi	r21, 0xE0	; 224
    5d4c:	68 f1       	brcs	.+90     	; 0x5da8 <__addsf3x+0x9c>
    5d4e:	1a 16       	cp	r1, r26
    5d50:	f0 40       	sbci	r31, 0x00	; 0
    5d52:	a2 2f       	mov	r26, r18
    5d54:	23 2f       	mov	r18, r19
    5d56:	34 2f       	mov	r19, r20
    5d58:	44 27       	eor	r20, r20
    5d5a:	58 5f       	subi	r21, 0xF8	; 248
    5d5c:	f3 cf       	rjmp	.-26     	; 0x5d44 <__addsf3x+0x38>
    5d5e:	46 95       	lsr	r20
    5d60:	37 95       	ror	r19
    5d62:	27 95       	ror	r18
    5d64:	a7 95       	ror	r26
    5d66:	f0 40       	sbci	r31, 0x00	; 0
    5d68:	53 95       	inc	r21
    5d6a:	c9 f7       	brne	.-14     	; 0x5d5e <__addsf3x+0x52>
    5d6c:	7e f4       	brtc	.+30     	; 0x5d8c <__addsf3x+0x80>
    5d6e:	1f 16       	cp	r1, r31
    5d70:	ba 0b       	sbc	r27, r26
    5d72:	62 0b       	sbc	r22, r18
    5d74:	73 0b       	sbc	r23, r19
    5d76:	84 0b       	sbc	r24, r20
    5d78:	ba f0       	brmi	.+46     	; 0x5da8 <__addsf3x+0x9c>
    5d7a:	91 50       	subi	r25, 0x01	; 1
    5d7c:	a1 f0       	breq	.+40     	; 0x5da6 <__addsf3x+0x9a>
    5d7e:	ff 0f       	add	r31, r31
    5d80:	bb 1f       	adc	r27, r27
    5d82:	66 1f       	adc	r22, r22
    5d84:	77 1f       	adc	r23, r23
    5d86:	88 1f       	adc	r24, r24
    5d88:	c2 f7       	brpl	.-16     	; 0x5d7a <__addsf3x+0x6e>
    5d8a:	0e c0       	rjmp	.+28     	; 0x5da8 <__addsf3x+0x9c>
    5d8c:	ba 0f       	add	r27, r26
    5d8e:	62 1f       	adc	r22, r18
    5d90:	73 1f       	adc	r23, r19
    5d92:	84 1f       	adc	r24, r20
    5d94:	48 f4       	brcc	.+18     	; 0x5da8 <__addsf3x+0x9c>
    5d96:	87 95       	ror	r24
    5d98:	77 95       	ror	r23
    5d9a:	67 95       	ror	r22
    5d9c:	b7 95       	ror	r27
    5d9e:	f7 95       	ror	r31
    5da0:	9e 3f       	cpi	r25, 0xFE	; 254
    5da2:	08 f0       	brcs	.+2      	; 0x5da6 <__addsf3x+0x9a>
    5da4:	b0 cf       	rjmp	.-160    	; 0x5d06 <__addsf3+0x28>
    5da6:	93 95       	inc	r25
    5da8:	88 0f       	add	r24, r24
    5daa:	08 f0       	brcs	.+2      	; 0x5dae <__addsf3x+0xa2>
    5dac:	99 27       	eor	r25, r25
    5dae:	ee 0f       	add	r30, r30
    5db0:	97 95       	ror	r25
    5db2:	87 95       	ror	r24
    5db4:	08 95       	ret
    5db6:	0e 94 e7 30 	call	0x61ce	; 0x61ce <__fp_pscA>
    5dba:	60 f0       	brcs	.+24     	; 0x5dd4 <__addsf3x+0xc8>
    5dbc:	80 e8       	ldi	r24, 0x80	; 128
    5dbe:	91 e0       	ldi	r25, 0x01	; 1
    5dc0:	09 f4       	brne	.+2      	; 0x5dc4 <__addsf3x+0xb8>
    5dc2:	9e ef       	ldi	r25, 0xFE	; 254
    5dc4:	0e 94 ee 30 	call	0x61dc	; 0x61dc <__fp_pscB>
    5dc8:	28 f0       	brcs	.+10     	; 0x5dd4 <__addsf3x+0xc8>
    5dca:	40 e8       	ldi	r20, 0x80	; 128
    5dcc:	51 e0       	ldi	r21, 0x01	; 1
    5dce:	71 f4       	brne	.+28     	; 0x5dec <atan2+0x10>
    5dd0:	5e ef       	ldi	r21, 0xFE	; 254
    5dd2:	0c c0       	rjmp	.+24     	; 0x5dec <atan2+0x10>
    5dd4:	0c 94 bd 30 	jmp	0x617a	; 0x617a <__fp_nan>
    5dd8:	0c 94 7f 31 	jmp	0x62fe	; 0x62fe <__fp_zero>

00005ddc <atan2>:
    5ddc:	e9 2f       	mov	r30, r25
    5dde:	e0 78       	andi	r30, 0x80	; 128
    5de0:	0e 94 45 31 	call	0x628a	; 0x628a <__fp_split3>
    5de4:	40 f3       	brcs	.-48     	; 0x5db6 <__addsf3x+0xaa>
    5de6:	09 2e       	mov	r0, r25
    5de8:	05 2a       	or	r0, r21
    5dea:	b1 f3       	breq	.-20     	; 0x5dd8 <__addsf3x+0xcc>
    5dec:	26 17       	cp	r18, r22
    5dee:	37 07       	cpc	r19, r23
    5df0:	48 07       	cpc	r20, r24
    5df2:	59 07       	cpc	r21, r25
    5df4:	38 f0       	brcs	.+14     	; 0x5e04 <atan2+0x28>
    5df6:	0e 2e       	mov	r0, r30
    5df8:	07 f8       	bld	r0, 7
    5dfa:	e0 25       	eor	r30, r0
    5dfc:	69 f0       	breq	.+26     	; 0x5e18 <atan2+0x3c>
    5dfe:	e0 25       	eor	r30, r0
    5e00:	e0 64       	ori	r30, 0x40	; 64
    5e02:	0a c0       	rjmp	.+20     	; 0x5e18 <atan2+0x3c>
    5e04:	ef 63       	ori	r30, 0x3F	; 63
    5e06:	07 f8       	bld	r0, 7
    5e08:	00 94       	com	r0
    5e0a:	07 fa       	bst	r0, 7
    5e0c:	db 01       	movw	r26, r22
    5e0e:	b9 01       	movw	r22, r18
    5e10:	9d 01       	movw	r18, r26
    5e12:	dc 01       	movw	r26, r24
    5e14:	ca 01       	movw	r24, r20
    5e16:	ad 01       	movw	r20, r26
    5e18:	ef 93       	push	r30
    5e1a:	0e 94 85 2f 	call	0x5f0a	; 0x5f0a <__divsf3_pse>
    5e1e:	0e 94 20 31 	call	0x6240	; 0x6240 <__fp_round>
    5e22:	0e 94 1e 2f 	call	0x5e3c	; 0x5e3c <atan>
    5e26:	5f 91       	pop	r21
    5e28:	55 23       	and	r21, r21
    5e2a:	39 f0       	breq	.+14     	; 0x5e3a <atan2+0x5e>
    5e2c:	2b ed       	ldi	r18, 0xDB	; 219
    5e2e:	3f e0       	ldi	r19, 0x0F	; 15
    5e30:	49 e4       	ldi	r20, 0x49	; 73
    5e32:	50 fd       	sbrc	r21, 0
    5e34:	49 ec       	ldi	r20, 0xC9	; 201
    5e36:	0c 94 6f 2e 	jmp	0x5cde	; 0x5cde <__addsf3>
    5e3a:	08 95       	ret

00005e3c <atan>:
    5e3c:	df 93       	push	r29
    5e3e:	dd 27       	eor	r29, r29
    5e40:	b9 2f       	mov	r27, r25
    5e42:	bf 77       	andi	r27, 0x7F	; 127
    5e44:	40 e8       	ldi	r20, 0x80	; 128
    5e46:	5f e3       	ldi	r21, 0x3F	; 63
    5e48:	16 16       	cp	r1, r22
    5e4a:	17 06       	cpc	r1, r23
    5e4c:	48 07       	cpc	r20, r24
    5e4e:	5b 07       	cpc	r21, r27
    5e50:	18 f4       	brcc	.+6      	; 0x5e58 <atan+0x1c>
    5e52:	d9 2f       	mov	r29, r25
    5e54:	0e 94 8b 31 	call	0x6316	; 0x6316 <inverse>
    5e58:	9f 93       	push	r25
    5e5a:	8f 93       	push	r24
    5e5c:	7f 93       	push	r23
    5e5e:	6f 93       	push	r22
    5e60:	0e 94 a5 32 	call	0x654a	; 0x654a <square>
    5e64:	e8 ec       	ldi	r30, 0xC8	; 200
    5e66:	f1 e0       	ldi	r31, 0x01	; 1
    5e68:	0e 94 c0 30 	call	0x6180	; 0x6180 <__fp_powser>
    5e6c:	0e 94 20 31 	call	0x6240	; 0x6240 <__fp_round>
    5e70:	2f 91       	pop	r18
    5e72:	3f 91       	pop	r19
    5e74:	4f 91       	pop	r20
    5e76:	5f 91       	pop	r21
    5e78:	0e 94 d9 31 	call	0x63b2	; 0x63b2 <__mulsf3x>
    5e7c:	dd 23       	and	r29, r29
    5e7e:	51 f0       	breq	.+20     	; 0x5e94 <atan+0x58>
    5e80:	90 58       	subi	r25, 0x80	; 128
    5e82:	a2 ea       	ldi	r26, 0xA2	; 162
    5e84:	2a ed       	ldi	r18, 0xDA	; 218
    5e86:	3f e0       	ldi	r19, 0x0F	; 15
    5e88:	49 ec       	ldi	r20, 0xC9	; 201
    5e8a:	5f e3       	ldi	r21, 0x3F	; 63
    5e8c:	d0 78       	andi	r29, 0x80	; 128
    5e8e:	5d 27       	eor	r21, r29
    5e90:	0e 94 86 2e 	call	0x5d0c	; 0x5d0c <__addsf3x>
    5e94:	df 91       	pop	r29
    5e96:	0c 94 20 31 	jmp	0x6240	; 0x6240 <__fp_round>

00005e9a <ceil>:
    5e9a:	0e 94 67 31 	call	0x62ce	; 0x62ce <__fp_trunc>
    5e9e:	90 f0       	brcs	.+36     	; 0x5ec4 <ceil+0x2a>
    5ea0:	9f 37       	cpi	r25, 0x7F	; 127
    5ea2:	48 f4       	brcc	.+18     	; 0x5eb6 <ceil+0x1c>
    5ea4:	91 11       	cpse	r25, r1
    5ea6:	16 f4       	brtc	.+4      	; 0x5eac <ceil+0x12>
    5ea8:	0c 94 80 31 	jmp	0x6300	; 0x6300 <__fp_szero>
    5eac:	60 e0       	ldi	r22, 0x00	; 0
    5eae:	70 e0       	ldi	r23, 0x00	; 0
    5eb0:	80 e8       	ldi	r24, 0x80	; 128
    5eb2:	9f e3       	ldi	r25, 0x3F	; 63
    5eb4:	08 95       	ret
    5eb6:	26 f0       	brts	.+8      	; 0x5ec0 <ceil+0x26>
    5eb8:	1b 16       	cp	r1, r27
    5eba:	61 1d       	adc	r22, r1
    5ebc:	71 1d       	adc	r23, r1
    5ebe:	81 1d       	adc	r24, r1
    5ec0:	0c 94 94 30 	jmp	0x6128	; 0x6128 <__fp_mintl>
    5ec4:	0c 94 af 30 	jmp	0x615e	; 0x615e <__fp_mpack>

00005ec8 <__cmpsf2>:
    5ec8:	0e 94 6a 30 	call	0x60d4	; 0x60d4 <__fp_cmp>
    5ecc:	08 f4       	brcc	.+2      	; 0x5ed0 <__cmpsf2+0x8>
    5ece:	81 e0       	ldi	r24, 0x01	; 1
    5ed0:	08 95       	ret

00005ed2 <cos>:
    5ed2:	0e 94 f7 30 	call	0x61ee	; 0x61ee <__fp_rempio2>
    5ed6:	e3 95       	inc	r30
    5ed8:	0c 94 31 31 	jmp	0x6262	; 0x6262 <__fp_sinus>

00005edc <__divsf3>:
    5edc:	0e 94 82 2f 	call	0x5f04	; 0x5f04 <__divsf3x>
    5ee0:	0c 94 20 31 	jmp	0x6240	; 0x6240 <__fp_round>
    5ee4:	0e 94 ee 30 	call	0x61dc	; 0x61dc <__fp_pscB>
    5ee8:	58 f0       	brcs	.+22     	; 0x5f00 <__divsf3+0x24>
    5eea:	0e 94 e7 30 	call	0x61ce	; 0x61ce <__fp_pscA>
    5eee:	40 f0       	brcs	.+16     	; 0x5f00 <__divsf3+0x24>
    5ef0:	29 f4       	brne	.+10     	; 0x5efc <__divsf3+0x20>
    5ef2:	5f 3f       	cpi	r21, 0xFF	; 255
    5ef4:	29 f0       	breq	.+10     	; 0x5f00 <__divsf3+0x24>
    5ef6:	0c 94 8e 30 	jmp	0x611c	; 0x611c <__fp_inf>
    5efa:	51 11       	cpse	r21, r1
    5efc:	0c 94 80 31 	jmp	0x6300	; 0x6300 <__fp_szero>
    5f00:	0c 94 bd 30 	jmp	0x617a	; 0x617a <__fp_nan>

00005f04 <__divsf3x>:
    5f04:	0e 94 45 31 	call	0x628a	; 0x628a <__fp_split3>
    5f08:	68 f3       	brcs	.-38     	; 0x5ee4 <__divsf3+0x8>

00005f0a <__divsf3_pse>:
    5f0a:	99 23       	and	r25, r25
    5f0c:	b1 f3       	breq	.-20     	; 0x5efa <__divsf3+0x1e>
    5f0e:	55 23       	and	r21, r21
    5f10:	91 f3       	breq	.-28     	; 0x5ef6 <__divsf3+0x1a>
    5f12:	95 1b       	sub	r25, r21
    5f14:	55 0b       	sbc	r21, r21
    5f16:	bb 27       	eor	r27, r27
    5f18:	aa 27       	eor	r26, r26
    5f1a:	62 17       	cp	r22, r18
    5f1c:	73 07       	cpc	r23, r19
    5f1e:	84 07       	cpc	r24, r20
    5f20:	38 f0       	brcs	.+14     	; 0x5f30 <__divsf3_pse+0x26>
    5f22:	9f 5f       	subi	r25, 0xFF	; 255
    5f24:	5f 4f       	sbci	r21, 0xFF	; 255
    5f26:	22 0f       	add	r18, r18
    5f28:	33 1f       	adc	r19, r19
    5f2a:	44 1f       	adc	r20, r20
    5f2c:	aa 1f       	adc	r26, r26
    5f2e:	a9 f3       	breq	.-22     	; 0x5f1a <__divsf3_pse+0x10>
    5f30:	35 d0       	rcall	.+106    	; 0x5f9c <__divsf3_pse+0x92>
    5f32:	0e 2e       	mov	r0, r30
    5f34:	3a f0       	brmi	.+14     	; 0x5f44 <__divsf3_pse+0x3a>
    5f36:	e0 e8       	ldi	r30, 0x80	; 128
    5f38:	32 d0       	rcall	.+100    	; 0x5f9e <__divsf3_pse+0x94>
    5f3a:	91 50       	subi	r25, 0x01	; 1
    5f3c:	50 40       	sbci	r21, 0x00	; 0
    5f3e:	e6 95       	lsr	r30
    5f40:	00 1c       	adc	r0, r0
    5f42:	ca f7       	brpl	.-14     	; 0x5f36 <__divsf3_pse+0x2c>
    5f44:	2b d0       	rcall	.+86     	; 0x5f9c <__divsf3_pse+0x92>
    5f46:	fe 2f       	mov	r31, r30
    5f48:	29 d0       	rcall	.+82     	; 0x5f9c <__divsf3_pse+0x92>
    5f4a:	66 0f       	add	r22, r22
    5f4c:	77 1f       	adc	r23, r23
    5f4e:	88 1f       	adc	r24, r24
    5f50:	bb 1f       	adc	r27, r27
    5f52:	26 17       	cp	r18, r22
    5f54:	37 07       	cpc	r19, r23
    5f56:	48 07       	cpc	r20, r24
    5f58:	ab 07       	cpc	r26, r27
    5f5a:	b0 e8       	ldi	r27, 0x80	; 128
    5f5c:	09 f0       	breq	.+2      	; 0x5f60 <__divsf3_pse+0x56>
    5f5e:	bb 0b       	sbc	r27, r27
    5f60:	80 2d       	mov	r24, r0
    5f62:	bf 01       	movw	r22, r30
    5f64:	ff 27       	eor	r31, r31
    5f66:	93 58       	subi	r25, 0x83	; 131
    5f68:	5f 4f       	sbci	r21, 0xFF	; 255
    5f6a:	3a f0       	brmi	.+14     	; 0x5f7a <__divsf3_pse+0x70>
    5f6c:	9e 3f       	cpi	r25, 0xFE	; 254
    5f6e:	51 05       	cpc	r21, r1
    5f70:	78 f0       	brcs	.+30     	; 0x5f90 <__divsf3_pse+0x86>
    5f72:	0c 94 8e 30 	jmp	0x611c	; 0x611c <__fp_inf>
    5f76:	0c 94 80 31 	jmp	0x6300	; 0x6300 <__fp_szero>
    5f7a:	5f 3f       	cpi	r21, 0xFF	; 255
    5f7c:	e4 f3       	brlt	.-8      	; 0x5f76 <__divsf3_pse+0x6c>
    5f7e:	98 3e       	cpi	r25, 0xE8	; 232
    5f80:	d4 f3       	brlt	.-12     	; 0x5f76 <__divsf3_pse+0x6c>
    5f82:	86 95       	lsr	r24
    5f84:	77 95       	ror	r23
    5f86:	67 95       	ror	r22
    5f88:	b7 95       	ror	r27
    5f8a:	f7 95       	ror	r31
    5f8c:	9f 5f       	subi	r25, 0xFF	; 255
    5f8e:	c9 f7       	brne	.-14     	; 0x5f82 <__divsf3_pse+0x78>
    5f90:	88 0f       	add	r24, r24
    5f92:	91 1d       	adc	r25, r1
    5f94:	96 95       	lsr	r25
    5f96:	87 95       	ror	r24
    5f98:	97 f9       	bld	r25, 7
    5f9a:	08 95       	ret
    5f9c:	e1 e0       	ldi	r30, 0x01	; 1
    5f9e:	66 0f       	add	r22, r22
    5fa0:	77 1f       	adc	r23, r23
    5fa2:	88 1f       	adc	r24, r24
    5fa4:	bb 1f       	adc	r27, r27
    5fa6:	62 17       	cp	r22, r18
    5fa8:	73 07       	cpc	r23, r19
    5faa:	84 07       	cpc	r24, r20
    5fac:	ba 07       	cpc	r27, r26
    5fae:	20 f0       	brcs	.+8      	; 0x5fb8 <__divsf3_pse+0xae>
    5fb0:	62 1b       	sub	r22, r18
    5fb2:	73 0b       	sbc	r23, r19
    5fb4:	84 0b       	sbc	r24, r20
    5fb6:	ba 0b       	sbc	r27, r26
    5fb8:	ee 1f       	adc	r30, r30
    5fba:	88 f7       	brcc	.-30     	; 0x5f9e <__divsf3_pse+0x94>
    5fbc:	e0 95       	com	r30
    5fbe:	08 95       	ret

00005fc0 <__fixsfsi>:
    5fc0:	0e 94 e7 2f 	call	0x5fce	; 0x5fce <__fixunssfsi>
    5fc4:	68 94       	set
    5fc6:	b1 11       	cpse	r27, r1
    5fc8:	0c 94 80 31 	jmp	0x6300	; 0x6300 <__fp_szero>
    5fcc:	08 95       	ret

00005fce <__fixunssfsi>:
    5fce:	0e 94 4d 31 	call	0x629a	; 0x629a <__fp_splitA>
    5fd2:	88 f0       	brcs	.+34     	; 0x5ff6 <__fixunssfsi+0x28>
    5fd4:	9f 57       	subi	r25, 0x7F	; 127
    5fd6:	98 f0       	brcs	.+38     	; 0x5ffe <__fixunssfsi+0x30>
    5fd8:	b9 2f       	mov	r27, r25
    5fda:	99 27       	eor	r25, r25
    5fdc:	b7 51       	subi	r27, 0x17	; 23
    5fde:	b0 f0       	brcs	.+44     	; 0x600c <__fixunssfsi+0x3e>
    5fe0:	e1 f0       	breq	.+56     	; 0x601a <__fixunssfsi+0x4c>
    5fe2:	66 0f       	add	r22, r22
    5fe4:	77 1f       	adc	r23, r23
    5fe6:	88 1f       	adc	r24, r24
    5fe8:	99 1f       	adc	r25, r25
    5fea:	1a f0       	brmi	.+6      	; 0x5ff2 <__fixunssfsi+0x24>
    5fec:	ba 95       	dec	r27
    5fee:	c9 f7       	brne	.-14     	; 0x5fe2 <__fixunssfsi+0x14>
    5ff0:	14 c0       	rjmp	.+40     	; 0x601a <__fixunssfsi+0x4c>
    5ff2:	b1 30       	cpi	r27, 0x01	; 1
    5ff4:	91 f0       	breq	.+36     	; 0x601a <__fixunssfsi+0x4c>
    5ff6:	0e 94 7f 31 	call	0x62fe	; 0x62fe <__fp_zero>
    5ffa:	b1 e0       	ldi	r27, 0x01	; 1
    5ffc:	08 95       	ret
    5ffe:	0c 94 7f 31 	jmp	0x62fe	; 0x62fe <__fp_zero>
    6002:	67 2f       	mov	r22, r23
    6004:	78 2f       	mov	r23, r24
    6006:	88 27       	eor	r24, r24
    6008:	b8 5f       	subi	r27, 0xF8	; 248
    600a:	39 f0       	breq	.+14     	; 0x601a <__fixunssfsi+0x4c>
    600c:	b9 3f       	cpi	r27, 0xF9	; 249
    600e:	cc f3       	brlt	.-14     	; 0x6002 <__fixunssfsi+0x34>
    6010:	86 95       	lsr	r24
    6012:	77 95       	ror	r23
    6014:	67 95       	ror	r22
    6016:	b3 95       	inc	r27
    6018:	d9 f7       	brne	.-10     	; 0x6010 <__fixunssfsi+0x42>
    601a:	3e f4       	brtc	.+14     	; 0x602a <__fixunssfsi+0x5c>
    601c:	90 95       	com	r25
    601e:	80 95       	com	r24
    6020:	70 95       	com	r23
    6022:	61 95       	neg	r22
    6024:	7f 4f       	sbci	r23, 0xFF	; 255
    6026:	8f 4f       	sbci	r24, 0xFF	; 255
    6028:	9f 4f       	sbci	r25, 0xFF	; 255
    602a:	08 95       	ret

0000602c <__floatunsisf>:
    602c:	e8 94       	clt
    602e:	09 c0       	rjmp	.+18     	; 0x6042 <__floatsisf+0x12>

00006030 <__floatsisf>:
    6030:	97 fb       	bst	r25, 7
    6032:	3e f4       	brtc	.+14     	; 0x6042 <__floatsisf+0x12>
    6034:	90 95       	com	r25
    6036:	80 95       	com	r24
    6038:	70 95       	com	r23
    603a:	61 95       	neg	r22
    603c:	7f 4f       	sbci	r23, 0xFF	; 255
    603e:	8f 4f       	sbci	r24, 0xFF	; 255
    6040:	9f 4f       	sbci	r25, 0xFF	; 255
    6042:	99 23       	and	r25, r25
    6044:	a9 f0       	breq	.+42     	; 0x6070 <__floatsisf+0x40>
    6046:	f9 2f       	mov	r31, r25
    6048:	96 e9       	ldi	r25, 0x96	; 150
    604a:	bb 27       	eor	r27, r27
    604c:	93 95       	inc	r25
    604e:	f6 95       	lsr	r31
    6050:	87 95       	ror	r24
    6052:	77 95       	ror	r23
    6054:	67 95       	ror	r22
    6056:	b7 95       	ror	r27
    6058:	f1 11       	cpse	r31, r1
    605a:	f8 cf       	rjmp	.-16     	; 0x604c <__floatsisf+0x1c>
    605c:	fa f4       	brpl	.+62     	; 0x609c <__floatsisf+0x6c>
    605e:	bb 0f       	add	r27, r27
    6060:	11 f4       	brne	.+4      	; 0x6066 <__floatsisf+0x36>
    6062:	60 ff       	sbrs	r22, 0
    6064:	1b c0       	rjmp	.+54     	; 0x609c <__floatsisf+0x6c>
    6066:	6f 5f       	subi	r22, 0xFF	; 255
    6068:	7f 4f       	sbci	r23, 0xFF	; 255
    606a:	8f 4f       	sbci	r24, 0xFF	; 255
    606c:	9f 4f       	sbci	r25, 0xFF	; 255
    606e:	16 c0       	rjmp	.+44     	; 0x609c <__floatsisf+0x6c>
    6070:	88 23       	and	r24, r24
    6072:	11 f0       	breq	.+4      	; 0x6078 <__floatsisf+0x48>
    6074:	96 e9       	ldi	r25, 0x96	; 150
    6076:	11 c0       	rjmp	.+34     	; 0x609a <__floatsisf+0x6a>
    6078:	77 23       	and	r23, r23
    607a:	21 f0       	breq	.+8      	; 0x6084 <__floatsisf+0x54>
    607c:	9e e8       	ldi	r25, 0x8E	; 142
    607e:	87 2f       	mov	r24, r23
    6080:	76 2f       	mov	r23, r22
    6082:	05 c0       	rjmp	.+10     	; 0x608e <__floatsisf+0x5e>
    6084:	66 23       	and	r22, r22
    6086:	71 f0       	breq	.+28     	; 0x60a4 <__floatsisf+0x74>
    6088:	96 e8       	ldi	r25, 0x86	; 134
    608a:	86 2f       	mov	r24, r22
    608c:	70 e0       	ldi	r23, 0x00	; 0
    608e:	60 e0       	ldi	r22, 0x00	; 0
    6090:	2a f0       	brmi	.+10     	; 0x609c <__floatsisf+0x6c>
    6092:	9a 95       	dec	r25
    6094:	66 0f       	add	r22, r22
    6096:	77 1f       	adc	r23, r23
    6098:	88 1f       	adc	r24, r24
    609a:	da f7       	brpl	.-10     	; 0x6092 <__floatsisf+0x62>
    609c:	88 0f       	add	r24, r24
    609e:	96 95       	lsr	r25
    60a0:	87 95       	ror	r24
    60a2:	97 f9       	bld	r25, 7
    60a4:	08 95       	ret

000060a6 <floor>:
    60a6:	0e 94 67 31 	call	0x62ce	; 0x62ce <__fp_trunc>
    60aa:	90 f0       	brcs	.+36     	; 0x60d0 <floor+0x2a>
    60ac:	9f 37       	cpi	r25, 0x7F	; 127
    60ae:	48 f4       	brcc	.+18     	; 0x60c2 <floor+0x1c>
    60b0:	91 11       	cpse	r25, r1
    60b2:	16 f0       	brts	.+4      	; 0x60b8 <floor+0x12>
    60b4:	0c 94 80 31 	jmp	0x6300	; 0x6300 <__fp_szero>
    60b8:	60 e0       	ldi	r22, 0x00	; 0
    60ba:	70 e0       	ldi	r23, 0x00	; 0
    60bc:	80 e8       	ldi	r24, 0x80	; 128
    60be:	9f eb       	ldi	r25, 0xBF	; 191
    60c0:	08 95       	ret
    60c2:	26 f4       	brtc	.+8      	; 0x60cc <floor+0x26>
    60c4:	1b 16       	cp	r1, r27
    60c6:	61 1d       	adc	r22, r1
    60c8:	71 1d       	adc	r23, r1
    60ca:	81 1d       	adc	r24, r1
    60cc:	0c 94 94 30 	jmp	0x6128	; 0x6128 <__fp_mintl>
    60d0:	0c 94 af 30 	jmp	0x615e	; 0x615e <__fp_mpack>

000060d4 <__fp_cmp>:
    60d4:	99 0f       	add	r25, r25
    60d6:	00 08       	sbc	r0, r0
    60d8:	55 0f       	add	r21, r21
    60da:	aa 0b       	sbc	r26, r26
    60dc:	e0 e8       	ldi	r30, 0x80	; 128
    60de:	fe ef       	ldi	r31, 0xFE	; 254
    60e0:	16 16       	cp	r1, r22
    60e2:	17 06       	cpc	r1, r23
    60e4:	e8 07       	cpc	r30, r24
    60e6:	f9 07       	cpc	r31, r25
    60e8:	c0 f0       	brcs	.+48     	; 0x611a <__fp_cmp+0x46>
    60ea:	12 16       	cp	r1, r18
    60ec:	13 06       	cpc	r1, r19
    60ee:	e4 07       	cpc	r30, r20
    60f0:	f5 07       	cpc	r31, r21
    60f2:	98 f0       	brcs	.+38     	; 0x611a <__fp_cmp+0x46>
    60f4:	62 1b       	sub	r22, r18
    60f6:	73 0b       	sbc	r23, r19
    60f8:	84 0b       	sbc	r24, r20
    60fa:	95 0b       	sbc	r25, r21
    60fc:	39 f4       	brne	.+14     	; 0x610c <__fp_cmp+0x38>
    60fe:	0a 26       	eor	r0, r26
    6100:	61 f0       	breq	.+24     	; 0x611a <__fp_cmp+0x46>
    6102:	23 2b       	or	r18, r19
    6104:	24 2b       	or	r18, r20
    6106:	25 2b       	or	r18, r21
    6108:	21 f4       	brne	.+8      	; 0x6112 <__fp_cmp+0x3e>
    610a:	08 95       	ret
    610c:	0a 26       	eor	r0, r26
    610e:	09 f4       	brne	.+2      	; 0x6112 <__fp_cmp+0x3e>
    6110:	a1 40       	sbci	r26, 0x01	; 1
    6112:	a6 95       	lsr	r26
    6114:	8f ef       	ldi	r24, 0xFF	; 255
    6116:	81 1d       	adc	r24, r1
    6118:	81 1d       	adc	r24, r1
    611a:	08 95       	ret

0000611c <__fp_inf>:
    611c:	97 f9       	bld	r25, 7
    611e:	9f 67       	ori	r25, 0x7F	; 127
    6120:	80 e8       	ldi	r24, 0x80	; 128
    6122:	70 e0       	ldi	r23, 0x00	; 0
    6124:	60 e0       	ldi	r22, 0x00	; 0
    6126:	08 95       	ret

00006128 <__fp_mintl>:
    6128:	88 23       	and	r24, r24
    612a:	71 f4       	brne	.+28     	; 0x6148 <__fp_mintl+0x20>
    612c:	77 23       	and	r23, r23
    612e:	21 f0       	breq	.+8      	; 0x6138 <__fp_mintl+0x10>
    6130:	98 50       	subi	r25, 0x08	; 8
    6132:	87 2b       	or	r24, r23
    6134:	76 2f       	mov	r23, r22
    6136:	07 c0       	rjmp	.+14     	; 0x6146 <__fp_mintl+0x1e>
    6138:	66 23       	and	r22, r22
    613a:	11 f4       	brne	.+4      	; 0x6140 <__fp_mintl+0x18>
    613c:	99 27       	eor	r25, r25
    613e:	0d c0       	rjmp	.+26     	; 0x615a <__fp_mintl+0x32>
    6140:	90 51       	subi	r25, 0x10	; 16
    6142:	86 2b       	or	r24, r22
    6144:	70 e0       	ldi	r23, 0x00	; 0
    6146:	60 e0       	ldi	r22, 0x00	; 0
    6148:	2a f0       	brmi	.+10     	; 0x6154 <__fp_mintl+0x2c>
    614a:	9a 95       	dec	r25
    614c:	66 0f       	add	r22, r22
    614e:	77 1f       	adc	r23, r23
    6150:	88 1f       	adc	r24, r24
    6152:	da f7       	brpl	.-10     	; 0x614a <__fp_mintl+0x22>
    6154:	88 0f       	add	r24, r24
    6156:	96 95       	lsr	r25
    6158:	87 95       	ror	r24
    615a:	97 f9       	bld	r25, 7
    615c:	08 95       	ret

0000615e <__fp_mpack>:
    615e:	9f 3f       	cpi	r25, 0xFF	; 255
    6160:	31 f0       	breq	.+12     	; 0x616e <__fp_mpack_finite+0xc>

00006162 <__fp_mpack_finite>:
    6162:	91 50       	subi	r25, 0x01	; 1
    6164:	20 f4       	brcc	.+8      	; 0x616e <__fp_mpack_finite+0xc>
    6166:	87 95       	ror	r24
    6168:	77 95       	ror	r23
    616a:	67 95       	ror	r22
    616c:	b7 95       	ror	r27
    616e:	88 0f       	add	r24, r24
    6170:	91 1d       	adc	r25, r1
    6172:	96 95       	lsr	r25
    6174:	87 95       	ror	r24
    6176:	97 f9       	bld	r25, 7
    6178:	08 95       	ret

0000617a <__fp_nan>:
    617a:	9f ef       	ldi	r25, 0xFF	; 255
    617c:	80 ec       	ldi	r24, 0xC0	; 192
    617e:	08 95       	ret

00006180 <__fp_powser>:
    6180:	df 93       	push	r29
    6182:	cf 93       	push	r28
    6184:	1f 93       	push	r17
    6186:	0f 93       	push	r16
    6188:	ff 92       	push	r15
    618a:	ef 92       	push	r14
    618c:	df 92       	push	r13
    618e:	7b 01       	movw	r14, r22
    6190:	8c 01       	movw	r16, r24
    6192:	68 94       	set
    6194:	06 c0       	rjmp	.+12     	; 0x61a2 <__fp_powser+0x22>
    6196:	da 2e       	mov	r13, r26
    6198:	ef 01       	movw	r28, r30
    619a:	0e 94 d9 31 	call	0x63b2	; 0x63b2 <__mulsf3x>
    619e:	fe 01       	movw	r30, r28
    61a0:	e8 94       	clt
    61a2:	a5 91       	lpm	r26, Z+
    61a4:	25 91       	lpm	r18, Z+
    61a6:	35 91       	lpm	r19, Z+
    61a8:	45 91       	lpm	r20, Z+
    61aa:	55 91       	lpm	r21, Z+
    61ac:	a6 f3       	brts	.-24     	; 0x6196 <__fp_powser+0x16>
    61ae:	ef 01       	movw	r28, r30
    61b0:	0e 94 86 2e 	call	0x5d0c	; 0x5d0c <__addsf3x>
    61b4:	fe 01       	movw	r30, r28
    61b6:	97 01       	movw	r18, r14
    61b8:	a8 01       	movw	r20, r16
    61ba:	da 94       	dec	r13
    61bc:	69 f7       	brne	.-38     	; 0x6198 <__fp_powser+0x18>
    61be:	df 90       	pop	r13
    61c0:	ef 90       	pop	r14
    61c2:	ff 90       	pop	r15
    61c4:	0f 91       	pop	r16
    61c6:	1f 91       	pop	r17
    61c8:	cf 91       	pop	r28
    61ca:	df 91       	pop	r29
    61cc:	08 95       	ret

000061ce <__fp_pscA>:
    61ce:	00 24       	eor	r0, r0
    61d0:	0a 94       	dec	r0
    61d2:	16 16       	cp	r1, r22
    61d4:	17 06       	cpc	r1, r23
    61d6:	18 06       	cpc	r1, r24
    61d8:	09 06       	cpc	r0, r25
    61da:	08 95       	ret

000061dc <__fp_pscB>:
    61dc:	00 24       	eor	r0, r0
    61de:	0a 94       	dec	r0
    61e0:	12 16       	cp	r1, r18
    61e2:	13 06       	cpc	r1, r19
    61e4:	14 06       	cpc	r1, r20
    61e6:	05 06       	cpc	r0, r21
    61e8:	08 95       	ret
    61ea:	0c 94 bd 30 	jmp	0x617a	; 0x617a <__fp_nan>

000061ee <__fp_rempio2>:
    61ee:	0e 94 4d 31 	call	0x629a	; 0x629a <__fp_splitA>
    61f2:	d8 f3       	brcs	.-10     	; 0x61ea <__fp_pscB+0xe>
    61f4:	e8 94       	clt
    61f6:	e0 e0       	ldi	r30, 0x00	; 0
    61f8:	bb 27       	eor	r27, r27
    61fa:	9f 57       	subi	r25, 0x7F	; 127
    61fc:	f0 f0       	brcs	.+60     	; 0x623a <__fp_rempio2+0x4c>
    61fe:	2a ed       	ldi	r18, 0xDA	; 218
    6200:	3f e0       	ldi	r19, 0x0F	; 15
    6202:	49 ec       	ldi	r20, 0xC9	; 201
    6204:	06 c0       	rjmp	.+12     	; 0x6212 <__fp_rempio2+0x24>
    6206:	ee 0f       	add	r30, r30
    6208:	bb 0f       	add	r27, r27
    620a:	66 1f       	adc	r22, r22
    620c:	77 1f       	adc	r23, r23
    620e:	88 1f       	adc	r24, r24
    6210:	28 f0       	brcs	.+10     	; 0x621c <__fp_rempio2+0x2e>
    6212:	b2 3a       	cpi	r27, 0xA2	; 162
    6214:	62 07       	cpc	r22, r18
    6216:	73 07       	cpc	r23, r19
    6218:	84 07       	cpc	r24, r20
    621a:	28 f0       	brcs	.+10     	; 0x6226 <__fp_rempio2+0x38>
    621c:	b2 5a       	subi	r27, 0xA2	; 162
    621e:	62 0b       	sbc	r22, r18
    6220:	73 0b       	sbc	r23, r19
    6222:	84 0b       	sbc	r24, r20
    6224:	e3 95       	inc	r30
    6226:	9a 95       	dec	r25
    6228:	72 f7       	brpl	.-36     	; 0x6206 <__fp_rempio2+0x18>
    622a:	80 38       	cpi	r24, 0x80	; 128
    622c:	30 f4       	brcc	.+12     	; 0x623a <__fp_rempio2+0x4c>
    622e:	9a 95       	dec	r25
    6230:	bb 0f       	add	r27, r27
    6232:	66 1f       	adc	r22, r22
    6234:	77 1f       	adc	r23, r23
    6236:	88 1f       	adc	r24, r24
    6238:	d2 f7       	brpl	.-12     	; 0x622e <__fp_rempio2+0x40>
    623a:	90 48       	sbci	r25, 0x80	; 128
    623c:	0c 94 b1 30 	jmp	0x6162	; 0x6162 <__fp_mpack_finite>

00006240 <__fp_round>:
    6240:	09 2e       	mov	r0, r25
    6242:	03 94       	inc	r0
    6244:	00 0c       	add	r0, r0
    6246:	11 f4       	brne	.+4      	; 0x624c <__fp_round+0xc>
    6248:	88 23       	and	r24, r24
    624a:	52 f0       	brmi	.+20     	; 0x6260 <__fp_round+0x20>
    624c:	bb 0f       	add	r27, r27
    624e:	40 f4       	brcc	.+16     	; 0x6260 <__fp_round+0x20>
    6250:	bf 2b       	or	r27, r31
    6252:	11 f4       	brne	.+4      	; 0x6258 <__fp_round+0x18>
    6254:	60 ff       	sbrs	r22, 0
    6256:	04 c0       	rjmp	.+8      	; 0x6260 <__fp_round+0x20>
    6258:	6f 5f       	subi	r22, 0xFF	; 255
    625a:	7f 4f       	sbci	r23, 0xFF	; 255
    625c:	8f 4f       	sbci	r24, 0xFF	; 255
    625e:	9f 4f       	sbci	r25, 0xFF	; 255
    6260:	08 95       	ret

00006262 <__fp_sinus>:
    6262:	ef 93       	push	r30
    6264:	e0 ff       	sbrs	r30, 0
    6266:	07 c0       	rjmp	.+14     	; 0x6276 <__fp_sinus+0x14>
    6268:	a2 ea       	ldi	r26, 0xA2	; 162
    626a:	2a ed       	ldi	r18, 0xDA	; 218
    626c:	3f e0       	ldi	r19, 0x0F	; 15
    626e:	49 ec       	ldi	r20, 0xC9	; 201
    6270:	5f eb       	ldi	r21, 0xBF	; 191
    6272:	0e 94 86 2e 	call	0x5d0c	; 0x5d0c <__addsf3x>
    6276:	0e 94 20 31 	call	0x6240	; 0x6240 <__fp_round>
    627a:	0f 90       	pop	r0
    627c:	03 94       	inc	r0
    627e:	01 fc       	sbrc	r0, 1
    6280:	90 58       	subi	r25, 0x80	; 128
    6282:	e5 ef       	ldi	r30, 0xF5	; 245
    6284:	f1 e0       	ldi	r31, 0x01	; 1
    6286:	0c 94 bb 32 	jmp	0x6576	; 0x6576 <__fp_powsodd>

0000628a <__fp_split3>:
    628a:	57 fd       	sbrc	r21, 7
    628c:	90 58       	subi	r25, 0x80	; 128
    628e:	44 0f       	add	r20, r20
    6290:	55 1f       	adc	r21, r21
    6292:	59 f0       	breq	.+22     	; 0x62aa <__fp_splitA+0x10>
    6294:	5f 3f       	cpi	r21, 0xFF	; 255
    6296:	71 f0       	breq	.+28     	; 0x62b4 <__fp_splitA+0x1a>
    6298:	47 95       	ror	r20

0000629a <__fp_splitA>:
    629a:	88 0f       	add	r24, r24
    629c:	97 fb       	bst	r25, 7
    629e:	99 1f       	adc	r25, r25
    62a0:	61 f0       	breq	.+24     	; 0x62ba <__fp_splitA+0x20>
    62a2:	9f 3f       	cpi	r25, 0xFF	; 255
    62a4:	79 f0       	breq	.+30     	; 0x62c4 <__fp_splitA+0x2a>
    62a6:	87 95       	ror	r24
    62a8:	08 95       	ret
    62aa:	12 16       	cp	r1, r18
    62ac:	13 06       	cpc	r1, r19
    62ae:	14 06       	cpc	r1, r20
    62b0:	55 1f       	adc	r21, r21
    62b2:	f2 cf       	rjmp	.-28     	; 0x6298 <__fp_split3+0xe>
    62b4:	46 95       	lsr	r20
    62b6:	f1 df       	rcall	.-30     	; 0x629a <__fp_splitA>
    62b8:	08 c0       	rjmp	.+16     	; 0x62ca <__fp_splitA+0x30>
    62ba:	16 16       	cp	r1, r22
    62bc:	17 06       	cpc	r1, r23
    62be:	18 06       	cpc	r1, r24
    62c0:	99 1f       	adc	r25, r25
    62c2:	f1 cf       	rjmp	.-30     	; 0x62a6 <__fp_splitA+0xc>
    62c4:	86 95       	lsr	r24
    62c6:	71 05       	cpc	r23, r1
    62c8:	61 05       	cpc	r22, r1
    62ca:	08 94       	sec
    62cc:	08 95       	ret

000062ce <__fp_trunc>:
    62ce:	0e 94 4d 31 	call	0x629a	; 0x629a <__fp_splitA>
    62d2:	a0 f0       	brcs	.+40     	; 0x62fc <__fp_trunc+0x2e>
    62d4:	be e7       	ldi	r27, 0x7E	; 126
    62d6:	b9 17       	cp	r27, r25
    62d8:	88 f4       	brcc	.+34     	; 0x62fc <__fp_trunc+0x2e>
    62da:	bb 27       	eor	r27, r27
    62dc:	9f 38       	cpi	r25, 0x8F	; 143
    62de:	60 f4       	brcc	.+24     	; 0x62f8 <__fp_trunc+0x2a>
    62e0:	16 16       	cp	r1, r22
    62e2:	b1 1d       	adc	r27, r1
    62e4:	67 2f       	mov	r22, r23
    62e6:	78 2f       	mov	r23, r24
    62e8:	88 27       	eor	r24, r24
    62ea:	98 5f       	subi	r25, 0xF8	; 248
    62ec:	f7 cf       	rjmp	.-18     	; 0x62dc <__fp_trunc+0xe>
    62ee:	86 95       	lsr	r24
    62f0:	77 95       	ror	r23
    62f2:	67 95       	ror	r22
    62f4:	b1 1d       	adc	r27, r1
    62f6:	93 95       	inc	r25
    62f8:	96 39       	cpi	r25, 0x96	; 150
    62fa:	c8 f3       	brcs	.-14     	; 0x62ee <__fp_trunc+0x20>
    62fc:	08 95       	ret

000062fe <__fp_zero>:
    62fe:	e8 94       	clt

00006300 <__fp_szero>:
    6300:	bb 27       	eor	r27, r27
    6302:	66 27       	eor	r22, r22
    6304:	77 27       	eor	r23, r23
    6306:	cb 01       	movw	r24, r22
    6308:	97 f9       	bld	r25, 7
    630a:	08 95       	ret

0000630c <__gesf2>:
    630c:	0e 94 6a 30 	call	0x60d4	; 0x60d4 <__fp_cmp>
    6310:	08 f4       	brcc	.+2      	; 0x6314 <__gesf2+0x8>
    6312:	8f ef       	ldi	r24, 0xFF	; 255
    6314:	08 95       	ret

00006316 <inverse>:
    6316:	9b 01       	movw	r18, r22
    6318:	ac 01       	movw	r20, r24
    631a:	60 e0       	ldi	r22, 0x00	; 0
    631c:	70 e0       	ldi	r23, 0x00	; 0
    631e:	80 e8       	ldi	r24, 0x80	; 128
    6320:	9f e3       	ldi	r25, 0x3F	; 63
    6322:	0c 94 6e 2f 	jmp	0x5edc	; 0x5edc <__divsf3>

00006326 <lround>:
    6326:	0e 94 4d 31 	call	0x629a	; 0x629a <__fp_splitA>
    632a:	58 f1       	brcs	.+86     	; 0x6382 <lround+0x5c>
    632c:	9e 57       	subi	r25, 0x7E	; 126
    632e:	60 f1       	brcs	.+88     	; 0x6388 <lround+0x62>
    6330:	98 51       	subi	r25, 0x18	; 24
    6332:	a0 f0       	brcs	.+40     	; 0x635c <lround+0x36>
    6334:	e9 f0       	breq	.+58     	; 0x6370 <lround+0x4a>
    6336:	98 30       	cpi	r25, 0x08	; 8
    6338:	20 f5       	brcc	.+72     	; 0x6382 <lround+0x5c>
    633a:	09 2e       	mov	r0, r25
    633c:	99 27       	eor	r25, r25
    633e:	66 0f       	add	r22, r22
    6340:	77 1f       	adc	r23, r23
    6342:	88 1f       	adc	r24, r24
    6344:	99 1f       	adc	r25, r25
    6346:	0a 94       	dec	r0
    6348:	d1 f7       	brne	.-12     	; 0x633e <lround+0x18>
    634a:	12 c0       	rjmp	.+36     	; 0x6370 <lround+0x4a>
    634c:	06 2e       	mov	r0, r22
    634e:	67 2f       	mov	r22, r23
    6350:	78 2f       	mov	r23, r24
    6352:	88 27       	eor	r24, r24
    6354:	98 5f       	subi	r25, 0xF8	; 248
    6356:	11 f4       	brne	.+4      	; 0x635c <lround+0x36>
    6358:	00 0c       	add	r0, r0
    635a:	07 c0       	rjmp	.+14     	; 0x636a <lround+0x44>
    635c:	99 3f       	cpi	r25, 0xF9	; 249
    635e:	b4 f3       	brlt	.-20     	; 0x634c <lround+0x26>
    6360:	86 95       	lsr	r24
    6362:	77 95       	ror	r23
    6364:	67 95       	ror	r22
    6366:	93 95       	inc	r25
    6368:	d9 f7       	brne	.-10     	; 0x6360 <lround+0x3a>
    636a:	61 1d       	adc	r22, r1
    636c:	71 1d       	adc	r23, r1
    636e:	81 1d       	adc	r24, r1
    6370:	3e f4       	brtc	.+14     	; 0x6380 <lround+0x5a>
    6372:	90 95       	com	r25
    6374:	80 95       	com	r24
    6376:	70 95       	com	r23
    6378:	61 95       	neg	r22
    637a:	7f 4f       	sbci	r23, 0xFF	; 255
    637c:	8f 4f       	sbci	r24, 0xFF	; 255
    637e:	9f 4f       	sbci	r25, 0xFF	; 255
    6380:	08 95       	ret
    6382:	68 94       	set
    6384:	0c 94 80 31 	jmp	0x6300	; 0x6300 <__fp_szero>
    6388:	0c 94 7f 31 	jmp	0x62fe	; 0x62fe <__fp_zero>

0000638c <__mulsf3>:
    638c:	0e 94 d9 31 	call	0x63b2	; 0x63b2 <__mulsf3x>
    6390:	0c 94 20 31 	jmp	0x6240	; 0x6240 <__fp_round>
    6394:	0e 94 e7 30 	call	0x61ce	; 0x61ce <__fp_pscA>
    6398:	38 f0       	brcs	.+14     	; 0x63a8 <__mulsf3+0x1c>
    639a:	0e 94 ee 30 	call	0x61dc	; 0x61dc <__fp_pscB>
    639e:	20 f0       	brcs	.+8      	; 0x63a8 <__mulsf3+0x1c>
    63a0:	95 23       	and	r25, r21
    63a2:	11 f0       	breq	.+4      	; 0x63a8 <__mulsf3+0x1c>
    63a4:	0c 94 8e 30 	jmp	0x611c	; 0x611c <__fp_inf>
    63a8:	0c 94 bd 30 	jmp	0x617a	; 0x617a <__fp_nan>
    63ac:	11 24       	eor	r1, r1
    63ae:	0c 94 80 31 	jmp	0x6300	; 0x6300 <__fp_szero>

000063b2 <__mulsf3x>:
    63b2:	0e 94 45 31 	call	0x628a	; 0x628a <__fp_split3>
    63b6:	70 f3       	brcs	.-36     	; 0x6394 <__mulsf3+0x8>

000063b8 <__mulsf3_pse>:
    63b8:	95 9f       	mul	r25, r21
    63ba:	c1 f3       	breq	.-16     	; 0x63ac <__mulsf3+0x20>
    63bc:	95 0f       	add	r25, r21
    63be:	50 e0       	ldi	r21, 0x00	; 0
    63c0:	55 1f       	adc	r21, r21
    63c2:	62 9f       	mul	r22, r18
    63c4:	f0 01       	movw	r30, r0
    63c6:	72 9f       	mul	r23, r18
    63c8:	bb 27       	eor	r27, r27
    63ca:	f0 0d       	add	r31, r0
    63cc:	b1 1d       	adc	r27, r1
    63ce:	63 9f       	mul	r22, r19
    63d0:	aa 27       	eor	r26, r26
    63d2:	f0 0d       	add	r31, r0
    63d4:	b1 1d       	adc	r27, r1
    63d6:	aa 1f       	adc	r26, r26
    63d8:	64 9f       	mul	r22, r20
    63da:	66 27       	eor	r22, r22
    63dc:	b0 0d       	add	r27, r0
    63de:	a1 1d       	adc	r26, r1
    63e0:	66 1f       	adc	r22, r22
    63e2:	82 9f       	mul	r24, r18
    63e4:	22 27       	eor	r18, r18
    63e6:	b0 0d       	add	r27, r0
    63e8:	a1 1d       	adc	r26, r1
    63ea:	62 1f       	adc	r22, r18
    63ec:	73 9f       	mul	r23, r19
    63ee:	b0 0d       	add	r27, r0
    63f0:	a1 1d       	adc	r26, r1
    63f2:	62 1f       	adc	r22, r18
    63f4:	83 9f       	mul	r24, r19
    63f6:	a0 0d       	add	r26, r0
    63f8:	61 1d       	adc	r22, r1
    63fa:	22 1f       	adc	r18, r18
    63fc:	74 9f       	mul	r23, r20
    63fe:	33 27       	eor	r19, r19
    6400:	a0 0d       	add	r26, r0
    6402:	61 1d       	adc	r22, r1
    6404:	23 1f       	adc	r18, r19
    6406:	84 9f       	mul	r24, r20
    6408:	60 0d       	add	r22, r0
    640a:	21 1d       	adc	r18, r1
    640c:	82 2f       	mov	r24, r18
    640e:	76 2f       	mov	r23, r22
    6410:	6a 2f       	mov	r22, r26
    6412:	11 24       	eor	r1, r1
    6414:	9f 57       	subi	r25, 0x7F	; 127
    6416:	50 40       	sbci	r21, 0x00	; 0
    6418:	9a f0       	brmi	.+38     	; 0x6440 <__mulsf3_pse+0x88>
    641a:	f1 f0       	breq	.+60     	; 0x6458 <__mulsf3_pse+0xa0>
    641c:	88 23       	and	r24, r24
    641e:	4a f0       	brmi	.+18     	; 0x6432 <__mulsf3_pse+0x7a>
    6420:	ee 0f       	add	r30, r30
    6422:	ff 1f       	adc	r31, r31
    6424:	bb 1f       	adc	r27, r27
    6426:	66 1f       	adc	r22, r22
    6428:	77 1f       	adc	r23, r23
    642a:	88 1f       	adc	r24, r24
    642c:	91 50       	subi	r25, 0x01	; 1
    642e:	50 40       	sbci	r21, 0x00	; 0
    6430:	a9 f7       	brne	.-22     	; 0x641c <__mulsf3_pse+0x64>
    6432:	9e 3f       	cpi	r25, 0xFE	; 254
    6434:	51 05       	cpc	r21, r1
    6436:	80 f0       	brcs	.+32     	; 0x6458 <__mulsf3_pse+0xa0>
    6438:	0c 94 8e 30 	jmp	0x611c	; 0x611c <__fp_inf>
    643c:	0c 94 80 31 	jmp	0x6300	; 0x6300 <__fp_szero>
    6440:	5f 3f       	cpi	r21, 0xFF	; 255
    6442:	e4 f3       	brlt	.-8      	; 0x643c <__mulsf3_pse+0x84>
    6444:	98 3e       	cpi	r25, 0xE8	; 232
    6446:	d4 f3       	brlt	.-12     	; 0x643c <__mulsf3_pse+0x84>
    6448:	86 95       	lsr	r24
    644a:	77 95       	ror	r23
    644c:	67 95       	ror	r22
    644e:	b7 95       	ror	r27
    6450:	f7 95       	ror	r31
    6452:	e7 95       	ror	r30
    6454:	9f 5f       	subi	r25, 0xFF	; 255
    6456:	c1 f7       	brne	.-16     	; 0x6448 <__mulsf3_pse+0x90>
    6458:	fe 2b       	or	r31, r30
    645a:	88 0f       	add	r24, r24
    645c:	91 1d       	adc	r25, r1
    645e:	96 95       	lsr	r25
    6460:	87 95       	ror	r24
    6462:	97 f9       	bld	r25, 7
    6464:	08 95       	ret

00006466 <round>:
    6466:	0e 94 4d 31 	call	0x629a	; 0x629a <__fp_splitA>
    646a:	e8 f0       	brcs	.+58     	; 0x64a6 <round+0x40>
    646c:	9e 37       	cpi	r25, 0x7E	; 126
    646e:	e8 f0       	brcs	.+58     	; 0x64aa <round+0x44>
    6470:	96 39       	cpi	r25, 0x96	; 150
    6472:	b8 f4       	brcc	.+46     	; 0x64a2 <round+0x3c>
    6474:	9e 38       	cpi	r25, 0x8E	; 142
    6476:	48 f4       	brcc	.+18     	; 0x648a <round+0x24>
    6478:	67 2f       	mov	r22, r23
    647a:	78 2f       	mov	r23, r24
    647c:	88 27       	eor	r24, r24
    647e:	98 5f       	subi	r25, 0xF8	; 248
    6480:	f9 cf       	rjmp	.-14     	; 0x6474 <round+0xe>
    6482:	86 95       	lsr	r24
    6484:	77 95       	ror	r23
    6486:	67 95       	ror	r22
    6488:	93 95       	inc	r25
    648a:	95 39       	cpi	r25, 0x95	; 149
    648c:	d0 f3       	brcs	.-12     	; 0x6482 <round+0x1c>
    648e:	b6 2f       	mov	r27, r22
    6490:	b1 70       	andi	r27, 0x01	; 1
    6492:	6b 0f       	add	r22, r27
    6494:	71 1d       	adc	r23, r1
    6496:	81 1d       	adc	r24, r1
    6498:	20 f4       	brcc	.+8      	; 0x64a2 <round+0x3c>
    649a:	87 95       	ror	r24
    649c:	77 95       	ror	r23
    649e:	67 95       	ror	r22
    64a0:	93 95       	inc	r25
    64a2:	0c 94 94 30 	jmp	0x6128	; 0x6128 <__fp_mintl>
    64a6:	0c 94 af 30 	jmp	0x615e	; 0x615e <__fp_mpack>
    64aa:	0c 94 80 31 	jmp	0x6300	; 0x6300 <__fp_szero>

000064ae <sin>:
    64ae:	9f 93       	push	r25
    64b0:	0e 94 f7 30 	call	0x61ee	; 0x61ee <__fp_rempio2>
    64b4:	0f 90       	pop	r0
    64b6:	07 fc       	sbrc	r0, 7
    64b8:	ee 5f       	subi	r30, 0xFE	; 254
    64ba:	0c 94 31 31 	jmp	0x6262	; 0x6262 <__fp_sinus>
    64be:	19 f4       	brne	.+6      	; 0x64c6 <sin+0x18>
    64c0:	16 f4       	brtc	.+4      	; 0x64c6 <sin+0x18>
    64c2:	0c 94 bd 30 	jmp	0x617a	; 0x617a <__fp_nan>
    64c6:	0c 94 af 30 	jmp	0x615e	; 0x615e <__fp_mpack>

000064ca <sqrt>:
    64ca:	0e 94 4d 31 	call	0x629a	; 0x629a <__fp_splitA>
    64ce:	b8 f3       	brcs	.-18     	; 0x64be <sin+0x10>
    64d0:	99 23       	and	r25, r25
    64d2:	c9 f3       	breq	.-14     	; 0x64c6 <sin+0x18>
    64d4:	b6 f3       	brts	.-20     	; 0x64c2 <sin+0x14>
    64d6:	9f 57       	subi	r25, 0x7F	; 127
    64d8:	55 0b       	sbc	r21, r21
    64da:	87 ff       	sbrs	r24, 7
    64dc:	0e 94 b4 32 	call	0x6568	; 0x6568 <__fp_norm2>
    64e0:	00 24       	eor	r0, r0
    64e2:	a0 e6       	ldi	r26, 0x60	; 96
    64e4:	40 ea       	ldi	r20, 0xA0	; 160
    64e6:	90 01       	movw	r18, r0
    64e8:	80 58       	subi	r24, 0x80	; 128
    64ea:	56 95       	lsr	r21
    64ec:	97 95       	ror	r25
    64ee:	28 f4       	brcc	.+10     	; 0x64fa <sqrt+0x30>
    64f0:	80 5c       	subi	r24, 0xC0	; 192
    64f2:	66 0f       	add	r22, r22
    64f4:	77 1f       	adc	r23, r23
    64f6:	88 1f       	adc	r24, r24
    64f8:	20 f0       	brcs	.+8      	; 0x6502 <sqrt+0x38>
    64fa:	26 17       	cp	r18, r22
    64fc:	37 07       	cpc	r19, r23
    64fe:	48 07       	cpc	r20, r24
    6500:	30 f4       	brcc	.+12     	; 0x650e <sqrt+0x44>
    6502:	62 1b       	sub	r22, r18
    6504:	73 0b       	sbc	r23, r19
    6506:	84 0b       	sbc	r24, r20
    6508:	20 29       	or	r18, r0
    650a:	31 29       	or	r19, r1
    650c:	4a 2b       	or	r20, r26
    650e:	a6 95       	lsr	r26
    6510:	17 94       	ror	r1
    6512:	07 94       	ror	r0
    6514:	20 25       	eor	r18, r0
    6516:	31 25       	eor	r19, r1
    6518:	4a 27       	eor	r20, r26
    651a:	58 f7       	brcc	.-42     	; 0x64f2 <sqrt+0x28>
    651c:	66 0f       	add	r22, r22
    651e:	77 1f       	adc	r23, r23
    6520:	88 1f       	adc	r24, r24
    6522:	20 f0       	brcs	.+8      	; 0x652c <sqrt+0x62>
    6524:	26 17       	cp	r18, r22
    6526:	37 07       	cpc	r19, r23
    6528:	48 07       	cpc	r20, r24
    652a:	30 f4       	brcc	.+12     	; 0x6538 <sqrt+0x6e>
    652c:	62 0b       	sbc	r22, r18
    652e:	73 0b       	sbc	r23, r19
    6530:	84 0b       	sbc	r24, r20
    6532:	20 0d       	add	r18, r0
    6534:	31 1d       	adc	r19, r1
    6536:	41 1d       	adc	r20, r1
    6538:	a0 95       	com	r26
    653a:	81 f7       	brne	.-32     	; 0x651c <sqrt+0x52>
    653c:	b9 01       	movw	r22, r18
    653e:	84 2f       	mov	r24, r20
    6540:	91 58       	subi	r25, 0x81	; 129
    6542:	88 0f       	add	r24, r24
    6544:	96 95       	lsr	r25
    6546:	87 95       	ror	r24
    6548:	08 95       	ret

0000654a <square>:
    654a:	9b 01       	movw	r18, r22
    654c:	ac 01       	movw	r20, r24
    654e:	0c 94 c6 31 	jmp	0x638c	; 0x638c <__mulsf3>

00006552 <trunc>:
    6552:	0e 94 67 31 	call	0x62ce	; 0x62ce <__fp_trunc>
    6556:	30 f0       	brcs	.+12     	; 0x6564 <trunc+0x12>
    6558:	9f 37       	cpi	r25, 0x7F	; 127
    655a:	10 f4       	brcc	.+4      	; 0x6560 <trunc+0xe>
    655c:	0c 94 80 31 	jmp	0x6300	; 0x6300 <__fp_szero>
    6560:	0c 94 94 30 	jmp	0x6128	; 0x6128 <__fp_mintl>
    6564:	0c 94 af 30 	jmp	0x615e	; 0x615e <__fp_mpack>

00006568 <__fp_norm2>:
    6568:	91 50       	subi	r25, 0x01	; 1
    656a:	50 40       	sbci	r21, 0x00	; 0
    656c:	66 0f       	add	r22, r22
    656e:	77 1f       	adc	r23, r23
    6570:	88 1f       	adc	r24, r24
    6572:	d2 f7       	brpl	.-12     	; 0x6568 <__fp_norm2>
    6574:	08 95       	ret

00006576 <__fp_powsodd>:
    6576:	9f 93       	push	r25
    6578:	8f 93       	push	r24
    657a:	7f 93       	push	r23
    657c:	6f 93       	push	r22
    657e:	ff 93       	push	r31
    6580:	ef 93       	push	r30
    6582:	9b 01       	movw	r18, r22
    6584:	ac 01       	movw	r20, r24
    6586:	0e 94 c6 31 	call	0x638c	; 0x638c <__mulsf3>
    658a:	ef 91       	pop	r30
    658c:	ff 91       	pop	r31
    658e:	0e 94 c0 30 	call	0x6180	; 0x6180 <__fp_powser>
    6592:	2f 91       	pop	r18
    6594:	3f 91       	pop	r19
    6596:	4f 91       	pop	r20
    6598:	5f 91       	pop	r21
    659a:	0c 94 c6 31 	jmp	0x638c	; 0x638c <__mulsf3>

0000659e <__tablejump2__>:
    659e:	ee 0f       	add	r30, r30
    65a0:	ff 1f       	adc	r31, r31
    65a2:	05 90       	lpm	r0, Z+
    65a4:	f4 91       	lpm	r31, Z
    65a6:	e0 2d       	mov	r30, r0
    65a8:	09 94       	ijmp

000065aa <__umulhisi3>:
    65aa:	a2 9f       	mul	r26, r18
    65ac:	b0 01       	movw	r22, r0
    65ae:	b3 9f       	mul	r27, r19
    65b0:	c0 01       	movw	r24, r0
    65b2:	a3 9f       	mul	r26, r19
    65b4:	70 0d       	add	r23, r0
    65b6:	81 1d       	adc	r24, r1
    65b8:	11 24       	eor	r1, r1
    65ba:	91 1d       	adc	r25, r1
    65bc:	b2 9f       	mul	r27, r18
    65be:	70 0d       	add	r23, r0
    65c0:	81 1d       	adc	r24, r1
    65c2:	11 24       	eor	r1, r1
    65c4:	91 1d       	adc	r25, r1
    65c6:	08 95       	ret

000065c8 <memcmp>:
    65c8:	fb 01       	movw	r30, r22
    65ca:	dc 01       	movw	r26, r24
    65cc:	04 c0       	rjmp	.+8      	; 0x65d6 <memcmp+0xe>
    65ce:	8d 91       	ld	r24, X+
    65d0:	01 90       	ld	r0, Z+
    65d2:	80 19       	sub	r24, r0
    65d4:	21 f4       	brne	.+8      	; 0x65de <memcmp+0x16>
    65d6:	41 50       	subi	r20, 0x01	; 1
    65d8:	50 40       	sbci	r21, 0x00	; 0
    65da:	c8 f7       	brcc	.-14     	; 0x65ce <memcmp+0x6>
    65dc:	88 1b       	sub	r24, r24
    65de:	99 0b       	sbc	r25, r25
    65e0:	08 95       	ret

000065e2 <_exit>:
    65e2:	f8 94       	cli

000065e4 <__stop_program>:
    65e4:	ff cf       	rjmp	.-2      	; 0x65e4 <__stop_program>
